
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.analysis.topology</title>
<meta name="description" content="Documentation of Coq module mathcomp.analysis.topology" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>

<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init('proofscript')">
<h1 class="title">Module mathcomp.analysis.topology</h1>
<div class="coq">
<span class="kwd">From</span> <span class="id">mathcomp</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">all_ssreflect</span> <span class="id">all_algebra</span> <span class="id">finmap</span> <span class="id">generic_quotient</span>.<br/>
<span class="kwd">From</span> <span class="id">mathcomp</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id"><a href="mathcomp.classical.boolp.html">boolp</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html">classical_sets</a></span> <span class="id"><a href="mathcomp.classical.functions.html">functions</a></span>.<br/>
<span class="kwd">From</span> <span class="id">mathcomp</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id"><a href="mathcomp.classical.cardinality.html">cardinality</a></span> <span class="id"><a href="mathcomp.classical.mathcomp_extra.html">mathcomp_extra</a></span> <span class="id"><a href="mathcomp.classical.fsbigop.html">fsbigop</a></span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id"><a href="mathcomp.analysis.reals.html">reals</a></span> <span class="id"><a href="mathcomp.analysis.signed.html">signed</a></span>.<br/>
<br/>
<pre class="ssrdoc">
                 Filters and basic topological notions                     
                                                                           
This file develops tools for the manipulation of filters and basic         
topological notions. The development of topological notions builds on      
"filtered types". They are types equipped with an interface that           
associates to each element a set of sets, intended to represent a filter.  
The notions of limit and convergence are defined for filtered types and in 
the documentation below we call "canonical filter" of an element the set   
of sets associated to it by the interface of filtered types.               
                                                                           
                monotonous A f := {in A &amp;, {mono f : x y / x &lt;= y}} \/     
                                  {in A &amp;, {mono f : x y /~ x &lt;= y}}.      
                                                                           
* Filters :                                                                
                  filteredType U == interface type for types whose         
                                    elements represent sets of sets on U.  
                                    These sets are intended to be filters  
                                    on U but this is not enforced yet.     
              FilteredType U T m == packs the function m: T -&gt; set (set U) 
                                    to build a filtered type of type       
                                    filteredType U; T must have a          
                                    pointedType structure.                 
    [filteredType U of T for cT] == T-clone of the filteredType U          
                                    structure cT.                          
           [filteredType U of T] == clone of a canonical structure of      
                                    filteredType U on T.                   
             Filtered.source Y Z == structure that records types X such    
                                    that there is a function mapping       
                                    functions of type X -&gt; Y to filters on 
                                    Z. Allows to infer the canonical       
                                    filter associated to a function by     
                                    looking at its source type.            
               Filtered.Source F == if F : (X -&gt; Y) -&gt; set (set Z), packs  
                                    X with F in a Filtered.source Y Z      
                                    structure.                             
                          nbhs p == set of sets associated to p (in a      
                                    filtered type).                        
                 filter_from D B == set of the supersets of the elements   
                                    of the family of sets B whose indices  
                                    are in the domain D.                   
                                    This is a filter if (B_i)_(i in D)     
                                    forms a filter base.                   
                 filter_prod F G == product of the filters F and G.        
                   [filter of x] == canonical filter associated to x.      
                       F `=&gt;` G &lt;-&gt; G is included in F; F and G are sets   
                                    of sets.                               
                        F --&gt; G &lt;-&gt; the canonical filter associated to G   
                                    is included in the canonical filter    
                                    associated to F.                       
                           lim F == limit of the canonical filter          
                                    associated with F if there is such a   
                                    limit, i.e., an element l such that    
                                    the canonical filter associated to l   
                                    is a subset of F.                      
                    [lim F in T] == limit of the canonical filter          
                                    associated to F in T where T has type  
                                    filteredType U.                        
                   [cvg F in T] &lt;-&gt; the canonical filter associated to F   
                                    converges in T.                        
                          cvg F &lt;-&gt; same as [cvg F in T] where T is        
                                    inferred from the type of the          
                                    canonical filter associated to F.      
                        Filter F == type class proving that the set of     
                                    sets F is a filter.                    
                  ProperFilter F == type class proving that the set of     
                                    sets F is a proper filter.             
                   UltraFilter F == type class proving that the set of     
                                    sets F is an ultrafilter               
                     filter_on T == interface type for sets of sets on T   
                                    that are filters.                      
                 FilterType F FF == packs the set of sets F with the proof 
                                    FF of Filter F to build a filter_on T  
                                    structure.                             
                    pfilter_on T == interface type for sets of sets on T   
                                    that are proper filters.               
                PFilterPack F FF == packs the set of sets F with the proof 
                                    FF of ProperFilter F to build a        
                                    pfilter_on T structure.                
                        fmap f F == image of the filter F by the function  
                                    f                                      
                      E @[x --&gt; F] == image of the canonical filter        
                                    associated to F by the function        
                                    (fun x =&gt; E).                          
                           f @ F == image of the canonical filter          
                                    associated to F by the function f.     
                       fmapi f F == image of the filter F by the relation  
                                    f                                      
                     E `@[x --&gt; F] == image of the canonical filter        
                                    associated to F by the relation        
                                    (fun x =&gt; E).                          
                          f `@ F == image of the canonical filter          
                                    associated to F by the relation f.     
                      globally A == filter of the sets containing A.       
               @frechet_filter T := [set S : set T | finite_set (~` S)]    
                                    a.k.a. cofinite filter                 
                      at_point a == filter of the sets containing a.       
                      within D F == restriction of the filter F to the     
                                    domain D.                              
              principal_filter x == filter containing every superset of x. 
               subset_filter F D == similar to within D F, but with        
                                    dependent types.                       
          powerset_filter_from F == The filter of downward closed subsets  
                                    of F. Enables use of near notation to  
                                    pick suitably small members of F       
                     in_filter F == interface type for the sets that       
                                    belong to the set of sets F.           
                     InFilter FP == packs a set P with a proof of F P to   
                                    build a in_filter F structure.         
                             \oo == "eventually" filter on nat: set of     
                                    predicates on natural numbers that are 
                                    eventually true.                       
                        clopen U == U is both open and closed              
                  normal_space X == X is normal, sometimes called T4       
                 regular_space X == X is regular, sometimes called T3      
   separate_points_from_closed f == For a closed set U and point x outside 
                                    some member of the family f sends      
                                    f_i(x) outside (closure (f_i @` U)).   
                                    Used together with join_product.       
                  join_product f == The function (x =&gt; f ^~ x). When the   
                                    family f separates points from closed  
                                    sets, join_product is an embedding.    
                                                                           
* Near notations and tactics:                                              
  --&gt; The purpose of the near notations and tactics is to make the         
      manipulation of filters easier. Instead of proving F G, one can      
      prove G x for x "near F", i.e. for x such that H x for H arbitrarily 
      precise as long as F H. The near tactics allow for a delayed         
      introduction of H: H is introduced as an existential variable and    
      progressively instantiated during the proof process.                 
  --&gt; Notations:                                                           
                     {near F, P} == the property P holds near the          
                                    canonical filter associated to F; P    
                                    must have the form forall x, Q x.      
                                    Equivalent to F Q.                     
         \forall x \near F, P x &lt;-&gt; F (fun x =&gt; P x).                      
                    \near x, P x := \forall y \near x, P y.                
                 {near F &amp; G, P} == same as {near H, P}, where H is the    
                                    product of the filters F and G.        
  \forall x \near F &amp; y \near G, P x y := {near F &amp; G, forall x y, P x y}. 
    \forall x &amp; y \near F, P x y == same as before, with G = F.            
              \near x &amp; y, P x y := \forall z \near x &amp; t \near y, P x y.  
                    x \is_near F == x belongs to a set P : in_filter F.    
  --&gt; Tactics:                                                             
    - near=&gt; x    introduces x:                                            
      On the goal \forall x \near F, G x, introduces the variable x and an 
      "existential", and unaccessible hypothesis ?H x and asks the user to 
      prove (G x) in this context.                                         
      Under the hood delays the proof of F ?H and waits for near: x        
      Also exists under the form near=&gt; x y.                               
    - near: x     discharges x:                                            
      On the goal H_i x, and where x \is_near F, it asks the user to prove 
      that (\forall x \near F, H_i x), provided that H_i x does not depend 
      on variables introduced after x.                                     
      Under the hood, it refines by intersection the existential variable  
      ?H attached to x, computes the intersection with F, and asks the     
      user to prove F H_i, right now                                       
    - end_near should be used to close remaining existentials trivially    
    - near F =&gt; x     poses a variable near F, where F is a proper filter  
      adds to the context a variable x that \is_near F, i.e. one may       
      assume H x for any H in F. This new variable x can be dealt with     
      using  near: x, as for variables introduced by near=&gt;.               
                                                                           
* Topology :                                                               
                 topologicalType == interface type for topological space   
                                    structure.                             
TopologicalMixin nbhs_filt nbhsE == builds the mixin for a topological     
                                    space from the proofs that nbhs        
                                    outputs proper filters and defines the 
                                    same notion of neighbourhood as the    
                                    open sets.                             
topologyOfFilterMixin nbhs_filt nbhs_sing nbhs_nbhs == builds the mixin    
                                    for a topological space from the       
                                    properties of nbhs and hence assumes   
                                    that the carrier is a filterType       
  topologyOfOpenMixin opT opI op_bigU == builds the mixin for a            
                                    topological space from the properties  
                                    of open sets, assuming the carrier is  
                                    a pointed type. nbhs_of_open must be   
                                    used to declare a filterType.          
  topologyOfBaseMixin b_cover b_join == builds the mixin for a topological 
                                    space from the properties of a base of 
                                    open sets; the type of indices must be 
                                    a pointedType, as well as the carrier. 
                                    nbhs_of_open \o open_from must be      
                                    used to declare a filterType           
                filterI_iter F n == nth stage of recursively building the  
                                    filter of finite intersections of F    
                   finI_from D f == set of \bigcap_(i in E) f i where E is 
                                    a finite subset of D                   
      topologyOfSubbaseMixin D b == builds the mixin for a topological     
                                    space from a subbase of open sets b    
                                    indexed on domain D; the type of       
                                    indices must be a pointedType.         
             TopologicalType T m == packs the mixin m to build a           
                                    topologicalType; T must have a         
                                    canonical structure of filteredType T. 
          weak_topologicalType f == weak topology by f : S -&gt; T on S; S    
                                    must be a pointedType and T a          
                                    topologicalType.                       
          sup_topologicalType Tc == supremum topology of the family of     
                                    topologicalType structures Tc on T; T  
                                    must be a pointedType.                 
       product_topologicalType T == product topology of the family of      
                                    topologicalTypes T.                    
   [topologicalType of T for cT] == T-clone of the topologicalType         
                                    structure cT.                          
          [topologicalType of T] == clone of a canonical structure of      
                                    topologicalType on T.                  
                            open == set of open sets.                      
                     open_nbhs p == set of open neighbourhoods of p.       
                         basis B == a family of open sets that converges   
                                    to each point                          
              second_countable T == T has a countable basis                
                   continuous f &lt;-&gt; f is continuous w.r.t the topology.    
                             x^' == set of neighbourhoods of x where x is  
                                    excluded (a "deleted neighborhood").   
                       closure A == closure of the set A.                  
                   limit_point E == the set of limit points of E           
                          closed == set of closed sets.                    
                       cluster F == set of cluster points of F.            
                         compact == set of compact sets w.r.t. the filter- 
                                    based definition of compactness.       
                  compact_near F == the filter F contains a closed comapct 
                                    set                                    
                    precompact A == The set A is contained in a closed and 
                                    compact set                            
               locally_compact A == every point in A has a compact         
                                    (and closed) neighborhood              
              hausdorff_space T &lt;-&gt; T is a Hausdorff space (T_2).          
               discrete_space T &lt;-&gt; every nbhs is a principal filter       
       finite_subset_cover D F A == the family of sets F is a cover of A   
                                    for a finite number of indices in D    
                   cover_compact == set of compact sets w.r.t. the open    
                                    cover-based definition of compactness. 
                   near_covering == a reformulation of covering compact    
                                    better suited for use with `near`      
                    connected A &lt;-&gt; the only non empty subset of A which   
                                    is both open and closed in A is A.     
             kolmogorov_space T &lt;-&gt; T is a Kolmogorov space (T_0).         
             accessible_space T &lt;-&gt; T is an accessible space (T_1).        
                   separated A B == the two sets A and B are separated     
                     component x == the connected component of point x     
                   perfect_set A == A is closed, and is every point in A   
                                    is a limit point of A.                 
          totally_disconnected A == The only connected subsets of A are    
                                    empty or singletons.                   
              zero_dimensional T == Points are separable by a clopen set.  
                      set_nbhs A == filter from open sets containing A     
                                                                           
                                                                           
                     [locally P] := forall a, A a -&gt; G (within A (nbhs x)) 
                                    if P is convertible to G (globally A)  
             quotient_topology Q == the quotient topology corresponding to 
                                    quotient Q : quotType T where T has    
                                    type topologicalType                   
                                                                           
* Function space topologies :                                              
    {uniform` A -&gt; V} == The space U -&gt; V, equipped with the topology of   
                         uniform convergence from a set A to V, where      
                         V is a uniformType.                               
     {uniform U -&gt; V} := {uniform` [set: U] -&gt; V}                          
 {uniform A, F --&gt; f} == F converges to f in {uniform A -&gt; V}.             
   {uniform, F --&gt; f} := {uniform setT, F --&gt; f}                           
        {ptws U -&gt; V} == The space U -&gt; V, equipped with the topology of   
                         pointwise convergence from U to V, where V is a   
                         topologicalType; notation for @fct_Pointwise U V. 
      {ptws, F --&gt; f} == F converges to f in {ptws U -&gt; V}.                
 {family fam, U -&gt; V} == The space U -&gt; V, equipped with the supremum      
                         topology of {uniform A -&gt; f} for each A in 'fam'  
                         In particular {family compact, U -&gt; V} is the     
                         topology of compact convergence.                  
{family fam, F --&gt; f} == F converges to f in {family fam, U -&gt; V}.         
                                                                           
--&gt; We used these topological notions to prove Tychonoff's Theorem, which  
    states that any product of compact sets is compact according to the    
    product topology.                                                      
* Uniform spaces :                                                         
                     nbhs_ ent == neighbourhoods defined using entourages  
                   uniformType == interface type for uniform spaces: a     
                                  type equipped with entourages            
  UniformMixin efilter erefl einv esplit nbhse == builds the mixin for a   
                                  uniform space from the properties of     
                                  entourages and the compatibility between 
                                  entourages and nbhs                      
               UniformType T m == packs the uniform space mixin into a     
                                  uniformType. T must have a canonical     
                                  structure of topologicalType             
     [uniformType of T for cT] == T-clone of the uniformType structure cT  
            [uniformType of T] == clone of a canonical structure of        
                                  uniformType on T                         
  topologyOfEntourageMixin umixin == builds the mixin for a topological    
                                  space from a mixin for a uniform space   
                     entourage == set of entourages in a uniform space     
                   split_ent E == when E is an entourage, split_ent E is   
                                  an entourage E' such that E' \o E' is    
                                  included in E when seen as a relation    
                  unif_continuous f &lt;-&gt; f is uniformly continuous.         
              weak_uniformType == the uniform space for weak topologies    
               sup_uniformType == the uniform space for sup topologies     
        countable_uniformity T == T's entourage has a countable base. This 
                                  is equivalent to `T` being metrizable    
                       gauge E == For an entourage E, gauge E is a filter  
                                  which includes `iter n split_ent E`.     
                                  Critically, `gauge E` forms a uniform    
                                  space with a countable uniformity        
      gauge_psuedoMetricType E == the pseudoMetricType associated with the 
                                  `gauge E`                                
                  discrete_ent == entourages for the discrete topology     
                                                                           
* PseudoMetric spaces :                                                    
               entourage_ ball == entourages defined using balls           
              pseudoMetricType == interface type for pseudo metric space   
                                  structure: a type equipped with balls.   
 PseudoMetricMixin brefl bsym btriangle nbhsb == builds the mixin for a    
                                  pseudo metric space from the properties  
                                  of balls and the compatibility between   
                                  balls and entourages.                    
          PseudoMetricType T m == packs the pseudo metric space mixin into 
                                  a pseudoMetricType. T must have a        
                                  canonical structure of uniformType.      
[pseudoMetricType R of T for cT] == T-clone of the pseudoMetricType        
                                  structure cT, with R the ball radius.    
     [pseudoMetricType R of T] == clone of a canonical structure of        
                                  pseudoMetricType on T, with R the ball   
                                  radius.                                  
  uniformityOfBallMixin umixin == builds the mixin for a topological space 
                                  from a mixin for a pseudoMetric space.   
                      ball x e == ball of center x and radius e.           
               nbhs_ball_ ball == nbhs defined using the given balls       
                     nbhs_ball == nbhs defined using balls in a            
                                  pseudometric space                       
                    close x y &lt;-&gt; x and y are arbitrarily close w.r.t. to  
                                  balls.                                   
         weak_pseudoMetricType == the metric space for weak topologies     
           quotient_topology Q == the quotient topology corresponding to   
                                  quotient Q : quotType T. where T has     
                                  type topologicalType                     
                 discrete_ball == singleton balls for thediscrete topology 
                                                                           
* Complete uniform spaces :                                                
                     cauchy F &lt;-&gt; the set of sets F is a cauchy filter     
                                  (entourage definition)                   
                  completeType == interface type for a complete uniform    
                                  space structure.                         
      CompleteType T cvgCauchy == packs the proof that every proper cauchy 
                                  filter on T converges into a             
                                  completeType structure; T must have a    
                                  canonical structure of uniformType.      
    [completeType of T for cT] == T-clone of the completeType structure    
                                  cT.                                      
           [completeType of T] == clone of a canonical structure of        
                                  completeType on T.                       
                                                                           
* Complete pseudometric spaces :                                           
                  cauchy_ex F &lt;-&gt; the set of sets F is a cauchy filter     
                                  (epsilon-delta definition).              
                     cauchy F &lt;-&gt; the set of sets F is a cauchy filter     
                                  (using the near notations).              
      completePseudoMetricType == interface type for a complete            
                                  pseudometric space structure.            
CompletePseudoMetricType T cvgCauchy == packs the proof that every proper  
                                  cauchy filter on T converges into a      
                                  completePseudoMetricType structure; T    
                                  must have a canonical structure of       
                                  pseudoMetricType.                        
[completePseudoMetricType of T for cT] == T-clone of the                   
                                  completePseudoMetricType structure cT.   
[completePseudoMetricType of T] == clone of a canonical structure of       
                                  completePseudoMetricType on T.           
                                                                           
                       ball_ N == balls defined by the norm/absolute       
                                  value N                                  
                       dense S == the set (S : set T) is dense in T, with  
                                  T of type topologicalType                
                                                                           
* Subspaces of topological spaces :                                        
                subspace A == for (A : set T), this is a copy of T with    
                              a topology that ignores points outside A     
           incl_subspace x == with x of type subspace A with (A : set T),  
                              inclusion of subspace A into T               
                                                                           
* Arzela Ascoli' theorem :                                                 
           singletons T := [set [set x] | x in [set: T]].                  
     equicontinuous W x == the set (W : X -&gt; Y) is equicontinuous at x     
 pointwise_precompact W == For each (x : X), set of images [f x | f in W]  
                           is precompact                                   
                                                                           
We endow several standard types with the types of topological notions:     
- products: prod_topologicalType, prod_uniformType, prod_pseudoMetricType  
    sup_pseudoMetricType, weak_pseudoMetricType, product_pseudoMetricType  
- matrices: matrix_filtered, matrix_topologicalType, matrix_uniformType,   
    matrix_pseudoMetricType, matrix_completeType,                          
    matrix_completePseudoMetricType                                        
- nat: nat_filteredType, nat_topologicalType                               
- numFieldType: numField_filteredType, numField_topologicalType,           
    numField_uniformType, numField_pseudoMetricType (accessible with       
    "Import numFieldTopology.Exports.")                                    
</pre>
<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">near</span>' <span class="id">x</span> , <span class="id">P</span> }" (<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "{ '<span class="id">near</span>'  <span class="id">x</span> ,  <span class="id">P</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "'\<span class="kwd">forall</span>' <span class="id">x</span> '\<span class="id">near</span>' <span class="id">x_0</span> , <span class="id">P</span>"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 200, <span class="id">x</span> <span class="id">name</span>, <span class="id">P</span> <span class="kwd">at</span> <span class="id">level</span> 200,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> "'\<span class="kwd">forall</span>'  <span class="id">x</span>  '\<span class="id">near</span>'  <span class="id">x_0</span> ,  <span class="id">P</span>").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "'\<span class="id">near</span>' <span class="id">x</span> , <span class="id">P</span>"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 200, <span class="id">x</span> <span class="kwd">at</span> <span class="id">level</span> 99, <span class="id">P</span> <span class="kwd">at</span> <span class="id">level</span> 200,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> "'\<span class="id">near</span>'  <span class="id">x</span> ,  <span class="id">P</span>", <span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">near</span>' <span class="id">x</span> &amp; <span class="id">y</span> , <span class="id">P</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "{ '<span class="id">near</span>'  <span class="id">x</span>  &amp;  <span class="id">y</span> ,  <span class="id">P</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "'\<span class="kwd">forall</span>' <span class="id">x</span> '\<span class="id">near</span>' <span class="id">x_0</span> &amp; <span class="id">y</span> '\<span class="id">near</span>' <span class="id">y_0</span> , <span class="id">P</span>"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 200, <span class="id">x</span> <span class="id">name</span>, <span class="id">y</span> <span class="id">name</span>, <span class="id">P</span> <span class="kwd">at</span> <span class="id">level</span> 200,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> "'\<span class="kwd">forall</span>'  <span class="id">x</span>  '\<span class="id">near</span>'  <span class="id">x_0</span>  &amp;  <span class="id">y</span>  '\<span class="id">near</span>'  <span class="id">y_0</span> ,  <span class="id">P</span>").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "'\<span class="kwd">forall</span>' <span class="id">x</span> &amp; <span class="id">y</span> '\<span class="id">near</span>' <span class="id">z</span> , <span class="id">P</span>"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 200, <span class="id">x</span> <span class="id">name</span>, <span class="id">y</span> <span class="id">name</span>, <span class="id">P</span> <span class="kwd">at</span> <span class="id">level</span> 200,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> "'\<span class="kwd">forall</span>'  <span class="id">x</span>  &amp;  <span class="id">y</span>  '\<span class="id">near</span>'  <span class="id">z</span> ,  <span class="id">P</span>").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "'\<span class="id">near</span>' <span class="id">x</span> &amp; <span class="id">y</span> , <span class="id">P</span>"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 200, <span class="id">x</span>, <span class="id">y</span> <span class="kwd">at</span> <span class="id">level</span> 99, <span class="id">P</span> <span class="kwd">at</span> <span class="id">level</span> 200,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> "'\<span class="id">near</span>'  <span class="id">x</span>  &amp;  <span class="id">y</span> ,  <span class="id">P</span>", <span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "[ '<span class="id">filter</span>' '<span class="id">of</span>' <span class="id">x</span> ]" (<span class="id">format</span> "[ '<span class="id">filter</span>'  '<span class="id">of</span>'  <span class="id">x</span> ]").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">F</span> `=&gt;` <span class="id">G</span>" (<span class="kwd">at</span> <span class="id">level</span> 70, <span class="id">format</span> "<span class="id">F</span>  `=&gt;`  <span class="id">G</span>").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">F</span> --&gt; <span class="id">G</span>" (<span class="kwd">at</span> <span class="id">level</span> 70, <span class="id">format</span> "<span class="id">F</span>  --&gt;  <span class="id">G</span>").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "[ '<span class="id">lim</span>' <span class="id">F</span> '<span class="kwd">in</span>' <span class="id">T</span> ]" (<span class="id">format</span> "[ '<span class="id">lim</span>'  <span class="id">F</span>  '<span class="kwd">in</span>'  <span class="id">T</span> ]").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "[ '<span class="id">cvg</span>' <span class="id">F</span> '<span class="kwd">in</span>' <span class="id">T</span> ]" (<span class="id">format</span> "[ '<span class="id">cvg</span>'  <span class="id">F</span>  '<span class="kwd">in</span>'  <span class="id">T</span> ]").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">x</span> \<span class="id">is_near</span> <span class="id">F</span>" (<span class="kwd">at</span> <span class="id">level</span> 10, <span class="id">format</span> "<span class="id">x</span>  \<span class="id">is_near</span>  <span class="id">F</span>").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">E</span> @[ <span class="id">x</span> --&gt; <span class="id">F</span> ]"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 60, <span class="id">x</span> <span class="id">name</span>, <span class="id">format</span> "<span class="id">E</span>  @[ <span class="id">x</span>  --&gt;  <span class="id">F</span> ]").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">f</span> @ <span class="id">F</span>" (<span class="kwd">at</span> <span class="id">level</span> 60, <span class="id">format</span> "<span class="id">f</span>  @  <span class="id">F</span>").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">E</span> `@[ <span class="id">x</span> --&gt; <span class="id">F</span> ]"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 60, <span class="id">x</span> <span class="id">name</span>, <span class="id">format</span> "<span class="id">E</span>  `@[ <span class="id">x</span>  --&gt;  <span class="id">F</span> ]").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">f</span> `@ <span class="id">F</span>" (<span class="kwd">at</span> <span class="id">level</span> 60, <span class="id">format</span> "<span class="id">f</span>  `@  <span class="id">F</span>").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">A</span> ^°" (<span class="kwd">at</span> <span class="id">level</span> 1, <span class="id">format</span> "<span class="id">A</span> ^°").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "[ '<span class="id">locally</span>' <span class="id">P</span> ]" (<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">locally</span>'  <span class="id">P</span> ]").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">x</span> ^'" (<span class="kwd">at</span> <span class="id">level</span> 2, <span class="id">format</span> "<span class="id">x</span> ^'").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">within</span>' <span class="id">A</span> , '<span class="id">continuous</span>' <span class="id">f</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 70, <span class="id">A</span> <span class="kwd">at</span> <span class="id">level</span> 69, <span class="id">format</span> "{ '<span class="id">within</span>'  <span class="id">A</span> ,  '<span class="id">continuous</span>'  <span class="id">f</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">uniform</span>`' <span class="id">A</span> -&gt; <span class="id">V</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">A</span> <span class="kwd">at</span> <span class="id">level</span> 69, <span class="id">format</span> "{ '<span class="id">uniform</span>`'  <span class="id">A</span>  -&gt;  <span class="id">V</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">uniform</span>' <span class="id">U</span> -&gt; <span class="id">V</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">U</span> <span class="kwd">at</span> <span class="id">level</span> 69, <span class="id">format</span> "{ '<span class="id">uniform</span>'  <span class="id">U</span>  -&gt;  <span class="id">V</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">uniform</span>' <span class="id">A</span> , <span class="id">F</span> --&gt; <span class="id">f</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">A</span> <span class="kwd">at</span> <span class="id">level</span> 69, <span class="id">F</span> <span class="kwd">at</span> <span class="id">level</span> 69,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> "{ '<span class="id">uniform</span>'  <span class="id">A</span> ,  <span class="id">F</span>  --&gt;  <span class="id">f</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">uniform</span>' , <span class="id">F</span> --&gt; <span class="id">f</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">F</span> <span class="kwd">at</span> <span class="id">level</span> 69,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> "{ '<span class="id">uniform</span>' ,  <span class="id">F</span>  --&gt;  <span class="id">f</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">ptws</span>' <span class="id">U</span> -&gt; <span class="id">V</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">U</span> <span class="kwd">at</span> <span class="id">level</span> 69, <span class="id">format</span> "{ '<span class="id">ptws</span>'  <span class="id">U</span>  -&gt;  <span class="id">V</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">ptws</span>' , <span class="id">F</span> --&gt; <span class="id">f</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">F</span> <span class="kwd">at</span> <span class="id">level</span> 69, <span class="id">format</span> "{ '<span class="id">ptws</span>' ,  <span class="id">F</span>  --&gt;  <span class="id">f</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">family</span>' <span class="id">fam</span> , <span class="id">U</span> -&gt; <span class="id">V</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">U</span> <span class="kwd">at</span> <span class="id">level</span> 69, <span class="id">format</span> "{ '<span class="id">family</span>'  <span class="id">fam</span> ,  <span class="id">U</span>  -&gt;  <span class="id">V</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">family</span>' <span class="id">fam</span> , <span class="id">F</span> --&gt; <span class="id">f</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">F</span> <span class="kwd">at</span> <span class="id">level</span> 69, <span class="id">format</span> "{ '<span class="id">family</span>'  <span class="id">fam</span> ,  <span class="id">F</span>  --&gt;  <span class="id">f</span> }").<br/>
<br/>
<span class="kwd">Set</span> <span class="kwd">Implicit</span> <span class="kwd">Arguments</span>.<br/>
<span class="id">Unset</span> <span class="id">Strict</span> <span class="kwd">Implicit</span>.<br/>
<span class="id">Unset</span> <span class="id">Printing</span> <span class="kwd">Implicit</span> <span class="id">Defensive</span>.<br/>
<br/>
<span class="kwd">Obligation</span> <span class="kwd">Tactic</span> := <span class="id">idtac</span>.<br/>
<br/>
<span class="kwd">Import</span> <span class="id">Order.TTheory</span> <span class="id">GRing.Theory</span> <span class="id">Num.Theory</span>.<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">classical_set_scope</span>.<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">ring_scope</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="bigmaxmin">bigmaxmin</a></span>.<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> <span class="id"><a name="max">max</a></span> := <span class="id">Order.max</span>.<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> <span class="id"><a name="min">min</a></span> := <span class="id">Order.min</span>.<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">order_scope</span>.<br/>
<span class="kwd">Variables</span> (<span class="id"><a name="bigmaxmin.d">d</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#unit">unit</a></span>) (<span class="id"><a name="bigmaxmin.T">T</a></span> : <span class="id">orderType</span> <span class="id">d</span>) (<span class="id"><a name="bigmaxmin.x">x</a></span> : <span class="id">T</span>) (<span class="id"><a name="bigmaxmin.I">I</a></span> : <span class="id">finType</span>) (<span class="id"><a name="bigmaxmin.P">P</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#pred">pred</a></span> <span class="id">I</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a name="bigmaxmin.m">m</a></span> : <span class="id">T</span>) (<span class="id"><a name="bigmaxmin.F">F</a></span> : <span class="id">I</span> -&gt; <span class="id">T</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="bigmax_geP">bigmax_geP</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#reflect">reflect</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span> &lt;= <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.x">x</a></span> \/ <span class="kwd">exists2</span> <span class="id"><a name="i:8">i</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.P">P</a></span> <span class="id">i</span> &amp; <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span> &lt;= <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.F">F</a></span> <span class="id">i</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span> &lt;= \<span class="id">big</span>[<span class="id"><a href="mathcomp.analysis.topology.html#max">max</a></span>/<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.x">x</a></span>]<span class="id">_</span>(<span class="id"><a name="i:10">i</a></span> | <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.P">P</a></span> <span class="id">i</span>) <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.F">F</a></span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof1')">Proof.</span></div>
<div class="proofscript" id="proof1">
<span class="id">apply</span>: (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#iffP">iffP</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#idP">idP</a></span>) =&gt; [|[<span class="id">mx</span>|[<span class="id">i</span> <span class="id">Pi</span> <span class="id">mFi</span>]]].<br/>
- <span class="id">rewrite</span> <span class="id">leNgt</span> =&gt; /<span class="id">bigmax_ltP</span> /<span class="id"><a href="mathcomp.classical.boolp.html#not_andP">not_andP</a></span>[/<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">negP</a></span>|]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">leNgt</span>; <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.classical.boolp.html#existsNP">existsNP</a></span>[<span class="id">i</span> /<span class="id"><a href="mathcomp.classical.boolp.html#not_implyP">not_implyP</a></span>[<span class="id">Pi</span> /<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">negP</a></span>]]; <span class="id">rewrite</span> -<span class="id">leNgt</span>; <span class="id">right</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">bigmax_idl</span> <span class="id">le_maxr</span> <span class="id">mx</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">bigmaxD1</span> <span class="id">i</span>)// <span class="id">le_maxr</span> <span class="id">mFi</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="bigmax_gtP">bigmax_gtP</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#reflect">reflect</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span> &lt; <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.x">x</a></span> \/ <span class="kwd">exists2</span> <span class="id"><a name="i:13">i</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.P">P</a></span> <span class="id">i</span> &amp; <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span> &lt; <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.F">F</a></span> <span class="id">i</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span> &lt; \<span class="id">big</span>[<span class="id"><a href="mathcomp.analysis.topology.html#max">max</a></span>/<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.x">x</a></span>]<span class="id">_</span>(<span class="id"><a name="i:15">i</a></span> | <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.P">P</a></span> <span class="id">i</span>) <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.F">F</a></span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof2')">Proof.</span></div>
<div class="proofscript" id="proof2">
<span class="id">apply</span>: (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#iffP">iffP</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#idP">idP</a></span>) =&gt; [|[<span class="id">mx</span>|[<span class="id">i</span> <span class="id">Pi</span> <span class="id">mFi</span>]]].<br/>
- <span class="id">rewrite</span> <span class="id">ltNge</span> =&gt; /<span class="id">bigmax_leP</span> /<span class="id"><a href="mathcomp.classical.boolp.html#not_andP">not_andP</a></span>[/<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">negP</a></span>|]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">ltNge</span>; <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.classical.boolp.html#existsNP">existsNP</a></span>[<span class="id">i</span> /<span class="id"><a href="mathcomp.classical.boolp.html#not_implyP">not_implyP</a></span>[<span class="id">Pi</span> /<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">negP</a></span>]]; <span class="id">rewrite</span> -<span class="id">ltNge</span>; <span class="id">right</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">bigmax_idl</span> <span class="id">lt_maxr</span> <span class="id">mx</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">bigmaxD1</span> <span class="id">i</span>)// <span class="id">lt_maxr</span> <span class="id">mFi</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="bigmin_leP">bigmin_leP</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#reflect">reflect</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.x">x</a></span> &lt;= <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span> \/ <span class="kwd">exists2</span> <span class="id"><a name="i:18">i</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.P">P</a></span> <span class="id">i</span> &amp; <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.F">F</a></span> <span class="id">i</span> &lt;= <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(\<span class="id">big</span>[<span class="id"><a href="mathcomp.analysis.topology.html#min">min</a></span>/<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.x">x</a></span>]<span class="id">_</span>(<span class="id"><a name="i:20">i</a></span> | <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.P">P</a></span> <span class="id">i</span>) <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.F">F</a></span> <span class="id">i</span> &lt;= <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof3')">Proof.</span></div>
<div class="proofscript" id="proof3">
<span class="id">apply</span>: (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#iffP">iffP</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#idP">idP</a></span>) =&gt; [|[<span class="id">xm</span>|[<span class="id">i</span> <span class="id">Pi</span> <span class="id">Fim</span>]]].<br/>
- <span class="id">rewrite</span> <span class="id">leNgt</span> =&gt; /<span class="id">bigmin_gtP</span> /<span class="id"><a href="mathcomp.classical.boolp.html#not_andP">not_andP</a></span>[/<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">negP</a></span>|]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">leNgt</span>; <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.classical.boolp.html#existsNP">existsNP</a></span>[<span class="id">i</span> /<span class="id"><a href="mathcomp.classical.boolp.html#not_implyP">not_implyP</a></span>[<span class="id">Pi</span> /<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">negP</a></span>]]; <span class="id">rewrite</span> -<span class="id">leNgt</span>; <span class="id">right</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">bigmin_idl</span> <span class="id">le_minl</span> <span class="id">xm</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">bigminD1</span> <span class="id">i</span>)// <span class="id">le_minl</span> <span class="id">Fim</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="bigmin_ltP">bigmin_ltP</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#reflect">reflect</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.x">x</a></span> &lt; <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span> \/ <span class="kwd">exists2</span> <span class="id"><a name="i:23">i</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.P">P</a></span> <span class="id">i</span> &amp; <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.F">F</a></span> <span class="id">i</span> &lt; <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(\<span class="id">big</span>[<span class="id"><a href="mathcomp.analysis.topology.html#min">min</a></span>/<span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.x">x</a></span>]<span class="id">_</span>(<span class="id"><a name="i:25">i</a></span> | <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.P">P</a></span> <span class="id">i</span>) <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.F">F</a></span> <span class="id">i</span> &lt; <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin.m">m</a></span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof4')">Proof.</span></div>
<div class="proofscript" id="proof4">
<span class="id">apply</span>: (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#iffP">iffP</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#idP">idP</a></span>) =&gt; [|[<span class="id">xm</span>|[<span class="id">i</span> <span class="id">Pi</span> <span class="id">Fim</span>]]].<br/>
- <span class="id">rewrite</span> <span class="id">ltNge</span> =&gt; /<span class="id">bigmin_geP</span> /<span class="id"><a href="mathcomp.classical.boolp.html#not_andP">not_andP</a></span>[/<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">negP</a></span>|]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">ltNge</span>; <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.classical.boolp.html#existsNP">existsNP</a></span>[<span class="id">i</span> /<span class="id"><a href="mathcomp.classical.boolp.html#not_implyP">not_implyP</a></span>[<span class="id">Pi</span> /<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">negP</a></span>]]; <span class="id">rewrite</span> -<span class="id">ltNge</span>; <span class="id">right</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">bigmin_idl</span> <span class="id">lt_minl</span> <span class="id">xm</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">bigminD1</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Pi</span>) <span class="id">lt_minl</span> <span class="id">Fim</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#bigmaxmin">bigmaxmin</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="monotonous">monotonous</a></span> <span class="id"><a name="d:28">d</a></span> (<span class="id"><a name="T:29">T</a></span> : <span class="id">porderType</span> <span class="id">d</span>) (<span class="id"><a name="pT:30">pT</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#predType">predType</a></span> <span class="id">T</span>) (<span class="id"><a name="A:31">A</a></span> : <span class="id">pT</span>) (<span class="id"><a name="f:32">f</a></span> : <span class="id">T</span> -&gt; <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> <span class="id">A</span> &amp;, {<span class="id">mono</span> <span class="id">f</span> : <span class="id"><a name="x:33">x</a></span> <span class="id"><a name="y:34">y</a></span> / (<span class="id">x</span> &lt;= <span class="id">y</span>)%<span class="id">O</span>}} \/ {<span class="kwd">in</span> <span class="id">A</span> &amp;, {<span class="id">mono</span> <span class="id">f</span> : <span class="id"><a name="x:38">x</a></span> <span class="id"><a name="y:37">y</a></span> /~ (<span class="id">x</span> &lt;= <span class="id">y</span>)%<span class="id">O</span>}}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="and_prop_in">and_prop_in</a></span> (<span class="id"><a name="T:41">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="p:42">p</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#mem_pred">mem_pred</a></span> <span class="id">T</span>) (<span class="id"><a name="P:43">P</a></span> <span class="id"><a name="Q:44">Q</a></span> : <span class="id">T</span> -&gt; <span class="kwd">Prop</span>) :<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> <span class="id">p</span>, <span class="kwd">forall</span> <span class="id"><a name="x:45">x</a></span>, <span class="id">P</span> <span class="id">x</span> /\ <span class="id">Q</span> <span class="id">x</span>} &lt;-&gt;<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> <span class="id">p</span>, <span class="kwd">forall</span> <span class="id"><a name="x:46">x</a></span>, <span class="id">P</span> <span class="id">x</span>} /\ {<span class="kwd">in</span> <span class="id">p</span>, <span class="kwd">forall</span> <span class="id"><a name="x:47">x</a></span>, <span class="id">Q</span> <span class="id">x</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof5')">Proof.</span></div>
<div class="proofscript" id="proof5">
<span class="id">split</span>=&gt; [<span class="id">cnd</span>|[<span class="id">cnd1</span> <span class="id">cnd2</span>] <span class="id">x</span> <span class="id">xin</span>]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">split</span>=&gt; <span class="id">x</span> <span class="id">xin</span>; <span class="id">case</span>: (<span class="id">cnd</span> <span class="id">x</span> <span class="id">xin</span>).<br/>
<span class="kwd">by</span> <span class="id">split</span>; [<span class="id">apply</span>: <span class="id">cnd1</span> | <span class="id">apply</span>: <span class="id">cnd2</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="mem_inc_segment">mem_inc_segment</a></span> <span class="id"><a name="d:48">d</a></span> (<span class="id"><a name="T:49">T</a></span> : <span class="id">porderType</span> <span class="id">d</span>) (<span class="id"><a name="a:50">a</a></span> <span class="id"><a name="b:51">b</a></span> : <span class="id">T</span>) (<span class="id"><a name="f:52">f</a></span> : <span class="id">T</span> -&gt; <span class="id">T</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="kwd">in</span> `[<span class="id">a</span>, <span class="id">b</span>] &amp;, {<span class="id">mono</span> <span class="id">f</span> : <span class="id"><a name="x:53">x</a></span> <span class="id"><a name="y:54">y</a></span> / (<span class="id">x</span> &lt;= <span class="id">y</span>)%<span class="id">O</span>}} -&gt;<br/>
&nbsp;&nbsp;{<span class="id">homo</span> <span class="id">f</span> : <span class="id"><a name="x:57">x</a></span> / <span class="id">x</span> \<span class="kwd">in</span> `[<span class="id">a</span>, <span class="id">b</span>] &gt;-&gt; <span class="id">x</span> \<span class="kwd">in</span> `[<span class="id">f</span> <span class="id">a</span>, <span class="id">f</span> <span class="id">b</span>]}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof6')">Proof.</span></div>
<div class="proofscript" id="proof6">
<span class="id">move</span>=&gt; <span class="id">fle</span> <span class="id">x</span> <span class="id">xab</span>; <span class="id">have</span> <span class="id">leab</span> : (<span class="id">a</span> &lt;= <span class="id">b</span>)%<span class="id">O</span> <span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">itvP</span> <span class="id">xab</span>).<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">in_itv</span>/= !<span class="id">fle</span> ?(<span class="id">itvP</span> <span class="id">xab</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="mem_dec_segment">mem_dec_segment</a></span> <span class="id"><a name="d:59">d</a></span> (<span class="id"><a name="T:60">T</a></span> : <span class="id">porderType</span> <span class="id">d</span>) (<span class="id"><a name="a:61">a</a></span> <span class="id"><a name="b:62">b</a></span> : <span class="id">T</span>) (<span class="id"><a name="f:63">f</a></span> : <span class="id">T</span> -&gt; <span class="id">T</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="kwd">in</span> `[<span class="id">a</span>, <span class="id">b</span>] &amp;, {<span class="id">mono</span> <span class="id">f</span> : <span class="id"><a name="x:65">x</a></span> <span class="id"><a name="y:64">y</a></span> /~ (<span class="id">x</span> &lt;= <span class="id">y</span>)%<span class="id">O</span>}} -&gt;<br/>
&nbsp;&nbsp;{<span class="id">homo</span> <span class="id">f</span> : <span class="id"><a name="x:68">x</a></span> / <span class="id">x</span> \<span class="kwd">in</span> `[<span class="id">a</span>, <span class="id">b</span>] &gt;-&gt; <span class="id">x</span> \<span class="kwd">in</span> `[<span class="id">f</span> <span class="id">b</span>, <span class="id">f</span> <span class="id">a</span>]}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof7')">Proof.</span></div>
<div class="proofscript" id="proof7">
<span class="id">move</span>=&gt; <span class="id">fge</span> <span class="id">x</span> <span class="id">xab</span>; <span class="id">have</span> <span class="id">leab</span> : (<span class="id">a</span> &lt;= <span class="id">b</span>)%<span class="id">O</span> <span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">itvP</span> <span class="id">xab</span>).<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">in_itv</span>/= !<span class="id">fge</span> ?(<span class="id">itvP</span> <span class="id">xab</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Linear1">Linear1</a></span>.<br/>
<span class="kwd">Context</span> (<span class="id"><a name="R:70">R</a></span> : <span class="id">ringType</span>) (<span class="id"><a name="U:71">U</a></span> : <span class="id">lmodType</span> <span class="id">R</span>) (<span class="id"><a name="V:72">V</a></span> : <span class="id">zmodType</span>) (<span class="id"><a name="s:73">s</a></span> : <span class="id">R</span> -&gt; <span class="id">V</span> -&gt; <span class="id">V</span>).<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="linear_eqType">linear_eqType</a></span> := <span class="id">EqType</span> {<span class="id">linear</span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear1.U">U</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Linear1.V">V</a></span> | <span class="id"><a href="mathcomp.analysis.topology.html#Linear1.s">s</a></span>} <span class="id"><a href="mathcomp.classical.boolp.html#gen_eqMixin">gen_eqMixin</a></span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="linear_choiceType">linear_choiceType</a></span> := <span class="id">ChoiceType</span> {<span class="id">linear</span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear1.U">U</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Linear1.V">V</a></span> | <span class="id"><a href="mathcomp.analysis.topology.html#Linear1.s">s</a></span>} <span class="id"><a href="mathcomp.classical.boolp.html#gen_choiceMixin">gen_choiceMixin</a></span>.<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear1">Linear1</a></span>.<br/>
<span class="kwd">Section</span> <span class="id"><a name="Linear2">Linear2</a></span>.<br/>
<span class="kwd">Context</span> (<span class="id"><a name="R:74">R</a></span> : <span class="id">ringType</span>) (<span class="id"><a name="U:75">U</a></span> : <span class="id">lmodType</span> <span class="id">R</span>) (<span class="id"><a name="V:76">V</a></span> : <span class="id">zmodType</span>) (<span class="id"><a name="s:77">s</a></span> : <span class="id">R</span> -&gt; <span class="id">V</span> -&gt; <span class="id">V</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a name="s_law:78">s_law</a></span> : <span class="id">GRing.Scale.law</span> <span class="id">s</span>).<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="linear_pointedType">linear_pointedType</a></span> := <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.PointedType">PointedType</a></span> {<span class="id">linear</span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear2.U">U</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Linear2.V">V</a></span> | <span class="id">GRing.Scale.op</span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear2.s_law">s_law</a></span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id">GRing.null_fun_linear</span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear2.R">R</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear2.U">U</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear2.V">V</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear2.s">s</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear2.s_law">s_law</a></span>).<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Linear2">Linear2</a></span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id"><a name="Filtered">Filtered</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Filtered.nbhs_of">nbhs_of</a></span> <span class="id"><a name="U:79">U</a></span> <span class="id"><a name="T:80">T</a></span> := <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>).<br/>
<span class="kwd">Record</span> <span class="id"><a name="Filtered.class_of">class_of</a></span> <span class="id"><a name="U:81">U</a></span> <span class="id"><a name="T:82">T</a></span> := <span class="kwd">Class</span> {<br/>
&nbsp;&nbsp;<span class="id"><a name="Filtered.base">base</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.class_of">Pointed.class_of</a></span> <span class="id">T</span>;<br/>
&nbsp;&nbsp;<span class="id"><a name="Filtered.nbhs_op">nbhs_op</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.nbhs_of">nbhs_of</a></span> <span class="id">U</span> <span class="id">T</span><br/>
}.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Filtered.ClassDef">ClassDef</a></span>.<br/>
<span class="kwd">Variable</span> <span class="id"><a name="Filtered.ClassDef.U">U</a></span> : <span class="kwd">Type</span>.<br/>
<br/>
<span class="kwd">Structure</span> <span class="id"><a name="Filtered.type">type</a></span> := <span class="id">Pack</span> { <span class="id"><a name="Filtered.sort">sort</a></span>; <span class="id">_</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.class_of">class_of</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.U">U</a></span> <span class="id">sort</span> }.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Variables</span> (<span class="id"><a name="Filtered.ClassDef.T">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="Filtered.ClassDef.cT">cT</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.type">type</a></span>).<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Filtered.class">class</a></span> := <span class="kwd">let</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Pack">Pack</a></span> <span class="id">_</span> <span class="id">c</span> := <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.cT">cT</a></span> <span class="kwd">return</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.class_of">class_of</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.U">U</a></span> <span class="id">cT</span> <span class="kwd">in</span> <span class="id">c</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Filtered.clone">clone</a></span> <span class="id"><a name="c:92">c</a></span> <span class="id">of</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#phant_id">phant_id</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.class">class</a></span> <span class="id">c</span> := @<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Pack">Pack</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.T">T</a></span> <span class="id">c</span>.<br/>
<span class="kwd">Let</span> <span class="id"><a name="Filtered.ClassDef.xT">xT</a></span> := <span class="kwd">let</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Pack">Pack</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#T">T</a></span> <span class="id">_</span> := <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.cT">cT</a></span> <span class="kwd">in</span> <span class="id">T</span>.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="Filtered.xclass">xclass</a></span> := (<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.class">class</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.class_of">class_of</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.U">U</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.xT">xT</a></span>).<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Pointed.class_of</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Filtered.pack">pack</a></span> <span class="id"><a name="m:94">m</a></span> :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id"><a name="bT:95">bT</a></span> <span class="id"><a name="b:96">b</a></span> <span class="id">of</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#phant_id">phant_id</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.class">Pointed.class</a></span> <span class="id">bT</span>) <span class="id">b</span> =&gt; @<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Pack">Pack</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.T">T</a></span> (<span class="kwd">Class</span> <span class="id">b</span> <span class="id">m</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Filtered.eqType">eqType</a></span> := @<span class="id">Equality.Pack</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.cT">cT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.xclass">xclass</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Filtered.choiceType">choiceType</a></span> := @<span class="id">Choice.Pack</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.cT">cT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.xclass">xclass</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Filtered.fpointedType">fpointedType</a></span> := @<span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Pack">Pointed.Pack</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef.cT">cT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.xclass">xclass</a></span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.ClassDef">ClassDef</a></span>.<br/>
<br/>
<span class="kwd">Structure</span> <span class="id"><a name="Filtered.source">source</a></span> <span class="id"><a name="Z:97">Z</a></span> <span class="id"><a name="Y:98">Y</a></span> := <span class="id">Source</span> {<br/>
&nbsp;&nbsp;<span class="id"><a name="Filtered.source_type">source_type</a></span> :&gt; <span class="kwd">Type</span>;<br/>
&nbsp;&nbsp;<span class="id">_</span> : (<span class="id">source_type</span> -&gt; <span class="id">Z</span>) -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">Y</span>)<br/>
}.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Filtered.source_filter">source_filter</a></span> <span class="id"><a name="Z:101">Z</a></span> <span class="id"><a name="Y:102">Y</a></span> (<span class="id"><a name="F:103">F</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.source">source</a></span> <span class="id">Z</span> <span class="id">Y</span>) : (<span class="id">F</span> -&gt; <span class="id">Z</span>) -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">Y</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Source">Source</a></span> <span class="id">X</span> <span class="id">f</span> := <span class="id">F</span> <span class="kwd">in</span> <span class="id">f</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id"><a name="Filtered.Exports">Exports</a></span>.<br/>
<span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Pointed.class_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">nbhs_op</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">nbhs_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">eqType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Equality.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.eqType">eqType</a></span>.<br/>
<span class="kwd">Coercion</span> <span class="id">choiceType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Choice.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.choiceType">choiceType</a></span>.<br/>
<span class="kwd">Coercion</span> <span class="id">fpointedType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Pointed.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.fpointedType">fpointedType</a></span>.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="Filtered.Exports.filteredType">filteredType</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.type">type</a></span>.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="Filtered.Exports.FilteredType">FilteredType</a></span> <span class="id">U</span> <span class="id">T</span> <span class="id">m</span> := (@<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.pack">pack</a></span> <span class="id">U</span> <span class="id">T</span> <span class="id">m</span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#idfun">idfun</a></span>).<br/>
<span class="kwd">Notation</span> "[ '<span class="id">filteredType</span>' <span class="id">U</span> '<span class="id">of</span>' <span class="id">T</span> '<span class="kwd">for</span>' <span class="id">cT</span> ]" :=  (@<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.clone">clone</a></span> <span class="id">U</span> <span class="id">T</span> <span class="id">cT</span> <span class="id">_</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#idfun">idfun</a></span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">filteredType</span>'  <span class="id">U</span>  '<span class="id">of</span>'  <span class="id">T</span>  '<span class="kwd">for</span>'  <span class="id">cT</span> ]") : <span class="id">form_scope</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">filteredType</span>' <span class="id">U</span> '<span class="id">of</span>' <span class="id">T</span> ]" := (@<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.clone">clone</a></span> <span class="id">U</span> <span class="id">T</span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">id</a></span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">filteredType</span>'  <span class="id">U</span>  '<span class="id">of</span>'  <span class="id">T</span> ]") : <span class="id">form_scope</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="Filtered.Exports.default_arrow_filter">default_arrow_filter</a></span> <span class="id"><a name="Y:105">Y</a></span> (<span class="id"><a name="Z:106">Z</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.pointedType">pointedType</a></span>) (<span class="id"><a name="X:107">X</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.source">source</a></span> <span class="id">Z</span> <span class="id">Y</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Exports.FilteredType">FilteredType</a></span> <span class="id">Y</span> (<span class="id">X</span> -&gt; <span class="id">Z</span>) (@<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.source_filter">source_filter</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">X</span>).<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="Filtered.Exports.source_filter_filter">source_filter_filter</a></span> <span class="id"><a name="Y:108">Y</a></span> :=<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Source">Source</a></span> <span class="kwd">Prop</span> <span class="id">_</span> (<span class="id">_</span> -&gt; <span class="kwd">Prop</span>) (<span class="kwd">fun</span> <span class="id"><a name="x:109">x</a></span> : (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">Y</span>)) =&gt; <span class="id">x</span>).<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="Filtered.Exports.source_filter_filter'">source_filter_filter</a></span>' <span class="id"><a name="Y:110">Y</a></span> :=<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Source">Source</a></span> <span class="kwd">Prop</span> <span class="id">_</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">_</span>) (<span class="kwd">fun</span> <span class="id"><a name="x:111">x</a></span> : (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">Y</span>)) =&gt; <span class="id">x</span>).<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Exports">Exports</a></span>.<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered">Filtered</a></span>.<br/>
<span class="kwd">Export</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Exports">Filtered.Exports</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="nbhs">nbhs</a></span> {<span class="id"><a name="U:112">U</a></span>} {<span class="id"><a name="T:113">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>} : <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_op">Filtered.nbhs_op</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#class">Filtered.class</a></span> <span class="id">T</span>).<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> {<span class="id">U</span> <span class="id">T</span>} <span class="id">_</span> <span class="id">_</span> : <span class="id">simpl</span> <span class="id">never</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="filter_from">filter_from</a></span> {<span class="id"><a name="I:114">I</a></span> <span class="id"><a name="T:115">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="D:116">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id"><a name="B:117">B</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id"><a name="P:118">P</a></span> | <span class="kwd">exists2</span> <span class="id"><a name="i:119">i</a></span>, <span class="id">D</span> <span class="id">i</span> &amp; <span class="id">B</span> <span class="id">i</span> `&lt;=` <span class="id">P</span>].<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="matrix_filtered">matrix_filtered</a></span> <span class="id"><a name="m:121">m</a></span> <span class="id"><a name="n:122">n</a></span> <span class="id"><a name="X:123">X</a></span> (<span class="id"><a name="Z:124">Z</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">X</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> '<span class="id">M</span>[<span class="id">X</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#FilteredType">FilteredType</a></span> '<span class="id">M</span>[<span class="id">X</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) '<span class="id">M</span>[<span class="id">Z</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) (<span class="kwd">fun</span> <span class="id"><a name="mx:125">mx</a></span> =&gt; <span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">set</span> <span class="id"><a name="P:130">P</a></span> | <span class="kwd">forall</span> <span class="id"><a name="i:131">i</a></span> <span class="id"><a name="j:132">j</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> (<span class="id">mx</span> <span class="id">i</span> <span class="id">j</span>) (<span class="id">P</span> <span class="id">i</span> <span class="id">j</span>)]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id"><a name="P:126">P</a></span> =&gt; [<span class="id">set</span> <span class="id"><a name="my:127">my</a></span> : '<span class="id">M</span>[<span class="id">X</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) | <span class="kwd">forall</span> <span class="id"><a name="i:128">i</a></span> <span class="id"><a name="j:129">j</a></span>, <span class="id">P</span> <span class="id">i</span> <span class="id">j</span> (<span class="id">my</span> <span class="id">i</span> <span class="id">j</span>)])).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="filter_prod">filter_prod</a></span> {<span class="id"><a name="T:133">T</a></span> <span class="id"><a name="U:134">U</a></span> : <span class="kwd">Type</span>}<br/>
&nbsp;&nbsp;(<span class="id"><a name="F:135">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="G:136">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id">T</span> * <span class="id">U</span>)) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> (<span class="kwd">fun</span> <span class="id"><a name="P:138">P</a></span> =&gt; <span class="id">F</span> <span class="id">P</span>.1 /\ <span class="id">G</span> <span class="id">P</span>.2) (<span class="kwd">fun</span> <span class="id"><a name="P:137">P</a></span> =&gt; <span class="id">P</span>.1 `*` <span class="id">P</span>.2).<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Near">Near</a></span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "{ '<span class="id">all1</span>' <span class="id">P</span> }" := (<span class="kwd">forall</span> <span class="id"><a name="x:139">x</a></span>, <span class="id">P</span> <span class="id">x</span> : <span class="kwd">Prop</span>) (<span class="kwd">at</span> <span class="id">level</span> 0).<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "{ '<span class="id">all2</span>' <span class="id">P</span> }" := (<span class="kwd">forall</span> <span class="id"><a name="x:140">x</a></span> <span class="id"><a name="y:141">y</a></span>, <span class="id">P</span> <span class="id">x</span> <span class="id">y</span> : <span class="kwd">Prop</span>) (<span class="kwd">at</span> <span class="id">level</span> 0).<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "{ '<span class="id">all3</span>' <span class="id">P</span> }" := (<span class="kwd">forall</span> <span class="id"><a name="x:142">x</a></span> <span class="id"><a name="y:143">y</a></span> <span class="id"><a name="z:144">z</a></span>, <span class="id">P</span> <span class="id">x</span> <span class="id">y</span> <span class="id">z</span>: <span class="kwd">Prop</span>) (<span class="kwd">at</span> <span class="id">level</span> 0).<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> <span class="id"><a name="ph">ph</a></span> := (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#phantom">phantom</a></span> <span class="id">_</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="prop_near1">prop_near1</a></span> {<span class="id"><a name="X:145">X</a></span>} {<span class="id"><a name="fX:146">fX</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">X</span>} (<span class="id"><a name="x:147">x</a></span> : <span class="id">fX</span>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id"><a name="P:148">P</a></span> (<span class="id"><a name="phP:149">phP</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#ph">ph</a></span> {<span class="id">all1</span> <span class="id">P</span>}) := <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span> <span class="id">P</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="prop_near2">prop_near2</a></span> {<span class="id"><a name="X:150">X</a></span> <span class="id"><a name="X':151">X</a></span>'} {<span class="id"><a name="fX:152">fX</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">X</span>} {<span class="id"><a name="fX':153">fX</a></span>' : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">X</span>'}<br/>
&nbsp;&nbsp;(<span class="id"><a name="x:154">x</a></span> : <span class="id">fX</span>) (<span class="id"><a name="x':155">x</a></span>' : <span class="id">fX</span>') := <span class="kwd">fun</span> <span class="id"><a name="P:156">P</a></span> <span class="id">of</span> <span class="id"><a href="mathcomp.analysis.topology.html#ph">ph</a></span> {<span class="id">all2</span> <span class="id">P</span>} =&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>') (<span class="kwd">fun</span> <span class="id"><a name="x:157">x</a></span> =&gt; <span class="id">P</span> <span class="id">x</span>.1 <span class="id">x</span>.2).<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Near">Near</a></span>.<br/>
<br/>
<span class="kwd">Notation</span> "{ '<span class="id">near</span>' <span class="id">x</span> , <span class="id">P</span> }" := (@<span class="id"><a href="mathcomp.analysis.topology.html#prop_near1">prop_near1</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">x</span> <span class="id">_</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#inPhantom">inPhantom</a></span> <span class="id">P</span>)) : <span class="id">type_scope</span>.<br/>
<span class="kwd">Notation</span> "'\<span class="kwd">forall</span>' <span class="id">x</span> '\<span class="id">near</span>' <span class="id">x_0</span> , <span class="id">P</span>" := {<span class="id">near</span> <span class="id">x_0</span>, <span class="kwd">forall</span> <span class="id"><a name="x:158">x</a></span>, <span class="id">P</span>} : <span class="id">type_scope</span>.<br/>
<span class="kwd">Notation</span> "'\<span class="id">near</span>' <span class="id">x</span> , <span class="id">P</span>" := (\<span class="kwd">forall</span> <span class="id"><a name="x:159">x</a></span> \<span class="id">near</span> <span class="id">x</span>, <span class="id">P</span>) : <span class="id">type_scope</span>.<br/>
<span class="kwd">Notation</span> "{ '<span class="id">near</span>' <span class="id">x</span> &amp; <span class="id">y</span> , <span class="id">P</span> }" :=<br/>
&nbsp;&nbsp;(@<span class="id"><a href="mathcomp.analysis.topology.html#prop_near2">prop_near2</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">x</span> <span class="id">y</span> <span class="id">_</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#inPhantom">inPhantom</a></span> <span class="id">P</span>)) : <span class="id">type_scope</span>.<br/>
<span class="kwd">Notation</span> "'\<span class="kwd">forall</span>' <span class="id">x</span> '\<span class="id">near</span>' <span class="id">x_0</span> &amp; <span class="id">y</span> '\<span class="id">near</span>' <span class="id">y_0</span> , <span class="id">P</span>" :=<br/>
&nbsp;&nbsp;{<span class="id">near</span> <span class="id">x_0</span> &amp; <span class="id">y_0</span>, <span class="kwd">forall</span> <span class="id"><a name="x:160">x</a></span> <span class="id"><a name="y:161">y</a></span>, <span class="id">P</span>} : <span class="id">type_scope</span>.<br/>
<span class="kwd">Notation</span> "'\<span class="kwd">forall</span>' <span class="id">x</span> &amp; <span class="id">y</span> '\<span class="id">near</span>' <span class="id">z</span> , <span class="id">P</span>" :=<br/>
&nbsp;&nbsp;{<span class="id">near</span> <span class="id">z</span> &amp; <span class="id">z</span>, <span class="kwd">forall</span> <span class="id"><a name="x:162">x</a></span> <span class="id"><a name="y:163">y</a></span>, <span class="id">P</span>} : <span class="id">type_scope</span>.<br/>
<span class="kwd">Notation</span> "'\<span class="id">near</span>' <span class="id">x</span> &amp; <span class="id">y</span> , <span class="id">P</span>" := (\<span class="kwd">forall</span> <span class="id"><a name="x:164">x</a></span> \<span class="id">near</span> <span class="id">x</span> &amp; <span class="id"><a name="y:165">y</a></span> \<span class="id">near</span> <span class="id">y</span>, <span class="id">P</span>) : <span class="id">type_scope</span>.<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#prop_near1">prop_near1</a></span> : <span class="id">simpl</span> <span class="id">never</span>.<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#prop_near2">prop_near2</a></span> : <span class="id">simpl</span> <span class="id">never</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nearE">nearE</a></span> {<span class="id"><a name="T:166">T</a></span>} {<span class="id"><a name="F:167">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} (<span class="id"><a name="P:168">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) : (\<span class="kwd">forall</span> <span class="id"><a name="x:169">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">P</span> <span class="id">x</span>) = <span class="id">F</span> <span class="id">P</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof8')">Proof.</span></div>
<div class="proofscript" id="proof8">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="eq_near">eq_near</a></span> {<span class="id"><a name="T:170">T</a></span>} {<span class="id"><a name="F:171">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} (<span class="id"><a name="P:172">P</a></span> <span class="id"><a name="Q:173">Q</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="x:174">x</a></span>, <span class="id">P</span> <span class="id">x</span> &lt;-&gt; <span class="id">Q</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="x:175">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">P</span> <span class="id">x</span>) = (\<span class="kwd">forall</span> <span class="id"><a name="x:176">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">Q</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof9')">Proof.</span></div>
<div class="proofscript" id="proof9">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.classical.boolp.html#predeqP">predeqP</a></span> -&gt;. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="filter_of">filter_of</a></span> <span class="id"><a name="X:177">X</a></span> (<span class="id"><a name="fX:178">fX</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">X</span>) (<span class="id"><a name="x:179">x</a></span> : <span class="id">fX</span>) <span class="id">of</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#phantom">phantom</a></span> <span class="id">fX</span> <span class="id">x</span> :=<br/>
&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">filter</span>' '<span class="id">of</span>' <span class="id">x</span> ]" :=<br/>
&nbsp;&nbsp;(@<span class="id"><a href="mathcomp.analysis.topology.html#filter_of">filter_of</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#Phantom">Phantom</a></span> <span class="id">_</span> <span class="id">x</span>)) : <span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_of">filter_of</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> /.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_of_filterE">filter_of_filterE</a></span> {<span class="id"><a name="T:180">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="F:181">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) : [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>] = <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof10')">Proof.</span></div>
<div class="proofscript" id="proof10">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhs_filterE">nbhs_filterE</a></span> {<span class="id"><a name="T:182">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="F:183">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">F</span> = <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof11')">Proof.</span></div>
<div class="proofscript" id="proof11">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Module</span> <span class="kwd">Export</span> <span class="id"><a name="NbhsFilter">NbhsFilter</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="NbhsFilter.nbhs_simpl">nbhs_simpl</a></span> := (@<span class="id"><a href="mathcomp.analysis.topology.html#filter_of_filterE">filter_of_filterE</a></span>, @<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_filterE">nbhs_filterE</a></span>).<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#NbhsFilter">NbhsFilter</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="cvg_to">cvg_to</a></span> {<span class="id"><a name="T:184">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="F:185">F</a></span> <span class="id"><a name="G:186">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) := <span class="id">G</span> `&lt;=` <span class="id">F</span>.<br/>
<span class="kwd">Notation</span> "<span class="id">F</span> `=&gt;` <span class="id">G</span>" := (<span class="id"><a href="mathcomp.analysis.topology.html#cvg_to">cvg_to</a></span> <span class="id">F</span> <span class="id">G</span>) : <span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_refl">cvg_refl</a></span> <span class="id"><a name="T:187">T</a></span> (<span class="id"><a name="F:188">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) : <span class="id">F</span> `=&gt;` <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof12')">Proof.</span></div>
<div class="proofscript" id="proof12">
 <span class="id">exact</span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvg_refl">cvg_refl</a></span> {<span class="id">T</span> <span class="id">F</span>}.<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">cvg_refl</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_trans">cvg_trans</a></span> <span class="id"><a name="T:189">T</a></span> (<span class="id"><a name="G:190">G</a></span> <span class="id"><a name="F:191">F</a></span> <span class="id"><a name="H:192">H</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;(<span class="id">F</span> `=&gt;` <span class="id">G</span>) -&gt; (<span class="id">G</span> `=&gt;` <span class="id">H</span>) -&gt; (<span class="id">F</span> `=&gt;` <span class="id">H</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof13')">Proof.</span></div>
<div class="proofscript" id="proof13">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FG</span> <span class="id">GH</span> <span class="id">P</span> /<span class="id">GH</span> /<span class="id">FG</span>. Qed.</div>
<br/>
<span class="kwd">Notation</span> "<span class="id">F</span> --&gt; <span class="id">G</span>" := (<span class="id"><a href="mathcomp.analysis.topology.html#cvg_to">cvg_to</a></span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>] [<span class="id">filter</span> <span class="id">of</span> <span class="id">G</span>]) : <span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="type_of_filter">type_of_filter</a></span> {<span class="id"><a name="T:193">T</a></span>} (<span class="id"><a name="F:194">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) := <span class="id">T</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="lim_in">lim_in</a></span> {<span class="id"><a name="U:195">U</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="T:196">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id"><a name="F:197">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) =&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#get">get</a></span> (<span class="kwd">fun</span> <span class="id"><a name="l:198">l</a></span> : <span class="id">T</span> =&gt; <span class="id">F</span> --&gt; <span class="id">l</span>).<br/>
<span class="kwd">Notation</span> "[ '<span class="id">lim</span>' <span class="id">F</span> '<span class="kwd">in</span>' <span class="id">T</span> ]" := (@<span class="id"><a href="mathcomp.analysis.topology.html#lim_in">lim_in</a></span> <span class="id">_</span> <span class="id">T</span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>]) : <span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="lim">lim</a></span> <span class="id">F</span> := [<span class="id">lim</span> <span class="id">F</span> <span class="kwd">in</span> [<span class="id">filteredType</span> <span class="id">_</span> <span class="id">of</span> @<span class="id"><a href="mathcomp.analysis.topology.html#type_of_filter">type_of_filter</a></span> <span class="id">_</span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>]]].<br/>
<span class="kwd">Notation</span> "[ '<span class="id">cvg</span>' <span class="id">F</span> '<span class="kwd">in</span>' <span class="id">T</span> ]" := (<span class="id">F</span> --&gt; [<span class="id">lim</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>]) : <span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="cvg">cvg</a></span> <span class="id">F</span> := [<span class="id">cvg</span> <span class="id">F</span> <span class="kwd">in</span> [<span class="id">filteredType</span> <span class="id">_</span> <span class="id">of</span> @<span class="id"><a href="mathcomp.analysis.topology.html#type_of_filter">type_of_filter</a></span> <span class="id">_</span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>]]].<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="FilteredTheory">FilteredTheory</a></span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="filtered_prod">filtered_prod</a></span> <span class="id"><a name="X1:199">X1</a></span> <span class="id"><a name="X2:200">X2</a></span> (<span class="id"><a name="Z1:201">Z1</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">X1</span>)<br/>
&nbsp;&nbsp;(<span class="id"><a name="Z2:202">Z2</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">X2</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> (<span class="id">X1</span> * <span class="id">X2</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#FilteredType">FilteredType</a></span> (<span class="id">X1</span> * <span class="id">X2</span>) (<span class="id">Z1</span> * <span class="id">Z2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id"><a name="x:203">x</a></span> =&gt; <span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>.1) (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>.2)).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_prod">cvg_prod</a></span> <span class="id"><a name="T:204">T</a></span> {<span class="id"><a name="U:205">U</a></span> <span class="id"><a name="U':206">U</a></span>' <span class="id"><a name="V:207">V</a></span> <span class="id"><a name="V':208">V</a></span>' : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">T</span>} (<span class="id"><a name="x:209">x</a></span> : <span class="id">U</span>) (<span class="id"><a name="l:210">l</a></span> : <span class="id">U</span>') (<span class="id"><a name="y:211">y</a></span> : <span class="id">V</span>) (<span class="id"><a name="k:212">k</a></span> : <span class="id">V</span>') :<br/>
&nbsp;&nbsp;<span class="id">x</span> --&gt; <span class="id">l</span> -&gt; <span class="id">y</span> --&gt; <span class="id">k</span> -&gt; (<span class="id">x</span>, <span class="id">y</span>) --&gt; (<span class="id">l</span>, <span class="id">k</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof14')">Proof.</span></div>
<div class="proofscript" id="proof14">
<span class="id">move</span>=&gt; <span class="id">xl</span> <span class="id">yk</span> <span class="id">X</span> [[<span class="id">X1</span> <span class="id">X2</span>] /= [<span class="id">HX1</span> <span class="id">HX2</span>] <span class="id">H</span>]; <span class="kwd">exists</span> (<span class="id">X1</span>, <span class="id">X2</span>) =&gt; //=.<br/>
<span class="id">split</span>; [<span class="id">exact</span>: <span class="id">xl</span> | <span class="id">exact</span>: <span class="id">yk</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_ex">cvg_ex</a></span> {<span class="id"><a name="U:213">U</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="T:214">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>) (<span class="id"><a name="F:215">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) :<br/>
&nbsp;&nbsp;[<span class="id">cvg</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>] &lt;-&gt; (<span class="kwd">exists</span> <span class="id"><a name="l:216">l</a></span> : <span class="id">T</span>, <span class="id">F</span> --&gt; <span class="id">l</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof15')">Proof.</span></div>
<div class="proofscript" id="proof15">
 <span class="kwd">by</span> <span class="id">split</span>=&gt; [<span class="id">cvg</span>|/<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span>//]; <span class="kwd">exists</span> [<span class="id">lim</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvgP">cvgP</a></span> {<span class="id"><a name="U:217">U</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="T:218">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>) (<span class="id"><a name="F:219">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id"><a name="l:220">l</a></span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">l</span> -&gt; [<span class="id">cvg</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof16')">Proof.</span></div>
<div class="proofscript" id="proof16">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Fl</span>; <span class="id">apply</span>/<span class="id"><a href="mathcomp.analysis.topology.html#cvg_ex">cvg_ex</a></span>; <span class="kwd">exists</span> <span class="id">l</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_toP">cvg_toP</a></span> {<span class="id"><a name="U:221">U</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="T:222">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>) (<span class="id"><a name="F:223">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id"><a name="l:224">l</a></span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;&nbsp;[<span class="id">cvg</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>] -&gt; [<span class="id">lim</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>] = <span class="id">l</span> -&gt; <span class="id">F</span> --&gt; <span class="id">l</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof17')">Proof.</span></div>
<div class="proofscript" id="proof17">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /[<span class="id">swap</span>]-&gt;. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="dvgP">dvgP</a></span> {<span class="id"><a name="U:225">U</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="T:226">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>) (<span class="id"><a name="F:227">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) :<br/>
&nbsp;&nbsp;~ [<span class="id">cvg</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>] -&gt; [<span class="id">lim</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>] = <span class="id"><a href="mathcomp.classical.classical_sets.html#point">point</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof18')">Proof.</span></div>
<div class="proofscript" id="proof18">
 <span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#lim_in">lim_in</a></span> /=; <span class="id">case</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#xgetP">xgetP</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvgNpoint">cvgNpoint</a></span> {<span class="id"><a name="U:228">U</a></span>} (<span class="id"><a name="T:229">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>) (<span class="id"><a name="F:230">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) :<br/>
&nbsp;&nbsp;[<span class="id">lim</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>] != <span class="id"><a href="mathcomp.classical.classical_sets.html#point">point</a></span> -&gt; [<span class="id">cvg</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof19')">Proof.</span></div>
<div class="proofscript" id="proof19">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.boolp.html#contra_neqP">contra_neqP</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#dvgP">dvgP</a></span>. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#FilteredTheory">FilteredTheory</a></span>.<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvgP">cvgP</a></span> {<span class="id">U</span> <span class="id">T</span> <span class="id">F</span>} <span class="id">l</span>.<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#dvgP">dvgP</a></span> {<span class="id">U</span>} <span class="id">T</span> {<span class="id">F</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhs_nearE">nbhs_nearE</a></span> {<span class="id"><a name="U:231">U</a></span>} {<span class="id"><a name="T:232">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>} (<span class="id"><a name="x:233">x</a></span> : <span class="id">T</span>) (<span class="id"><a name="P:234">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span> <span class="id">P</span> = \<span class="id">near</span> <span class="id"><a name="x:235">x</a></span>, <span class="id">P</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof20')">Proof.</span></div>
<div class="proofscript" id="proof20">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_nbhs">near_nbhs</a></span> {<span class="id"><a name="U:238">U</a></span>} {<span class="id"><a name="T:239">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>} (<span class="id"><a name="x:240">x</a></span> : <span class="id">T</span>) (<span class="id"><a name="P:241">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="x:242">x</a></span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>, <span class="id">P</span> <span class="id">x</span>) = \<span class="id">near</span> <span class="id"><a name="x:243">x</a></span>, <span class="id">P</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof21')">Proof.</span></div>
<div class="proofscript" id="proof21">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near2_curry">near2_curry</a></span> {<span class="id"><a name="U:246">U</a></span> <span class="id"><a name="V:247">V</a></span>} (<span class="id"><a name="F:248">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id"><a name="G:249">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>)) (<span class="id"><a name="P:250">P</a></span> : <span class="id">U</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>) :<br/>
&nbsp;&nbsp;{<span class="id">near</span> <span class="id">F</span> &amp; <span class="id">G</span>, <span class="kwd">forall</span> <span class="id"><a name="x:251">x</a></span> <span class="id"><a name="y:252">y</a></span>, <span class="id">P</span> <span class="id">x</span> <span class="id">y</span>} = {<span class="id">near</span> (<span class="id">F</span>, <span class="id">G</span>), <span class="kwd">forall</span> <span class="id"><a name="x:253">x</a></span>, <span class="id">P</span> <span class="id">x</span>.1 <span class="id">x</span>.2}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof22')">Proof.</span></div>
<div class="proofscript" id="proof22">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near2_pair">near2_pair</a></span> {<span class="id"><a name="U:254">U</a></span> <span class="id"><a name="V:255">V</a></span>} (<span class="id"><a name="F:256">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id"><a name="G:257">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>)) (<span class="id"><a name="P:258">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id">U</span> * <span class="id">V</span>)) :<br/>
&nbsp;&nbsp;{<span class="id">near</span> <span class="id">F</span> &amp; <span class="id">G</span>, <span class="kwd">forall</span> <span class="id"><a name="x:259">x</a></span> <span class="id"><a name="y:260">y</a></span>, <span class="id">P</span> (<span class="id">x</span>, <span class="id">y</span>)} = {<span class="id">near</span> (<span class="id">F</span>, <span class="id">G</span>), <span class="kwd">forall</span> <span class="id"><a name="x:261">x</a></span>, <span class="id">P</span> <span class="id">x</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof23')">Proof.</span></div>
<div class="proofscript" id="proof23">
 <span class="kwd">by</span> <span class="id">symmetry</span>; <span class="id">congr</span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">_</span>); <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; -[]. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="near2E">near2E</a></span> := (@<span class="id"><a href="mathcomp.analysis.topology.html#near2_curry">near2_curry</a></span>, @<span class="id"><a href="mathcomp.analysis.topology.html#near2_pair">near2_pair</a></span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_of_nearI">filter_of_nearI</a></span> (<span class="id"><a name="X:262">X</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="fX:263">fX</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">X</span>)<br/>
&nbsp;&nbsp;(<span class="id"><a name="x:264">x</a></span> : <span class="id">fX</span>) (<span class="id"><a name="ph:265">ph</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#phantom">phantom</a></span> <span class="id">fX</span> <span class="id">x</span>) : <span class="kwd">forall</span> <span class="id"><a name="P:266">P</a></span>,<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#filter_of">filter_of</a></span> <span class="id">X</span> <span class="id">fX</span> <span class="id">x</span> <span class="id">ph</span> <span class="id">P</span> = @<span class="id"><a href="mathcomp.analysis.topology.html#prop_near1">prop_near1</a></span> <span class="id">X</span> <span class="id">fX</span> <span class="id">x</span> <span class="id">P</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#inPhantom">inPhantom</a></span> (<span class="kwd">forall</span> <span class="id"><a name="x:267">x</a></span>, <span class="id">P</span> <span class="id">x</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof24')">Proof.</span></div>
<div class="proofscript" id="proof24">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Module</span> <span class="kwd">Export</span> <span class="id"><a name="NearNbhs">NearNbhs</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="NearNbhs.near_simpl">near_simpl</a></span> := (@<span class="id"><a href="mathcomp.analysis.topology.html#near_nbhs">near_nbhs</a></span>, @<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_nearE">nbhs_nearE</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#filter_of_nearI">filter_of_nearI</a></span>).<br/>
<span class="kwd">Ltac</span> <span class="id">near_simpl</span> := <span class="id">rewrite</span> ?<span class="id"><a href="mathcomp.analysis.topology.html#NearNbhs.near_simpl">near_simpl</a></span>.<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#NearNbhs">NearNbhs</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_swap">near_swap</a></span> {<span class="id"><a name="U:268">U</a></span> <span class="id"><a name="V:269">V</a></span>} (<span class="id"><a name="F:270">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id"><a name="G:271">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>)) (<span class="id"><a name="P:272">P</a></span> : <span class="id">U</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="x:273">x</a></span> \<span class="id">near</span> <span class="id">F</span> &amp; <span class="id"><a name="y:274">y</a></span> \<span class="id">near</span> <span class="id">G</span>, <span class="id">P</span> <span class="id">x</span> <span class="id">y</span>) = (\<span class="kwd">forall</span> <span class="id"><a name="y:275">y</a></span> \<span class="id">near</span> <span class="id">G</span> &amp; <span class="id"><a name="x:276">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">P</span> <span class="id">x</span> <span class="id">y</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof25')">Proof.</span></div>
<div class="proofscript" id="proof25">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">propeqE</a></span>; <span class="id">split</span> =&gt; -[[/=<span class="id">A</span> <span class="id">B</span>] [<span class="id">FA</span> <span class="id">FB</span>] <span class="id">ABP</span>];<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">B</span>, <span class="id">A</span>) =&gt; // -[<span class="id">x</span> <span class="id">y</span>] [/=<span class="id">Bx</span> <span class="id">Ay</span>]; <span class="id">apply</span>: (<span class="id">ABP</span> (<span class="id">y</span>, <span class="id">x</span>)).<br/>
Qed.</div>
<br/>
<h1> Filters </h1>
<br/>
<h2> Definitions </h2>
<br/>
<span class="kwd">Class</span> <span class="id"><a name="Filter">Filter</a></span> {<span class="id"><a name="T:277">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="F:278">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) := {<br/>
&nbsp;&nbsp;<span class="id"><a name="filterT">filterT</a></span> : <span class="id">F</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> ;<br/>
&nbsp;&nbsp;<span class="id"><a name="filterI">filterI</a></span> : <span class="kwd">forall</span> <span class="id"><a name="P:281">P</a></span> <span class="id"><a name="Q:282">Q</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>, <span class="id">F</span> <span class="id">P</span> -&gt; <span class="id">F</span> <span class="id">Q</span> -&gt; <span class="id">F</span> (<span class="id">P</span> `&amp;` <span class="id">Q</span>) ;<br/>
&nbsp;&nbsp;<span class="id"><a name="filterS">filterS</a></span> : <span class="kwd">forall</span> <span class="id"><a name="P:284">P</a></span> <span class="id"><a name="Q:285">Q</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>, <span class="id">P</span> `&lt;=` <span class="id">Q</span> -&gt; <span class="id">F</span> <span class="id">P</span> -&gt; <span class="id">F</span> <span class="id">Q</span><br/>
}.<br/>
<span class="id">Global</span> <span class="kwd">Hint</span> <span class="id">Mode</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> - ! : <span class="id">typeclass_instances</span>.<br/>
<br/>
<span class="kwd">Class</span> <span class="id"><a name="ProperFilter'">ProperFilter</a></span>' {<span class="id"><a name="T:287">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="F:288">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) := {<br/>
&nbsp;&nbsp;<span class="id"><a name="filter_not_empty">filter_not_empty</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#not">not</a></span> (<span class="id">F</span> (<span class="kwd">fun</span> <span class="id">_</span> =&gt; <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#False">False</a></span>)) ;<br/>
&nbsp;&nbsp;<span class="id"><a name="filter_filter'">filter_filter</a></span>' : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span><br/>
}.<br/>
<span class="id">Global</span> <span class="id">Existing</span> <span class="kwd">Instance</span> <span class="id">filter_filter</span>'.<br/>
<span class="id">Global</span> <span class="kwd">Hint</span> <span class="id">Mode</span> <span class="id">ProperFilter</span>' - ! : <span class="id">typeclass_instances</span>.<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_not_empty">filter_not_empty</a></span> {<span class="id">T</span>} <span class="id">F</span> {<span class="id">_</span>}.<br/>
<br/>
<span class="kwd">Notation</span> <span class="id"><a name="ProperFilter">ProperFilter</a></span> := <span class="id">ProperFilter</span>'.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_setT">filter_setT</a></span> (<span class="id"><a name="T':292">T</a></span>' : <span class="kwd">Type</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>'].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof26')">Proof.</span></div>
<div class="proofscript" id="proof26">
 <span class="kwd">by</span> <span class="id">constructor</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filterP_strong">filterP_strong</a></span> <span class="id"><a name="T:293">T</a></span> (<span class="id"><a name="F:294">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) {<span class="id"><a name="FF:295">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} (<span class="id"><a name="P:296">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">exists</span> <span class="id"><a name="Q:297">Q</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>, <span class="kwd">exists</span> <span class="id"><a name="FQ:298">FQ</a></span>  : <span class="id">F</span> <span class="id">Q</span>, <span class="kwd">forall</span> <span class="id"><a name="x:299">x</a></span> : <span class="id">T</span>, <span class="id">Q</span> <span class="id">x</span> -&gt; <span class="id">P</span> <span class="id">x</span>) &lt;-&gt; <span class="id">F</span> <span class="id">P</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof27')">Proof.</span></div>
<div class="proofscript" id="proof27">
<span class="id">split</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">P</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">Q</span> [<span class="id">FQ</span> <span class="id">QP</span>]]; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">QP</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Structure</span> <span class="id"><a name="filter_on">filter_on</a></span> <span class="id"><a name="T:300">T</a></span> := <span class="id">FilterType</span> {<br/>
&nbsp;&nbsp;<span class="id"><a name="filter">filter</a></span> :&gt; (<span class="id">T</span> -&gt; <span class="kwd">Prop</span>) -&gt; <span class="kwd">Prop</span>;<br/>
&nbsp;&nbsp;<span class="id">_</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">filter</span><br/>
}.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="filter_class">filter_class</a></span> <span class="id"><a name="T:303">T</a></span> (<span class="id"><a name="F:304">F</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span>: <span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> <span class="id">_</span> <span class="id">class</span> := <span class="id">F</span> <span class="kwd">in</span> <span class="id">class</span>.<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> {<span class="id">T</span>} <span class="id">_</span> <span class="id">_</span>.<br/>
#[<span class="id">global</span>] <span class="id">Existing</span> <span class="kwd">Instance</span> <span class="id">filter_class</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">filter_filter</span>' : <span class="id">ProperFilter</span> &gt;-&gt; <span class="id">Filter</span>.<br/>
<br/>
<span class="kwd">Structure</span> <span class="id"><a name="pfilter_on">pfilter_on</a></span> <span class="id"><a name="T:306">T</a></span> := <span class="id">PFilterPack</span> {<br/>
&nbsp;&nbsp;<span class="id"><a name="pfilter">pfilter</a></span> :&gt; (<span class="id">T</span> -&gt; <span class="kwd">Prop</span>) -&gt; <span class="kwd">Prop</span>;<br/>
&nbsp;&nbsp;<span class="id">_</span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">pfilter</span><br/>
}.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="pfilter_class">pfilter_class</a></span> <span class="id"><a name="T:309">T</a></span> (<span class="id"><a name="F:310">F</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#pfilter_on">pfilter_on</a></span> <span class="id">T</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span>: <span class="id"><a href="mathcomp.analysis.topology.html#PFilterPack">PFilterPack</a></span> <span class="id">_</span> <span class="id">class</span> := <span class="id">F</span> <span class="kwd">in</span> <span class="id">class</span>.<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#PFilterPack">PFilterPack</a></span> {<span class="id">T</span>} <span class="id">_</span> <span class="id">_</span>.<br/>
#[<span class="id">global</span>] <span class="id">Existing</span> <span class="kwd">Instance</span> <span class="id">pfilter_class</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="pfilter_filter_on">pfilter_filter_on</a></span> <span class="id"><a name="T:312">T</a></span> (<span class="id"><a name="F:313">F</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#pfilter_on">pfilter_on</a></span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> <span class="id">F</span> (<span class="id"><a href="mathcomp.analysis.topology.html#pfilter_class">pfilter_class</a></span> <span class="id">F</span>).<br/>
<span class="kwd">Coercion</span> <span class="id">pfilter_filter_on</span> : <span class="id">pfilter_on</span> &gt;-&gt; <span class="id">filter_on</span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="PFilterType">PFilterType</a></span> {<span class="id"><a name="T:314">T</a></span>} (<span class="id"><a name="F:315">F</a></span> : (<span class="id">T</span> -&gt; <span class="kwd">Prop</span>) -&gt; <span class="kwd">Prop</span>)<br/>
&nbsp;&nbsp;{<span class="id"><a name="fF:316">fF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} (<span class="id"><a name="fN0:317">fN0</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#not">not</a></span> (<span class="id">F</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span>)) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#PFilterPack">PFilterPack</a></span> <span class="id">F</span> (<span class="id">Build_ProperFilter</span>' <span class="id">fN0</span> <span class="id">fF</span>).<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#PFilterType">PFilterType</a></span> {<span class="id">T</span>} <span class="id">F</span> {<span class="id">fF</span>} <span class="id">fN0</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="filter_on_eqType">filter_on_eqType</a></span> <span class="id"><a name="T:318">T</a></span> := <span class="id">EqType</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) <span class="id"><a href="mathcomp.classical.boolp.html#gen_eqMixin">gen_eqMixin</a></span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="filter_on_choiceType">filter_on_choiceType</a></span> <span class="id"><a name="T:319">T</a></span> :=<br/>
&nbsp;&nbsp;<span class="id">ChoiceType</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) <span class="id"><a href="mathcomp.classical.boolp.html#gen_choiceMixin">gen_choiceMixin</a></span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="filter_on_PointedType">filter_on_PointedType</a></span> <span class="id"><a name="T:320">T</a></span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.PointedType">PointedType</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> <span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_setT">filter_setT</a></span> <span class="id">T</span>)).<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="filter_on_FilteredType">filter_on_FilteredType</a></span> <span class="id"><a name="T:321">T</a></span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#FilteredType">FilteredType</a></span> <span class="id">T</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) (@<span class="id"><a href="mathcomp.analysis.topology.html#filter">filter</a></span> <span class="id">T</span>).<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="filter_on_Filter">filter_on_Filter</a></span> <span class="id"><a name="T:322">T</a></span> (<span class="id"><a name="F:323">F</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof28')">Proof.</span></div>
<div class="proofscript" id="proof28">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id">F</span>. Qed.</div>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="pfilter_on_ProperFilter">pfilter_on_ProperFilter</a></span> <span class="id"><a name="T:324">T</a></span> (<span class="id"><a name="F:325">F</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#pfilter_on">pfilter_on</a></span> <span class="id">T</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof29')">Proof.</span></div>
<div class="proofscript" id="proof29">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id">F</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhs_filter_onE">nbhs_filter_onE</a></span> <span class="id"><a name="T:326">T</a></span> (<span class="id"><a name="F:327">F</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">F</span> = <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter">filter</a></span> <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof30')">Proof.</span></div>
<div class="proofscript" id="proof30">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Definition</span> <span class="id"><a name="nbhs_simpl">nbhs_simpl</a></span> := (@<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_simpl">nbhs_simpl</a></span>, @<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_filter_onE">nbhs_filter_onE</a></span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_filter_onE">near_filter_onE</a></span> <span class="id"><a name="T:328">T</a></span> (<span class="id"><a name="F:329">F</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) (<span class="id"><a name="P:330">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="x:331">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">P</span> <span class="id">x</span>) = \<span class="kwd">forall</span> <span class="id"><a name="x:332">x</a></span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter">filter</a></span> <span class="id">F</span>, <span class="id">P</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof31')">Proof.</span></div>
<div class="proofscript" id="proof31">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Definition</span> <span class="id"><a name="near_simpl">near_simpl</a></span> := (@<span class="id"><a href="mathcomp.analysis.topology.html#near_simpl">near_simpl</a></span>, @<span class="id"><a href="mathcomp.analysis.topology.html#near_filter_onE">near_filter_onE</a></span>).<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id"><a name="trivial_filter_on">trivial_filter_on</a></span> <span class="id"><a name="T:333">T</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> [<span class="id">set</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>] <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof32')">Next Obligation.</span></div>
<div class="proofscript" id="proof32">
<span class="id">split</span>=&gt; // [<span class="id">_</span> <span class="id">_</span> -&gt; -&gt;|<span class="id">Q</span> <span class="id">R</span> <span class="id">sQR</span> <span class="id">QT</span>]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setIT">setIT</a></span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>; <span class="id">split</span> =&gt; // ? <span class="id">_</span>; <span class="id">apply</span>/<span class="id">sQR</span>; <span class="id">rewrite</span> <span class="id">QT</span>.<br/>
Qed.</div>
<span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#trivial_filter_on">trivial_filter_on</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_nbhsT">filter_nbhsT</a></span> {<span class="id"><a name="T:334">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="F:335">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">F</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof33')">Proof.</span></div>
<div class="proofscript" id="proof33">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>. Qed.</div>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">filter_nbhsT</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nearT">nearT</a></span> {<span class="id"><a name="T:336">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="F:337">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; \<span class="id">near</span> <span class="id"><a name="F:338">F</a></span>, <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#True">True</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof34')">Proof.</span></div>
<div class="proofscript" id="proof34">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>. Qed.</div>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">nearT</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_not_empty_ex">filter_not_empty_ex</a></span> {<span class="id"><a name="T:341">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="F:342">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="P:343">P</a></span>, <span class="id">F</span> <span class="id">P</span> -&gt; <span class="kwd">exists</span> <span class="id"><a name="x:344">x</a></span>, <span class="id">P</span> <span class="id">x</span>) -&gt; ~ <span class="id">F</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof35')">Proof.</span></div>
<div class="proofscript" id="proof35">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span>) <span class="id">ex</span> /<span class="id">ex</span> []. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Build_ProperFilter">Build_ProperFilter</a></span> {<span class="id"><a name="T:345">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="F:346">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>))<br/>
&nbsp;&nbsp;(<span class="id"><a name="filter_ex:349">filter_ex</a></span> : <span class="kwd">forall</span> <span class="id"><a name="P:347">P</a></span>, <span class="id">F</span> <span class="id">P</span> -&gt; <span class="kwd">exists</span> <span class="id"><a name="x:348">x</a></span>, <span class="id">P</span> <span class="id">x</span>)<br/>
&nbsp;&nbsp;(<span class="id"><a name="filter_filter:350">filter_filter</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>) :=<br/>
&nbsp;&nbsp;<span class="id">Build_ProperFilter</span>' (<span class="id"><a href="mathcomp.analysis.topology.html#filter_not_empty_ex">filter_not_empty_ex</a></span> <span class="id">filter_ex</span>) (<span class="id">filter_filter</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_ex_subproof">filter_ex_subproof</a></span> {<span class="id"><a name="T:351">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="F:352">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~ <span class="id">F</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span> -&gt; (<span class="kwd">forall</span> <span class="id"><a name="P:353">P</a></span>, <span class="id">F</span> <span class="id">P</span> -&gt; <span class="kwd">exists</span> <span class="id"><a name="x:354">x</a></span>, <span class="id">P</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof36')">Proof.</span></div>
<div class="proofscript" id="proof36">
<span class="id">move</span>=&gt; <span class="id">NFset0</span> <span class="id">P</span> <span class="id">FP</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.boolp.html#contra_notP">contra_notP</a></span> <span class="id">NFset0</span> =&gt; <span class="id">nex</span>; <span class="id">suff</span> &lt;- : <span class="id">P</span> = <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span> <span class="kwd">by</span> [].<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#funeqE">funeqE</a></span> =&gt; <span class="id">x</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">propeqE</a></span>; <span class="id">split</span>=&gt; // <span class="id">Px</span>; <span class="id">apply</span>: <span class="id">nex</span>; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="filter_ex">filter_ex</a></span> {<span class="id"><a name="T:355">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="F:356">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) {<span class="id"><a name="FF:357">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span>} :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#filter_ex_subproof">filter_ex_subproof</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_not_empty">filter_not_empty</a></span> <span class="id">F</span>).<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> {<span class="id">T</span> <span class="id">F</span> <span class="id">FF</span> <span class="id">_</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_getP">filter_getP</a></span> {<span class="id"><a name="T:358">T</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.pointedType">pointedType</a></span>} (<span class="id"><a name="F:359">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) {<span class="id"><a name="FF:360">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a name="P:361">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) : <span class="id">F</span> <span class="id">P</span> -&gt; <span class="id">P</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#get">get</a></span> <span class="id">P</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof37')">Proof.</span></div>
<div class="proofscript" id="proof37">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span>. Qed.</div>
<br/>
<br/>
<span class="kwd">Record</span> <span class="id"><a name="in_filter">in_filter</a></span> <span class="id"><a name="T:362">T</a></span> (<span class="id"><a name="F:363">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) := <span class="id">InFilter</span> {<br/>
&nbsp;&nbsp;<span class="id"><a name="prop_in_filter_proj">prop_in_filter_proj</a></span> : <span class="id">T</span> -&gt; <span class="kwd">Prop</span>;<br/>
&nbsp;&nbsp;<span class="id"><a name="prop_in_filterP_proj">prop_in_filterP_proj</a></span> : <span class="id">F</span> <span class="id">prop_in_filter_proj</span><br/>
}.<br/>
<br/>
<span class="kwd">Module</span> <span class="kwd">Type</span> <span class="id"><a name="PropInFilterSig">PropInFilterSig</a></span>.<br/>
<span class="kwd">Axiom</span> <span class="id"><a name="PropInFilterSig.t">t</a></span> : <span class="kwd">forall</span> (<span class="id"><a name="T:367">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="F:368">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)), <span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">F</span> -&gt; <span class="id">T</span> -&gt; <span class="kwd">Prop</span>.<br/>
<span class="kwd">Axiom</span> <span class="id"><a name="PropInFilterSig.tE">tE</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#PropInFilterSig.t">t</a></span> = <span class="id"><a href="mathcomp.analysis.topology.html#prop_in_filter_proj">prop_in_filter_proj</a></span>.<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#PropInFilterSig">PropInFilterSig</a></span>.<br/>
<span class="kwd">Module</span> <span class="id"><a name="PropInFilter">PropInFilter</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#PropInFilterSig">PropInFilterSig</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="PropInFilter.t">t</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#prop_in_filter_proj">prop_in_filter_proj</a></span>.<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="PropInFilter.tE">tE</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#PropInFilter.t">t</a></span> = <span class="id"><a href="mathcomp.analysis.topology.html#prop_in_filter_proj">prop_in_filter_proj</a></span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof38')">Proof.</span></div>
<div class="proofscript" id="proof38">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#PropInFilter">PropInFilter</a></span>.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="prop_of">prop_of</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#t">PropInFilter.t</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="prop_ofE">prop_ofE</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#tE">PropInFilter.tE</a></span>.<br/>
<span class="kwd">Notation</span> "<span class="id">x</span> \<span class="id">is_near</span> <span class="id">F</span>" := (@<span class="id"><a href="mathcomp.analysis.topology.html#t">PropInFilter.t</a></span> <span class="id">_</span> <span class="id">F</span> <span class="id">_</span> <span class="id">x</span>).<br/>
<span class="kwd">Definition</span> <span class="id"><a name="is_nearE">is_nearE</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#prop_ofE">prop_ofE</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="prop_ofP">prop_ofP</a></span> <span class="id"><a name="T:371">T</a></span> <span class="id"><a name="F:372">F</a></span> (<span class="id"><a name="iF:373">iF</a></span> : @<span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">T</span> <span class="id">F</span>) : <span class="id">F</span> (<span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">iF</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof39')">Proof.</span></div>
<div class="proofscript" id="proof39">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#prop_ofE">prop_ofE</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#prop_in_filterP_proj">prop_in_filterP_proj</a></span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="in_filterT">in_filterT</a></span> <span class="id"><a name="T:374">T</a></span> <span class="id"><a name="F:375">F</a></span> (<span class="id"><a name="FF:376">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>) : @<span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">T</span> <span class="id">F</span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#InFilter">InFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>).<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="in_filterI">in_filterI</a></span> <span class="id"><a name="T:377">T</a></span> <span class="id"><a name="F:378">F</a></span> (<span class="id"><a name="FF:379">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>) (<span class="id"><a name="P:380">P</a></span> <span class="id"><a name="Q:381">Q</a></span> : @<span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">T</span> <span class="id">F</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#InFilter">InFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#prop_in_filterP_proj">prop_in_filterP_proj</a></span> <span class="id">P</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#prop_in_filterP_proj">prop_in_filterP_proj</a></span> <span class="id">Q</span>)).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_near_of">filter_near_of</a></span> <span class="id"><a name="T:382">T</a></span> <span class="id"><a name="F:383">F</a></span> (<span class="id"><a name="P:384">P</a></span> : @<span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">T</span> <span class="id">F</span>) (<span class="id"><a name="Q:385">Q</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="x:386">x</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">P</span> <span class="id">x</span> -&gt; <span class="id">Q</span> <span class="id">x</span>) -&gt; <span class="id">F</span> <span class="id">Q</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof40')">Proof.</span></div>
<div class="proofscript" id="proof40">
<span class="kwd">by</span> <span class="id">move</span>: <span class="id">P</span> =&gt; [<span class="id">P</span> <span class="id">FP</span>] <span class="id">FF</span> /=; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#prop_ofE">prop_ofE</a></span> /= =&gt; /<span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span>; <span class="id">apply</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Fact</span> <span class="id"><a name="near_key">near_key</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#unit">unit</a></span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof41')">Proof.</span></div>
<div class="proofscript" id="proof41">
 <span class="id">exact</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="mark_near">mark_near</a></span> (<span class="id"><a name="P:387">P</a></span> : <span class="kwd">Prop</span>) : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#locked_with">locked_with</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#near_key">near_key</a></span> <span class="id">P</span> -&gt; <span class="id">P</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof42')">Proof.</span></div>
<div class="proofscript" id="proof42">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#unlock">unlock</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_acc">near_acc</a></span> <span class="id"><a name="T:388">T</a></span> <span class="id"><a name="F:389">F</a></span> (<span class="id"><a name="P:390">P</a></span> : @<span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">T</span> <span class="id">F</span>) (<span class="id"><a name="Q:391">Q</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) (<span class="id"><a name="FF:392">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>)<br/>
&nbsp;&nbsp;&nbsp;(<span class="id"><a name="FQ:394">FQ</a></span> : \<span class="kwd">forall</span> <span class="id"><a name="x:393">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">Q</span> <span class="id">x</span>) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#locked_with">locked_with</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#near_key">near_key</a></span> (<span class="kwd">forall</span> <span class="id"><a name="x:395">x</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#in_filterI">in_filterI</a></span> <span class="id">FF</span> <span class="id">P</span> (<span class="id"><a href="mathcomp.analysis.topology.html#InFilter">InFilter</a></span> <span class="id">FQ</span>)) <span class="id">x</span> -&gt; <span class="id">Q</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof43')">Proof.</span></div>
<div class="proofscript" id="proof43">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#unlock">unlock</a></span> =&gt; <span class="id">x</span> /=; <span class="id">rewrite</span> !<span class="id"><a href="mathcomp.analysis.topology.html#prop_ofE">prop_ofE</a></span> /= =&gt; -[<span class="id">Px</span>]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_skip_subproof">near_skip_subproof</a></span> <span class="id"><a name="T:396">T</a></span> <span class="id"><a name="F:397">F</a></span> (<span class="id"><a name="P:398">P</a></span> <span class="id"><a name="Q:399">Q</a></span> : @<span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">T</span> <span class="id">F</span>) (<span class="id"><a name="G:400">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) (<span class="id"><a name="FF:401">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#locked_with">locked_with</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#near_key">near_key</a></span> (<span class="kwd">forall</span> <span class="id"><a name="x:402">x</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">P</span> <span class="id">x</span> -&gt; <span class="id">G</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#locked_with">locked_with</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#near_key">near_key</a></span> (<span class="kwd">forall</span> <span class="id"><a name="x:403">x</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#in_filterI">in_filterI</a></span> <span class="id">FF</span> <span class="id">P</span> <span class="id">Q</span>) <span class="id">x</span> -&gt; <span class="id">G</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof44')">Proof.</span></div>
<div class="proofscript" id="proof44">
<span class="id">rewrite</span> !<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#unlock">unlock</a></span> =&gt; <span class="id">FG</span> <span class="id">x</span> /=; <span class="id">rewrite</span> !<span class="id"><a href="mathcomp.analysis.topology.html#prop_ofE">prop_ofE</a></span> /= =&gt; -[<span class="id">Px</span> <span class="id">Qx</span>].<br/>
<span class="kwd">by</span> <span class="id">have</span> /= := <span class="id">FG</span> <span class="id">x</span>; <span class="id">apply</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#prop_ofE">prop_ofE</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Tactic</span> <span class="kwd">Notation</span> "<span class="id">near</span>=&gt;" <span class="id">ident</span>(<span class="id">x</span>) := <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_near_of">filter_near_of</a></span> =&gt; <span class="id">x</span> ?.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">just_discharge_near</span> <span class="id">x</span> :=<br/>
&nbsp;&nbsp;<span class="id">tryif</span> <span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span> <span class="id">Hx</span> : <span class="id">x</span> \<span class="id">is_near</span> <span class="id">_</span> |- <span class="id">_</span> =&gt; <span class="id">move</span>: (<span class="id">x</span>) (<span class="id">Hx</span>); <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#mark_near">mark_near</a></span> <span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">idtac</span> <span class="kwd">else</span> <span class="id">fail</span> "<span class="id">the</span> <span class="id">variable</span>" <span class="id">x</span> "<span class="id">is</span> <span class="id">not</span> <span class="id">a</span> ""<span class="id">near</span>"" <span class="id">variable</span>".<br/>
<span class="kwd">Ltac</span> <span class="id">near_skip</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span> |- <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#locked_with">locked_with</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#near_key">near_key</a></span> (<span class="kwd">forall</span> <span class="id">_</span>, @<span class="id"><a href="mathcomp.analysis.topology.html#t">PropInFilter.t</a></span> <span class="id">_</span> <span class="id">_</span> ?<span class="id">P</span> <span class="id">_</span> -&gt; <span class="id">_</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tryif</span> <span class="id">is_evar</span> <span class="id">P</span> <span class="kwd">then</span> <span class="id">fail</span> "<span class="id">nothing</span> <span class="id">to</span> <span class="id">skip</span>" <span class="kwd">else</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#near_skip_subproof">near_skip_subproof</a></span> <span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Tactic</span> <span class="kwd">Notation</span> "<span class="id">near</span>:" <span class="id">ident</span>(<span class="id">x</span>) :=<br/>
&nbsp;&nbsp;<span class="id">just_discharge_near</span> <span class="id">x</span>;<br/>
&nbsp;&nbsp;<span class="id">tryif</span> <span class="id">do</span> ![<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#near_acc">near_acc</a></span>; <span class="id">first</span> <span class="id">shelve</span>|<span class="id">near_skip</span>]<br/>
&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">idtac</span><br/>
&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">fail</span> "<span class="id">the</span> <span class="id">goal</span> <span class="id">depends</span> <span class="id">on</span> <span class="id">variables</span> <span class="id">introduced</span> <span class="id">after</span>" <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">under_near</span> <span class="id">i</span> <span class="id">tac</span> := <span class="id">near</span>=&gt; <span class="id">i</span>; <span class="id">tac</span>; <span class="id">near</span>: <span class="id">i</span>.<br/>
<span class="kwd">Tactic</span> <span class="kwd">Notation</span> "<span class="id">near</span>=&gt;" <span class="id">ident</span>(<span class="id">i</span>) "<span class="id">do</span>" <span class="id">tactic3</span>(<span class="id">tac</span>) := <span class="id">under_near</span> <span class="id">i</span> <span class="id">ltac</span>:(<span class="id">tac</span>).<br/>
<span class="kwd">Tactic</span> <span class="kwd">Notation</span> "<span class="id">near</span>=&gt;" <span class="id">ident</span>(<span class="id">i</span>) "<span class="id">do</span>" "[" <span class="id">tactic4</span>(<span class="id">tac</span>) "]" := <span class="id">near</span>=&gt; <span class="id">i</span> <span class="id">do</span> <span class="id">tac</span>.<br/>
<span class="kwd">Tactic</span> <span class="kwd">Notation</span> "<span class="id">near</span>" "<span class="id">do</span>" <span class="id">tactic3</span>(<span class="id">tac</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">i</span> := <span class="id">fresh</span> "<span class="id">i</span>" <span class="kwd">in</span> <span class="id">under_near</span> <span class="id">i</span> <span class="id">ltac</span>:(<span class="id">tac</span>).<br/>
<span class="kwd">Tactic</span> <span class="kwd">Notation</span> "<span class="id">near</span>" "<span class="id">do</span>" "[" <span class="id">tactic4</span>(<span class="id">tac</span>) "]" := <span class="id">near</span> <span class="id">do</span> <span class="id">tac</span>.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">end_near</span> := <span class="id">do</span> ?<span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#in_filterT">in_filterT</a></span>.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">done</span> :=<br/>
&nbsp;&nbsp;<span class="id">trivial</span>; <span class="id">hnf</span>; <span class="id">intros</span>; <span class="id">solve</span><br/>
&nbsp;&nbsp;&nbsp;[ <span class="id">do</span> ![<span class="id">solve</span> [<span class="id">trivial</span> | <span class="id">apply</span>: <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#sym_equal">sym_equal</a></span>; <span class="id">trivial</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">discriminate</span> | <span class="id">contradiction</span> | <span class="id">split</span>]<br/>
&nbsp;&nbsp;&nbsp;| <span class="id">case</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#not_locked_false_eq_true">not_locked_false_eq_true</a></span>; <span class="id">assumption</span><br/>
&nbsp;&nbsp;&nbsp;| <span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span> <span class="id">H</span> : ~ <span class="id">_</span> |- <span class="id">_</span> =&gt; <span class="id">solve</span> [<span class="id">case</span> <span class="id">H</span>; <span class="id">trivial</span>] <span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;| <span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span> |- ?<span class="id">x</span> \<span class="id">is_near</span> <span class="id">_</span> =&gt; <span class="id">near</span>: <span class="id">x</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#prop_ofP">prop_ofP</a></span> <span class="kwd">end</span> ].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="have_near">have_near</a></span> (<span class="id"><a name="U:404">U</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="fT:405">fT</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">U</span>) (<span class="id"><a name="x:406">x</a></span> : <span class="id">fT</span>) (<span class="id"><a name="P:407">P</a></span> : <span class="kwd">Prop</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>) -&gt; (\<span class="kwd">forall</span> <span class="id"><a name="x:408">x</a></span> \<span class="id">near</span> <span class="id">x</span>, <span class="id">P</span>) -&gt; <span class="id">P</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof45')">Proof.</span></div>
<div class="proofscript" id="proof45">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">nP</span>; <span class="id">have</span> [] := @<span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">FF</span> (<span class="kwd">fun</span>=&gt; <span class="id">P</span>). Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#have_near">have_near</a></span> {<span class="id">U</span> <span class="id">fT</span>} <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Tactic</span> <span class="kwd">Notation</span> "<span class="id">near</span>" <span class="id">constr</span>(<span class="id">F</span>) "=&gt;" <span class="id">ident</span>(<span class="id">x</span>) :=<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#have_near">have_near</a></span> <span class="id">F</span>); <span class="id">near</span>=&gt; <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near">near</a></span> <span class="id"><a name="T:409">T</a></span> (<span class="id"><a name="F:410">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) <span class="id"><a name="P:411">P</a></span> (<span class="id"><a name="FP:412">FP</a></span> : <span class="id">F</span> <span class="id">P</span>) (<span class="id"><a name="x:413">x</a></span> : <span class="id">T</span>)<br/>
&nbsp;&nbsp;(<span class="id"><a name="Px:414">Px</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#InFilter">InFilter</a></span> <span class="id">FP</span>) <span class="id">x</span>) : <span class="id">P</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof46')">Proof.</span></div>
<div class="proofscript" id="proof46">
 <span class="kwd">by</span> <span class="id">move</span>: <span class="id">Px</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#prop_ofE">prop_ofE</a></span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#near">near</a></span> {<span class="id">T</span> <span class="id">F</span> <span class="id">P</span>} <span class="id">FP</span> <span class="id">x</span> <span class="id">Px</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nearW">nearW</a></span> {<span class="id"><a name="T:415">T</a></span> : <span class="kwd">Type</span>} {<span class="id"><a name="F:416">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} (<span class="id"><a name="P:417">P</a></span> : <span class="id">T</span> -&gt; <span class="kwd">Prop</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; (<span class="kwd">forall</span> <span class="id"><a name="x:418">x</a></span>, <span class="id">P</span> <span class="id">x</span>) -&gt; (\<span class="kwd">forall</span> <span class="id"><a name="x:419">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">P</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof47')">Proof.</span></div>
<div class="proofscript" id="proof47">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">FP</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filterE">filterE</a></span> {<span class="id"><a name="T:420">T</a></span> : <span class="kwd">Type</span>} {<span class="id"><a name="F:421">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="kwd">forall</span> <span class="id"><a name="P:422">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>, (<span class="kwd">forall</span> <span class="id"><a name="x:423">x</a></span>, <span class="id">P</span> <span class="id">x</span>) -&gt; <span class="id">F</span> <span class="id">P</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof48')">Proof.</span></div>
<div class="proofscript" id="proof48">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">FT</span> <span class="id">_</span> +] <span class="id">P</span> <span class="id">fP</span> =&gt; /(<span class="id">_</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>); <span class="id">apply</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_app">filter_app</a></span> (<span class="id"><a name="T:424">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="F:425">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="kwd">forall</span> <span class="id"><a name="P:426">P</a></span> <span class="id"><a name="Q:427">Q</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>, <span class="id">F</span> (<span class="kwd">fun</span> <span class="id"><a name="x:428">x</a></span> =&gt; <span class="id">P</span> <span class="id">x</span> -&gt; <span class="id">Q</span> <span class="id">x</span>) -&gt; <span class="id">F</span> <span class="id">P</span> -&gt; <span class="id">F</span> <span class="id">Q</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof49')">Proof.</span></div>
<div class="proofscript" id="proof49">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">P</span> <span class="id">Q</span> <span class="id">subPQ</span> <span class="id">FP</span>; <span class="id">near</span>=&gt; <span class="id">x</span> <span class="id">do</span> <span class="id">suff</span>: <span class="id">P</span> <span class="id">x</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_app2">filter_app2</a></span> (<span class="id"><a name="T:429">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="F:430">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="kwd">forall</span> <span class="id"><a name="P:431">P</a></span> <span class="id"><a name="Q:432">Q</a></span> <span class="id"><a name="R:433">R</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>,  <span class="id">F</span> (<span class="kwd">fun</span> <span class="id"><a name="x:434">x</a></span> =&gt; <span class="id">P</span> <span class="id">x</span> -&gt; <span class="id">Q</span> <span class="id">x</span> -&gt; <span class="id">R</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">F</span> <span class="id">P</span> -&gt; <span class="id">F</span> <span class="id">Q</span> -&gt; <span class="id">F</span> <span class="id">R</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof50')">Proof.</span></div>
<div class="proofscript" id="proof50">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ???? <span class="id">PQR</span> <span class="id">FP</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app">filter_app</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app">filter_app</a></span> <span class="id">FP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_app3">filter_app3</a></span> (<span class="id"><a name="T:435">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="F:436">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="kwd">forall</span> <span class="id"><a name="P:437">P</a></span> <span class="id"><a name="Q:438">Q</a></span> <span class="id"><a name="R:439">R</a></span> <span class="id"><a name="S:440">S</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>, <span class="id">F</span> (<span class="kwd">fun</span> <span class="id"><a name="x:441">x</a></span> =&gt; <span class="id">P</span> <span class="id">x</span> -&gt; <span class="id">Q</span> <span class="id">x</span> -&gt; <span class="id">R</span> <span class="id">x</span> -&gt; <span class="id">S</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">F</span> <span class="id">P</span> -&gt; <span class="id">F</span> <span class="id">Q</span> -&gt; <span class="id">F</span> <span class="id">R</span> -&gt; <span class="id">F</span> <span class="id">S</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof51')">Proof.</span></div>
<div class="proofscript" id="proof51">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ????? <span class="id">PQR</span> <span class="id">FP</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app2">filter_app2</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app">filter_app</a></span> <span class="id">FP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filterS2">filterS2</a></span> (<span class="id"><a name="T:442">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="F:443">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="kwd">forall</span> <span class="id"><a name="P:444">P</a></span> <span class="id"><a name="Q:445">Q</a></span> <span class="id"><a name="R:446">R</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>, (<span class="kwd">forall</span> <span class="id"><a name="x:447">x</a></span>, <span class="id">P</span> <span class="id">x</span> -&gt; <span class="id">Q</span> <span class="id">x</span> -&gt; <span class="id">R</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">F</span> <span class="id">P</span> -&gt; <span class="id">F</span> <span class="id">Q</span> -&gt; <span class="id">F</span> <span class="id">R</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof52')">Proof.</span></div>
<div class="proofscript" id="proof52">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? ? ? ?; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app2">filter_app2</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterE">filterE</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filterS3">filterS3</a></span> (<span class="id"><a name="T:448">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="F:449">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="kwd">forall</span> <span class="id"><a name="P:450">P</a></span> <span class="id"><a name="Q:451">Q</a></span> <span class="id"><a name="R:452">R</a></span> <span class="id"><a name="S:453">S</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>, (<span class="kwd">forall</span> <span class="id"><a name="x:454">x</a></span>, <span class="id">P</span> <span class="id">x</span> -&gt; <span class="id">Q</span> <span class="id">x</span> -&gt; <span class="id">R</span> <span class="id">x</span> -&gt; <span class="id">S</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">F</span> <span class="id">P</span> -&gt; <span class="id">F</span> <span class="id">Q</span> -&gt; <span class="id">F</span> <span class="id">R</span> -&gt; <span class="id">F</span> <span class="id">S</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof53')">Proof.</span></div>
<div class="proofscript" id="proof53">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? ? ? ? ?; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app3">filter_app3</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterE">filterE</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_const">filter_const</a></span> {<span class="id"><a name="T:455">T</a></span> : <span class="kwd">Type</span>} {<span class="id"><a name="F:456">F</a></span>} {<span class="id"><a name="FF:457">FF</a></span>: @<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">T</span> <span class="id">F</span>} (<span class="id"><a name="P:458">P</a></span> : <span class="kwd">Prop</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> (<span class="kwd">fun</span>=&gt; <span class="id">P</span>) -&gt; <span class="id">P</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof54')">Proof.</span></div>
<div class="proofscript" id="proof54">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FP</span>; <span class="id">case</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> <span class="id">FP</span>). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="in_filter_from">in_filter_from</a></span> {<span class="id"><a name="I:459">I</a></span> <span class="id"><a name="T:460">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="D:461">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id"><a name="B:462">B</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) (<span class="id"><a name="i:463">i</a></span> : <span class="id">I</span>) :<br/>
&nbsp;&nbsp;<span class="id">D</span> <span class="id">i</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> <span class="id">D</span> <span class="id">B</span> (<span class="id">B</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof55')">Proof.</span></div>
<div class="proofscript" id="proof55">
 <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">i</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_andP">near_andP</a></span> {<span class="id"><a name="T:464">T</a></span> : <span class="kwd">Type</span>} <span class="id"><a name="F:465">F</a></span> (<span class="id"><a name="b1:466">b1</a></span> <span class="id"><a name="b2:467">b2</a></span> : <span class="id">T</span> -&gt; <span class="kwd">Prop</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="x:468">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">b1</span> <span class="id">x</span> /\ <span class="id">b2</span> <span class="id">x</span>) &lt;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="x:469">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">b1</span> <span class="id">x</span>) /\ (\<span class="kwd">forall</span> <span class="id"><a name="x:470">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">b2</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof56')">Proof.</span></div>
<div class="proofscript" id="proof56">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">split</span>=&gt; [<span class="id">H</span>|[<span class="id">H1</span> <span class="id">H2</span>]]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">split</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">H</span> =&gt; ? [].<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS2">filterS2</a></span> <span class="id">H1</span> <span class="id">H2</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nearP_dep">nearP_dep</a></span> {<span class="id"><a name="T:471">T</a></span> <span class="id"><a name="U:472">U</a></span>} {<span class="id"><a name="F:473">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} {<span class="id"><a name="G:474">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)}<br/>
&nbsp;&nbsp;&nbsp;{<span class="id"><a name="FF:475">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} {<span class="id"><a name="FG:476">FG</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">G</span>} (<span class="id"><a name="P:477">P</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span> -&gt; <span class="kwd">Prop</span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="x:478">x</a></span> \<span class="id">near</span> <span class="id">F</span> &amp; <span class="id"><a name="y:479">y</a></span> \<span class="id">near</span> <span class="id">G</span>, <span class="id">P</span> <span class="id">x</span> <span class="id">y</span>) -&gt;<br/>
&nbsp;&nbsp;\<span class="kwd">forall</span> <span class="id"><a name="x:480">x</a></span> \<span class="id">near</span> <span class="id">F</span>, \<span class="kwd">forall</span> <span class="id"><a name="y:481">y</a></span> \<span class="id">near</span> <span class="id">G</span>, <span class="id">P</span> <span class="id">x</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof57')">Proof.</span></div>
<div class="proofscript" id="proof57">
<span class="id">move</span>=&gt; [[<span class="id">Q</span> <span class="id">R</span>] [/=<span class="id">FQ</span> <span class="id">GR</span>]] <span class="id">QRP</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">FQ</span> =&gt; <span class="id">x</span> <span class="id">Q1x</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">GR</span> =&gt; <span class="id">y</span> <span class="id">Q2y</span>; <span class="id">apply</span>: (<span class="id">QRP</span> (<span class="id">_</span>, <span class="id">_</span>)).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter2P">filter2P</a></span> <span class="id"><a name="T:482">T</a></span> <span class="id"><a name="U:483">U</a></span> (<span class="id"><a name="F:484">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="G:485">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>))<br/>
&nbsp;&nbsp;{<span class="id"><a name="FF:486">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} {<span class="id"><a name="FG:487">FG</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">G</span>} (<span class="id"><a name="P:488">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id">T</span> * <span class="id">U</span>)) :<br/>
&nbsp;&nbsp;(<span class="kwd">exists2</span> <span class="id"><a name="Q:489">Q</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span> * <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>, <span class="id">F</span> <span class="id">Q</span>.1 /\ <span class="id">G</span> <span class="id">Q</span>.2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp; <span class="kwd">forall</span> (<span class="id"><a name="x:491">x</a></span> : <span class="id">T</span>) (<span class="id"><a name="y:492">y</a></span> : <span class="id">U</span>), <span class="id">Q</span>.1 <span class="id">x</span> -&gt; <span class="id">Q</span>.2 <span class="id">y</span> -&gt; <span class="id">P</span> (<span class="id">x</span>, <span class="id">y</span>))<br/>
&nbsp;&nbsp;&nbsp;&lt;-&gt; \<span class="kwd">forall</span> <span class="id"><a name="x:493">x</a></span> \<span class="id">near</span> (<span class="id">F</span>, <span class="id">G</span>), <span class="id">P</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof58')">Proof.</span></div>
<div class="proofscript" id="proof58">
<span class="id">split</span>=&gt; [][[<span class="id">A</span> <span class="id">B</span>] /=[<span class="id">FA</span> <span class="id">GB</span>] <span class="id">ABP</span>]; <span class="kwd">exists</span> (<span class="id">A</span>, <span class="id">B</span>) =&gt; //=.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">a</span> <span class="id">b</span>] [/=<span class="id">Aa</span> <span class="id">Bb</span>]; <span class="id">apply</span>: <span class="id">ABP</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">a</span> <span class="id">b</span> <span class="id">Aa</span> <span class="id">Bb</span>; <span class="id">apply</span>: (<span class="id">ABP</span> (<span class="id">_</span>, <span class="id">_</span>)).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_ex2">filter_ex2</a></span> {<span class="id"><a name="T:494">T</a></span> <span class="id"><a name="U:495">U</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="F:496">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="G:497">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>))<br/>
&nbsp;&nbsp;{<span class="id"><a name="FF:498">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span>} {<span class="id"><a name="FG:499">FG</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">G</span>} (<span class="id"><a name="P:500">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) (<span class="id"><a name="Q:501">Q</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">F</span> <span class="id">P</span> -&gt; <span class="id">G</span> <span class="id">Q</span> -&gt; <span class="kwd">exists</span> <span class="id"><a name="x:502">x</a></span> : <span class="id">T</span>, <span class="kwd">exists2</span> <span class="id"><a name="y:503">y</a></span> : <span class="id">U</span>, <span class="id">P</span> <span class="id">x</span> &amp; <span class="id">Q</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof59')">Proof.</span></div>
<div class="proofscript" id="proof59">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> [<span class="id">x</span> <span class="id">Px</span>] /<span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> [<span class="id">y</span> <span class="id">Qy</span>]; <span class="kwd">exists</span> <span class="id">x</span>, <span class="id">y</span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_ex2">filter_ex2</a></span> {<span class="id">T</span> <span class="id">U</span> <span class="id">F</span> <span class="id">G</span> <span class="id">FF</span> <span class="id">FG</span> <span class="id">_</span> <span class="id">_</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_fromP">filter_fromP</a></span> {<span class="id"><a name="I:505">I</a></span> <span class="id"><a name="T:506">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="D:507">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id"><a name="B:508">B</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) (<span class="id"><a name="F:509">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id">F</span> `=&gt;` <span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> <span class="id">D</span> <span class="id">B</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id"><a name="i:510">i</a></span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">F</span> (<span class="id">B</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof60')">Proof.</span></div>
<div class="proofscript" id="proof60">
<span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FB</span> <span class="id">i</span> ?; <span class="id">apply</span>/<span class="id">FB</span>/<span class="id"><a href="mathcomp.analysis.topology.html#in_filter_from">in_filter_from</a></span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FB</span> <span class="id">P</span> [<span class="id">i</span> <span class="id">Di</span> <span class="id">BjP</span>]; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">BjP</span>); <span class="id">apply</span>: <span class="id">FB</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_fromTP">filter_fromTP</a></span> {<span class="id"><a name="I:511">I</a></span> <span class="id"><a name="T:512">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="B:513">B</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) (<span class="id"><a name="F:514">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id">F</span> `=&gt;` <span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> <span class="id">B</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id"><a name="i:515">i</a></span>, <span class="id">F</span> (<span class="id">B</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof61')">Proof.</span></div>
<div class="proofscript" id="proof61">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_fromP">filter_fromP</a></span>; <span class="id">split</span>=&gt; [<span class="id">P</span> <span class="id">i</span>|<span class="id">P</span> <span class="id">i</span> <span class="id">_</span>]; <span class="id">apply</span>: <span class="id">P</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_from_filter">filter_from_filter</a></span> {<span class="id"><a name="I:516">I</a></span> <span class="id"><a name="T:517">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="D:518">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id"><a name="B:519">B</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">exists</span> <span class="id"><a name="i:520">i</a></span> : <span class="id">I</span>, <span class="id">D</span> <span class="id">i</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="i:521">i</a></span> <span class="id"><a name="j:522">j</a></span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">D</span> <span class="id">j</span> -&gt; <span class="kwd">exists2</span> <span class="id"><a name="k:523">k</a></span>, <span class="id">D</span> <span class="id">k</span> &amp; <span class="id">B</span> <span class="id">k</span> `&lt;=` <span class="id">B</span> <span class="id">i</span> `&amp;` <span class="id">B</span> <span class="id">j</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> <span class="id">D</span> <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof62')">Proof.</span></div>
<div class="proofscript" id="proof62">
<span class="id">move</span>=&gt; [<span class="id">i0</span> <span class="id">Di0</span>] <span class="id">Binter</span>; <span class="id">constructor</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">i0</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> [<span class="id">i</span> <span class="id">Di</span> <span class="id">BiP</span>] [<span class="id">j</span> <span class="id">Dj</span> <span class="id">BjQ</span>]; <span class="id">have</span> [<span class="id">k</span> <span class="id">Dk</span> <span class="id">BkPQ</span>]:= <span class="id">Binter</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Di</span> <span class="id">Dj</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">k</span> =&gt; // <span class="id">x</span> /<span class="id">BkPQ</span> [/<span class="id">BiP</span> ? /<span class="id">BjQ</span>].<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> <span class="id">subPQ</span> [<span class="id">i</span> <span class="id">Di</span> <span class="id">BiP</span>]; <span class="kwd">exists</span> <span class="id">i</span> =&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#subset_trans">subset_trans</a></span> <span class="id">subPQ</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_fromT_filter">filter_fromT_filter</a></span> {<span class="id"><a name="I:525">I</a></span> <span class="id"><a name="T:526">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="B:527">B</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">exists</span> <span class="id">_</span> : <span class="id">I</span>, <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#True">True</a></span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="i:528">i</a></span> <span class="id"><a name="j:529">j</a></span>, <span class="kwd">exists</span> <span class="id"><a name="k:530">k</a></span>, <span class="id">B</span> <span class="id">k</span> `&lt;=` <span class="id">B</span> <span class="id">i</span> `&amp;` <span class="id">B</span> <span class="id">j</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof63')">Proof.</span></div>
<div class="proofscript" id="proof63">
<span class="id">move</span>=&gt; [<span class="id">i0</span> <span class="id">_</span>] <span class="id">BI</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_from_filter">filter_from_filter</a></span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">i0</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">j</span> <span class="id">_</span> <span class="id">_</span>; <span class="id">have</span> [<span class="id">k</span>] := <span class="id">BI</span> <span class="id">i</span> <span class="id">j</span>; <span class="kwd">exists</span> <span class="id">k</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_from_proper">filter_from_proper</a></span> {<span class="id"><a name="I:531">I</a></span> <span class="id"><a name="T:532">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="D:533">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id"><a name="B:534">B</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> <span class="id">D</span> <span class="id">B</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="i:535">i</a></span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">B</span> <span class="id">i</span> !=<span class="id">set0</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> <span class="id">D</span> <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof64')">Proof.</span></div>
<div class="proofscript" id="proof64">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">BN0</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Build_ProperFilter">Build_ProperFilter</a></span>=&gt; <span class="id">P</span> [<span class="id">i</span> <span class="id">Di</span> <span class="id">BiP</span>].<br/>
<span class="kwd">by</span> <span class="id">have</span> [<span class="id">x</span> <span class="id">Bix</span>] := <span class="id">BN0</span> <span class="id">_</span> <span class="id">Di</span>; <span class="kwd">exists</span> <span class="id">x</span>; <span class="id">apply</span>: <span class="id">BiP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_bigI">filter_bigI</a></span> <span class="id"><a name="T:536">T</a></span> (<span class="id"><a name="I:537">I</a></span> : <span class="id">choiceType</span>) (<span class="id"><a name="D:538">D</a></span> : {<span class="id">fset</span> <span class="id">I</span>}) (<span class="id"><a name="f:539">f</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)<br/>
&nbsp;&nbsp;(<span class="id"><a name="F:540">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; (<span class="kwd">forall</span> <span class="id"><a name="i:541">i</a></span>, <span class="id">i</span> \<span class="kwd">in</span> <span class="id">D</span> -&gt; <span class="id">F</span> (<span class="id">f</span> <span class="id">i</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">F</span> (\<span class="id">bigcap_</span>(<span class="id"><a name="i:543">i</a></span> <span class="kwd">in</span> [<span class="id">set</span> <span class="id"><a name="i:542">i</a></span> | <span class="id">i</span> \<span class="kwd">in</span> <span class="id">D</span>]) <span class="id">f</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof65')">Proof.</span></div>
<div class="proofscript" id="proof65">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">FfD</span>.<br/>
<span class="id">suff</span>: <span class="id">F</span> [<span class="id">set</span> <span class="id"><a name="p:544">p</a></span> | <span class="kwd">forall</span> <span class="id"><a name="i:545">i</a></span>, <span class="id">i</span> \<span class="kwd">in</span> <span class="id">enum_fset</span> <span class="id">D</span> -&gt; <span class="id">f</span> <span class="id">i</span> <span class="id">p</span>] <span class="kwd">by</span> [].<br/>
<span class="id">have</span> {<span class="id">FfD</span>} : <span class="kwd">forall</span> <span class="id"><a name="i:546">i</a></span>, <span class="id">i</span> \<span class="kwd">in</span> <span class="id">enum_fset</span> <span class="id">D</span> -&gt; <span class="id">F</span> (<span class="id">f</span> <span class="id">i</span>) <span class="kwd">by</span> <span class="id">move</span>=&gt; ? /<span class="id">FfD</span>.<br/>
<span class="id">elim</span>: (<span class="id">enum_fset</span> <span class="id">D</span>) =&gt; [|<span class="id">i</span> <span class="id">s</span> <span class="id">ihs</span>] <span class="id">FfD</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
<span class="id">apply</span>: (@<span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">f</span> <span class="id">i</span> `&amp;` [<span class="id">set</span> <span class="id"><a name="p:547">p</a></span> | <span class="kwd">forall</span> <span class="id"><a name="i:548">i</a></span>, <span class="id">i</span> \<span class="kwd">in</span> <span class="id">s</span> -&gt; <span class="id">f</span> <span class="id">i</span> <span class="id">p</span>])).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span> [<span class="id">fip</span> <span class="id">fsp</span>] <span class="id">j</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> =&gt; /<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#orP">orP</a></span> [/<span class="id">eqP</span>-&gt;|] //; <span class="id">apply</span>: <span class="id">fsp</span>.<br/>
<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">FfD</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> <span class="id">eq_refl</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">ihs</span> =&gt; <span class="id">j</span> <span class="id">sj</span>; <span class="id">apply</span>: <span class="id">FfD</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> <span class="id">sj</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#orbC">orbC</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_forall">filter_forall</a></span> <span class="id"><a name="T:551">T</a></span> (<span class="id"><a name="I:552">I</a></span> : <span class="id">finType</span>) (<span class="id"><a name="f:553">f</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) (<span class="id"><a name="F:554">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; (<span class="kwd">forall</span> <span class="id"><a name="i:555">i</a></span> : <span class="id">I</span>, \<span class="kwd">forall</span> <span class="id"><a name="x:556">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">f</span> <span class="id">i</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;\<span class="kwd">forall</span> <span class="id"><a name="x:557">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="kwd">forall</span> <span class="id"><a name="i:558">i</a></span>, <span class="id">f</span> <span class="id">i</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof66')">Proof.</span></div>
<div class="proofscript" id="proof66">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">fIF</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> (@<span class="id"><a href="mathcomp.analysis.topology.html#filter_bigI">filter_bigI</a></span> <span class="id">T</span> <span class="id">I</span> [<span class="id">fset</span> <span class="id"><a name="x:559">x</a></span> <span class="kwd">in</span> <span class="id">I</span>]%<span class="id">fset</span> <span class="id">f</span> <span class="id">F</span> <span class="id">FF</span> <span class="id">_</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">fIx</span> <span class="id">i</span>; <span class="id">have</span> := <span class="id">fIx</span> <span class="id">i</span>; <span class="id">rewrite</span> /= <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span>/=; <span class="id">apply</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">i</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span>/= =&gt; <span class="id">_</span>; <span class="id">apply</span>: (<span class="id">fIF</span> <span class="id">i</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_imply">filter_imply</a></span> [<span class="id"><a name="T:565">T</a></span> : <span class="kwd">Type</span>] [<span class="id"><a name="P:566">P</a></span> : <span class="kwd">Prop</span>] [<span class="id"><a name="f:567">f</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>] [<span class="id"><a name="F:568">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)] :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; (<span class="id">P</span> -&gt; \<span class="id">near</span> <span class="id"><a name="F:569">F</a></span>, <span class="id">f</span> <span class="id">F</span>) -&gt; \<span class="id">near</span> <span class="id"><a name="F:572">F</a></span>, <span class="id">P</span> -&gt; <span class="id">f</span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof67')">Proof.</span></div>
<div class="proofscript" id="proof67">
<span class="id">move</span>=&gt; ? <span class="id">PF</span>; <span class="id">near</span> <span class="id">do</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.classical.boolp.html#asboolP">asboolP</a></span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>: <span class="id"><a href="mathcomp.classical.boolp.html#asboolP">asboolP</a></span>=&gt; [/<span class="id">PF</span>|<span class="id">_</span>]; <span class="kwd">by</span> [<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span>|<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nearW">nearW</a></span>].<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<h2> Limits expressed with filters </h2>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="fmap">fmap</a></span> {<span class="id"><a name="T:575">T</a></span> <span class="id"><a name="U:576">U</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="f:577">f</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id"><a name="F:578">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id"><a name="P:579">P</a></span> | <span class="id">F</span> (<span class="id">f</span> @^-1` <span class="id">P</span>)].<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#fmap">fmap</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> /.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="fmapE">fmapE</a></span> {<span class="id"><a name="U:580">U</a></span> <span class="id"><a name="V:581">V</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="f:582">f</a></span> : <span class="id">U</span> -&gt; <span class="id">V</span>)<br/>
&nbsp;&nbsp;(<span class="id"><a name="F:583">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id"><a name="P:584">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#fmap">fmap</a></span> <span class="id">f</span> <span class="id">F</span> <span class="id">P</span> = <span class="id">F</span> (<span class="id">f</span> @^-1` <span class="id">P</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof68')">Proof.</span></div>
<div class="proofscript" id="proof68">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Notation</span> "<span class="id">E</span> @[ <span class="id">x</span> --&gt; <span class="id">F</span> ]" :=<br/>
&nbsp;&nbsp;(<span class="id"><a href="mathcomp.analysis.topology.html#fmap">fmap</a></span> (<span class="kwd">fun</span> <span class="id"><a name="x:585">x</a></span> =&gt; <span class="id">E</span>) [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>]) : <span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Notation</span> "<span class="id">f</span> @ <span class="id">F</span>" := (<span class="id"><a href="mathcomp.analysis.topology.html#fmap">fmap</a></span> <span class="id">f</span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>]) : <span class="id">classical_set_scope</span>.<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="fmap_filter">fmap_filter</a></span> <span class="id"><a name="T:586">T</a></span> <span class="id"><a name="U:587">U</a></span> (<span class="id"><a name="f:588">f</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id"><a name="F:589">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id">f</span> @ <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof69')">Proof.</span></div>
<div class="proofscript" id="proof69">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">constructor</span> =&gt; [|<span class="id">P</span> <span class="id">Q</span>|<span class="id">P</span> <span class="id">Q</span> <span class="id">PQ</span>]; <span class="id">rewrite</span> ?<span class="id"><a href="mathcomp.analysis.topology.html#fmapE">fmapE</a></span> ?<span class="id">filter_ofE</span> //=.<br/>
- <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
- <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span>=&gt; ?/<span class="id">PQ</span>.<br/>
Qed.</div>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="fmap_proper_filter">fmap_proper_filter</a></span> <span class="id"><a name="T:590">T</a></span> <span class="id"><a name="U:591">U</a></span> (<span class="id"><a name="f:592">f</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id"><a name="F:593">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id">f</span> @ <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof70')">Proof.</span></div>
<div class="proofscript" id="proof70">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">apply</span>: <span class="id">Build_ProperFilter</span>';<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#fmapE">fmapE</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_not_empty">filter_not_empty</a></span>.<br/>
Qed.</div>
<span class="kwd">Definition</span> <span class="id"><a name="fmap_proper_filter'">fmap_proper_filter</a></span>' := <span class="id"><a href="mathcomp.analysis.topology.html#fmap_proper_filter">fmap_proper_filter</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="fmapi">fmapi</a></span> {<span class="id"><a name="T:594">T</a></span> <span class="id"><a name="U:595">U</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="f:596">f</a></span> : <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) (<span class="id"><a name="F:597">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id"><a name="P:598">P</a></span> | \<span class="kwd">forall</span> <span class="id"><a name="x:599">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="kwd">exists</span> <span class="id"><a name="y:600">y</a></span>, <span class="id">f</span> <span class="id">x</span> <span class="id">y</span> /\ <span class="id">P</span> <span class="id">y</span>].<br/>
<br/>
<span class="kwd">Notation</span> "<span class="id">E</span> `@[ <span class="id">x</span> --&gt; <span class="id">F</span> ]" :=<br/>
&nbsp;&nbsp;(<span class="id"><a href="mathcomp.analysis.topology.html#fmapi">fmapi</a></span> (<span class="kwd">fun</span> <span class="id"><a name="x:601">x</a></span> =&gt; <span class="id">E</span>) [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>]) : <span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Notation</span> "<span class="id">f</span> `@ <span class="id">F</span>" := (<span class="id"><a href="mathcomp.analysis.topology.html#fmapi">fmapi</a></span> <span class="id">f</span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>]) : <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="fmapiE">fmapiE</a></span> {<span class="id"><a name="U:602">U</a></span> <span class="id"><a name="V:603">V</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="f:604">f</a></span> : <span class="id">U</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>)<br/>
&nbsp;&nbsp;(<span class="id"><a name="F:605">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id"><a name="P:606">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#fmapi">fmapi</a></span> <span class="id">f</span> <span class="id">F</span> <span class="id">P</span> = \<span class="kwd">forall</span> <span class="id"><a name="x:607">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="kwd">exists</span> <span class="id"><a name="y:608">y</a></span>, <span class="id">f</span> <span class="id">x</span> <span class="id">y</span> /\ <span class="id">P</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof71')">Proof.</span></div>
<div class="proofscript" id="proof71">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="fmapi_filter">fmapi_filter</a></span> <span class="id"><a name="T:609">T</a></span> <span class="id"><a name="U:610">U</a></span> (<span class="id"><a name="f:611">f</a></span> : <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) (<span class="id"><a name="F:612">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.signed.html#infer">infer</a></span> {<span class="id">near</span> <span class="id">F</span>, <span class="id"><a href="mathcomp.classical.classical_sets.html#is_totalfun">is_totalfun</a></span> <span class="id">f</span>} -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id">f</span> `@ <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof72')">Proof.</span></div>
<div class="proofscript" id="proof72">
<span class="id">move</span>=&gt; <span class="id">f_totalfun</span> <span class="id">FF</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#fmapi">fmapi</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Build_Filter">Build_Filter</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">f_totalfun</span> =&gt; <span class="id">x</span> [[<span class="id">y</span> <span class="id">Hy</span>] <span class="id">H</span>]; <span class="kwd">exists</span> <span class="id">y</span>.<br/>
- <span class="id">move</span>=&gt; /= <span class="id">P</span> <span class="id">Q</span> <span class="id">FP</span> <span class="id">FQ</span>; <span class="id">near</span>=&gt; <span class="id">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span> [//|<span class="id">y</span> [<span class="id">fxy</span> <span class="id">Py</span>]] := <span class="id"><a href="mathcomp.analysis.topology.html#near">near</a></span> <span class="id">FP</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span> [//|<span class="id">z</span> [<span class="id">fxz</span> <span class="id">Qz</span>]] := <span class="id"><a href="mathcomp.analysis.topology.html#near">near</a></span> <span class="id">FQ</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span> [//|<span class="id">_</span> <span class="id">fx_prop</span>] := <span class="id"><a href="mathcomp.analysis.topology.html#near">near</a></span> <span class="id">f_totalfun</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">y</span>; <span class="id">split</span> =&gt; //; <span class="id">split</span> =&gt; //; <span class="id">rewrite</span> [<span class="id">y</span>](<span class="id">fx_prop</span> <span class="id">_</span> <span class="id">z</span>).<br/>
- <span class="id">move</span>=&gt; /= <span class="id">P</span> <span class="id">Q</span> <span class="id">subPQ</span> <span class="id">FP</span>; <span class="id">near</span>=&gt; <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [//|<span class="id">y</span> [<span class="id">fxy</span> /<span class="id">subPQ</span> <span class="id">Qy</span>]] := <span class="id"><a href="mathcomp.analysis.topology.html#near">near</a></span> <span class="id">FP</span> <span class="id">x</span>; <span class="kwd">exists</span> <span class="id">y</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
#[<span class="id">global</span>] <span class="id">Typeclasses</span> <span class="kwd">Opaque</span> <span class="id">fmapi</span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="fmapi_proper_filter">fmapi_proper_filter</a></span><br/>
&nbsp;&nbsp;<span class="id"><a name="T:613">T</a></span> <span class="id"><a name="U:614">U</a></span> (<span class="id"><a name="f:615">f</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span> -&gt; <span class="kwd">Prop</span>) (<span class="id"><a name="F:616">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.signed.html#infer">infer</a></span> {<span class="id">near</span> <span class="id">F</span>, <span class="id"><a href="mathcomp.classical.classical_sets.html#is_totalfun">is_totalfun</a></span> <span class="id">f</span>} -&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id">f</span> `@ <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof73')">Proof.</span></div>
<div class="proofscript" id="proof73">
<span class="id">move</span>=&gt; <span class="id">f_totalfun</span> <span class="id">FF</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Build_ProperFilter">Build_ProperFilter</a></span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#fmapi">fmapi</a></span>/= =&gt; /<span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> [<span class="id">x</span> [<span class="id">y</span> [??]]]; <span class="kwd">exists</span> <span class="id">y</span>.<br/>
Qed.</div>
<span class="kwd">Definition</span> <span class="id"><a name="filter_map_proper_filter'">filter_map_proper_filter</a></span>' := <span class="id"><a href="mathcomp.analysis.topology.html#fmapi_proper_filter">fmapi_proper_filter</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_id">cvg_id</a></span> <span class="id"><a name="T:617">T</a></span> (<span class="id"><a name="F:618">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) : <span class="id">x</span> @[<span class="id"><a name="x:619">x</a></span> --&gt; <span class="id">F</span>] --&gt; <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof74')">Proof.</span></div>
<div class="proofscript" id="proof74">
 <span class="id">exact</span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvg_id">cvg_id</a></span> {<span class="id">T</span> <span class="id">F</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="fmap_comp">fmap_comp</a></span> {<span class="id"><a name="A:620">A</a></span> <span class="id"><a name="B:621">B</a></span> <span class="id"><a name="C:622">C</a></span>} (<span class="id"><a name="f:623">f</a></span> : <span class="id">B</span> -&gt; <span class="id">C</span>) (<span class="id"><a name="g:624">g</a></span> : <span class="id">A</span> -&gt; <span class="id">B</span>) <span class="id"><a name="F:625">F</a></span>:<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; (<span class="id">f</span> \<span class="id">o</span> <span class="id">g</span>)%<span class="id">FUN</span> @ <span class="id">F</span> = <span class="id">f</span> @ (<span class="id">g</span> @ <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof75')">Proof.</span></div>
<div class="proofscript" id="proof75">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="appfilter">appfilter</a></span> <span class="id"><a name="U:626">U</a></span> <span class="id"><a name="V:627">V</a></span> (<span class="id"><a name="f:628">f</a></span> : <span class="id">U</span> -&gt; <span class="id">V</span>) (<span class="id"><a name="F:629">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> = [<span class="id">set</span> <span class="id"><a name="P:630">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">_</span> | \<span class="kwd">forall</span> <span class="id"><a name="x:631">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">P</span> (<span class="id">f</span> <span class="id">x</span>)].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof76')">Proof.</span></div>
<div class="proofscript" id="proof76">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_app">cvg_app</a></span> <span class="id"><a name="U:632">U</a></span> <span class="id"><a name="V:633">V</a></span> (<span class="id"><a name="F:634">F</a></span> <span class="id"><a name="G:635">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id"><a name="f:636">f</a></span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">G</span> -&gt; <span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">f</span> @ <span class="id">G</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof77')">Proof.</span></div>
<div class="proofscript" id="proof77">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FG</span> <span class="id">P</span> /=; <span class="id">exact</span>: <span class="id">FG</span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvg_app">cvg_app</a></span> {<span class="id">U</span> <span class="id">V</span> <span class="id">F</span> <span class="id">G</span>} <span class="id">_</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvgi_app">cvgi_app</a></span> <span class="id"><a name="U:637">U</a></span> <span class="id"><a name="V:638">V</a></span> (<span class="id"><a name="F:639">F</a></span> <span class="id"><a name="G:640">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id"><a name="f:641">f</a></span> : <span class="id">U</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">G</span> -&gt; <span class="id">f</span> `@ <span class="id">F</span> --&gt; <span class="id">f</span> `@ <span class="id">G</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof78')">Proof.</span></div>
<div class="proofscript" id="proof78">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FG</span> <span class="id">P</span> /=; <span class="id">exact</span>: <span class="id">FG</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_comp">cvg_comp</a></span> <span class="id"><a name="T:642">T</a></span> <span class="id"><a name="U:643">U</a></span> <span class="id"><a name="V:644">V</a></span> (<span class="id"><a name="f:645">f</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id"><a name="g:646">g</a></span> : <span class="id">U</span> -&gt; <span class="id">V</span>)<br/>
&nbsp;&nbsp;(<span class="id"><a name="F:647">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="G:648">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id"><a name="H:649">H</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>)) :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> `=&gt;` <span class="id">G</span> -&gt; <span class="id">g</span> @ <span class="id">G</span> `=&gt;` <span class="id">H</span> -&gt; <span class="id">g</span> \<span class="id">o</span> <span class="id">f</span> @ <span class="id">F</span> `=&gt;` <span class="id">H</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof79')">Proof.</span></div>
<div class="proofscript" id="proof79">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">fFG</span> <span class="id">gGH</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_trans">cvg_trans</a></span> <span class="id">gGH</span> =&gt; <span class="id">P</span> /<span class="id">fFG</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvgi_comp">cvgi_comp</a></span> <span class="id"><a name="T:650">T</a></span> <span class="id"><a name="U:651">U</a></span> <span class="id"><a name="V:652">V</a></span> (<span class="id"><a name="f:653">f</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id"><a name="g:654">g</a></span> : <span class="id">U</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>)<br/>
&nbsp;&nbsp;(<span class="id"><a name="F:655">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="G:656">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) (<span class="id"><a name="H:657">H</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>)) :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> `=&gt;` <span class="id">G</span> -&gt; <span class="id">g</span> `@ <span class="id">G</span> `=&gt;` <span class="id">H</span> -&gt; <span class="id">g</span> \<span class="id">o</span> <span class="id">f</span> `@ <span class="id">F</span> `=&gt;` <span class="id">H</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof80')">Proof.</span></div>
<div class="proofscript" id="proof80">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">fFG</span> <span class="id">gGH</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_trans">cvg_trans</a></span> <span class="id">gGH</span> =&gt; <span class="id">P</span> /<span class="id">fFG</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_eq_cvg">near_eq_cvg</a></span> {<span class="id"><a name="T:658">T</a></span> <span class="id"><a name="U:659">U</a></span>} {<span class="id"><a name="F:660">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} {<span class="id"><a name="FF:661">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} (<span class="id"><a name="f:662">f</a></span> <span class="id"><a name="g:663">g</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;{<span class="id">near</span> <span class="id">F</span>, <span class="id">f</span> =1 <span class="id">g</span>} -&gt; <span class="id">g</span> @ <span class="id">F</span> `=&gt;` <span class="id">f</span> @ <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof81')">Proof.</span></div>
<div class="proofscript" id="proof81">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">eq_fg</span> <span class="id">P</span> /=; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS2">filterS2</a></span> <span class="id">eq_fg</span> =&gt; <span class="id">x</span> /= &lt;-. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="eq_cvg">eq_cvg</a></span> (<span class="id"><a name="T:664">T</a></span> <span class="id"><a name="T':665">T</a></span>' : <span class="kwd">Type</span>) (<span class="id"><a name="F:666">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="f:667">f</a></span> <span class="id"><a name="g:668">g</a></span> : <span class="id">T</span> -&gt; <span class="id">T</span>') (<span class="id"><a name="x:669">x</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>')) :<br/>
&nbsp;&nbsp;<span class="id">f</span> =1 <span class="id">g</span> -&gt; (<span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">x</span>) = (<span class="id">g</span> @ <span class="id">F</span> --&gt; <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof82')">Proof.</span></div>
<div class="proofscript" id="proof82">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.classical.boolp.html#funext">funext</a></span>-&gt;. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="eq_is_cvg">eq_is_cvg</a></span> (<span class="id"><a name="T:670">T</a></span> <span class="id"><a name="T':671">T</a></span>' : <span class="kwd">Type</span>) (<span class="id"><a name="fT:672">fT</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">T</span>') (<span class="id"><a name="F:673">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="f:674">f</a></span> <span class="id"><a name="g:675">g</a></span> : <span class="id">T</span> -&gt; <span class="id">T</span>') :<br/>
&nbsp;&nbsp;<span class="id">f</span> =1 <span class="id">g</span> -&gt; [<span class="id">cvg</span> (<span class="id">f</span> @ <span class="id">F</span>) <span class="kwd">in</span> <span class="id">fT</span>] = [<span class="id">cvg</span> (<span class="id">g</span> @ <span class="id">F</span>) <span class="kwd">in</span> <span class="id">fT</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof83')">Proof.</span></div>
<div class="proofscript" id="proof83">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.classical.boolp.html#funext">funext</a></span>-&gt;. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="neari_eq_loc">neari_eq_loc</a></span> {<span class="id"><a name="T:676">T</a></span> <span class="id"><a name="U:677">U</a></span>} {<span class="id"><a name="F:678">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} {<span class="id"><a name="FF:679">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} (<span class="id"><a name="f:680">f</a></span> <span class="id"><a name="g:681">g</a></span> : <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;{<span class="id">near</span> <span class="id">F</span>, <span class="id">f</span> =2 <span class="id">g</span>} -&gt; <span class="id">g</span> `@ <span class="id">F</span> `=&gt;` <span class="id">f</span> `@ <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof84')">Proof.</span></div>
<div class="proofscript" id="proof84">
<span class="id">move</span>=&gt; <span class="id">eq_fg</span> <span class="id">P</span> /=; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS2">filterS2</a></span> <span class="id">eq_fg</span> =&gt; <span class="id">x</span> <span class="id">eq_fg</span> [<span class="id">y</span> [<span class="id">fxy</span> <span class="id">Py</span>]].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">y</span>; <span class="id">rewrite</span> -<span class="id">eq_fg</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_near_const">cvg_near_const</a></span> (<span class="id"><a name="T:682">T</a></span> <span class="id"><a name="U:683">U</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="f:684">f</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id"><a name="F:685">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="G:686">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">G</span> -&gt;<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="y:687">y</a></span> \<span class="id">near</span> <span class="id">G</span>, \<span class="kwd">forall</span> <span class="id"><a name="x:688">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">f</span> <span class="id">x</span> = <span class="id">y</span>) -&gt; <span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">G</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof85')">Proof.</span></div>
<div class="proofscript" id="proof85">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">FG</span> <span class="id">fFG</span> <span class="id">P</span> /= <span class="id">GP</span>; <span class="id">rewrite</span> !<span class="id"><a href="mathcomp.analysis.topology.html#near_simpl">near_simpl</a></span>; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#have_near">have_near</a></span> <span class="id">G</span>).<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app">filter_app</a></span> <span class="id">fFG</span>; <span class="id">near</span> <span class="id">do</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> =&gt; <span class="id">x</span> /= -&gt;.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="globally">globally</a></span> {<span class="id"><a name="T:689">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="A:690">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;&nbsp;[<span class="id">set</span> <span class="id"><a name="P:691">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span> | <span class="kwd">forall</span> <span class="id"><a name="x:692">x</a></span>, <span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">P</span> <span class="id">x</span>].<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> {<span class="id">T</span>} <span class="id">A</span> <span class="id">_</span> /.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="globally0">globally0</a></span> {<span class="id"><a name="T:693">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="A:694">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span> <span class="id">A</span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof86')">Proof.</span></div>
<div class="proofscript" id="proof86">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="globally_filter">globally_filter</a></span> {<span class="id"><a name="T:695">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="A:696">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof87')">Proof.</span></div>
<div class="proofscript" id="proof87">
<span class="id">constructor</span> =&gt; //= <span class="id">P</span> <span class="id">Q</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">PQ</span> <span class="id">AP</span> <span class="id">x</span> /<span class="id">AP</span> /<span class="id">PQ</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">AP</span> <span class="id">AQ</span> <span class="id">x</span> <span class="id">Ax</span>; <span class="id">split</span>; [<span class="id">apply</span>: <span class="id">AP</span>|<span class="id">apply</span>: <span class="id">AQ</span>].<br/>
Qed.</div>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="globally_properfilter">globally_properfilter</a></span> {<span class="id"><a name="T:697">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="A:698">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) <span class="id"><a name="a:699">a</a></span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.signed.html#infer">infer</a></span> (<span class="id">A</span> <span class="id">a</span>) -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof88')">Proof.</span></div>
<div class="proofscript" id="proof88">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Aa</span>; <span class="id">apply</span>: <span class="id">Build_ProperFilter</span>' =&gt; /(<span class="id">_</span> <span class="id">a</span>). Qed.</div>
<br/>
<h2> Specific filters </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="frechet_filter">frechet_filter</a></span>.<br/>
<span class="kwd">Variable</span> <span class="id"><a name="frechet_filter.T">T</a></span> : <span class="kwd">Type</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="frechet_filter">frechet_filter</a></span> := [<span class="id">set</span> <span class="id"><a name="S:701">S</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#frechet_filter.T">T</a></span> | <span class="id"><a href="mathcomp.classical.cardinality.html#finite_set">finite_set</a></span> (~` <span class="id">S</span>)].<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="frechet_properfilter">frechet_properfilter</a></span> : <span class="id"><a href="mathcomp.classical.cardinality.html#infinite_set">infinite_set</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.topology.html#frechet_filter.T">T</a></span>] -&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#frechet_filter">frechet_filter</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof89')">Proof.</span></div>
<div class="proofscript" id="proof89">
<span class="id">move</span>=&gt; <span class="id">infT</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#frechet_filter">frechet_filter</a></span>.<br/>
<span class="id">constructor</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> /= <span class="id"><a href="mathcomp.classical.classical_sets.html#setC0">setC0</a></span>; <span class="id">exact</span>: <span class="id">infT</span>.<br/>
<span class="id">constructor</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> /= <span class="id"><a href="mathcomp.classical.classical_sets.html#setCT">setCT</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id">rewrite</span> /= <span class="id"><a href="mathcomp.classical.classical_sets.html#setCI">setCI</a></span> <span class="id"><a href="mathcomp.classical.cardinality.html#finite_setU">finite_setU</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> <span class="id">PQ</span>; <span class="id">exact</span>/<span class="id"><a href="mathcomp.classical.cardinality.html#sub_finite_set">sub_finite_set</a></span>/<span class="id"><a href="mathcomp.classical.classical_sets.html#subsetC">subsetC</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#frechet_filter">frechet_filter</a></span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="frechet_properfilter_nat">frechet_properfilter_nat</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (@<span class="id"><a href="mathcomp.analysis.topology.html#frechet_filter">frechet_filter</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof90')">Proof.</span></div>
<div class="proofscript" id="proof90">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#frechet_properfilter">frechet_properfilter</a></span>; <span class="id">exact</span>: <span class="id"><a href="mathcomp.classical.cardinality.html#infinite_nat">infinite_nat</a></span>. Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="at_point">at_point</a></span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id"><a name="T:702">T</a></span> : <span class="kwd">Type</span>}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="at_point">at_point</a></span> (<span class="id"><a name="a:703">a</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#at_point.T">T</a></span>) (<span class="id"><a name="P:704">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#at_point.T">T</a></span>) : <span class="kwd">Prop</span> := <span class="id">P</span> <span class="id">a</span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="at_point_filter">at_point_filter</a></span> (<span class="id"><a name="a:705">a</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#at_point.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#at_point">at_point</a></span> <span class="id">a</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof91')">Proof.</span></div>
<div class="proofscript" id="proof91">
 <span class="kwd">by</span> <span class="id">constructor</span>=&gt; //; <span class="id">constructor</span>=&gt; // <span class="id">P</span> <span class="id">Q</span> <span class="id">subPQ</span> /<span class="id">subPQ</span>. Qed.</div>
<span class="id">Typeclasses</span> <span class="kwd">Opaque</span> <span class="id">at_point</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#at_point">at_point</a></span>.<br/>
<br/>
<div class="doc">Filters for pairs </div>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="filter_prod_filter">filter_prod_filter</a></span> <span class="id"><a name="T:706">T</a></span> <span class="id"><a name="U:707">U</a></span> (<span class="id"><a name="F:708">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="G:709">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">G</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> <span class="id">F</span> <span class="id">G</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof92')">Proof.</span></div>
<div class="proofscript" id="proof92">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">FG</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_from_filter">filter_from_filter</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>, <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>); <span class="id">split</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
<span class="id">move</span>=&gt; [<span class="id">P</span> <span class="id">Q</span>] [<span class="id">P</span>' <span class="id">Q</span>'] /= [<span class="id">FP</span> <span class="id">GQ</span>] [<span class="id">FP</span>' <span class="id">GQ</span>'].<br/>
<span class="kwd">exists</span> (<span class="id">P</span> `&amp;` <span class="id">P</span>', <span class="id">Q</span> `&amp;` <span class="id">Q</span>') =&gt; /=; <span class="id">first</span> <span class="kwd">by</span> <span class="id">split</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">x</span> <span class="id">y</span>] [/= [??] []].<br/>
Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="prod_filter_on">prod_filter_on</a></span> <span class="id"><a name="T:710">T</a></span> <span class="id"><a name="U:711">U</a></span> (<span class="id"><a name="F:712">F</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) (<span class="id"><a name="G:713">G</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">U</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> <span class="id">F</span> <span class="id">G</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#filter_prod_filter">filter_prod_filter</a></span> <span class="id">_</span> <span class="id">_</span>).<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="filter_prod_proper">filter_prod_proper</a></span> {<span class="id"><a name="T1:714">T1</a></span> <span class="id"><a name="T2:715">T2</a></span> : <span class="kwd">Type</span>}<br/>
&nbsp;&nbsp;{<span class="id"><a name="F:716">F</a></span> : (<span class="id">T1</span> -&gt; <span class="kwd">Prop</span>) -&gt; <span class="kwd">Prop</span>} {<span class="id"><a name="G:717">G</a></span> : (<span class="id">T2</span> -&gt; <span class="kwd">Prop</span>) -&gt; <span class="kwd">Prop</span>}<br/>
&nbsp;&nbsp;{<span class="id"><a name="FF:718">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span>} {<span class="id"><a name="FG:719">FG</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">G</span>} :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> <span class="id">F</span> <span class="id">G</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof93')">Proof.</span></div>
<div class="proofscript" id="proof93">
<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_from_proper">filter_from_proper</a></span> =&gt; -[<span class="id">A</span> <span class="id">B</span>] [/=<span class="id">FA</span> <span class="id">GB</span>].<br/>
<span class="kwd">by</span> <span class="id">have</span> [[<span class="id">x</span> ?] [<span class="id">y</span> ?]] := (<span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> <span class="id">FA</span>, <span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> <span class="id">GB</span>); <span class="kwd">exists</span> (<span class="id">x</span>, <span class="id">y</span>).<br/>
Qed.</div>
<span class="kwd">Definition</span> <span class="id"><a name="filter_prod_proper'">filter_prod_proper</a></span>' := @<span class="id"><a href="mathcomp.analysis.topology.html#filter_prod_proper">filter_prod_proper</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_prod1">filter_prod1</a></span> {<span class="id"><a name="T:720">T</a></span> <span class="id"><a name="U:721">U</a></span>} {<span class="id"><a name="F:722">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} {<span class="id"><a name="G:723">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)}<br/>
&nbsp;&nbsp;{<span class="id"><a name="FG:724">FG</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">G</span>} (<span class="id"><a name="P:725">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="x:726">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">P</span> <span class="id">x</span>) -&gt; \<span class="kwd">forall</span> <span class="id"><a name="x:727">x</a></span> \<span class="id">near</span> <span class="id">F</span> &amp; <span class="id">_</span> \<span class="id">near</span> <span class="id">G</span>, <span class="id">P</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof94')">Proof.</span></div>
<div class="proofscript" id="proof94">
<span class="id">move</span>=&gt; <span class="id">FP</span>; <span class="kwd">exists</span> (<span class="id">P</span>, <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>)=&gt; //= [|[?? []//]].<br/>
<span class="kwd">by</span> <span class="id">split</span>=&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
Qed.</div>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_prod2">filter_prod2</a></span> {<span class="id"><a name="T:728">T</a></span> <span class="id"><a name="U:729">U</a></span>} {<span class="id"><a name="F:730">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} {<span class="id"><a name="G:731">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)}<br/>
&nbsp;&nbsp;{<span class="id"><a name="FF:732">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} (<span class="id"><a name="P:733">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="y:734">y</a></span> \<span class="id">near</span> <span class="id">G</span>, <span class="id">P</span> <span class="id">y</span>) -&gt; \<span class="kwd">forall</span> <span class="id">_</span> \<span class="id">near</span> <span class="id">F</span> &amp; <span class="id"><a name="y:735">y</a></span> \<span class="id">near</span> <span class="id">G</span>, <span class="id">P</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof95')">Proof.</span></div>
<div class="proofscript" id="proof95">
<span class="id">move</span>=&gt; <span class="id">FP</span>; <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>, <span class="id">P</span>)=&gt; //= [|[?? []//]].<br/>
<span class="kwd">by</span> <span class="id">split</span>=&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
Qed.</div>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id"><a name="in_filter_prod">in_filter_prod</a></span> {<span class="id"><a name="T:736">T</a></span> <span class="id"><a name="U:737">U</a></span>} {<span class="id"><a name="F:738">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} {<span class="id"><a name="G:739">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)}<br/>
&nbsp;&nbsp;(<span class="id"><a name="P:740">P</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">F</span>) (<span class="id"><a name="Q:741">Q</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">G</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> <span class="id">F</span> <span class="id">G</span>) :=<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#InFilter">InFilter</a></span> <span class="id">_</span> <span class="id">_</span> (<span class="kwd">fun</span> <span class="id"><a name="x:742">x</a></span> =&gt; <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">P</span> <span class="id">x</span>.1 /\ <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">Q</span> <span class="id">x</span>.2) <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof96')">Next Obligation.</span></div>
<div class="proofscript" id="proof96">
<span class="id">move</span>=&gt; <span class="id">T</span> <span class="id">U</span> <span class="id">F</span> <span class="id">G</span> <span class="id">P</span> <span class="id">Q</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">P</span>, <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">Q</span>) =&gt; //=; <span class="id">split</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#prop_ofP">prop_ofP</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_pair">near_pair</a></span> {<span class="id"><a name="T:743">T</a></span> <span class="id"><a name="U:744">U</a></span>} {<span class="id"><a name="F:745">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} {<span class="id"><a name="G:746">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id"><a name="FF:747">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} {<span class="id"><a name="FG:748">FG</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">G</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a name="P:749">P</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">F</span>) (<span class="id"><a name="Q:750">Q</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">G</span>) <span class="id"><a name="x:751">x</a></span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">P</span> <span class="id">x</span>.1 -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">Q</span> <span class="id">x</span>.2 -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#in_filter_prod">in_filter_prod</a></span> <span class="id">P</span> <span class="id">Q</span>) <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof97')">Proof.</span></div>
<div class="proofscript" id="proof97">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id">x</span>=&gt; <span class="id">x</span> <span class="id">y</span>; <span class="id">do</span> ?<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#prop_ofE">prop_ofE</a></span> /=; <span class="id">split</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_fst">cvg_fst</a></span> {<span class="id"><a name="T:752">T</a></span> <span class="id"><a name="U:753">U</a></span> <span class="id"><a name="F:754">F</a></span> <span class="id"><a name="G:755">G</a></span>} {<span class="id"><a name="FG:756">FG</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">G</span>} :<br/>
&nbsp;&nbsp;(@<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#fst">fst</a></span> <span class="id">T</span> <span class="id">U</span>) @ <span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> <span class="id">F</span> <span class="id">G</span> --&gt; <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof98')">Proof.</span></div>
<div class="proofscript" id="proof98">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_prod1">filter_prod1</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_snd">cvg_snd</a></span> {<span class="id"><a name="T:757">T</a></span> <span class="id"><a name="U:758">U</a></span> <span class="id"><a name="F:759">F</a></span> <span class="id"><a name="G:760">G</a></span>} {<span class="id"><a name="FF:761">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} :<br/>
&nbsp;&nbsp;(@<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#snd">snd</a></span> <span class="id">T</span> <span class="id">U</span>) @ <span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> <span class="id">F</span> <span class="id">G</span> --&gt; <span class="id">G</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof99')">Proof.</span></div>
<div class="proofscript" id="proof99">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_prod2">filter_prod2</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_map">near_map</a></span> {<span class="id"><a name="T:762">T</a></span> <span class="id"><a name="U:763">U</a></span>} (<span class="id"><a name="f:764">f</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id"><a name="F:765">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="P:766">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="y:767">y</a></span> \<span class="id">near</span> <span class="id">f</span> @ <span class="id">F</span>, <span class="id">P</span> <span class="id">y</span>) = (\<span class="kwd">forall</span> <span class="id"><a name="x:768">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">P</span> (<span class="id">f</span> <span class="id">x</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof100')">Proof.</span></div>
<div class="proofscript" id="proof100">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_map2">near_map2</a></span> {<span class="id"><a name="T:769">T</a></span> <span class="id"><a name="T':770">T</a></span>' <span class="id"><a name="U:771">U</a></span> <span class="id"><a name="U':772">U</a></span>'} (<span class="id"><a name="f:773">f</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id"><a name="g:774">g</a></span> : <span class="id">T</span>' -&gt; <span class="id">U</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a name="F:775">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="G:776">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>')) (<span class="id"><a name="P:777">P</a></span> : <span class="id">U</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>') :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">G</span> -&gt;<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="y:778">y</a></span> \<span class="id">near</span> <span class="id">f</span> @ <span class="id">F</span> &amp; <span class="id"><a name="y':779">y</a></span>' \<span class="id">near</span> <span class="id">g</span> @ <span class="id">G</span>, <span class="id">P</span> <span class="id">y</span> <span class="id">y</span>') =<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="x:780">x</a></span> \<span class="id">near</span> <span class="id">F</span>     &amp; <span class="id"><a name="x':781">x</a></span>' \<span class="id">near</span> <span class="id">G</span>     , <span class="id">P</span> (<span class="id">f</span> <span class="id">x</span>) (<span class="id">g</span> <span class="id">x</span>')).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof101')">Proof.</span></div>
<div class="proofscript" id="proof101">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">FG</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">propeqE</a></span>; <span class="id">split</span>=&gt; -[[<span class="id">A</span> <span class="id">B</span>] /= [<span class="id">fFA</span> <span class="id">fGB</span>] <span class="id">ABP</span>].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">f</span> @^-1` <span class="id">A</span>, <span class="id">g</span> @^-1` <span class="id">B</span>) =&gt; //= -[<span class="id">x</span> <span class="id">y</span> /=] <span class="id">xyAB</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">ABP</span> (<span class="id">_</span>, <span class="id">_</span>)); <span class="id">apply</span>: <span class="id">xyAB</span>.<br/>
<span class="kwd">exists</span> (<span class="id">f</span> @` <span class="id">A</span>, <span class="id">g</span> @` <span class="id">B</span>) =&gt; //=; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; -<span class="id">_</span> [/= [<span class="id">x</span> <span class="id">Ax</span> &lt;-] [<span class="id">x</span>' <span class="id">Bx</span>' &lt;-]]; <span class="id">apply</span>: (<span class="id">ABP</span> (<span class="id">_</span>, <span class="id">_</span>)).<br/>
<span class="id">rewrite</span> !<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_simpl">nbhs_simpl</a></span> /<span class="id"><a href="mathcomp.analysis.topology.html#fmap">fmap</a></span> /=; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">fFA</span>=&gt; <span class="id">x</span> <span class="id">Ax</span>; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">fGB</span> =&gt; <span class="id">x</span> <span class="id">Bx</span>; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_mapi">near_mapi</a></span> {<span class="id"><a name="T:782">T</a></span> <span class="id"><a name="U:783">U</a></span>} (<span class="id"><a name="f:784">f</a></span> : <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) (<span class="id"><a name="F:785">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="P:786">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="y:787">y</a></span> \<span class="id">near</span> <span class="id">f</span> `@ <span class="id">F</span>, <span class="id">P</span> <span class="id">y</span>) = (\<span class="kwd">forall</span> <span class="id"><a name="x:788">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="kwd">exists</span> <span class="id"><a name="y:789">y</a></span>, <span class="id">f</span> <span class="id">x</span> <span class="id">y</span> /\ <span class="id">P</span> <span class="id">y</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof102')">Proof.</span></div>
<div class="proofscript" id="proof102">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_pair_set">filter_pair_set</a></span> (<span class="id"><a name="T:790">T</a></span> <span class="id"><a name="T':791">T</a></span>' : <span class="kwd">Type</span>) (<span class="id"><a name="F:792">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="F':793">F</a></span>' : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>')) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id"><a name="P:794">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) (<span class="id"><a name="P':795">P</a></span>' : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>') (<span class="id"><a name="Q:796">Q</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id">T</span> * <span class="id">T</span>')),<br/>
&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="x:797">x</a></span> <span class="id"><a name="x':798">x</a></span>', <span class="id">P</span> <span class="id">x</span> -&gt; <span class="id">P</span>' <span class="id">x</span>' -&gt; <span class="id">Q</span> (<span class="id">x</span>, <span class="id">x</span>')) -&gt; <span class="id">F</span> <span class="id">P</span> /\ <span class="id">F</span>' <span class="id">P</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> <span class="id">F</span> <span class="id">F</span>' <span class="id">Q</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof103')">Proof.</span></div>
<div class="proofscript" id="proof103">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">FF</span>' <span class="id">P</span> <span class="id">P</span>' <span class="id">Q</span> <span class="id">PQ</span> [<span class="id">FP</span> <span class="id">FP</span>'];<br/>
&nbsp;&nbsp;&nbsp;<span class="id">near</span>=&gt; <span class="id">x</span> <span class="id">do</span> [<span class="id">have</span> := <span class="id">PQ</span> <span class="id">x</span>.1 <span class="id">x</span>.2; <span class="id">rewrite</span> -<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#surjective_pairing">surjective_pairing</a></span>; <span class="id">apply</span>];<br/>
&nbsp;&nbsp;&nbsp;[<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_fst">cvg_fst</a></span> | <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_snd">cvg_snd</a></span>].<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filter_pair_near_of">filter_pair_near_of</a></span> (<span class="id"><a name="T:799">T</a></span> <span class="id"><a name="T':800">T</a></span>' : <span class="kwd">Type</span>) (<span class="id"><a name="F:801">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="F':802">F</a></span>' : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>')) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id"><a name="P:803">P</a></span> : @<span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">T</span> <span class="id">F</span>) (<span class="id"><a name="P':804">P</a></span>' : @<span class="id"><a href="mathcomp.analysis.topology.html#in_filter">in_filter</a></span> <span class="id">T</span>' <span class="id">F</span>') (<span class="id"><a name="Q:805">Q</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id">T</span> * <span class="id">T</span>')),<br/>
&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="x:806">x</a></span> <span class="id"><a name="x':807">x</a></span>', <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">P</span> <span class="id">x</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#prop_of">prop_of</a></span> <span class="id">P</span>' <span class="id">x</span>' -&gt; <span class="id">Q</span> (<span class="id">x</span>, <span class="id">x</span>')) -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> <span class="id">F</span> <span class="id">F</span>' <span class="id">Q</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof104')">Proof.</span></div>
<div class="proofscript" id="proof104">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">FF</span>' [<span class="id">P</span> <span class="id">FP</span>] [<span class="id">P</span>' <span class="id">FP</span>'] <span class="id">Q</span> <span class="id">PQ</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#prop_ofE">prop_ofE</a></span> <span class="kwd">in</span> <span class="id">FP</span> <span class="id">FP</span>' <span class="id">PQ</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">P</span>, <span class="id">P</span>') =&gt; //= -[<span class="id">t</span> <span class="id">t</span>'] [] /=; <span class="id">exact</span>: <span class="id">PQ</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Tactic</span> <span class="kwd">Notation</span> "<span class="id">near</span>=&gt;" <span class="id">ident</span>(<span class="id">x</span>) <span class="id">ident</span>(<span class="id">y</span>) :=<br/>
&nbsp;&nbsp;(<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_pair_near_of">filter_pair_near_of</a></span> =&gt; <span class="id">x</span> <span class="id">y</span> ? ?).<br/>
<span class="kwd">Tactic</span> <span class="kwd">Notation</span> "<span class="id">near</span>" <span class="id">constr</span>(<span class="id">F</span>) "=&gt;" <span class="id">ident</span>(<span class="id">x</span>) <span class="id">ident</span>(<span class="id">y</span>) :=<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#have_near">have_near</a></span> <span class="id">F</span>); <span class="id">near</span>=&gt; <span class="id">x</span> <span class="id">y</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="kwd">Export</span> <span class="id"><a name="NearMap">NearMap</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="NearMap.near_simpl">near_simpl</a></span> := (@<span class="id"><a href="mathcomp.analysis.topology.html#near_simpl">near_simpl</a></span>, @<span class="id"><a href="mathcomp.analysis.topology.html#near_map">near_map</a></span>, @<span class="id"><a href="mathcomp.analysis.topology.html#near_mapi">near_mapi</a></span>, @<span class="id"><a href="mathcomp.analysis.topology.html#near_map2">near_map2</a></span>).<br/>
<span class="kwd">Ltac</span> <span class="id">near_simpl</span> := <span class="id">rewrite</span> ?<span class="id"><a href="mathcomp.analysis.topology.html#NearMap.near_simpl">near_simpl</a></span>.<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#NearMap">NearMap</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_pair">cvg_pair</a></span> {<span class="id"><a name="T:808">T</a></span> <span class="id"><a name="U:809">U</a></span> <span class="id"><a name="V:810">V</a></span> <span class="id"><a name="F:811">F</a></span>} {<span class="id"><a name="G:812">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)} {<span class="id"><a name="H:813">H</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>)}<br/>
&nbsp;&nbsp;{<span class="id"><a name="FF:814">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} {<span class="id"><a name="FG:815">FG</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">G</span>} {<span class="id"><a name="FH:816">FH</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">H</span>} (<span class="id"><a name="f:817">f</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id"><a name="g:818">g</a></span> : <span class="id">T</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">G</span> -&gt; <span class="id">g</span> @ <span class="id">F</span> --&gt; <span class="id">H</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">f</span> <span class="id">x</span>, <span class="id">g</span> <span class="id">x</span>) @[<span class="id"><a name="x:819">x</a></span> --&gt; <span class="id">F</span>] --&gt; (<span class="id">G</span>, <span class="id">H</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof105')">Proof.</span></div>
<div class="proofscript" id="proof105">
<span class="id">move</span>=&gt; <span class="id">fFG</span> <span class="id">gFH</span> <span class="id">P</span>; <span class="id">rewrite</span> !<span class="id"><a href="mathcomp.analysis.topology.html#near_simpl">near_simpl</a></span> =&gt; -[[<span class="id">A</span> <span class="id">B</span>] /=[<span class="id">GA</span> <span class="id">HB</span>] <span class="id">ABP</span>]; <span class="id">near</span>=&gt; <span class="id">x</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">ABP</span> (<span class="id">_</span>, <span class="id">_</span>)); <span class="id">split</span>=&gt; //=; <span class="id">near</span>: <span class="id">x</span>; [<span class="id">apply</span>: <span class="id">fFG</span>|<span class="id">apply</span>: <span class="id">gFH</span>].<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_comp2">cvg_comp2</a></span> {<span class="id"><a name="T:820">T</a></span> <span class="id"><a name="U:821">U</a></span> <span class="id"><a name="V:822">V</a></span> <span class="id"><a name="W:823">W</a></span>}<br/>
&nbsp;&nbsp;{<span class="id"><a name="F:824">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)} {<span class="id"><a name="G:825">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)} {<span class="id"><a name="H:826">H</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">V</span>)} {<span class="id"><a name="I:827">I</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">W</span>)}<br/>
&nbsp;&nbsp;{<span class="id"><a name="FF:828">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} {<span class="id"><a name="FG:829">FG</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">G</span>} {<span class="id"><a name="FH:830">FH</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">H</span>}<br/>
&nbsp;&nbsp;(<span class="id"><a name="f:831">f</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id"><a name="g:832">g</a></span> : <span class="id">T</span> -&gt; <span class="id">V</span>) (<span class="id"><a name="h:833">h</a></span> : <span class="id">U</span> -&gt; <span class="id">V</span> -&gt; <span class="id">W</span>) :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">G</span> -&gt; <span class="id">g</span> @ <span class="id">F</span> --&gt; <span class="id">H</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">h</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#fst">fst</a></span> <span class="id">x</span>) (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#snd">snd</a></span> <span class="id">x</span>) @[<span class="id"><a name="x:834">x</a></span> --&gt; (<span class="id">G</span>, <span class="id">H</span>)] --&gt; <span class="id">I</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">h</span> (<span class="id">f</span> <span class="id">x</span>) (<span class="id">g</span> <span class="id">x</span>) @[<span class="id"><a name="x:835">x</a></span> --&gt; <span class="id">F</span>] --&gt; <span class="id">I</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof106')">Proof.</span></div>
<div class="proofscript" id="proof106">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">fFG</span> <span class="id">gFH</span> <span class="id">hGHI</span> <span class="id">P</span> /= <span class="id">IP</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_pair">cvg_pair</a></span> (<span class="id">hGHI</span> <span class="id">_</span> <span class="id">IP</span>). Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvg_comp2">cvg_comp2</a></span> {<span class="id">T</span> <span class="id">U</span> <span class="id">V</span> <span class="id">W</span> <span class="id">F</span> <span class="id">G</span> <span class="id">H</span> <span class="id">I</span> <span class="id">FF</span> <span class="id">FG</span> <span class="id">FH</span> <span class="id">f</span> <span class="id">g</span> <span class="id">h</span>} <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="cvg_to_comp_2">cvg_to_comp_2</a></span> := @<span class="id"><a href="mathcomp.analysis.topology.html#cvg_comp2">cvg_comp2</a></span>.<br/>
<br/>
<br/>
<div class="doc">Restriction of a filter to a domain </div>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="within">within</a></span>.<br/>
<span class="kwd">Context</span> {<span class="id"><a name="T:836">T</a></span> : <span class="kwd">Type</span>}.<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> (<span class="id">D</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within.T">T</a></span>) (<span class="id">F</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within.T">T</a></span>)).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="within">within</a></span> <span class="id"><a name="D:837">D</a></span> <span class="id"><a name="F:838">F</a></span> (<span class="id"><a name="P:839">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within.T">T</a></span>) := {<span class="id">near</span> <span class="id">F</span>, <span class="id">D</span> `&lt;=` <span class="id">P</span>}.<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> : <span class="id">simpl</span> <span class="id">never</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_withinE">near_withinE</a></span> <span class="id"><a name="D:840">D</a></span> <span class="id"><a name="F:841">F</a></span> (<span class="id"><a name="P:842">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within.T">T</a></span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="x:843">x</a></span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id">D</span> <span class="id">F</span>, <span class="id">P</span> <span class="id">x</span>) = {<span class="id">near</span> <span class="id">F</span>, <span class="id">D</span> `&lt;=` <span class="id">P</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof107')">Proof.</span></div>
<div class="proofscript" id="proof107">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="withinT">withinT</a></span> <span class="id"><a name="F:844">F</a></span> <span class="id"><a name="D:845">D</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id">D</span> <span class="id">F</span> <span class="id">D</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof108')">Proof.</span></div>
<div class="proofscript" id="proof108">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterE">filterE</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_withinT">near_withinT</a></span> <span class="id"><a name="F:846">F</a></span> <span class="id"><a name="D:847">D</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; \<span class="kwd">forall</span> <span class="id"><a name="x:848">x</a></span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id">D</span> <span class="id">F</span>, <span class="id">D</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof109')">Proof.</span></div>
<div class="proofscript" id="proof109">
 <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#withinT">withinT</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_within">cvg_within</a></span> {<span class="id"><a name="F:849">F</a></span>} {<span class="id"><a name="FF:850">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} <span class="id"><a name="D:851">D</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id">D</span> <span class="id">F</span> --&gt; <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof110')">Proof.</span></div>
<div class="proofscript" id="proof110">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="withinET">withinET</a></span> {<span class="id"><a name="F:852">F</a></span>} {<span class="id"><a name="FF:853">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} : <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> <span class="id">F</span> = <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof111')">Proof.</span></div>
<div class="proofscript" id="proof111">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span> /<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span>; <span class="id">split</span> =&gt; ?; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app">filter_app</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nearW">nearW</a></span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">exact</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="within_filter">within_filter</a></span> <span class="id"><a name="T:854">T</a></span> <span class="id"><a name="D:855">D</a></span> <span class="id"><a name="F:856">F</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (@<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id">T</span> <span class="id">D</span> <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof112')">Proof.</span></div>
<div class="proofscript" id="proof112">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span>; <span class="id">constructor</span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterE">filterE</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS2">filterS2</a></span> =&gt; <span class="id">x</span> <span class="id">DP</span> <span class="id">DQ</span> <span class="id">Dx</span>; <span class="id">split</span>; [<span class="id">apply</span>: <span class="id">DP</span>|<span class="id">apply</span>: <span class="id">DQ</span>].<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> <span class="id">subPQ</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> =&gt; <span class="id">x</span> <span class="id">DP</span> /<span class="id">DP</span> /<span class="id">subPQ</span>.<br/>
Qed.</div>
<br/>
#[<span class="id">global</span>] <span class="id">Typeclasses</span> <span class="kwd">Opaque</span> <span class="id">within</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="within_filter_on">within_filter_on</a></span> <span class="id"><a name="T:857">T</a></span> <span class="id"><a name="D:858">D</a></span> (<span class="id"><a name="F:859">F</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filter_on">filter_on</a></span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id">D</span> <span class="id">F</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#within_filter">within_filter</a></span> <span class="id">_</span> <span class="id">_</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="subset_filter">subset_filter</a></span> {<span class="id"><a name="T:860">T</a></span>} (<span class="id"><a name="F:861">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="D:862">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id"><a name="P:864">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> {<span class="id"><a name="x:863">x</a></span> | <span class="id">D</span> <span class="id">x</span>} | <span class="id">F</span> [<span class="id">set</span> <span class="id"><a name="x:865">x</a></span> | <span class="kwd">forall</span> <span class="id"><a name="Dx:866">Dx</a></span> : <span class="id">D</span> <span class="id">x</span>, <span class="id">P</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#exist">exist</a></span> <span class="id">_</span> <span class="id">x</span> <span class="id">Dx</span>)]].<br/>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#subset_filter">subset_filter</a></span> {<span class="id">T</span>} <span class="id">F</span> <span class="id">D</span> <span class="id">_</span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="subset_filter_filter">subset_filter_filter</a></span> <span class="id"><a name="T:867">T</a></span> <span class="id"><a name="F:868">F</a></span> (<span class="id"><a name="D:869">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#subset_filter">subset_filter</a></span> <span class="id">F</span> <span class="id">D</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof113')">Proof.</span></div>
<div class="proofscript" id="proof113">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">constructor</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#subset_filter">subset_filter</a></span>/=.<br/>
- <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterE">filterE</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS2">filterS2</a></span>=&gt; <span class="id">x</span> <span class="id">PD</span> <span class="id">QD</span> <span class="id">Dx</span>; <span class="id">split</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> <span class="id">subPQ</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> =&gt; <span class="id">R</span> <span class="id">PD</span> <span class="id">Dx</span>; <span class="id">apply</span>: <span class="id">subPQ</span>.<br/>
Qed.</div>
#[<span class="id">global</span>] <span class="id">Typeclasses</span> <span class="kwd">Opaque</span> <span class="id">subset_filter</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="subset_filter_proper">subset_filter_proper</a></span> {<span class="id"><a name="T:870">T</a></span> <span class="id"><a name="F:871">F</a></span>} {<span class="id"><a name="FF:872">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} (<span class="id"><a name="D:873">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="P:874">P</a></span>, <span class="id">F</span> <span class="id">P</span> -&gt; ~ ~ <span class="kwd">exists</span> <span class="id"><a name="x:875">x</a></span>, <span class="id">D</span> <span class="id">x</span> /\ <span class="id">P</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#subset_filter">subset_filter</a></span> <span class="id">F</span> <span class="id">D</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof114')">Proof.</span></div>
<div class="proofscript" id="proof114">
<span class="id">move</span>=&gt; <span class="id">DAP</span>; <span class="id">apply</span>: <span class="id">Build_ProperFilter</span>'; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#subset_filter">subset_filter</a></span> =&gt; <span class="id">subFD</span>.<br/>
<span class="kwd">by</span> <span class="id">have</span> /(<span class="id">_</span> <span class="id">subFD</span>) := <span class="id">DAP</span> (~` <span class="id">D</span>); <span class="id">apply</span> =&gt; -[<span class="id">x</span> [<span class="id">dx</span> /(<span class="id">_</span> <span class="id">dx</span>)]].<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="NearSet">NearSet</a></span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id"><a name="T:876">T</a></span> : <span class="id">choiceType</span>} {<span class="id"><a name="Y:877">Y</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#filteredType">filteredType</a></span> <span class="id">T</span>}.<br/>
<span class="kwd">Context</span> (<span class="id"><a name="F:878">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.Y">Y</a></span>)) (<span class="id"><a name="PF:879">PF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="powerset_filter_from">powerset_filter_from</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.Y">Y</a></span>)) := <span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span><br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id"><a name="M:880">M</a></span> | [/\ <span class="id">M</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="E1:881">E1</a></span> <span class="id"><a name="E2:882">E2</a></span>, <span class="id">M</span> <span class="id">E1</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> <span class="id">E2</span> -&gt; <span class="id">E2</span> `&lt;=` <span class="id">E1</span> -&gt; <span class="id">M</span> <span class="id">E2</span>) &amp; <span class="id">M</span> !=<span class="id">set0</span> ] ]<br/>
&nbsp;&nbsp;<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">id</a></span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="powerset_filter_from_filter">powerset_filter_from_filter</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#powerset_filter_from">powerset_filter_from</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof115')">Proof.</span></div>
<div class="proofscript" id="proof115">
<span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">_</span> : <span class="id"><a href="mathcomp.classical.boolp.html#xpredp0">xpredp0</a></span> = <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">W</span> [<span class="id">_</span> <span class="id">_</span> [<span class="id">N</span> +]]]; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#subset0">subset0</a></span> =&gt; /[<span class="id">swap</span>] -&gt;; <span class="id">apply</span>.<br/>
<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_from_filter">filter_from_filter</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span>; <span class="id">split</span> =&gt; //; <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
<span class="id">move</span>=&gt; <span class="id">M</span> <span class="id">N</span> /= [<span class="id">entM</span> <span class="id">subM</span> [<span class="id">M0</span> <span class="id">MM0</span>]] [<span class="id">entN</span> <span class="id">subN</span> [<span class="id">N0</span> <span class="id">NN0</span>]].<br/>
<span class="kwd">exists</span> [<span class="id">set</span> <span class="id"><a name="E:883">E</a></span> | <span class="kwd">exists</span> <span class="id"><a name="P:884">P</a></span> <span class="id"><a name="Q:885">Q</a></span>, [/\ <span class="id">M</span> <span class="id">P</span>, <span class="id">N</span> <span class="id">Q</span> &amp; <span class="id">E</span> = <span class="id">P</span> `&amp;` <span class="id">Q</span>] ]; <span class="id">first</span> <span class="id">split</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ? [? [? [? ? -&gt;]]]; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span>; [<span class="id">exact</span>: <span class="id">entM</span> | <span class="id">exact</span>: <span class="id">entN</span>].<br/>
- <span class="id">move</span>=&gt; ? <span class="id">E2</span> [<span class="id">P</span> [<span class="id">Q</span> [<span class="id">MP</span> <span class="id">MQ</span> -&gt;]]] <span class="id">entE2</span> <span class="id">E2subPQ</span>; <span class="kwd">exists</span> <span class="id">E2</span>, <span class="id">E2</span>.<br/>
&nbsp;&nbsp;<span class="id">split</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setIid">setIid</a></span>.<br/>
&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">subM</span> <span class="id">_</span> <span class="id">_</span> <span class="id">MP</span>) =&gt; // ? /<span class="id">E2subPQ</span> [].<br/>
&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">subN</span> <span class="id">_</span> <span class="id">_</span> <span class="id">MQ</span>) =&gt; // ? /<span class="id">E2subPQ</span> [].<br/>
- <span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">M0</span> `&amp;` <span class="id">N0</span>), <span class="id">M0</span>, <span class="id">N0</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">E</span> /= [<span class="id">P</span> [<span class="id">Q</span> [<span class="id">MP</span> <span class="id">MQ</span> -&gt;]]]; <span class="id">have</span> <span class="id">entPQ</span> : <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> (<span class="id">P</span> `&amp;` <span class="id">Q</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span>; [<span class="id">exact</span>: <span class="id">entM</span> | <span class="id">exact</span>: <span class="id">entN</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span>; [<span class="id">apply</span>: (<span class="id">subM</span> <span class="id">_</span> <span class="id">_</span> <span class="id">MP</span>) | <span class="id">apply</span>: (<span class="id">subN</span> <span class="id">_</span> <span class="id">_</span> <span class="id">MQ</span>)] =&gt; // ? [].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_small_set">near_small_set</a></span> : \<span class="kwd">forall</span> <span class="id"><a name="E:889">E</a></span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#powerset_filter_from">powerset_filter_from</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> <span class="id">E</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof116')">Proof.</span></div>
<div class="proofscript" id="proof116">
 <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> =&gt; //; <span class="id">split</span> =&gt; //; <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="small_set_sub">small_set_sub</a></span> (<span class="id"><a name="E:890">E</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.Y">Y</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> <span class="id">E</span> -&gt;<br/>
&nbsp;&nbsp;\<span class="kwd">forall</span> <span class="id"><a name="E':891">E</a></span>' \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#powerset_filter_from">powerset_filter_from</a></span>, <span class="id">E</span>' `&lt;=` <span class="id">E</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof117')">Proof.</span></div>
<div class="proofscript" id="proof117">
<span class="id">move</span>=&gt; <span class="id">entE</span>; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id"><a name="E':892">E</a></span>' | <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> <span class="id">E</span>' /\ <span class="id">E</span>' `&lt;=` <span class="id">E</span>]; <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? [].<br/>
<span class="id">split</span>; [<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">E</span>' [] | | <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">E</span>; <span class="id">split</span>].<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">E1</span> <span class="id">E2</span> [] ? <span class="id">sub</span> ? ?; <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#subset_trans">subset_trans</a></span> <span class="id">sub</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_powerset_filter_fromP">near_powerset_filter_fromP</a></span> (<span class="id"><a name="P:894">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.Y">Y</a></span> -&gt; <span class="kwd">Prop</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="A:895">A</a></span> <span class="id"><a name="B:896">B</a></span>, <span class="id">A</span> `&lt;=` <span class="id">B</span> -&gt; <span class="id">P</span> <span class="id">B</span> -&gt; <span class="id">P</span> <span class="id">A</span>) -&gt;<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="U:897">U</a></span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#powerset_filter_from">powerset_filter_from</a></span>, <span class="id">P</span> <span class="id">U</span>) &lt;-&gt; <span class="kwd">exists2</span> <span class="id"><a name="U:898">U</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> <span class="id">U</span> &amp; <span class="id">P</span> <span class="id">U</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof118')">Proof.</span></div>
<div class="proofscript" id="proof118">
<span class="id">move</span>=&gt; <span class="id">Psub</span>; <span class="id">split</span>=&gt; [[<span class="id">M</span> [<span class="id">FM</span> ? [<span class="id">U</span> <span class="id">MU</span>]]] <span class="id">MsubP</span>|[<span class="id">U</span> <span class="id">FU</span> <span class="id">PU</span>]].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">U</span>; [<span class="id">exact</span>: <span class="id">FM</span> | <span class="id">exact</span>: <span class="id">MsubP</span>].<br/>
<span class="kwd">exists</span> [<span class="id">set</span> <span class="id"><a name="V:900">V</a></span> | <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> <span class="id">V</span> /\ <span class="id">V</span> `&lt;=` <span class="id">U</span>]; <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">V</span> [<span class="id">_</span>] /<span class="id">Psub</span>; <span class="id">exact</span>.<br/>
<span class="id">split</span>=&gt; [<span class="id">E</span> [] //| |]; <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">U</span>; <span class="id">split</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">E1</span> <span class="id">E2</span> [<span class="id">F1</span> <span class="id">E1U</span> <span class="id">F2</span> <span class="id">E2subE1</span>]; <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#subset_trans">subset_trans</a></span> <span class="id">E1U</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="powerset_filter_fromP">powerset_filter_fromP</a></span> <span class="id"><a name="C:902">C</a></span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> <span class="id">C</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#powerset_filter_from">powerset_filter_from</a></span> [<span class="id">set</span> <span class="id"><a name="W:903">W</a></span> | <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> <span class="id">W</span> /\ <span class="id">W</span> `&lt;=` <span class="id">C</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof119')">Proof.</span></div>
<div class="proofscript" id="proof119">
<span class="id">move</span>=&gt; <span class="id">FC</span>; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id"><a name="W:904">W</a></span> | <span class="id"><a href="mathcomp.analysis.topology.html#NearSet.F">F</a></span> <span class="id">W</span> /\ <span class="id">W</span> `&lt;=` <span class="id">C</span>] =&gt; //; <span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? [].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> [<span class="id">_</span> <span class="id">AC</span>] <span class="id">FB</span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#subset_trans">subset_trans</a></span>/(<span class="id">_</span> <span class="id">AC</span>).<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">C</span>; <span class="id">split</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#NearSet">NearSet</a></span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="PrincipalFilters">PrincipalFilters</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="principal_filter">principal_filter</a></span> {<span class="id"><a name="X:906">X</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="x:907">x</a></span> : <span class="id">X</span>) : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">X</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> [<span class="id">set</span> <span class="id">x</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="principal_filterP">principal_filterP</a></span> {<span class="id"><a name="X:908">X</a></span>} (<span class="id"><a name="x:909">x</a></span> : <span class="id">X</span>) (<span class="id"><a name="W:910">W</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">X</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#principal_filter">principal_filter</a></span> <span class="id">x</span> <span class="id">W</span> &lt;-&gt; <span class="id">W</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof120')">Proof.</span></div>
<div class="proofscript" id="proof120">
 <span class="kwd">by</span> <span class="id">split</span>=&gt; [|? ? -&gt;]; [<span class="id">exact</span>|]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="principal_filter_proper">principal_filter_proper</a></span> {<span class="id"><a name="X:911">X</a></span>} (<span class="id"><a name="x:912">x</a></span> : <span class="id">X</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#principal_filter">principal_filter</a></span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof121')">Proof.</span></div>
<div class="proofscript" id="proof121">
 <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#globally_properfilter">globally_properfilter</a></span>. Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="bool_discrete_filter">bool_discrete_filter</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#FilteredType">FilteredType</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#bool">bool</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#bool">bool</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#principal_filter">principal_filter</a></span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#PrincipalFilters">PrincipalFilters</a></span>.<br/>
<br/>
<h1> Topological spaces </h1>
<br/>
<span class="kwd">Module</span> <span class="id"><a name="Topological">Topological</a></span>.<br/>
<br/>
<span class="kwd">Record</span> <span class="id"><a name="Topological.mixin_of">mixin_of</a></span> (<span class="id"><a name="T:913">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="nbhs:914">nbhs</a></span> : <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) := <span class="id">Mixin</span> {<br/>
&nbsp;&nbsp;<span class="id"><a name="Topological.open">open</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) ;<br/>
&nbsp;&nbsp;<span class="id"><a name="Topological.nbhs_pfilter">nbhs_pfilter</a></span> : <span class="kwd">forall</span> <span class="id"><a name="p:917">p</a></span> : <span class="id">T</span>, <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id">nbhs</span> <span class="id">p</span>) ;<br/>
&nbsp;&nbsp;<span class="id"><a name="Topological.nbhsE">nbhsE</a></span> : <span class="kwd">forall</span> <span class="id"><a name="p:919">p</a></span> : <span class="id">T</span>, <span class="id">nbhs</span> <span class="id">p</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">set</span> <span class="id"><a name="A:920">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span> | <span class="kwd">exists</span> <span class="id"><a name="B:921">B</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>, [/\ <span class="id">open</span> <span class="id">B</span>, <span class="id">B</span> <span class="id">p</span> &amp; <span class="id">B</span> `&lt;=` <span class="id">A</span>] ] ;<br/>
&nbsp;&nbsp;<span class="id"><a name="Topological.openE">openE</a></span> : <span class="id">open</span> = [<span class="id">set</span> <span class="id"><a name="A:923">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span> | <span class="id">A</span> `&lt;=` <span class="id">nbhs</span>^~ <span class="id">A</span> ]<br/>
}.<br/>
<br/>
<span class="kwd">Record</span> <span class="id"><a name="Topological.class_of">class_of</a></span> (<span class="id"><a name="T:925">T</a></span> : <span class="kwd">Type</span>) := <span class="kwd">Class</span> {<br/>
&nbsp;&nbsp;<span class="id"><a name="Topological.base">base</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.class_of">Filtered.class_of</a></span> <span class="id">T</span> <span class="id">T</span>;<br/>
&nbsp;&nbsp;<span class="id"><a name="Topological.mixin">mixin</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological.mixin_of">mixin_of</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.nbhs_op">Filtered.nbhs_op</a></span> <span class="id">base</span>)<br/>
}.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Topological.ClassDef">ClassDef</a></span>.<br/>
<br/>
<span class="kwd">Structure</span> <span class="id"><a name="Topological.type">type</a></span> := <span class="id">Pack</span> { <span class="id"><a name="Topological.sort">sort</a></span>; <span class="id">_</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological.class_of">class_of</a></span> <span class="id">sort</span> }.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Variables</span> (<span class="id"><a name="Topological.ClassDef.T">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="Topological.ClassDef.cT">cT</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological.type">type</a></span>).<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Topological.class">class</a></span> := <span class="kwd">let</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Topological.Pack">Pack</a></span> <span class="id">_</span> <span class="id">c</span> := <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.cT">cT</a></span> <span class="kwd">return</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.class_of">class_of</a></span> <span class="id">cT</span> <span class="kwd">in</span> <span class="id">c</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Topological.clone">clone</a></span> <span class="id"><a name="c:934">c</a></span> <span class="id">of</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#phant_id">phant_id</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.class">class</a></span> <span class="id">c</span> := @<span class="id"><a href="mathcomp.analysis.topology.html#Topological.Pack">Pack</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.T">T</a></span> <span class="id">c</span>.<br/>
<span class="kwd">Let</span> <span class="id"><a name="Topological.ClassDef.xT">xT</a></span> := <span class="kwd">let</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Topological.Pack">Pack</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#T">T</a></span> <span class="id">_</span> := <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.cT">cT</a></span> <span class="kwd">in</span> <span class="id">T</span>.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="Topological.xclass">xclass</a></span> := (<span class="id"><a href="mathcomp.analysis.topology.html#Topological.class">class</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological.class_of">class_of</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.xT">xT</a></span>).<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Filtered.class_of</span>.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">mixin</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">mixin_of</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Topological.pack">pack</a></span> <span class="id"><a name="nbhs':936">nbhs</a></span>' (<span class="id"><a name="m:937">m</a></span> : @<span class="id"><a href="mathcomp.analysis.topology.html#Topological.mixin_of">mixin_of</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.T">T</a></span> <span class="id">nbhs</span>') :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id"><a name="bT:938">bT</a></span> (<span class="id"><a name="b:939">b</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filtered.class_of">Filtered.class_of</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.T">T</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.T">T</a></span>) <span class="id">of</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#phant_id">phant_id</a></span> (@<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.class">Filtered.class</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.T">T</a></span> <span class="id">bT</span>) <span class="id">b</span> =&gt;<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id"><a name="m':940">m</a></span>'   <span class="id">of</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#phant_id">phant_id</a></span> <span class="id">m</span> (<span class="id">m</span>' : @<span class="id"><a href="mathcomp.analysis.topology.html#Topological.mixin_of">mixin_of</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.T">T</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.nbhs_op">Filtered.nbhs_op</a></span> <span class="id">b</span>)) =&gt;<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#Topological.Pack">Pack</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.T">T</a></span> (@<span class="kwd">Class</span> <span class="id">_</span> <span class="id">b</span> <span class="id">m</span>').<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Topological.eqType">eqType</a></span> := @<span class="id">Equality.Pack</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.cT">cT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.xclass">xclass</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Topological.choiceType">choiceType</a></span> := @<span class="id">Choice.Pack</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.cT">cT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.xclass">xclass</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Topological.pointedType">pointedType</a></span> := @<span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Pack">Pointed.Pack</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.cT">cT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.xclass">xclass</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="Topological.filteredType">filteredType</a></span> := @<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Pack">Filtered.Pack</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.cT">cT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef.cT">cT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.xclass">xclass</a></span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.ClassDef">ClassDef</a></span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id"><a name="Topological.Exports">Exports</a></span>.<br/>
<br/>
<span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Filtered.class_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">mixin</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">mixin_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">eqType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Equality.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.eqType">eqType</a></span>.<br/>
<span class="kwd">Coercion</span> <span class="id">choiceType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Choice.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.choiceType">choiceType</a></span>.<br/>
<span class="kwd">Coercion</span> <span class="id">pointedType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Pointed.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.pointedType">pointedType</a></span>.<br/>
<span class="kwd">Coercion</span> <span class="id">filteredType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Filtered.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.filteredType">filteredType</a></span>.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="Topological.Exports.topologicalType">topologicalType</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#Topological.type">type</a></span>.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="Topological.Exports.TopologicalType">TopologicalType</a></span> <span class="id">T</span> <span class="id">m</span> := (@<span class="id"><a href="mathcomp.analysis.topology.html#Topological.pack">pack</a></span> <span class="id">T</span> <span class="id">_</span> <span class="id">m</span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#idfun">idfun</a></span> <span class="id">_</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#idfun">idfun</a></span>).<br/>
<span class="kwd">Notation</span> <span class="id"><a name="Topological.Exports.TopologicalMixin">TopologicalMixin</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#Topological.Mixin">Mixin</a></span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">topologicalType</span>' '<span class="id">of</span>' <span class="id">T</span> '<span class="kwd">for</span>' <span class="id">cT</span> ]" :=  (@<span class="id"><a href="mathcomp.analysis.topology.html#Topological.clone">clone</a></span> <span class="id">T</span> <span class="id">cT</span> <span class="id">_</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#idfun">idfun</a></span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">topologicalType</span>'  '<span class="id">of</span>'  <span class="id">T</span>  '<span class="kwd">for</span>'  <span class="id">cT</span> ]") : <span class="id">form_scope</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">topologicalType</span>' '<span class="id">of</span>' <span class="id">T</span> ]" := (@<span class="id"><a href="mathcomp.analysis.topology.html#Topological.clone">clone</a></span> <span class="id">T</span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">id</a></span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">topologicalType</span>'  '<span class="id">of</span>'  <span class="id">T</span> ]") : <span class="id">form_scope</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.Exports">Exports</a></span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological">Topological</a></span>.<br/>
<br/>
<span class="kwd">Export</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological.Exports">Topological.Exports</a></span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Topological1">Topological1</a></span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id"><a name="T:941">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="open">open</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#open">Topological.open</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#class">Topological.class</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="open_nbhs">open_nbhs</a></span> (<span class="id"><a name="p:942">p</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) (<span class="id"><a name="A:943">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) := <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">A</span> /\ <span class="id">A</span> <span class="id">p</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="basis">basis</a></span> (<span class="id"><a name="B:944">B</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>)) :=<br/>
&nbsp;&nbsp;<span class="id">B</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> /\ <span class="kwd">forall</span> <span class="id"><a name="x:945">x</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> [<span class="id">set</span> <span class="id"><a name="U:946">U</a></span> | <span class="id">B</span> <span class="id">U</span> /\ <span class="id">U</span> <span class="id">x</span>] <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">id</a></span> --&gt; <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="second_countable">second_countable</a></span> := <span class="kwd">exists2</span> <span class="id"><a name="B:947">B</a></span>, <span class="id"><a href="mathcomp.classical.cardinality.html#countable">countable</a></span> <span class="id">B</span> &amp; <span class="id"><a href="mathcomp.analysis.topology.html#basis">basis</a></span> <span class="id">B</span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="nbhs_pfilter">nbhs_pfilter</a></span> (<span class="id"><a name="p:949">p</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof122')">Proof.</span></div>
<div class="proofscript" id="proof122">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_pfilter">Topological.nbhs_pfilter</a></span>; <span class="id">case</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span> <span class="id">p</span> =&gt; ? []. Qed.</div>
<span class="id">Typeclasses</span> <span class="kwd">Opaque</span> <span class="id">nbhs</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhs_filter">nbhs_filter</a></span> (<span class="id"><a name="p:950">p</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof123')">Proof.</span></div>
<div class="proofscript" id="proof123">
 <span class="id">exact</span>: (@<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_pfilter">nbhs_pfilter</a></span>). Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="nbhs_filter_on">nbhs_filter_on</a></span> (<span class="id"><a name="x:951">x</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) := <span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>) (@<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_filter">nbhs_filter</a></span> <span class="id">x</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhsE">nbhsE</a></span> (<span class="id"><a name="p:952">p</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span> = [<span class="id">set</span> <span class="id"><a name="A:953">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span> | <span class="kwd">exists2</span> <span class="id"><a name="B:954">B</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">p</span> <span class="id">B</span> &amp; <span class="id">B</span> `&lt;=` <span class="id">A</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof124')">Proof.</span></div>
<div class="proofscript" id="proof124">
<span class="id">have</span> -&gt; : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span> = [<span class="id">set</span> <span class="id"><a name="A:956">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span> | <span class="kwd">exists</span> <span class="id"><a name="B:957">B</a></span>, [/\ <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">B</span>, <span class="id">B</span> <span class="id">p</span> &amp; <span class="id">B</span> `&lt;=` <span class="id">A</span>] ].<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">Topological.nbhsE</a></span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">A</span>; <span class="id">split</span>=&gt; [[<span class="id">B</span> [?]]|[<span class="id">B</span>[]]]; <span class="kwd">exists</span> <span class="id">B</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="open_nbhsE">open_nbhsE</a></span> (<span class="id"><a name="p:958">p</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) (<span class="id"><a name="A:959">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">p</span> <span class="id">A</span> = (<span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">A</span> /\ <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span> <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof125')">Proof.</span></div>
<div class="proofscript" id="proof125">
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">propeqE</a></span>; <span class="id">split</span>=&gt; [[? ?]|[? [<span class="id">B</span> [? ?] <span class="id">BA</span>]]]; <span class="id">split</span> =&gt; //;<br/>
&nbsp;&nbsp;[<span class="kwd">exists</span> <span class="id">A</span> | <span class="id">exact</span>: <span class="id">BA</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="interior">interior</a></span> (<span class="id"><a name="A:960">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) := (@<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>)^~ <span class="id">A</span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "<span class="id">A</span> ^°" := (<span class="id"><a href="mathcomp.analysis.topology.html#interior">interior</a></span> <span class="id">A</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="interior_subset">interior_subset</a></span> (<span class="id"><a name="A:961">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id">A</span>^° `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof126')">Proof.</span></div>
<div class="proofscript" id="proof126">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#interior">interior</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; -[? [? ?]]; <span class="id">apply</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="openE">openE</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> = [<span class="id">set</span> <span class="id"><a name="A:962">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span> | <span class="id">A</span> `&lt;=` <span class="id">A</span>^°].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof127')">Proof.</span></div>
<div class="proofscript" id="proof127">
 <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#openE">Topological.openE</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhs_singleton">nbhs_singleton</a></span> (<span class="id"><a name="p:963">p</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) (<span class="id"><a name="A:964">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id">A</span> <span class="id">p</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof128')">Proof.</span></div>
<div class="proofscript" id="proof128">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; - [? [<span class="id">_</span> ?]]; <span class="id">apply</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhs_interior">nbhs_interior</a></span> (<span class="id"><a name="p:965">p</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) (<span class="id"><a name="A:966">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span> <span class="id">A</span>^°.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof129')">Proof.</span></div>
<div class="proofscript" id="proof129">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> /<span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; - [<span class="id">B</span> [<span class="id">Bop</span> <span class="id">Bp</span>] <span class="id">sBA</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">B</span> =&gt; // <span class="id">q</span> <span class="id">Bq</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">sBA</span> <span class="id">_</span>; <span class="id">apply</span>: <span class="id">Bop</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="open0">open0</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof130')">Proof.</span></div>
<div class="proofscript" id="proof130">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="openT">openT</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof131')">Proof.</span></div>
<div class="proofscript" id="proof131">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; ??; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="openI">openI</a></span> (<span class="id"><a name="A:967">A</a></span> <span class="id"><a name="B:968">B</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">B</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> (<span class="id">A</span> `&amp;` <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof132')">Proof.</span></div>
<div class="proofscript" id="proof132">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; <span class="id">Aop</span> <span class="id">Bop</span> <span class="id">p</span> [<span class="id">Ap</span> <span class="id">Bp</span>].<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span>; [<span class="id">apply</span>: <span class="id">Aop</span>|<span class="id">apply</span>: <span class="id">Bop</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="bigcup_open">bigcup_open</a></span> (<span class="id"><a name="I:969">I</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="D:970">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id"><a name="f:971">f</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="i:972">i</a></span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> (<span class="id">f</span> <span class="id">i</span>)) -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> (\<span class="id">bigcup_</span>(<span class="id"><a name="i:973">i</a></span> <span class="kwd">in</span> <span class="id">D</span>) <span class="id">f</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof133')">Proof.</span></div>
<div class="proofscript" id="proof133">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; <span class="id">fop</span> <span class="id">p</span> [<span class="id">i</span> <span class="id">Di</span>].<br/>
<span class="kwd">by</span> <span class="id">have</span> /<span class="id">fop</span> <span class="id">fiop</span> := <span class="id">Di</span>; <span class="id">move</span>/<span class="id">fiop</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> =&gt; ??; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="openU">openU</a></span> (<span class="id"><a name="A:974">A</a></span> <span class="id"><a name="B:975">B</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">B</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> (<span class="id">A</span> `|` <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof134')">Proof.</span></div>
<div class="proofscript" id="proof134">
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; <span class="id">Aop</span> <span class="id">Bop</span> <span class="id">p</span> [/<span class="id">Aop</span>|/<span class="id">Bop</span>]; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> =&gt; ??; [<span class="id">left</span>|<span class="id">right</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="open_subsetE">open_subsetE</a></span> (<span class="id"><a name="A:976">A</a></span> <span class="id"><a name="B:977">B</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">A</span> -&gt; (<span class="id">A</span> `&lt;=` <span class="id">B</span>) = (<span class="id">A</span> `&lt;=` <span class="id">B</span>^°).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof135')">Proof.</span></div>
<div class="proofscript" id="proof135">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; <span class="id">Aop</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">propeqE</a></span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">sAB</span> <span class="id">p</span> <span class="id">Ap</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">sAB</span> <span class="id">_</span>; <span class="id">apply</span>: <span class="id">Aop</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">sAB</span> <span class="id">p</span> /<span class="id">sAB</span> /<span class="id"><a href="mathcomp.analysis.topology.html#interior_subset">interior_subset</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="open_interior">open_interior</a></span> (<span class="id"><a name="A:978">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">A</span>^°.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof136')">Proof.</span></div>
<div class="proofscript" id="proof136">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; <span class="id">p</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#interior">interior</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; - [<span class="id">B</span> [<span class="id">Bop</span> <span class="id">Bp</span>]].<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#open_subsetE">open_subsetE</a></span> //; <span class="kwd">exists</span> <span class="id">B</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="interior_bigcup">interior_bigcup</a></span> <span class="id"><a name="I:979">I</a></span> (<span class="id"><a name="D:980">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id"><a name="f:981">f</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) :<br/>
&nbsp;&nbsp;\<span class="id">bigcup_</span>(<span class="id"><a name="i:982">i</a></span> <span class="kwd">in</span> <span class="id">D</span>) (<span class="id">f</span> <span class="id">i</span>)^° `&lt;=` (\<span class="id">bigcup_</span>(<span class="id"><a name="i:983">i</a></span> <span class="kwd">in</span> <span class="id">D</span>) <span class="id">f</span> <span class="id">i</span>)^°.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof137')">Proof.</span></div>
<div class="proofscript" id="proof137">
<span class="id">move</span>=&gt; <span class="id">p</span> [<span class="id">i</span> <span class="id">Di</span>]; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#interior">interior</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; - [<span class="id">B</span> [<span class="id">Bop</span> <span class="id">Bp</span>] <span class="id">sBfi</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">B</span> =&gt; // ? /<span class="id">sBfi</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="open_nbhsT">open_nbhsT</a></span> (<span class="id"><a name="p:984">p</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">p</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof138')">Proof.</span></div>
<div class="proofscript" id="proof138">
 <span class="kwd">by</span> <span class="id">split</span>=&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#openT">openT</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="open_nbhsI">open_nbhsI</a></span> (<span class="id"><a name="p:985">p</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) (<span class="id"><a name="A:986">A</a></span> <span class="id"><a name="B:987">B</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">p</span> <span class="id">B</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">p</span> (<span class="id">A</span> `&amp;` <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof139')">Proof.</span></div>
<div class="proofscript" id="proof139">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">Aop</span> <span class="id">Ap</span>] [<span class="id">Bop</span> <span class="id">Bp</span>]; <span class="id">split</span>; [<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#openI">openI</a></span>|<span class="id">split</span>]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="open_nbhs_nbhs">open_nbhs_nbhs</a></span> (<span class="id"><a name="p:988">p</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) (<span class="id"><a name="A:989">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof140')">Proof.</span></div>
<div class="proofscript" id="proof140">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; <span class="id">p_A</span>; <span class="kwd">exists</span> <span class="id">A</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="interiorI">interiorI</a></span> (<span class="id"><a name="A:990">A</a></span> <span class="id"><a name="B:991">B</a></span>:<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1.T">T</a></span>): (<span class="id">A</span> `&amp;` <span class="id">B</span>)^° = <span class="id">A</span>^° `&amp;` <span class="id">B</span>^°.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof141')">Proof.</span></div>
<div class="proofscript" id="proof141">
<span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#interior">interior</a></span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; //= <span class="id">x</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span>; <span class="id">split</span> =&gt; [[<span class="id">B0</span> ?] | []].<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#subsetI">subsetI</a></span> =&gt; // -[? ?]; <span class="id">split</span>; <span class="kwd">exists</span> <span class="id">B0</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; -[<span class="id">B0</span> ? ?] [<span class="id">B1</span> ? ?]; <span class="kwd">exists</span> (<span class="id">B0</span> `&amp;` <span class="id">B1</span>);<br/>
&nbsp;&nbsp;[<span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhsI">open_nbhsI</a></span> | <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#subsetI">subsetI</a></span>; <span class="id">split</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#subIset">subIset</a></span>; [<span class="id">left</span>|<span class="id">right</span>]].<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Topological1">Topological1</a></span>.<br/>
<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Extern</span> 0 (<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">_</span>)) =&gt;<br/>
&nbsp;&nbsp;<span class="id">solve</span> [<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_filter">nbhs_filter</a></span>] : <span class="id">typeclass_instances</span>.<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Extern</span> 0 (<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">_</span>)) =&gt;<br/>
&nbsp;&nbsp;<span class="id">solve</span> [<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_pfilter">nbhs_pfilter</a></span>] : <span class="id">typeclass_instances</span>.<br/>
<br/>
<span class="kwd">Notation</span> "<span class="id">A</span> ^°" := (<span class="id"><a href="mathcomp.analysis.topology.html#interior">interior</a></span> <span class="id">A</span>) : <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Notation</span> <span class="id"><a name="continuous">continuous</a></span> <span class="id">f</span> := (<span class="kwd">forall</span> <span class="id"><a name="x:992">x</a></span>, <span class="id">f</span>%<span class="id">function</span> @ <span class="id">x</span> --&gt; <span class="id">f</span>%<span class="id">function</span> <span class="id">x</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_fun">near_fun</a></span> (<span class="id"><a name="T:993">T</a></span> <span class="id"><a name="T':994">T</a></span>' : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>) (<span class="id"><a name="f:995">f</a></span> : <span class="id">T</span> -&gt; <span class="id">T</span>') (<span class="id"><a name="x:996">x</a></span> : <span class="id">T</span>) (<span class="id"><a name="P:997">P</a></span> : <span class="id">T</span>' -&gt; <span class="kwd">Prop</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="kwd">for</span> <span class="id">x</span>, <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">f</span>} -&gt;<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="y:998">y</a></span> \<span class="id">near</span> <span class="id">f</span> <span class="id">x</span>, <span class="id">P</span> <span class="id">y</span>) -&gt; (\<span class="id">near</span> <span class="id"><a name="x:999">x</a></span>, <span class="id">P</span> (<span class="id">f</span> <span class="id">x</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof142')">Proof.</span></div>
<div class="proofscript" id="proof142">
 <span class="id">exact</span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#near_fun">near_fun</a></span> {<span class="id">T</span> <span class="id">T</span>'} <span class="id">f</span> <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="continuousP">continuousP</a></span> (<span class="id"><a name="S:1002">S</a></span> <span class="id"><a name="T:1003">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>) (<span class="id"><a name="f:1004">f</a></span> : <span class="id">S</span> -&gt; <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">f</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id"><a name="A:1005">A</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> (<span class="id">f</span> @^-1` <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof143')">Proof.</span></div>
<div class="proofscript" id="proof143">
<span class="id">split</span>=&gt; <span class="id">fcont</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> !<span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; <span class="id">A</span> <span class="id">Aop</span> ? /<span class="id">Aop</span> /<span class="id">fcont</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">s</span> <span class="id">A</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_simpl">nbhs_simpl</a></span> /= !<span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; - [<span class="id">B</span> [<span class="id">Bop</span> <span class="id">Bfs</span>] <span class="id">sBA</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">f</span> @^-1` <span class="id">B</span>); [<span class="id">split</span>=&gt; //; <span class="id">apply</span>/<span class="id">fcont</span>|<span class="id">move</span>=&gt; ? /<span class="id">sBA</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="continuous_comp">continuous_comp</a></span> (<span class="id"><a name="R:1006">R</a></span> <span class="id"><a name="S:1007">S</a></span> <span class="id"><a name="T:1008">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>) (<span class="id"><a name="f:1009">f</a></span> : <span class="id">R</span> -&gt; <span class="id">S</span>) (<span class="id"><a name="g:1010">g</a></span> : <span class="id">S</span> -&gt; <span class="id">T</span>) <span class="id"><a name="x:1011">x</a></span> :<br/>
&nbsp;&nbsp;{<span class="kwd">for</span> <span class="id">x</span>, <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">f</span>} -&gt; {<span class="kwd">for</span> (<span class="id">f</span> <span class="id">x</span>), <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">g</span>} -&gt;<br/>
&nbsp;&nbsp;{<span class="kwd">for</span> <span class="id">x</span>, <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> (<span class="id">g</span> \<span class="id">o</span> <span class="id">f</span>)}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof144')">Proof.</span></div>
<div class="proofscript" id="proof144">
 <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_comp">cvg_comp</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="open_comp">open_comp</a></span>  {<span class="id"><a name="T:1012">T</a></span> <span class="id"><a name="U:1013">U</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id"><a name="f:1014">f</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id"><a name="D:1015">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> <span class="id">f</span> @^-1` <span class="id">D</span>, <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">f</span>} -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">D</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> (<span class="id">f</span> @^-1` <span class="id">D</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof145')">Proof.</span></div>
<div class="proofscript" id="proof145">
<span class="id">rewrite</span> !<span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; <span class="id">fcont</span> <span class="id">Dop</span> <span class="id">x</span> /= <span class="id">Dfx</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">fcont</span>; [<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span>|<span class="id">apply</span>: <span class="id">Dop</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_fmap">cvg_fmap</a></span> {<span class="id"><a name="T:1016">T</a></span>: <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} {<span class="id"><a name="U:1017">U</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>}<br/>
&nbsp;&nbsp;(<span class="id"><a name="F:1018">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) <span class="id"><a name="x:1019">x</a></span> (<span class="id"><a name="f:1020">f</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;&nbsp;{<span class="kwd">for</span> <span class="id">x</span>, <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">f</span>} -&gt; <span class="id">F</span> --&gt; <span class="id">x</span> -&gt; <span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">f</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof146')">Proof.</span></div>
<div class="proofscript" id="proof146">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">cf</span> <span class="id">fx</span> <span class="id">P</span> /<span class="id">cf</span> /<span class="id">fx</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_join">near_join</a></span> (<span class="id"><a name="T:1021">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>) (<span class="id"><a name="x:1022">x</a></span> : <span class="id">T</span>) (<span class="id"><a name="P:1023">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(\<span class="id">near</span> <span class="id"><a name="x:1024">x</a></span>, <span class="id">P</span> <span class="id">x</span>) -&gt; \<span class="id">near</span> <span class="id"><a name="x:1027">x</a></span>, \<span class="id">near</span> <span class="id"><a name="x:1030">x</a></span>, <span class="id">P</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof147')">Proof.</span></div>
<div class="proofscript" id="proof147">
 <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_interior">nbhs_interior</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_bind">near_bind</a></span> (<span class="id"><a name="T:1033">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>) (<span class="id"><a name="P:1034">P</a></span> <span class="id"><a name="Q:1035">Q</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) (<span class="id"><a name="x:1036">x</a></span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(\<span class="id">near</span> <span class="id"><a name="x:1037">x</a></span>, (\<span class="id">near</span> <span class="id"><a name="x:1040">x</a></span>, <span class="id">P</span> <span class="id">x</span>) -&gt; <span class="id">Q</span> <span class="id">x</span>) -&gt; (\<span class="id">near</span> <span class="id"><a name="x:1043">x</a></span>, <span class="id">P</span> <span class="id">x</span>) -&gt; \<span class="id">near</span> <span class="id"><a name="x:1046">x</a></span>, <span class="id">Q</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof148')">Proof.</span></div>
<div class="proofscript" id="proof148">
<span class="id">move</span>=&gt; <span class="id">PQ</span> <span class="id">xP</span>; <span class="id">near</span>=&gt; <span class="id">y</span>; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#near">near</a></span> <span class="id">PQ</span> <span class="id">y</span>) =&gt; //;<br/>
<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#near">near</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#near_join">near_join</a></span> <span class="id">xP</span>) <span class="id">y</span>).<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="continuous_cvg">continuous_cvg</a></span> {<span class="id"><a name="T:1049">T</a></span> : <span class="kwd">Type</span>} {<span class="id"><a name="V:1050">V</a></span> <span class="id"><a name="U:1051">U</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>}<br/>
&nbsp;&nbsp;(<span class="id"><a name="F:1052">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="FF:1053">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>)<br/>
&nbsp;&nbsp;(<span class="id"><a name="f:1054">f</a></span> : <span class="id">T</span> -&gt; <span class="id">V</span>) (<span class="id"><a name="h:1055">h</a></span> : <span class="id">V</span> -&gt; <span class="id">U</span>) (<span class="id"><a name="a:1056">a</a></span> : <span class="id">V</span>) :<br/>
&nbsp;&nbsp;{<span class="kwd">for</span> <span class="id">a</span>, <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">h</span>} -&gt;<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">a</span> -&gt; (<span class="id">h</span> \<span class="id">o</span> <span class="id">f</span>) @ <span class="id">F</span> --&gt; <span class="id">h</span> <span class="id">a</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof149')">Proof.</span></div>
<div class="proofscript" id="proof149">
<span class="id">move</span>=&gt; <span class="id">h_continuous</span> <span class="id">fa</span> <span class="id">fb</span>; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#cvg_trans">cvg_trans</a></span> <span class="id">_</span> <span class="id">h_continuous</span>).<br/>
<span class="id">exact</span>: (@<span class="id"><a href="mathcomp.analysis.topology.html#cvg_comp">cvg_comp</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">h</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">fa</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="continuous_is_cvg">continuous_is_cvg</a></span> {<span class="id"><a name="T:1057">T</a></span> : <span class="kwd">Type</span>} {<span class="id"><a name="V:1058">V</a></span> <span class="id"><a name="U:1059">U</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} [<span class="id"><a name="F:1060">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)]<br/>
&nbsp;&nbsp;(<span class="id"><a name="FF:1061">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>) (<span class="id"><a name="f:1062">f</a></span> : <span class="id">T</span> -&gt; <span class="id">V</span>) (<span class="id"><a name="h:1063">h</a></span> : <span class="id">V</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="l:1064">l</a></span>, <span class="id">f</span> <span class="id">x</span> @[<span class="id"><a name="x:1065">x</a></span> --&gt; <span class="id">F</span>] --&gt; <span class="id">l</span> -&gt; {<span class="kwd">for</span> <span class="id">l</span>, <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">h</span>}) -&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#cvg">cvg</a></span> (<span class="id">f</span> <span class="id">x</span> @[<span class="id"><a name="x:1066">x</a></span> --&gt; <span class="id">F</span>]) -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#cvg">cvg</a></span> ((<span class="id">h</span> \<span class="id">o</span> <span class="id">f</span>) <span class="id">x</span> @[<span class="id"><a name="x:1069">x</a></span> --&gt; <span class="id">F</span>]).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof150')">Proof.</span></div>
<div class="proofscript" id="proof150">
<span class="id">move</span>=&gt; <span class="id">ach</span> /<span class="id"><a href="mathcomp.analysis.topology.html#cvg_ex">cvg_ex</a></span>[<span class="id">l</span> <span class="id">fxl</span>]; <span class="id">apply</span>/<span class="id"><a href="mathcomp.analysis.topology.html#cvg_ex">cvg_ex</a></span>; <span class="kwd">exists</span> (<span class="id">h</span> <span class="id">l</span>).<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#continuous_cvg">continuous_cvg</a></span> =&gt; //; <span class="id">exact</span>: <span class="id">ach</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="continuous2_cvg">continuous2_cvg</a></span> {<span class="id"><a name="T:1072">T</a></span> : <span class="kwd">Type</span>} {<span class="id"><a name="V:1073">V</a></span> <span class="id"><a name="W:1074">W</a></span> <span class="id"><a name="U:1075">U</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>}<br/>
&nbsp;&nbsp;(<span class="id"><a name="F:1076">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="FF:1077">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>)<br/>
&nbsp;&nbsp;(<span class="id"><a name="f:1078">f</a></span> : <span class="id">T</span> -&gt; <span class="id">V</span>) (<span class="id"><a name="g:1079">g</a></span> : <span class="id">T</span> -&gt; <span class="id">W</span>) (<span class="id"><a name="h:1080">h</a></span> : <span class="id">V</span> -&gt; <span class="id">W</span> -&gt; <span class="id">U</span>) (<span class="id"><a name="a:1081">a</a></span> : <span class="id">V</span>) (<span class="id"><a name="b:1082">b</a></span> : <span class="id">W</span>) :<br/>
&nbsp;&nbsp;<span class="id">h</span> <span class="id">z</span>.1 <span class="id">z</span>.2 @[<span class="id"><a name="z:1083">z</a></span> --&gt; (<span class="id">a</span>, <span class="id">b</span>)] --&gt; <span class="id">h</span> <span class="id">a</span> <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">a</span> -&gt; <span class="id">g</span> @ <span class="id">F</span> --&gt; <span class="id">b</span> -&gt; (<span class="kwd">fun</span> <span class="id"><a name="x:1084">x</a></span> =&gt; <span class="id">h</span> (<span class="id">f</span> <span class="id">x</span>) (<span class="id">g</span> <span class="id">x</span>)) @ <span class="id">F</span> --&gt; <span class="id">h</span> <span class="id">a</span> <span class="id">b</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof151')">Proof.</span></div>
<div class="proofscript" id="proof151">
<span class="id">move</span>=&gt; <span class="id">h_continuous</span> <span class="id">fa</span> <span class="id">fb</span>; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#cvg_trans">cvg_trans</a></span> <span class="id">_</span> <span class="id">h_continuous</span>).<br/>
<span class="id">exact</span>: (@<span class="id"><a href="mathcomp.analysis.topology.html#cvg_comp">cvg_comp</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="kwd">fun</span> <span class="id"><a name="x:1085">x</a></span> =&gt; <span class="id">h</span> <span class="id">x</span>.1 <span class="id">x</span>.2) <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.topology.html#cvg_pair">cvg_pair</a></span> <span class="id">fa</span> <span class="id">fb</span>)).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_near_cst">cvg_near_cst</a></span> (<span class="id"><a name="T:1087">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="U:1088">U</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>)<br/>
&nbsp;&nbsp;(<span class="id"><a name="l:1089">l</a></span> : <span class="id">U</span>) (<span class="id"><a name="f:1090">f</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id"><a name="F:1091">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) {<span class="id"><a name="FF:1092">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="x:1093">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">f</span> <span class="id">x</span> = <span class="id">l</span>) -&gt; <span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">l</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof152')">Proof.</span></div>
<div class="proofscript" id="proof152">
<span class="id">move</span>=&gt; <span class="id">fFl</span> <span class="id">P</span> /=; <span class="id">rewrite</span> !<span class="id"><a href="mathcomp.analysis.topology.html#near_simpl">near_simpl</a></span> =&gt; <span class="id">Pl</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">fFl</span> =&gt; <span class="id">_</span> -&gt;; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_singleton">nbhs_singleton</a></span>.<br/>
Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvg_near_cst">cvg_near_cst</a></span> {<span class="id">T</span> <span class="id">U</span>} <span class="id">l</span> {<span class="id">f</span> <span class="id">F</span> <span class="id">FF</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="is_cvg_near_cst">is_cvg_near_cst</a></span> (<span class="id"><a name="T:1094">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="U:1095">U</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>)<br/>
&nbsp;&nbsp;(<span class="id"><a name="l:1096">l</a></span> : <span class="id">U</span>) (<span class="id"><a name="f:1097">f</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id"><a name="F:1098">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) {<span class="id"><a name="FF:1099">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="x:1100">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">f</span> <span class="id">x</span> = <span class="id">l</span>) -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#cvg">cvg</a></span> (<span class="id">f</span> @ <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof153')">Proof.</span></div>
<div class="proofscript" id="proof153">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.analysis.topology.html#cvg_near_cst">cvg_near_cst</a></span>/<span class="id"><a href="mathcomp.analysis.topology.html#cvgP">cvgP</a></span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#is_cvg_near_cst">is_cvg_near_cst</a></span> {<span class="id">T</span> <span class="id">U</span>} <span class="id">l</span> {<span class="id">f</span> <span class="id">F</span> <span class="id">FF</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_cst_continuous">near_cst_continuous</a></span> (<span class="id"><a name="T:1101">T</a></span> <span class="id"><a name="U:1102">U</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>)<br/>
&nbsp;&nbsp;(<span class="id"><a name="l:1103">l</a></span> : <span class="id">U</span>) (<span class="id"><a name="f:1104">f</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id"><a name="x:1105">x</a></span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="y:1106">y</a></span> \<span class="id">near</span> <span class="id">x</span>, <span class="id">f</span> <span class="id">y</span> = <span class="id">l</span>) -&gt; {<span class="kwd">for</span> <span class="id">x</span>, <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof154')">Proof.</span></div>
<div class="proofscript" id="proof154">
<span class="id">move</span>=&gt; <span class="id">eq_f_l</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_near_cst">cvg_near_cst</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> (<span class="id">eq_f_l</span>) =&gt; <span class="id">y</span> -&gt;.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_singleton">nbhs_singleton</a></span> <span class="id">eq_f_l</span>).<br/>
Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#near_cst_continuous">near_cst_continuous</a></span> {<span class="id">T</span> <span class="id">U</span>} <span class="id">l</span> [<span class="id">f</span> <span class="id">x</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_cst">cvg_cst</a></span> (<span class="id"><a name="U:1107">U</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>) (<span class="id"><a name="x:1108">x</a></span> : <span class="id">U</span>) (<span class="id"><a name="T:1109">T</a></span> : <span class="kwd">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a name="F:1110">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) {<span class="id"><a name="FF:1111">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} :<br/>
&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">_</span> : <span class="id">T</span> =&gt; <span class="id">x</span>) @ <span class="id">F</span> --&gt; <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof155')">Proof.</span></div>
<div class="proofscript" id="proof155">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_near_cst">cvg_near_cst</a></span>; <span class="id">near</span>=&gt; <span class="id">x0</span>. <span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvg_cst">cvg_cst</a></span> {<span class="id">U</span>} <span class="id">x</span> {<span class="id">T</span> <span class="id">F</span> <span class="id">FF</span>}.<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">cvg_cst</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="is_cvg_cst">is_cvg_cst</a></span> (<span class="id"><a name="U:1112">U</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>) (<span class="id"><a name="x:1113">x</a></span> : <span class="id">U</span>) (<span class="id"><a name="T:1114">T</a></span> : <span class="kwd">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id"><a name="F:1115">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) {<span class="id"><a name="FF:1116">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#cvg">cvg</a></span> ((<span class="kwd">fun</span> <span class="id">_</span> : <span class="id">T</span> =&gt; <span class="id">x</span>) @ <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof156')">Proof.</span></div>
<div class="proofscript" id="proof156">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvgP">cvgP</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_cst">cvg_cst</a></span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id"><a href="mathcomp.analysis.topology.html#is_cvg_cst">is_cvg_cst</a></span> {<span class="id">U</span>} <span class="id">x</span> {<span class="id">T</span> <span class="id">F</span> <span class="id">FF</span>}.<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">is_cvg_cst</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cst_continuous">cst_continuous</a></span> {<span class="id"><a name="T:1117">T</a></span> <span class="id"><a name="U:1118">U</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id"><a name="x:1119">x</a></span> : <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> (<span class="kwd">fun</span> <span class="id">_</span> : <span class="id">T</span> =&gt; <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof157')">Proof.</span></div>
<div class="proofscript" id="proof157">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">t</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_cst">cvg_cst</a></span>. Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="within_topologicalType">within_topologicalType</a></span>.<br/>
<span class="kwd">Context</span> {<span class="id"><a name="T:1120">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id"><a name="A:1121">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>).<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> <span class="id">B</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.T">T</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="within_nbhsW">within_nbhsW</a></span> (<span class="id"><a name="x:1122">x</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> <span class="id">x</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>) `=&gt;` <span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof158')">Proof.</span></div>
<div class="proofscript" id="proof158">
<span class="id">move</span>=&gt; <span class="id">Ax</span> <span class="id">P</span> <span class="id">AP</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span>; <span class="id">near</span>=&gt; <span class="id">y</span>; <span class="id">apply</span>: <span class="id">AP</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="locally_of">locally_of</a></span> (<span class="id"><a name="P:1123">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.T">T</a></span>) -&gt; <span class="kwd">Prop</span>) <span class="id">of</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#phantom">phantom</a></span> <span class="kwd">Prop</span> (<span class="id">P</span> (<span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span>))<br/>
&nbsp;&nbsp;:= <span class="kwd">forall</span> <span class="id"><a name="x:1124">x</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> <span class="id">x</span> -&gt; <span class="id">P</span> (<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>)).<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "[ '<span class="id">locally</span>' <span class="id">P</span> ]" := (@<span class="id"><a href="mathcomp.analysis.topology.html#locally_of">locally_of</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#Phantom">Phantom</a></span> <span class="id">_</span> <span class="id">P</span>)).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="within_interior">within_interior</a></span> (<span class="id"><a name="x:1125">x</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.T">T</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span>^° <span class="id">x</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>) = <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof159')">Proof.</span></div>
<div class="proofscript" id="proof159">
<span class="id">move</span>=&gt; <span class="id">Aox</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_within">cvg_within</a></span>.<br/>
<span class="id">rewrite</span> ?<span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; <span class="id">W</span> /= =&gt; [[<span class="id">B</span> + <span class="id">BsubW</span>]].<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhsE">open_nbhsE</a></span> =&gt; [[<span class="id">oB</span> <span class="id">nbhsB</span>]].<br/>
<span class="kwd">exists</span> (<span class="id">B</span> `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span>^°); <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">t</span> /= [] /<span class="id">BsubW</span> + /<span class="id"><a href="mathcomp.analysis.topology.html#interior_subset">interior_subset</a></span>; <span class="id">apply</span>.<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhsE">open_nbhsE</a></span>; <span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#openI">openI</a></span> =&gt; //; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#open_interior">open_interior</a></span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span> =&gt; //; <span class="id">move</span>:(<span class="id"><a href="mathcomp.analysis.topology.html#open_interior">open_interior</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span>); <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span>; <span class="id">exact</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="within_subset">within_subset</a></span> <span class="id"><a name="B:1126">B</a></span> <span class="id"><a name="F:1127">F</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> `&lt;=` <span class="id">B</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> <span class="id">F</span> `=&gt;` <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id">B</span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof160')">Proof.</span></div>
<div class="proofscript" id="proof160">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">AsubB</span> <span class="id">W</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app">filter_app</a></span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_simpl">nbhs_simpl</a></span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterE">filterE</a></span> =&gt; ? + ?; <span class="id">apply</span>; <span class="id">exact</span>: <span class="id">AsubB</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="withinE">withinE</a></span> <span class="id"><a name="F:1128">F</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> <span class="id">F</span> = [<span class="id">set</span> <span class="id"><a name="U:1129">U</a></span> | <span class="kwd">exists2</span> <span class="id"><a name="V:1130">V</a></span>, <span class="id">F</span> <span class="id">V</span> &amp; <span class="id">U</span> `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> = <span class="id">V</span> `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof161')">Proof.</span></div>
<div class="proofscript" id="proof161">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>; <span class="id">split</span>=&gt; <span class="id">U</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">Wu</span>; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id"><a name="x:1132">x</a></span> | <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> <span class="id">x</span> -&gt; <span class="id">U</span> <span class="id">x</span>] =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>; <span class="id">split</span> =&gt; <span class="id">t</span> [<span class="id">L</span> <span class="id">R</span>]; <span class="id">split</span>=&gt; //; <span class="id">apply</span>: <span class="id">L</span>.<br/>
<span class="id">move</span>=&gt; [<span class="id">V</span> <span class="id">FV</span> <span class="id">AU</span>]; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> /<span class="id"><a href="mathcomp.analysis.topology.html#prop_near1">prop_near1</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_simpl">nbhs_simpl</a></span>; <span class="id">near</span>=&gt; <span class="id">w</span> =&gt; <span class="id">Aw</span>.<br/>
<span class="kwd">by</span> <span class="id">have</span> []// : (<span class="id">U</span> `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span>) <span class="id">w</span>; <span class="id">rewrite</span> <span class="id">AU</span>; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#near">near</a></span> <span class="id">FV</span>).<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="fmap_within_eq">fmap_within_eq</a></span> {<span class="id"><a name="S:1134">S</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id"><a name="F:1135">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.T">T</a></span>)) (<span class="id"><a name="f:1136">f</a></span> <span class="id"><a name="g:1137">g</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.T">T</a></span> -&gt; <span class="id">S</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; {<span class="kwd">in</span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span>, <span class="id">f</span> =1 <span class="id">g</span>} -&gt; <span class="id">f</span> @ <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> <span class="id">F</span> --&gt; <span class="id">g</span> @ <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof162')">Proof.</span></div>
<div class="proofscript" id="proof162">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">feq</span> <span class="id">U</span> /=; <span class="id">near_simpl</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app">filter_app</a></span>.<br/>
<span class="id">rewrite</span> ?<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_simpl">nbhs_simpl</a></span>; <span class="id">near_simpl</span>; <span class="id">near</span>=&gt; <span class="id">w</span>; <span class="id">rewrite</span> (<span class="id">feq</span> <span class="id">w</span>) // <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span>.<br/>
<span class="id">exact</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#near">near</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#withinT">withinT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType.A">A</a></span> <span class="id">FF</span>) <span class="id">w</span>).<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#within_topologicalType">within_topologicalType</a></span>.<br/>
<br/>
<span class="kwd">Notation</span> "[ '<span class="id">locally</span>' <span class="id">P</span> ]" := (@<span class="id"><a href="mathcomp.analysis.topology.html#locally_of">locally_of</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#Phantom">Phantom</a></span> <span class="id">_</span> <span class="id">P</span>)).<br/>
<br/>
<h2> Topology defined by a filter </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="TopologyOfFilter">TopologyOfFilter</a></span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id"><a name="T:1138">T</a></span> : <span class="kwd">Type</span>} {<span class="id"><a name="nbhs':1139">nbhs</a></span>' : <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)}.<br/>
<span class="kwd">Hypothesis</span> (<span class="id"><a name="TopologyOfFilter.nbhs'_filter">nbhs</a></span>'<span class="id">_filter</span> : <span class="kwd">forall</span> <span class="id"><a name="p:1140">p</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfFilter.T">T</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id">nbhs</span>' <span class="id">p</span>)).<br/>
<span class="kwd">Hypothesis</span> (<span class="id"><a name="TopologyOfFilter.nbhs'_singleton">nbhs</a></span>'<span class="id">_singleton</span> : <span class="kwd">forall</span> (<span class="id"><a name="p:1142">p</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfFilter.T">T</a></span>) (<span class="id"><a name="A:1143">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfFilter.T">T</a></span>), <span class="id">nbhs</span>' <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id">A</span> <span class="id">p</span>).<br/>
<span class="kwd">Hypothesis</span> (<span class="id"><a name="TopologyOfFilter.nbhs'_nbhs'">nbhs</a></span>'<span class="id">_nbhs</span>' : <span class="kwd">forall</span> (<span class="id"><a name="p:1145">p</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfFilter.T">T</a></span>) (<span class="id"><a name="A:1146">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfFilter.T">T</a></span>), <span class="id">nbhs</span>' <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id">nbhs</span>' <span class="id">p</span> (<span class="id">nbhs</span>'^~ <span class="id">A</span>)).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="open_of_nbhs">open_of_nbhs</a></span> := [<span class="id">set</span> <span class="id"><a name="A:1148">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfFilter.T">T</a></span> | <span class="id">A</span> `&lt;=` <span class="id">nbhs</span>'^~ <span class="id">A</span>].<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id"><a name="topologyOfFilterMixin">topologyOfFilterMixin</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#mixin_of">Topological.mixin_of</a></span> <span class="id">nbhs</span>' :=<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#Mixin">Topological.Mixin</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfFilter.T">T</a></span> <span class="id">nbhs</span>' <span class="id"><a href="mathcomp.analysis.topology.html#open_of_nbhs">open_of_nbhs</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof163')">Next Obligation.</span></div>
<div class="proofscript" id="proof163">
<span class="id">move</span>=&gt; <span class="id">p</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">A</span>; <span class="id">split</span>=&gt; [<span class="id">p_A</span>|]; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">B</span> [<span class="id">Bop</span> <span class="id">Bp</span> <span class="id">sBA</span>]]; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">sBA</span> <span class="id">_</span>; <span class="id">apply</span>: <span class="id">Bop</span>.<br/>
<span class="kwd">exists</span> (<span class="id">nbhs</span>'^~ <span class="id">A</span>) ; <span class="id">split</span> =&gt; //; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">apply</span>: <span class="id">nbhs</span>'<span class="id">_nbhs</span>'.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">q</span> /<span class="id">nbhs</span>'<span class="id">_singleton</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof164')">Next Obligation.</span></div>
<div class="proofscript" id="proof164">
 <span class="id">done</span>. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfFilter">TopologyOfFilter</a></span>.<br/>
<br/>
<h2> Topology defined by open sets </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="TopologyOfOpen">TopologyOfOpen</a></span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id"><a name="TopologyOfOpen.T">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="TopologyOfOpen.op">op</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span> -&gt; <span class="kwd">Prop</span>).<br/>
<span class="kwd">Hypothesis</span> (<span class="id"><a name="TopologyOfOpen.opT">opT</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op">op</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>).<br/>
<span class="kwd">Hypothesis</span> (<span class="id"><a name="TopologyOfOpen.opI">opI</a></span> : <span class="kwd">forall</span> (<span class="id"><a name="A:1152">A</a></span> <span class="id"><a name="B:1153">B</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.T">T</a></span>), <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op">op</a></span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op">op</a></span> <span class="id">B</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op">op</a></span> (<span class="id">A</span> `&amp;` <span class="id">B</span>)).<br/>
<span class="kwd">Hypothesis</span> (<span class="id"><a name="TopologyOfOpen.op_bigU">op_bigU</a></span> : <span class="kwd">forall</span> (<span class="id"><a name="I:1155">I</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="f:1156">f</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.T">T</a></span>),<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="i:1157">i</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op">op</a></span> (<span class="id">f</span> <span class="id">i</span>)) -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op">op</a></span> (\<span class="id">bigcup_i</span> <span class="id">f</span> <span class="id">i</span>)).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="nbhs_of_open">nbhs_of_open</a></span> (<span class="id"><a name="p:1160">p</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.T">T</a></span>) (<span class="id"><a name="A:1161">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.T">T</a></span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id"><a name="B:1162">B</a></span>, [/\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op">op</a></span> <span class="id">B</span>, <span class="id">B</span> <span class="id">p</span> &amp; <span class="id">B</span> `&lt;=` <span class="id">A</span>].<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id"><a name="topologyOfOpenMixin">topologyOfOpenMixin</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#mixin_of">Topological.mixin_of</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_of_open">nbhs_of_open</a></span> :=<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#Mixin">Topological.Mixin</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.T">T</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_of_open">nbhs_of_open</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op">op</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof165')">Next Obligation.</span></div>
<div class="proofscript" id="proof165">
<span class="id">move</span>=&gt; <span class="id">p</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Build_ProperFilter">Build_ProperFilter</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A</span> [<span class="id">B</span> [<span class="id">_</span> <span class="id">Bp</span> <span class="id">sBA</span>]]; <span class="kwd">exists</span> <span class="id">p</span>; <span class="id">apply</span>: <span class="id">sBA</span>.<br/>
<span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> [<span class="id">C</span> [<span class="id">Cop</span> <span class="id">Cp</span> <span class="id">sCA</span>]] [<span class="id">D</span> [<span class="id">Dop</span> <span class="id">Dp</span> <span class="id">sDB</span>]].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">C</span> `&amp;` <span class="id">D</span>); <span class="id">split</span> =&gt; //; <span class="id">first</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.opI">opI</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">q</span> [/<span class="id">sCA</span> <span class="id">Aq</span> /<span class="id">sDB</span> <span class="id">Bq</span>].<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> <span class="id">sAB</span> [<span class="id">C</span> [<span class="id">Cop</span> <span class="id">p_C</span> <span class="id">sCA</span>]].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">C</span>; <span class="id">split</span>=&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#subset_trans">subset_trans</a></span> <span class="id">sAB</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof166')">Next Obligation.</span></div>
<div class="proofscript" id="proof166">
 <span class="id">done</span>. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof167')">Next Obligation.</span></div>
<div class="proofscript" id="proof167">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">A</span>; <span class="id">split</span>=&gt; [<span class="id">Aop</span> <span class="id">p</span> <span class="id">Ap</span>|<span class="id">Aop</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">A</span>; <span class="id">split</span>=&gt; //; <span class="id">split</span>.<br/>
<span class="id">suff</span> -&gt; : <span class="id">A</span> = \<span class="id">bigcup_</span>(<span class="id"><a name="B:1164">B</a></span> : {<span class="id"><a name="B:1163">B</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.T">T</a></span> &amp; <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op">op</a></span> <span class="id">B</span> /\ <span class="id">B</span> `&lt;=` <span class="id">A</span>}) <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">projT1</a></span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen.op_bigU">op_bigU</a></span> =&gt; <span class="id">B</span>; <span class="id">have</span> [] := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">projT2</a></span> <span class="id">B</span>.<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">p</span>; <span class="id">split</span>=&gt; [|[<span class="id">B</span> <span class="id">_</span> <span class="id">Bp</span>]]; <span class="id">last</span> <span class="kwd">by</span> <span class="id">have</span> [<span class="id">_</span>] := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">projT2</a></span> <span class="id">B</span>; <span class="id">apply</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">Aop</span> [<span class="id">B</span> [<span class="id">Bop</span> <span class="id">Bp</span> <span class="id">sBA</span>]]; <span class="kwd">exists</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#existT">existT</a></span> <span class="id">_</span> <span class="id">B</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#conj">conj</a></span> <span class="id">Bop</span> <span class="id">sBA</span>)).<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfOpen">TopologyOfOpen</a></span>.<br/>
<br/>
<h2> Topology defined by a base of open sets </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="TopologyOfBase">TopologyOfBase</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="open_from">open_from</a></span> <span class="id"><a name="I:1165">I</a></span> <span class="id"><a name="T:1166">T</a></span> (<span class="id"><a name="D:1167">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id"><a name="b:1168">b</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> \<span class="id">bigcup_</span>(<span class="id"><a name="i:1170">i</a></span> <span class="kwd">in</span> <span class="id">D</span>') <span class="id">b</span> <span class="id">i</span> | <span class="id"><a name="D':1169">D</a></span>' <span class="kwd">in</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#subset">subset</a></span>^~ <span class="id">D</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="open_fromT">open_fromT</a></span> <span class="id"><a name="I:1171">I</a></span> <span class="id"><a name="T:1172">T</a></span> (<span class="id"><a name="D:1173">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id"><a name="b:1174">b</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;\<span class="id">bigcup_</span>(<span class="id"><a name="i:1175">i</a></span> <span class="kwd">in</span> <span class="id">D</span>) <span class="id">b</span> <span class="id">i</span> = <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#open_from">open_from</a></span> <span class="id">D</span> <span class="id">b</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof168')">Proof.</span></div>
<div class="proofscript" id="proof168">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="kwd">exists</span> <span class="id">D</span>. Qed.</div>
<br/>
<span class="kwd">Variable</span> (<span class="id"><a name="TopologyOfBase.I">I</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.pointedType">pointedType</a></span>) (<span class="id"><a name="TopologyOfBase.T">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="TopologyOfBase.D">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id"><a name="TopologyOfBase.b">b</a></span> : <span class="id">I</span> -&gt; (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)).<br/>
<span class="kwd">Hypothesis</span> (<span class="id"><a name="TopologyOfBase.b_cover">b_cover</a></span> : \<span class="id">bigcup_</span>(<span class="id"><a name="i:1180">i</a></span> <span class="kwd">in</span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span>) <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">i</span> = <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>).<br/>
<span class="kwd">Hypothesis</span> (<span class="id"><a name="TopologyOfBase.b_join">b_join</a></span> : <span class="kwd">forall</span> <span class="id"><a name="i:1182">i</a></span> <span class="id"><a name="j:1183">j</a></span> <span class="id"><a name="t:1184">t</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span> <span class="id">i</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span> <span class="id">j</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">i</span> <span class="id">t</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">j</span> <span class="id">t</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id"><a name="k:1185">k</a></span>, [/\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span> <span class="id">k</span>, <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">k</span> <span class="id">t</span> &amp; <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">k</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">i</span> `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">j</span>]).<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id"><a name="topologyOfBaseMixin">topologyOfBaseMixin</a></span> :=<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#topologyOfOpenMixin">topologyOfOpenMixin</a></span> <span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.topology.html#open_from">open_from</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span>) (<span class="id"><a href="mathcomp.analysis.topology.html#open_fromT">open_fromT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b_cover">b_cover</a></span>) <span class="id">_</span> <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof169')">Next Obligation.</span></div>
<div class="proofscript" id="proof169">
<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> [<span class="id">DA</span> <span class="id">sDAD</span> <span class="id">AeUbA</span>] [<span class="id">DB</span> <span class="id">sDBD</span> <span class="id">BeUbB</span>].<br/>
<span class="id">have</span> <span class="id">ABU</span> : <span class="kwd">forall</span> <span class="id"><a name="t:1187">t</a></span>, (<span class="id">A</span> `&amp;` <span class="id">B</span>) <span class="id">t</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id"><a name="it:1188">it</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span> <span class="id">it</span> /\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">it</span> <span class="id">t</span> /\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">it</span> `&lt;=` <span class="id">A</span> `&amp;` <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">t</span> [<span class="id">At</span> <span class="id">Bt</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">iA</span> [<span class="id">DiA</span> [<span class="id">biAt</span> <span class="id">sbiA</span>]]] : <span class="kwd">exists</span> <span class="id"><a name="i:1189">i</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span> <span class="id">i</span> /\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">i</span> <span class="id">t</span> /\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">i</span> `&lt;=` <span class="id">A</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>: <span class="id">At</span>; <span class="id">rewrite</span> -<span class="id">AeUbA</span> =&gt; - [<span class="id">i</span> <span class="id">DAi</span> <span class="id">bit</span>]; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span>; [<span class="id">apply</span>: <span class="id">sDAD</span>|<span class="id">split</span>=&gt; // ?; <span class="kwd">exists</span> <span class="id">i</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">iB</span> [<span class="id">DiB</span> [<span class="id">biBt</span> <span class="id">sbiB</span>]]] : <span class="kwd">exists</span> <span class="id"><a name="i:1190">i</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span> <span class="id">i</span> /\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">i</span> <span class="id">t</span> /\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">i</span> `&lt;=` <span class="id">B</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>: <span class="id">Bt</span>; <span class="id">rewrite</span> -<span class="id">BeUbB</span> =&gt; - [<span class="id">i</span> <span class="id">DBi</span> <span class="id">bit</span>]; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span>; [<span class="id">apply</span>: <span class="id">sDBD</span>|<span class="id">split</span>=&gt; // ?; <span class="kwd">exists</span> <span class="id">i</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">i</span> [<span class="id">Di</span> <span class="id">bit</span> <span class="id">sbiAB</span>]] := <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b_join">b_join</a></span> <span class="id">DiA</span> <span class="id">DiB</span> <span class="id">biAt</span> <span class="id">biBt</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">i</span>; <span class="id">split</span>=&gt; //; <span class="id">split</span>=&gt; // <span class="id">s</span> /<span class="id">sbiAB</span> [/<span class="id">sbiA</span> ? /<span class="id">sbiB</span>].<br/>
<span class="id">set</span> <span class="id">Dt</span> := <span class="kwd">fun</span> <span class="id"><a name="t:1191">t</a></span> =&gt; [<span class="id">set</span> <span class="id"><a name="it:1192">it</a></span> | <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span> <span class="id">it</span> /\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">it</span> <span class="id">t</span> /\ <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">it</span> `&lt;=` <span class="id">A</span> `&amp;` <span class="id">B</span>].<br/>
<span class="kwd">exists</span> [<span class="id">set</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#get">get</a></span> (<span class="id">Dt</span> <span class="id">t</span>) | <span class="id"><a name="t:1197">t</a></span> <span class="kwd">in</span> <span class="id">A</span> `&amp;` <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">_</span> [<span class="id">t</span> <span class="id">ABt</span> &lt;-]; <span class="id">have</span> /<span class="id">ABU</span>/<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span> [] := <span class="id">ABt</span>.<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">t</span>; <span class="id">split</span>=&gt; [[<span class="id">_</span> [<span class="id">s</span> <span class="id">ABs</span> &lt;-] <span class="id">bDtst</span>]|<span class="id">ABt</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> /<span class="id">ABU</span>/<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span> [<span class="id">_</span> [<span class="id">_</span>]] := <span class="id">ABs</span>; <span class="id">apply</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#get">get</a></span> (<span class="id">Dt</span> <span class="id">t</span>)); [<span class="kwd">exists</span> <span class="id">t</span>| <span class="id">have</span> /<span class="id">ABU</span>/<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span> [? []]:= <span class="id">ABt</span>].<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof170')">Next Obligation.</span></div>
<div class="proofscript" id="proof170">
<span class="id">move</span>=&gt; <span class="id">I0</span> <span class="id">f</span>.<br/>
<span class="id">set</span> <span class="id">fop</span> := <span class="kwd">fun</span> <span class="id"><a name="j:1199">j</a></span> =&gt; [<span class="id">set</span> <span class="id"><a name="Dj:1200">Dj</a></span> | <span class="id">Dj</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.D">D</a></span> /\ <span class="id">f</span> <span class="id">j</span> = \<span class="id">bigcup_</span>(<span class="id"><a name="i:1201">i</a></span> <span class="kwd">in</span> <span class="id">Dj</span>) <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase.b">b</a></span> <span class="id">i</span>].<br/>
<span class="kwd">exists</span> (\<span class="id">bigcup_j</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#get">get</a></span> (<span class="id">fop</span> <span class="id">j</span>)).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">i</span> [<span class="id">j</span> <span class="id">_</span> <span class="id">fopji</span>].<br/>
&nbsp;&nbsp;<span class="id">suff</span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span> [/(<span class="id">_</span> <span class="id">_</span> <span class="id">fopji</span>)] : <span class="kwd">exists</span> <span class="id"><a name="Dj:1210">Dj</a></span>, <span class="id">fop</span> <span class="id">j</span> <span class="id">Dj</span> <span class="kwd">by</span> [].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [<span class="id">Dj</span>] := <span class="id">H</span> <span class="id">j</span>; <span class="kwd">exists</span> <span class="id">Dj</span>.<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">t</span>; <span class="id">split</span>=&gt; [[<span class="id">i</span> [<span class="id">j</span> <span class="id">_</span> <span class="id">fopji</span> <span class="id">bit</span>]]|[<span class="id">j</span> <span class="id">_</span>]].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">j</span> =&gt; //; <span class="id">suff</span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span> [<span class="id">_</span> -&gt;] : <span class="kwd">exists</span> <span class="id"><a name="Dj:1211">Dj</a></span>, <span class="id">fop</span> <span class="id">j</span> <span class="id">Dj</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">i</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [<span class="id">Dj</span>] := <span class="id">H</span> <span class="id">j</span>; <span class="kwd">exists</span> <span class="id">Dj</span>.<br/>
<span class="id">have</span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span> [<span class="id">_</span> -&gt;] : <span class="kwd">exists</span> <span class="id"><a name="Dj:1212">Dj</a></span>, <span class="id">fop</span> <span class="id">j</span> <span class="id">Dj</span> <span class="kwd">by</span> <span class="id">have</span> [<span class="id">Dj</span>] := <span class="id">H</span> <span class="id">j</span>; <span class="kwd">exists</span> <span class="id">Dj</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">i</span>]; <span class="kwd">exists</span> <span class="id">i</span> =&gt; //; <span class="kwd">exists</span> <span class="id">j</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfBase">TopologyOfBase</a></span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="filter_supremums">filter_supremums</a></span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="smallest_filter_filter">smallest_filter_filter</a></span> {<span class="id"><a name="T:1213">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="F:1214">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#smallest">smallest</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof171')">Proof.</span></div>
<div class="proofscript" id="proof171">
<span class="id">split</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">G</span> [? <span class="id">_</span>]; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? <span class="id">sFP</span> <span class="id">sFQ</span> ? [? ?]; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span>; [<span class="id">apply</span>: <span class="id">sFP</span> | <span class="id">apply</span>: <span class="id">sFQ</span>].<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? /<span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> + <span class="id">sFP</span> ? [? ?]; <span class="id">apply</span>; <span class="id">apply</span>: <span class="id">sFP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id"><a name="filterI_iter">filterI_iter</a></span> {<span class="id"><a name="T:1215">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="F:1216">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="n:1217">n</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">n</span> <span class="id">is</span> <span class="id">m</span>.+1<br/>
&nbsp;&nbsp;<span class="kwd">then</span> [<span class="id">set</span> <span class="id">P</span> `&amp;` <span class="id">Q</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a name="P:1220">P</a></span> <span class="kwd">in</span> <span class="id">filterI_iter</span> <span class="id">F</span> <span class="id">m</span> &amp; <span class="id"><a name="Q:1221">Q</a></span> <span class="kwd">in</span> <span class="id">filterI_iter</span> <span class="id">F</span> <span class="id">m</span>]<br/>
&nbsp;&nbsp;<span class="kwd">else</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> |` <span class="id">F</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filterI_iter_sub">filterI_iter_sub</a></span> {<span class="id"><a name="T:1222">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="F:1223">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;{<span class="id">homo</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterI_iter">filterI_iter</a></span> <span class="id">F</span> : <span class="id"><a name="i:1224">i</a></span> <span class="id"><a name="j:1225">j</a></span> / (<span class="id">i</span> &lt;= <span class="id">j</span>)%<span class="id">N</span> &gt;-&gt; <span class="id">i</span> `&lt;=` <span class="id">j</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof172')">Proof.</span></div>
<div class="proofscript" id="proof172">
<span class="id">move</span>=&gt; + <span class="id">j</span>; <span class="id">elim</span>: <span class="id">j</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">i</span>; <span class="id">rewrite</span> <span class="id">leqn0</span> =&gt; /<span class="id">eqP</span> -&gt;.<br/>
<span class="id">move</span>=&gt; <span class="id">j</span> <span class="id">IH</span> <span class="id">i</span>; <span class="id">rewrite</span> <span class="id">leq_eqVlt</span> =&gt; /<span class="id">predU1P</span>[-&gt;//|].<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">IH</span>/<span class="id"><a href="mathcomp.classical.classical_sets.html#subset_trans">subset_trans</a></span>; <span class="id">apply</span>=&gt; <span class="id">A</span> ?; <span class="id">do</span> 2 <span class="kwd">exists</span> <span class="id">A</span> =&gt; //; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setIid">setIid</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filterI_iterE">filterI_iterE</a></span> {<span class="id"><a name="T:1228">T</a></span> : <span class="kwd">Type</span>} (<span class="id"><a name="F:1229">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.classical_sets.html#smallest">smallest</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> = <span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> (\<span class="id">bigcup_n</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filterI_iter">filterI_iter</a></span> <span class="id">F</span> <span class="id">n</span>)) <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">id</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof173')">Proof.</span></div>
<div class="proofscript" id="proof173">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#smallest_sub">smallest_sub</a></span> =&gt; //; <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">FA</span>; <span class="kwd">exists</span> <span class="id">A</span> =&gt; //; <span class="kwd">exists</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#O">O</a></span> =&gt; //; <span class="id">right</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_from_filter">filter_from_filter</a></span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>; <span class="kwd">exists</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#O">O</a></span> =&gt; //; <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> [<span class="id">i</span> <span class="id">_</span> <span class="id">sFP</span>] [<span class="id">j</span> <span class="id">_</span> <span class="id">sFQ</span>]; <span class="kwd">exists</span> (<span class="id">P</span> `&amp;` <span class="id">Q</span>) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">maxn</span> <span class="id">i</span> <span class="id">j</span>).+1 =&gt; //=; <span class="kwd">exists</span> <span class="id">P</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI_iter_sub">filterI_iter_sub</a></span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">leq_maxl</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">Q</span> =&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI_iter_sub">filterI_iter_sub</a></span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">leq_maxr</span>.<br/>
<span class="id">move</span>=&gt; + [+ [<span class="id">n</span> <span class="id">_</span>]]; <span class="id">elim</span>: <span class="id">n</span> =&gt; [<span class="id">A</span> <span class="id">B</span>|<span class="id">n</span> <span class="id">IH</span>/= <span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; [-&gt; /[!(@<span class="id"><a href="mathcomp.classical.classical_sets.html#subTset">subTset</a></span> <span class="id">T</span>)] -&gt;|]; <span class="id">first</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FB</span> /<span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span>; <span class="id">apply</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#sub_gen_smallest">sub_gen_smallest</a></span>.<br/>
<span class="id">move</span>=&gt; [<span class="id">P</span> <span class="id">sFP</span>] [<span class="id">Q</span> <span class="id">sFQ</span>] <span class="id">PQB</span> /<span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span>; <span class="id">apply</span>; <span class="id">rewrite</span> -<span class="id">PQB</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span> <span class="id">_</span> <span class="id">_</span>); [<span class="id">exact</span>: (<span class="id">IH</span> <span class="id">_</span> <span class="id">_</span> <span class="id">sFP</span>)|<span class="id">exact</span>: (<span class="id">IH</span> <span class="id">_</span> <span class="id">_</span> <span class="id">sFQ</span>)].<br/>
Qed.</div>
<br/>
<h2> Topology defined by a subbase of open sets </h2>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="finI_from">finI_from</a></span> (<span class="id"><a name="I:1231">I</a></span> : <span class="id">choiceType</span>) <span class="id"><a name="T:1232">T</a></span> (<span class="id"><a name="D:1233">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id"><a name="f:1234">f</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> \<span class="id">bigcap_</span>(<span class="id"><a name="i:1237">i</a></span> <span class="kwd">in</span> [<span class="id">set</span>` <span class="id">D</span>']) <span class="id">f</span> <span class="id">i</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a name="D':1236">D</a></span>' <span class="kwd">in</span> [<span class="id">set</span> <span class="id"><a name="A:1235">A</a></span> : {<span class="id">fset</span> <span class="id">I</span>} | {<span class="id">subset</span> <span class="id">A</span> &lt;= <span class="id">D</span>}]].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="finI_from_cover">finI_from_cover</a></span> (<span class="id"><a name="I:1238">I</a></span> : <span class="id">choiceType</span>) <span class="id"><a name="T:1239">T</a></span> (<span class="id"><a name="D:1240">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id"><a name="f:1241">f</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;\<span class="id">bigcup_</span>(<span class="id"><a name="A:1242">A</a></span> <span class="kwd">in</span> <span class="id"><a href="mathcomp.analysis.topology.html#finI_from">finI_from</a></span> <span class="id">D</span> <span class="id">f</span>) <span class="id">A</span> = <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof174')">Proof.</span></div>
<div class="proofscript" id="proof174">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">t</span>; <span class="id">split</span>=&gt; // <span class="id">_</span>; <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">fset0</span> =&gt; //; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set_fset0">set_fset0</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#bigcap_set0">bigcap_set0</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="finI_from1">finI_from1</a></span> (<span class="id"><a name="I:1243">I</a></span> : <span class="id">choiceType</span>) <span class="id"><a name="T:1244">T</a></span> (<span class="id"><a name="D:1245">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id"><a name="f:1246">f</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) <span class="id"><a name="i:1247">i</a></span> :<br/>
&nbsp;&nbsp;<span class="id">D</span> <span class="id">i</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#finI_from">finI_from</a></span> <span class="id">D</span> <span class="id">f</span> (<span class="id">f</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof175')">Proof.</span></div>
<div class="proofscript" id="proof175">
<span class="id">move</span>=&gt; <span class="id">Di</span>; <span class="kwd">exists</span> [<span class="id">fset</span> <span class="id">i</span>]%<span class="id">fset</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">rewrite</span> !<span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> =&gt; /<span class="id">eqP</span> -&gt;.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#bigcap_fset">bigcap_fset</a></span> <span class="id">big_seq_fset1</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="finI_from_countable">finI_from_countable</a></span> (<span class="id"><a name="I:1248">I</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.pointedType">pointedType</a></span>) <span class="id"><a name="T:1249">T</a></span> (<span class="id"><a name="D:1250">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id"><a name="f:1251">f</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.cardinality.html#countable">countable</a></span> <span class="id">D</span> -&gt; <span class="id"><a href="mathcomp.classical.cardinality.html#countable">countable</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#finI_from">finI_from</a></span> <span class="id">D</span> <span class="id">f</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof176')">Proof.</span></div>
<div class="proofscript" id="proof176">
<span class="id">move</span>=&gt; ?; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.classical.cardinality.html#card_le_trans">card_le_trans</a></span> (<span class="id"><a href="mathcomp.classical.cardinality.html#card_image_le">card_image_le</a></span> <span class="id">_</span> <span class="id">_</span>)).<br/>
<span class="id">exact</span>: <span class="id"><a href="mathcomp.classical.cardinality.html#fset_subset_countable">fset_subset_countable</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="finI_fromI">finI_fromI</a></span> {<span class="id"><a name="I:1252">I</a></span> : <span class="id">choiceType</span>} <span class="id"><a name="T:1253">T</a></span> <span class="id"><a name="D:1254">D</a></span> (<span class="id"><a name="f:1255">f</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) <span class="id"><a name="A:1256">A</a></span> <span class="id"><a name="B:1257">B</a></span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#finI_from">finI_from</a></span> <span class="id">D</span> <span class="id">f</span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#finI_from">finI_from</a></span> <span class="id">D</span> <span class="id">f</span> <span class="id">B</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#finI_from">finI_from</a></span> <span class="id">D</span> <span class="id">f</span> (<span class="id">A</span> `&amp;` <span class="id">B</span>) .<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof177')">Proof.</span></div>
<div class="proofscript" id="proof177">
<span class="id">case</span>=&gt; <span class="id">N</span> <span class="id">ND</span> &lt;- [<span class="id">M</span> <span class="id">MD</span> &lt;-]; <span class="kwd">exists</span> (<span class="id">N</span> `|` <span class="id">M</span>)%<span class="id">fset</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> =&gt; /<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#orP">orP</a></span>[/<span class="id">ND</span> | /<span class="id">MD</span>].<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.classical.classical_sets.html#bigcap_setU">bigcap_setU</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set_fsetU">set_fsetU</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="filterI_iter_finI">filterI_iter_finI</a></span> {<span class="id"><a name="I:1258">I</a></span> : <span class="id">choiceType</span>} <span class="id"><a name="T:1259">T</a></span> <span class="id"><a name="D:1260">D</a></span> (<span class="id"><a name="f:1261">f</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#finI_from">finI_from</a></span> <span class="id">D</span> <span class="id">f</span> = \<span class="id">bigcup_n</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filterI_iter">filterI_iter</a></span> (<span class="id">f</span> @` <span class="id">D</span>) <span class="id">n</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof178')">Proof.</span></div>
<div class="proofscript" id="proof178">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">A</span> [<span class="id">N</span> /= + &lt;-]; <span class="id">have</span> /<span class="id"><a href="mathcomp.classical.cardinality.html#finite_setP">finite_setP</a></span>[<span class="id">n</span>] := <span class="id"><a href="mathcomp.classical.cardinality.html#finite_fset">finite_fset</a></span> <span class="id">N</span>; <span class="id">elim</span>: <span class="id">n</span> <span class="id">N</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>=&gt; ?; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#II0">II0</a></span> <span class="id"><a href="mathcomp.classical.cardinality.html#card_eq0">card_eq0</a></span> =&gt; /<span class="id">eqP</span> -&gt; <span class="id">_</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#bigcap_set0">bigcap_set0</a></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#O">O</a></span> =&gt; //; <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">IH</span> <span class="id">N</span> /<span class="id"><a href="mathcomp.classical.cardinality.html#eq_cardSP">eq_cardSP</a></span>[<span class="id">x</span> <span class="id">Ax</span> + <span class="id">ND</span>]; <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.classical.classical_sets.html#set_fsetD1">set_fsetD1</a></span> =&gt; <span class="id">Nxn</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">NxD</span> : {<span class="id">subset</span> (<span class="id">N</span> `\ <span class="id">x</span>)%<span class="id">fset</span> &lt;= <span class="id">D</span>}.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">rewrite</span> ?<span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> =&gt; /<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#andP">andP</a></span> [<span class="id">_</span> /<span class="id">ND</span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#set_mem">set_mem</a></span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">r</span> <span class="id">_</span> <span class="id">xr</span>] := <span class="id">IH</span> <span class="id">_</span> <span class="id">Nxn</span> <span class="id">NxD</span>; <span class="kwd">exists</span> <span class="id">r</span>.+1 =&gt; //; <span class="kwd">exists</span> (<span class="id">f</span> <span class="id">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span>: (@<span class="id"><a href="mathcomp.analysis.topology.html#filterI_iter_sub">filterI_iter_sub</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#O">O</a></span>) =&gt; //; <span class="id">right</span>; <span class="kwd">exists</span> <span class="id">x</span> =&gt; //.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span>; <span class="id">apply</span>: <span class="id">ND</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (\<span class="id">bigcap_</span>(<span class="id"><a name="i:1263">i</a></span> <span class="kwd">in</span> [<span class="id">set</span>` (<span class="id">N</span> `\ <span class="id">x</span>)%<span class="id">fset</span>]) <span class="id">f</span> <span class="id">i</span>) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.classical.classical_sets.html#bigcap_setU1">bigcap_setU1</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set_fsetD1">set_fsetD1</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setD1K">setD1K</a></span>.<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> [<span class="id">n</span> <span class="id">_</span>]; <span class="id">elim</span>: <span class="id">n</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">a</span> [-&gt; |[<span class="id">i</span> <span class="id">Di</span> &lt;-]]; [<span class="kwd">exists</span> <span class="id">fset0</span> | <span class="kwd">exists</span> [<span class="id">fset</span> <span class="id">i</span>]%<span class="id">fset</span>] =&gt; //.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set_fset0">set_fset0</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#bigcap_set0">bigcap_set0</a></span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">rewrite</span> !<span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> =&gt; /<span class="id">eqP</span> -&gt;.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set_fset1">set_fset1</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#bigcap_set1">bigcap_set1</a></span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">IH</span> <span class="id">A</span> /= [<span class="id">B</span> <span class="id">snB</span> [<span class="id">C</span> <span class="id">snC</span> &lt;-]]; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#finI_fromI">finI_fromI</a></span>; <span class="id">apply</span>: <span class="id">IH</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="smallest_filter_finI">smallest_filter_finI</a></span> {<span class="id"><a name="T:1265">T</a></span> : <span class="id">choiceType</span>} (<span class="id"><a name="D:1266">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) <span class="id"><a name="f:1267">f</a></span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#finI_from">finI_from</a></span> <span class="id">D</span> <span class="id">f</span>) <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">id</a></span> = <span class="id"><a href="mathcomp.classical.classical_sets.html#smallest">smallest</a></span> (@<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">T</span>) (<span class="id">f</span> @` <span class="id">D</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof179')">Proof.</span></div>
<div class="proofscript" id="proof179">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterI_iter_finI">filterI_iter_finI</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#filterI_iterE">filterI_iterE</a></span>. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_supremums">filter_supremums</a></span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="TopologyOfSubbase">TopologyOfSubbase</a></span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id"><a name="TopologyOfSubbase.I">I</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.pointedType">pointedType</a></span>) (<span class="id"><a name="TopologyOfSubbase.T">T</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="TopologyOfSubbase.D">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>) (<span class="id"><a name="TopologyOfSubbase.b">b</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>).<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id"><a name="topologyOfSubbaseMixin">topologyOfSubbaseMixin</a></span> :=<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#topologyOfBaseMixin">topologyOfBaseMixin</a></span> <span class="id">_</span> <span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.topology.html#finI_from">finI_from</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfSubbase.D">D</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfSubbase.b">b</a></span>) <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">id</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#finI_from_cover">finI_from_cover</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfSubbase.D">D</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfSubbase.b">b</a></span>) <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof180')">Next Obligation.</span></div>
<div class="proofscript" id="proof180">
<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> <span class="id">t</span> [<span class="id">DA</span> <span class="id">sDAD</span> <span class="id">AeIbA</span>] [<span class="id">DB</span> <span class="id">sDBD</span> <span class="id">BeIbB</span>] <span class="id">At</span> <span class="id">Bt</span>.<br/>
<span class="kwd">exists</span> (<span class="id">A</span> `&amp;` <span class="id">B</span>); <span class="id">split</span> =&gt; //.<br/>
<span class="kwd">exists</span> (<span class="id">DA</span> `|` <span class="id">DB</span>)%<span class="id">fset</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">i</span> /<span class="id">fsetUP</span> [/<span class="id">sDAD</span>|/<span class="id">sDBD</span>].<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">s</span>; <span class="id">split</span>=&gt; [<span class="id">Ifs</span>|[<span class="id">As</span> <span class="id">Bs</span>] <span class="id">i</span> /<span class="id">fsetUP</span>].<br/>
&nbsp;&nbsp;<span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">AeIbA</span> =&gt; <span class="id">i</span> <span class="id">DAi</span>; <span class="id">apply</span>: <span class="id">Ifs</span>; <span class="id">rewrite</span> /= <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> <span class="id">DAi</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">BeIbB</span> =&gt; <span class="id">i</span> <span class="id">DBi</span>; <span class="id">apply</span>: <span class="id">Ifs</span>; <span class="id">rewrite</span> /= <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> <span class="id">DBi</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#orbC">orbC</a></span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">DAi</span>|<span class="id">DBi</span>];<br/>
&nbsp;&nbsp;[<span class="id">have</span> := <span class="id">As</span>; <span class="id">rewrite</span> -<span class="id">AeIbA</span>; <span class="id">apply</span>|<span class="id">have</span> := <span class="id">Bs</span>; <span class="id">rewrite</span> -<span class="id">BeIbB</span>; <span class="id">apply</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#TopologyOfSubbase">TopologyOfSubbase</a></span>.<br/>
<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="nat_topologicalType">nat_topologicalType</a></span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="nat_topologicalType.D">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span> := <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>.<br/>
<span class="kwd">Let</span> <span class="id"><a name="nat_topologicalType.b">b</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span> := <span class="kwd">fun</span> <span class="id"><a name="i:1272">i</a></span> =&gt; [<span class="id">set</span> <span class="id">i</span>].<br/>
<span class="kwd">Let</span> <span class="id"><a name="nat_topologicalType.bT">bT</a></span> : \<span class="id">bigcup_</span>(<span class="id"><a name="i:1273">i</a></span> <span class="kwd">in</span> <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.D">D</a></span>) <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.b">b</a></span> <span class="id">i</span> = <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof181')">Proof.</span></div>
<div class="proofscript" id="proof181">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">i</span>; <span class="id">split</span> =&gt; // <span class="id">_</span>; <span class="kwd">exists</span> <span class="id">i</span>. Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="nat_topologicalType.bD">bD</a></span> : <span class="kwd">forall</span> <span class="id"><a name="i:1274">i</a></span> <span class="id"><a name="j:1275">j</a></span> <span class="id"><a name="t:1276">t</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.D">D</a></span> <span class="id">i</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.D">D</a></span> <span class="id">j</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.b">b</a></span> <span class="id">i</span> <span class="id">t</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.b">b</a></span> <span class="id">j</span> <span class="id">t</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id"><a name="k:1277">k</a></span>, [/\ <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.D">D</a></span> <span class="id">k</span>, <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.b">b</a></span> <span class="id">k</span> <span class="id">t</span> &amp; <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.b">b</a></span> <span class="id">k</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.b">b</a></span> <span class="id">i</span> `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.b">b</a></span> <span class="id">j</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof182')">Proof.</span></div>
<div class="proofscript" id="proof182">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">j</span> <span class="id">t</span> <span class="id">_</span> <span class="id">_</span> -&gt; -&gt;; <span class="kwd">exists</span> <span class="id">j</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="nat_topologicalTypeMixin">nat_topologicalTypeMixin</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#topologyOfBaseMixin">topologyOfBaseMixin</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.bT">bT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.bD">bD</a></span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="nat_filteredType">nat_filteredType</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#FilteredType">FilteredType</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_of_open">nbhs_of_open</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#open_from">open_from</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.D">D</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType.b">b</a></span>)).<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="nat_topologicalType">nat_topologicalType</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#TopologicalType">TopologicalType</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalTypeMixin">nat_topologicalTypeMixin</a></span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType">nat_topologicalType</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="eventually">eventually</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> (<span class="kwd">fun</span> <span class="id"><a name="N:1278">N</a></span> =&gt; [<span class="id">set</span> <span class="id"><a name="n:1279">n</a></span> | (<span class="id">N</span> &lt;= <span class="id">n</span>)%<span class="id">N</span>]).<br/>
<span class="kwd">Notation</span> "'\<span class="id">oo</span>'" := <span class="id"><a href="mathcomp.analysis.topology.html#eventually">eventually</a></span> : <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="eventually_filter_source">eventually_filter_source</a></span> <span class="id"><a name="X:1280">X</a></span> :=<br/>
&nbsp;&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#Source">Filtered.Source</a></span> <span class="id">X</span> <span class="id">_</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span> (<span class="kwd">fun</span> <span class="id"><a name="f:1281">f</a></span> =&gt; <span class="id">f</span> @ \<span class="id">oo</span>).<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="eventually_filter">eventually_filter</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#eventually">eventually</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof183')">Proof.</span></div>
<div class="proofscript" id="proof183">
<span class="id">eapply</span> @<span class="id"><a href="mathcomp.analysis.topology.html#filter_from_proper">filter_from_proper</a></span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">_</span>; <span class="kwd">exists</span> <span class="id">i</span> =&gt; /=.<br/>
<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_fromT_filter">filter_fromT_filter</a></span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> 0%<span class="id">N</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">j</span>; <span class="kwd">exists</span> (<span class="id">maxn</span> <span class="id">i</span> <span class="id">j</span>) =&gt; <span class="id">n</span> //=.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">geq_max</span> =&gt; /<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#andP">andP</a></span>[<span class="id">ltin</span> <span class="id">ltjn</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="eventually_filterType">eventually_filterType</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#eventually">eventually</a></span> <span class="id">_</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="eventually_pfilterType">eventually_pfilterType</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#PFilterType">PFilterType</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#eventually">eventually</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_not_empty">filter_not_empty</a></span> <span class="id">_</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhs_infty_gt">nbhs_infty_gt</a></span> <span class="id"><a name="N:1282">N</a></span> : \<span class="kwd">forall</span> <span class="id"><a name="n:1283">n</a></span> \<span class="id">near</span> \<span class="id">oo</span>, (<span class="id">N</span> &lt; <span class="id">n</span>)%<span class="id">N</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof184')">Proof.</span></div>
<div class="proofscript" id="proof184">
 <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">N</span>.+1. Qed.</div>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">nbhs_infty_gt</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhs_infty_ge">nbhs_infty_ge</a></span> <span class="id"><a name="N:1284">N</a></span> : \<span class="kwd">forall</span> <span class="id"><a name="n:1285">n</a></span> \<span class="id">near</span> \<span class="id">oo</span>, (<span class="id">N</span> &lt;= <span class="id">n</span>)%<span class="id">N</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof185')">Proof.</span></div>
<div class="proofscript" id="proof185">
 <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">N</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_addnl">cvg_addnl</a></span> <span class="id"><a name="N:1286">N</a></span> : <span class="id">addn</span> <span class="id">N</span> @ \<span class="id">oo</span> --&gt; \<span class="id">oo</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof186')">Proof.</span></div>
<div class="proofscript" id="proof186">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> [<span class="id">n</span> <span class="id">_</span> <span class="id">Pn</span>]; <span class="kwd">exists</span> (<span class="id">n</span> - <span class="id">N</span>)%<span class="id">N</span> =&gt; // <span class="id">m</span>; <span class="id">rewrite</span> /= <span class="id">leq_subLR</span> =&gt; /<span class="id">Pn</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_addnr">cvg_addnr</a></span> <span class="id"><a name="N:1287">N</a></span> : <span class="id">addn</span>^~ <span class="id">N</span> --&gt; \<span class="id">oo</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof187')">Proof.</span></div>
<div class="proofscript" id="proof187">
 <span class="kwd">by</span> <span class="id">under</span> [<span class="id">addn</span>^~ <span class="id">N</span>]<span class="id"><a href="mathcomp.classical.boolp.html#funext">funext</a></span> =&gt; <span class="id">n</span> <span class="id">do</span> <span class="id">rewrite</span> <span class="id">addnC</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_addnl">cvg_addnl</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_subnr">cvg_subnr</a></span> <span class="id"><a name="N:1288">N</a></span> : <span class="id">subn</span>^~ <span class="id">N</span> --&gt; \<span class="id">oo</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof188')">Proof.</span></div>
<div class="proofscript" id="proof188">
<span class="id">move</span>=&gt; <span class="id">P</span> [<span class="id">n</span> <span class="id">_</span> <span class="id">Pn</span>]; <span class="kwd">exists</span> (<span class="id">N</span> + <span class="id">n</span>)%<span class="id">N</span> =&gt; //= <span class="id">m</span> <span class="id">le_m</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">Pn</span>; <span class="id">rewrite</span> /= <span class="id">leq_subRL</span>// (<span class="id">leq_trans</span> <span class="id">_</span> <span class="id">le_m</span>)// <span class="id">leq_addr</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_mulnl">cvg_mulnl</a></span> <span class="id"><a name="N:1289">N</a></span> : (<span class="id">N</span> &gt; 0)%<span class="id">N</span> -&gt; <span class="id">muln</span> <span class="id">N</span> --&gt; \<span class="id">oo</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof189')">Proof.</span></div>
<div class="proofscript" id="proof189">
<span class="id">case</span>: <span class="id">N</span> =&gt; <span class="id">N</span> // <span class="id">_</span> <span class="id">P</span> [<span class="id">n</span> <span class="id">_</span> <span class="id">Pn</span>]; <span class="kwd">exists</span> (<span class="id">n</span> %/ <span class="id">N</span>.+1).+1 =&gt; // <span class="id">m</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> /= <span class="id">ltn_divLR</span>// =&gt; <span class="id">n_lt</span>; <span class="id">apply</span>: <span class="id">Pn</span>; <span class="id">rewrite</span> <span class="id">mulnC</span> /= <span class="id">ltnW</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_mulnr">cvg_mulnr</a></span> <span class="id"><a name="N:1290">N</a></span> :(<span class="id">N</span> &gt; 0)%<span class="id">N</span> -&gt; <span class="id">muln</span>^~ <span class="id">N</span> --&gt; \<span class="id">oo</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof190')">Proof.</span></div>
<div class="proofscript" id="proof190">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">N_gt0</span>; <span class="id">under</span> [<span class="id">muln</span>^~ <span class="id">N</span>]<span class="id"><a href="mathcomp.classical.boolp.html#funext">funext</a></span> =&gt; <span class="id">n</span> <span class="id">do</span> <span class="id">rewrite</span> <span class="id">mulnC</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_mulnl">cvg_mulnl</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_divnr">cvg_divnr</a></span> <span class="id"><a name="N:1291">N</a></span> : (<span class="id">N</span> &gt; 0)%<span class="id">N</span> -&gt; <span class="id">divn</span>^~ <span class="id">N</span> --&gt; \<span class="id">oo</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof191')">Proof.</span></div>
<div class="proofscript" id="proof191">
<span class="id">move</span>=&gt; <span class="id">N_gt0</span> <span class="id">P</span> [<span class="id">n</span> <span class="id">_</span> <span class="id">Pn</span>]; <span class="kwd">exists</span> (<span class="id">n</span> * <span class="id">N</span>)%<span class="id">N</span> =&gt; //= <span class="id">m</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> /= -<span class="id">leq_divRL</span>//; <span class="id">apply</span>: <span class="id">Pn</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="near_inftyS">near_inftyS</a></span> (<span class="id"><a name="P:1292">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span>) :<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id"><a name="x:1293">x</a></span> \<span class="id">near</span> \<span class="id">oo</span>, <span class="id">P</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#S">S</a></span> <span class="id">x</span>)) -&gt; (\<span class="kwd">forall</span> <span class="id"><a name="x:1294">x</a></span> \<span class="id">near</span> \<span class="id">oo</span>, <span class="id">P</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof192')">Proof.</span></div>
<div class="proofscript" id="proof192">
 <span class="id">case</span>=&gt; <span class="id">N</span> <span class="id">_</span> <span class="id">NPS</span>; <span class="kwd">exists</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#S">S</a></span> <span class="id">N</span>) =&gt; // [[]]; <span class="id">rewrite</span> /= ?<span class="id">ltn0</span> //. Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="infty_nat">infty_nat</a></span>.<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">nat_scope</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="infty_nat.cvgnyP">cvgnyP</a></span> {<span class="id"><a name="F:1295">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span>)} {<span class="id"><a name="FF:1296">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} : [&lt;-&gt;<br/>
 <span class="id">F</span> --&gt; \<span class="id">oo</span>;<br/>
 <span class="kwd">forall</span> <span class="id"><a name="A:1297">A</a></span>, \<span class="kwd">forall</span> <span class="id"><a name="x:1298">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">A</span> &lt;= <span class="id">x</span>;<br/>
 <span class="kwd">forall</span> <span class="id"><a name="A:1299">A</a></span>, \<span class="kwd">forall</span> <span class="id"><a name="x:1300">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">A</span> &lt; <span class="id">x</span>;<br/>
 \<span class="kwd">forall</span> <span class="id"><a name="A:1301">A</a></span> \<span class="id">near</span> \<span class="id">oo</span>, \<span class="kwd">forall</span> <span class="id"><a name="x:1302">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">A</span> &lt; <span class="id">x</span>;<br/>
 \<span class="kwd">forall</span> <span class="id"><a name="A:1303">A</a></span> \<span class="id">near</span> \<span class="id">oo</span>, \<span class="kwd">forall</span> <span class="id"><a name="x:1304">x</a></span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">A</span> &lt;= <span class="id">x</span> ].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof193')">Proof.</span></div>
<div class="proofscript" id="proof193">
<span class="id">tfae</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Foo</span> <span class="id">A</span>; <span class="id">apply</span>: <span class="id">Foo</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_infty_ge">nbhs_infty_ge</a></span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">AF</span> <span class="id">A</span>; <span class="id">near</span> \<span class="id">oo</span> =&gt; <span class="id">B</span>; <span class="id">near</span>=&gt; <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="id">suff</span> : (<span class="id">B</span> &lt;= <span class="id">x</span>)%<span class="id">N</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">leq_trans</span>; <span class="id">near</span>: <span class="id">B</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_infty_gt">nbhs_infty_gt</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">near</span>: <span class="id">x</span>; <span class="id">apply</span>: <span class="id">AF</span>; <span class="id">near</span>: <span class="id">B</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Foo</span>; <span class="id">near</span> <span class="id">do</span> <span class="id">apply</span>: <span class="id">Foo</span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> =&gt; ?; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> =&gt; ?; <span class="id">apply</span>: <span class="id">ltnW</span>.<br/>
<span class="id">case</span>=&gt; [<span class="id">A</span> <span class="id">_</span> <span class="id">AF</span>] <span class="id">P</span> [<span class="id">n</span> <span class="id">_</span> <span class="id">Pn</span>]; <span class="id">near</span> \<span class="id">oo</span> =&gt; <span class="id">B</span>; <span class="id">near</span>=&gt; <span class="id">m</span>; <span class="id">apply</span>: <span class="id">Pn</span> =&gt; /=.<br/>
<span class="id">suff</span>: (<span class="id">B</span> &lt;= <span class="id">m</span>)%<span class="id">N</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">leq_trans</span>; <span class="id">near</span>: <span class="id">B</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_infty_ge">nbhs_infty_ge</a></span>.<br/>
<span class="kwd">by</span> <span class="id">near</span>: <span class="id">m</span>; <span class="id">apply</span>: <span class="id">AF</span>; <span class="id">near</span>: <span class="id">B</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_infty_ge">nbhs_infty_ge</a></span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="infty_nat.map">map</a></span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id"><a name="I:1305">I</a></span> : <span class="kwd">Type</span>} {<span class="id"><a name="F:1306">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">I</span>)} {<span class="id"><a name="FF:1307">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>} (<span class="id"><a name="f:1308">f</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvgnyPge">cvgnyPge</a></span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.f">f</a></span> @ <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.F">F</a></span> --&gt; \<span class="id">oo</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id"><a name="A:1309">A</a></span>, \<span class="kwd">forall</span> <span class="id"><a name="x:1310">x</a></span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.F">F</a></span>, <span class="id">A</span> &lt;= <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.f">f</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof194')">Proof.</span></div>
<div class="proofscript" id="proof194">
 <span class="id">exact</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.cvgnyP">cvgnyP</a></span> 0%<span class="id">N</span> 1%<span class="id">N</span>). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvgnyPgt">cvgnyPgt</a></span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.f">f</a></span> @ <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.F">F</a></span> --&gt; \<span class="id">oo</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id"><a name="A:1311">A</a></span>, \<span class="kwd">forall</span> <span class="id"><a name="x:1312">x</a></span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.F">F</a></span>, <span class="id">A</span> &lt; <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.f">f</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof195')">Proof.</span></div>
<div class="proofscript" id="proof195">
 <span class="id">exact</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.cvgnyP">cvgnyP</a></span> 0%<span class="id">N</span> 2%<span class="id">N</span>). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvgnyPgty">cvgnyPgty</a></span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.f">f</a></span> @ <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.F">F</a></span> --&gt; \<span class="id">oo</span> &lt;-&gt; \<span class="kwd">forall</span> <span class="id"><a name="A:1313">A</a></span> \<span class="id">near</span> \<span class="id">oo</span>, \<span class="kwd">forall</span> <span class="id"><a name="x:1314">x</a></span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.F">F</a></span>, <span class="id">A</span> &lt; <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.f">f</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof196')">Proof.</span></div>
<div class="proofscript" id="proof196">
 <span class="id">exact</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.cvgnyP">cvgnyP</a></span> 0%<span class="id">N</span> 3%<span class="id">N</span>). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvgnyPgey">cvgnyPgey</a></span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.f">f</a></span> @ <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.F">F</a></span> --&gt; \<span class="id">oo</span> &lt;-&gt; \<span class="kwd">forall</span> <span class="id"><a name="A:1315">A</a></span> \<span class="id">near</span> \<span class="id">oo</span>, \<span class="kwd">forall</span> <span class="id"><a name="x:1316">x</a></span> \<span class="id">near</span> <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.F">F</a></span>, <span class="id">A</span> &lt;= <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map.f">f</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof197')">Proof.</span></div>
<div class="proofscript" id="proof197">
 <span class="id">exact</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.cvgnyP">cvgnyP</a></span> 0%<span class="id">N</span> 4%<span class="id">N</span>). Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat.map">map</a></span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#infty_nat">infty_nat</a></span>.<br/>
<br/>
<h2> Topology on the product of two spaces </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Prod_Topology">Prod_Topology</a></span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id"><a name="T:1317">T</a></span> <span class="id"><a name="U:1318">U</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>}.<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="Prod_Topology.prod_nbhs">prod_nbhs</a></span> (<span class="id"><a name="p:1319">p</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.T">T</a></span> * <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.U">U</a></span>) := <span class="id"><a href="mathcomp.analysis.topology.html#filter_prod">filter_prod</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span>.1) (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span>.2).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="prod_nbhs_filter">prod_nbhs_filter</a></span> (<span class="id"><a name="p:1320">p</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.T">T</a></span> * <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.U">U</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.prod_nbhs">prod_nbhs</a></span> <span class="id">p</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof198')">Proof.</span></div>
<div class="proofscript" id="proof198">
 <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_prod_proper">filter_prod_proper</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="prod_nbhs_singleton">prod_nbhs_singleton</a></span> (<span class="id"><a name="p:1321">p</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.T">T</a></span> * <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.U">U</a></span>) (<span class="id"><a name="A:1322">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.T">T</a></span> * <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.U">U</a></span>)) : <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.prod_nbhs">prod_nbhs</a></span> <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id">A</span> <span class="id">p</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof199')">Proof.</span></div>
<div class="proofscript" id="proof199">
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">QR</span> [/<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_singleton">nbhs_singleton</a></span> <span class="id">Qp1</span> /<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_singleton">nbhs_singleton</a></span> <span class="id">Rp2</span>]]; <span class="id">apply</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="prod_nbhs_nbhs">prod_nbhs_nbhs</a></span> (<span class="id"><a name="p:1323">p</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.T">T</a></span> * <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.U">U</a></span>) (<span class="id"><a name="A:1324">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.T">T</a></span> * <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.U">U</a></span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.prod_nbhs">prod_nbhs</a></span> <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.prod_nbhs">prod_nbhs</a></span> <span class="id">p</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.prod_nbhs">prod_nbhs</a></span>^~ <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof200')">Proof.</span></div>
<div class="proofscript" id="proof200">
<span class="id">move</span>=&gt; [<span class="id">QR</span> [/<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_interior">nbhs_interior</a></span> <span class="id">p1_Q</span> /<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_interior">nbhs_interior</a></span> <span class="id">p2_R</span>] <span class="id">sQRA</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">QR</span>.1^°, <span class="id">QR</span>.2^°) =&gt; // ??; <span class="kwd">exists</span> <span class="id">QR</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="prod_topologicalTypeMixin">prod_topologicalTypeMixin</a></span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#topologyOfFilterMixin">topologyOfFilterMixin</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#prod_nbhs_filter">prod_nbhs_filter</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#prod_nbhs_singleton">prod_nbhs_singleton</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#prod_nbhs_nbhs">prod_nbhs_nbhs</a></span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="prod_topologicalType">prod_topologicalType</a></span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#TopologicalType">TopologicalType</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.T">T</a></span> * <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology.U">U</a></span>) <span class="id"><a href="mathcomp.analysis.topology.html#prod_topologicalTypeMixin">prod_topologicalTypeMixin</a></span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Prod_Topology">Prod_Topology</a></span>.<br/>
<br/>
<h2> Topology on matrices </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="matrix_Topology">matrix_Topology</a></span>.<br/>
<br/>
<span class="kwd">Variables</span> (<span class="id"><a name="matrix_Topology.m">m</a></span> <span class="id"><a name="matrix_Topology.n">n</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span>) (<span class="id"><a name="matrix_Topology.T">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>).<br/>
<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> <span class="id">M</span> : '<span class="id">M</span>[<span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.T">T</a></span>]<span class="id">_</span>(<span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.m">m</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.n">n</a></span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="mx_nbhs_filter">mx_nbhs_filter</a></span> <span class="id"><a name="M:1328">M</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">M</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof201')">Proof.</span></div>
<div class="proofscript" id="proof201">
<span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#filter_from_proper">filter_from_proper</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_from_filter">filter_from_filter</a></span> <span class="id">_</span> <span class="id">_</span>)) =&gt; [|<span class="id">P</span> <span class="id">Q</span> <span class="id">M_P</span> <span class="id">M_Q</span>|<span class="id">P</span> <span class="id">M_P</span>].<br/>
- <span class="kwd">by</span> <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id"><a name="i:1329">i</a></span> <span class="id"><a name="j:1330">j</a></span> =&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>) =&gt; ??; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
- <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id"><a name="i:1333">i</a></span> <span class="id"><a name="j:1334">j</a></span> =&gt; <span class="id">P</span> <span class="id">i</span> <span class="id">j</span> `&amp;` <span class="id">Q</span> <span class="id">i</span> <span class="id">j</span>) =&gt; [??|<span class="id">mx</span> <span class="id">PQmx</span>]; <span class="id">first</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span>=&gt; <span class="id">i</span> <span class="id">j</span>; <span class="id">have</span> [] := <span class="id">PQmx</span> <span class="id">i</span> <span class="id">j</span>.<br/>
- <span class="kwd">exists</span> (\<span class="id">matrix_</span>(<span class="id"><a name="i:1337">i</a></span>, <span class="id"><a name="j:1338">j</a></span>) <span class="id"><a href="mathcomp.classical.classical_sets.html#get">get</a></span> (<span class="id">P</span> <span class="id">i</span> <span class="id">j</span>)) =&gt; <span class="id">i</span> <span class="id">j</span>; <span class="id">rewrite</span> <span class="id">mxE</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">filter_ex</a></span> (<span class="id">M_P</span> <span class="id">i</span> <span class="id">j</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="mx_nbhs_singleton">mx_nbhs_singleton</a></span> <span class="id"><a name="M:1341">M</a></span> (<span class="id"><a name="A:1342">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> '<span class="id">M</span>[<span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.T">T</a></span>]<span class="id">_</span>(<span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.m">m</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.n">n</a></span>)) : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">M</span> <span class="id">A</span> -&gt; <span class="id">A</span> <span class="id">M</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof202')">Proof.</span></div>
<div class="proofscript" id="proof202">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">P</span> <span class="id">M_P</span>]; <span class="id">apply</span>=&gt; ??; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_singleton">nbhs_singleton</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="mx_nbhs_nbhs">mx_nbhs_nbhs</a></span> <span class="id"><a name="M:1343">M</a></span> (<span class="id"><a name="A:1344">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> '<span class="id">M</span>[<span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.T">T</a></span>]<span class="id">_</span>(<span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.m">m</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.n">n</a></span>)) : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">M</span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">M</span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span>^~ <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof203')">Proof.</span></div>
<div class="proofscript" id="proof203">
<span class="id">move</span>=&gt; [<span class="id">P</span> <span class="id">M_P</span> <span class="id">sPA</span>]; <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id"><a name="i:1345">i</a></span> <span class="id"><a name="j:1346">j</a></span> =&gt; (<span class="id">P</span> <span class="id">i</span> <span class="id">j</span>)^°).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_interior">nbhs_interior</a></span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="kwd">exists</span> <span class="id">P</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="matrix_topologicalTypeMixin">matrix_topologicalTypeMixin</a></span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#topologyOfFilterMixin">topologyOfFilterMixin</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#mx_nbhs_filter">mx_nbhs_filter</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#mx_nbhs_singleton">mx_nbhs_singleton</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#mx_nbhs_nbhs">mx_nbhs_nbhs</a></span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="matrix_topologicalType">matrix_topologicalType</a></span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#TopologicalType">TopologicalType</a></span> '<span class="id">M</span>[<span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.T">T</a></span>]<span class="id">_</span>(<span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.m">m</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology.n">n</a></span>) <span class="id"><a href="mathcomp.analysis.topology.html#matrix_topologicalTypeMixin">matrix_topologicalTypeMixin</a></span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#matrix_Topology">matrix_Topology</a></span>.<br/>
<br/>
<h2> Weak topology by a function </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Weak_Topology">Weak_Topology</a></span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id"><a name="Weak_Topology.S">S</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.pointedType">pointedType</a></span>) (<span class="id"><a name="Weak_Topology.T">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>) (<span class="id"><a name="Weak_Topology.f">f</a></span> : <span class="id">S</span> -&gt; <span class="id">T</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="wopen">wopen</a></span> := [<span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> @^-1` <span class="id">A</span> | <span class="id"><a name="A:1352">A</a></span> <span class="kwd">in</span> <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="wopT">wopT</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#wopen">wopen</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof204')">Proof.</span></div>
<div class="proofscript" id="proof204">
 <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> =&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#openT">openT</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="wopI">wopI</a></span> (<span class="id"><a name="A:1353">A</a></span> <span class="id"><a name="B:1354">B</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.S">S</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#wopen">wopen</a></span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#wopen">wopen</a></span> <span class="id">B</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#wopen">wopen</a></span> (<span class="id">A</span> `&amp;` <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof205')">Proof.</span></div>
<div class="proofscript" id="proof205">
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">C</span> <span class="id">Cop</span> &lt;-] [<span class="id">D</span> <span class="id">Dop</span> &lt;-]; <span class="kwd">exists</span> (<span class="id">C</span> `&amp;` <span class="id">D</span>) =&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#openI">openI</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="wop_bigU">wop_bigU</a></span> (<span class="id"><a name="I:1355">I</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="g:1356">g</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.S">S</a></span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="i:1357">i</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#wopen">wopen</a></span> (<span class="id">g</span> <span class="id">i</span>)) -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#wopen">wopen</a></span> (\<span class="id">bigcup_i</span> <span class="id">g</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof206')">Proof.</span></div>
<div class="proofscript" id="proof206">
<span class="id">move</span>=&gt; <span class="id">gop</span>.<br/>
<span class="id">set</span> <span class="id">opi</span> := <span class="kwd">fun</span> <span class="id"><a name="i:1359">i</a></span> =&gt; [<span class="id">set</span> <span class="id"><a name="Ui:1360">Ui</a></span> | <span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">Ui</span> /\ <span class="id">g</span> <span class="id">i</span> = <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> @^-1` <span class="id">Ui</span>].<br/>
<span class="kwd">exists</span> (\<span class="id">bigcup_i</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#get">get</a></span> (<span class="id">opi</span> <span class="id">i</span>)).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#bigcup_open">bigcup_open</a></span> =&gt; <span class="id">i</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span> [] : <span class="kwd">exists</span> <span class="id"><a name="U:1367">U</a></span>, <span class="id">opi</span> <span class="id">i</span> <span class="id">U</span> <span class="kwd">by</span> <span class="id">have</span> [<span class="id">U</span>] := <span class="id">gop</span> <span class="id">i</span>; <span class="kwd">exists</span> <span class="id">U</span>.<br/>
<span class="id">have</span> <span class="id">g_preim</span> <span class="id">i</span> : <span class="id">g</span> <span class="id">i</span> = <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> @^-1` (<span class="id"><a href="mathcomp.classical.classical_sets.html#get">get</a></span> (<span class="id">opi</span> <span class="id">i</span>)).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">getPex</a></span> [] : <span class="kwd">exists</span> <span class="id"><a name="U:1369">U</a></span>, <span class="id">opi</span> <span class="id">i</span> <span class="id">U</span> <span class="kwd">by</span> <span class="id">have</span> [<span class="id">U</span>] := <span class="id">gop</span> <span class="id">i</span>; <span class="kwd">exists</span> <span class="id">U</span>.<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">s</span>; <span class="id">split</span>=&gt; [[<span class="id">i</span> <span class="id">_</span>]|[<span class="id">i</span> <span class="id">_</span>]]; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">g_preim</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -[<span class="id">_</span> <span class="id">_</span>]/((<span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> @^-1` <span class="id">_</span>) <span class="id">_</span>) -<span class="id">g_preim</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="weak_topologicalTypeMixin">weak_topologicalTypeMixin</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#topologyOfOpenMixin">topologyOfOpenMixin</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#wopT">wopT</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#wopI">wopI</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#wop_bigU">wop_bigU</a></span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="Weak_Topology.S_filteredClass">S_filteredClass</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#Class">Filtered.Class</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.class">Pointed.class</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.S">S</a></span>) (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_of_open">nbhs_of_open</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#wopen">wopen</a></span>).<br/>
<span class="kwd">Definition</span> <span class="id"><a name="weak_topologicalType">weak_topologicalType</a></span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Pack">Topological.Pack</a></span> (@<span class="id"><a href="mathcomp.analysis.topology.html#Class">Topological.Class</a></span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.S_filteredClass">S_filteredClass</a></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#weak_topologicalTypeMixin">weak_topologicalTypeMixin</a></span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="weak_continuous">weak_continuous</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#weak_topologicalType">weak_topologicalType</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.T">T</a></span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof207')">Proof.</span></div>
<div class="proofscript" id="proof207">
 <span class="kwd">by</span> <span class="id">apply</span>/<span class="id"><a href="mathcomp.analysis.topology.html#continuousP">continuousP</a></span> =&gt; <span class="id">A</span> ?; <span class="kwd">exists</span> <span class="id">A</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_image">cvg_image</a></span> (<span class="id"><a name="F:1370">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.S">S</a></span>)) (<span class="id"><a name="s:1371">s</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.S">S</a></span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> @` <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> = <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; (<span class="id">s</span> : <span class="id"><a href="mathcomp.analysis.topology.html#weak_topologicalType">weak_topologicalType</a></span>) &lt;-&gt; [<span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> @` <span class="id">A</span> | <span class="id"><a name="A:1372">A</a></span> <span class="kwd">in</span> <span class="id">F</span>] --&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> <span class="id">s</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof208')">Proof.</span></div>
<div class="proofscript" id="proof208">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">fsurj</span>; <span class="id">split</span>=&gt; [<span class="id">cvFs</span>|<span class="id">cvfFfs</span>].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">A</span> /<span class="id"><a href="mathcomp.analysis.topology.html#weak_continuous">weak_continuous</a></span> [<span class="id">B</span> [<span class="id">Bop</span> <span class="id">Bs</span> <span class="id">sBAf</span>]].<br/>
&nbsp;&nbsp;<span class="id">have</span> /<span class="id">cvFs</span> <span class="id">FB</span> : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> (<span class="id">s</span> : <span class="id"><a href="mathcomp.analysis.topology.html#weak_topologicalType">weak_topologicalType</a></span>) <span class="id">B</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs_nbhs">open_nbhs_nbhs</a></span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_simpl">nbhs_simpl</a></span>; <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> @^-1` <span class="id">A</span>); <span class="id">first</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">FB</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#image_preimage">image_preimage</a></span>.<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> /= [<span class="id">_</span> [[<span class="id">B</span> <span class="id">Bop</span> &lt;-] <span class="id">Bfs</span> <span class="id">sBfA</span>]].<br/>
<span class="id">have</span> /<span class="id">cvfFfs</span> [<span class="id">C</span> <span class="id">FC</span> <span class="id">fCeB</span>] : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology.f">f</a></span> <span class="id">s</span>) <span class="id">B</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span>; <span class="kwd">exists</span> <span class="id">B</span>.<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_filterE">nbhs_filterE</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">FC</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#subset_trans">subset_trans</a></span> <span class="id">sBfA</span>; <span class="id">rewrite</span> -<span class="id">fCeB</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#preimage_image">preimage_image</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Weak_Topology">Weak_Topology</a></span>.<br/>
<br/>
<h2> Supremum of a family of topologies </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Sup_Topology">Sup_Topology</a></span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id"><a name="Sup_Topology.T">T</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.pointedType">pointedType</a></span>) (<span class="id"><a name="Sup_Topology.I">I</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="Sup_Topology.Tc">Tc</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#class_of">Topological.class_of</a></span> <span class="id">T</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="Sup_Topology.TS">TS</a></span> := <span class="kwd">fun</span> <span class="id"><a name="i:1376">i</a></span> =&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Pack">Topological.Pack</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Sup_Topology.Tc">Tc</a></span> <span class="id">i</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="sup_subbase">sup_subbase</a></span> := \<span class="id">bigcup_i</span> (@<span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Sup_Topology.TS">TS</a></span> <span class="id">i</span>) : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Sup_Topology.T">T</a></span>)).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="sup_topologicalTypeMixin">sup_topologicalTypeMixin</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#topologyOfSubbaseMixin">topologyOfSubbaseMixin</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#sup_subbase">sup_subbase</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">id</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="sup_topologicalType">sup_topologicalType</a></span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Pack">Topological.Pack</a></span> (@<span class="id"><a href="mathcomp.analysis.topology.html#Class">Topological.Class</a></span> <span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Class">Filtered.Class</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.class">Pointed.class</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Sup_Topology.T">T</a></span>) <span class="id">_</span>)<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#sup_topologicalTypeMixin">sup_topologicalTypeMixin</a></span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_sup">cvg_sup</a></span> (<span class="id"><a name="F:1378">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Sup_Topology.T">T</a></span>)) (<span class="id"><a name="t:1379">t</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Sup_Topology.T">T</a></span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id">F</span> --&gt; (<span class="id">t</span> : <span class="id"><a href="mathcomp.analysis.topology.html#sup_topologicalType">sup_topologicalType</a></span>) &lt;-&gt; <span class="kwd">forall</span> <span class="id"><a name="i:1380">i</a></span>, <span class="id">F</span> --&gt; (<span class="id">t</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Sup_Topology.TS">TS</a></span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof209')">Proof.</span></div>
<div class="proofscript" id="proof209">
<span class="id">move</span>=&gt; <span class="id">Ffilt</span>; <span class="id">split</span>=&gt; <span class="id">cvFt</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">A</span> /=; <span class="id">rewrite</span> (@<span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Sup_Topology.TS">TS</a></span> <span class="id">i</span>)) =&gt; - [<span class="id">B</span> [<span class="id">Bop</span> <span class="id">Bt</span>] <span class="id">sBA</span>].<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">cvFt</span>; <span class="kwd">exists</span> <span class="id">B</span>; <span class="id">split</span>=&gt; //; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">B</span>]; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; ?; <span class="id">split</span>=&gt; [[<span class="id">_</span> -&gt;]|] //; <span class="kwd">exists</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">_</span> -&gt;; <span class="kwd">exists</span> [<span class="id">fset</span> <span class="id">B</span>]%<span class="id">fset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> =&gt; /<span class="id">eqP</span>-&gt;; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span>=&gt; ?; <span class="id">split</span>=&gt; [|??]; [<span class="id">apply</span>|]; <span class="id">rewrite</span> /= <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> // =&gt;/<span class="id">eqP</span>-&gt;.<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> /=; <span class="id">rewrite</span> (@<span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#sup_topologicalType">sup_topologicalType</a></span>).<br/>
<span class="id">move</span>=&gt; [<span class="id">_</span> [[<span class="id">B</span> <span class="id">sB</span> &lt;-] [<span class="id">C</span> <span class="id">BC</span> <span class="id">Ct</span>] <span class="id">sUBA</span>]].<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_filterE">nbhs_filterE</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">sUBA</span> <span class="id">_</span>; <span class="id">apply</span>: (@<span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">C</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="kwd">exists</span> <span class="id">C</span>.<br/>
<span class="id">have</span> /<span class="id">sB</span> [<span class="id">D</span> <span class="id">sD</span> <span class="id">IDeC</span>] := <span class="id">BC</span>; <span class="id">rewrite</span> -<span class="id">IDeC</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_bigI">filter_bigI</a></span> =&gt; <span class="id">E</span> <span class="id">DE</span>.<br/>
<span class="id">have</span> /<span class="id">sD</span> := <span class="id">DE</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">inE</a></span> =&gt; - [<span class="id">i</span> <span class="id">_</span>]; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; <span class="id">Eop</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">cvFt</span> <span class="id">i</span>); <span class="id">apply</span>: <span class="id">Eop</span>; <span class="id">move</span>: <span class="id">Ct</span>; <span class="id">rewrite</span> -<span class="id">IDeC</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">DE</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Sup_Topology">Sup_Topology</a></span>.<br/>
<br/>
<h2> Product topology </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Product_Topology">Product_Topology</a></span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id"><a name="Product_Topology.I">I</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="Product_Topology.T">T</a></span> : <span class="id">I</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="product_topologicalType">product_topologicalType</a></span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#sup_topologicalType">sup_topologicalType</a></span> (<span class="kwd">fun</span> <span class="id"><a name="i:1383">i</a></span> =&gt; <span class="id"><a href="mathcomp.analysis.topology.html#class">Topological.class</a></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a href="mathcomp.analysis.topology.html#weak_topologicalType">weak_topologicalType</a></span> (<span class="kwd">fun</span> <span class="id"><a name="f:1384">f</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#dep_arrow_pointedType">dep_arrow_pointedType</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Product_Topology.T">T</a></span> =&gt; <span class="id">f</span> <span class="id">i</span>))).<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#Product_Topology">Product_Topology</a></span>.<br/>
<br/>
<div class="doc">dnbhs </div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="dnbhs">dnbhs</a></span> {<span class="id"><a name="T:1385">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id"><a name="x:1386">x</a></span> : <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> (<span class="kwd">fun</span> <span class="id"><a name="y:1387">y</a></span> =&gt; <span class="id">y</span> != <span class="id">x</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>).<br/>
<span class="kwd">Notation</span> "<span class="id">x</span> ^'" := (<span class="id"><a href="mathcomp.analysis.topology.html#dnbhs">dnbhs</a></span> <span class="id">x</span>) : <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="dnbhsE">dnbhsE</a></span> (<span class="id"><a name="T:1388">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>) (<span class="id"><a name="x:1389">x</a></span> : <span class="id">T</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span> = <span class="id">x</span>^' `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#at_point">at_point</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof210')">Proof.</span></div>
<div class="proofscript" id="proof210">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">A</span>; <span class="id">split</span>=&gt; [<span class="id">x_A</span>|[<span class="id">x_A</span> <span class="id">Ax</span>]].<br/>
&nbsp;&nbsp;<span class="id">split</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_singleton">nbhs_singleton</a></span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>: <span class="id">x_A</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; -[<span class="id">B</span> [<span class="id">oB</span> <span class="id">x_B</span> <span class="id">sBA</span>]]; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#dnbhs">dnbhs</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">B</span> =&gt; // ? /<span class="id">sBA</span>.<br/>
<span class="id">move</span>: <span class="id">x_A</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#dnbhs">dnbhs</a></span> !<span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; -[<span class="id">B</span> [<span class="id">oB</span> <span class="id">x_B</span> <span class="id">sBA</span>]]; <span class="kwd">exists</span> <span class="id">B</span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">y</span> /<span class="id">sBA</span> <span class="id">Ay</span>; <span class="id">case</span>: (<span class="id">eqVneq</span> <span class="id">y</span> <span class="id">x</span>) =&gt; [-&gt;|].<br/>
Qed.</div>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="dnbhs_filter">dnbhs_filter</a></span> {<span class="id"><a name="T:1390">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id"><a name="x:1391">x</a></span> : <span class="id">T</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">x</span>^'.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof211')">Proof.</span></div>
<div class="proofscript" id="proof211">
 <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#within_filter">within_filter</a></span>. Qed.</div>
#[<span class="id">global</span>] <span class="id">Typeclasses</span> <span class="kwd">Opaque</span> <span class="id">dnbhs</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="dnbhs_filter_on">dnbhs_filter_on</a></span> (<span class="id"><a name="T:1392">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>)  (<span class="id"><a name="x:1393">x</a></span> : <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#FilterType">FilterType</a></span> <span class="id">x</span>^' (<span class="id"><a href="mathcomp.analysis.topology.html#dnbhs_filter">dnbhs_filter</a></span> <span class="id">_</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_fmap2">cvg_fmap2</a></span> (<span class="id"><a name="T:1394">T</a></span> <span class="id"><a name="U:1395">U</a></span> : <span class="kwd">Type</span>) (<span class="id"><a name="f:1396">f</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span>):<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id"><a name="F:1397">F</a></span> <span class="id"><a name="G:1398">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)), <span class="id">G</span> `=&gt;` <span class="id">F</span> -&gt; <span class="id">f</span> @ <span class="id">G</span> `=&gt;` <span class="id">f</span> @ <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof212')">Proof.</span></div>
<div class="proofscript" id="proof212">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">F</span> <span class="id">G</span> <span class="id">H</span> <span class="id">A</span> <span class="id">fFA</span> ; <span class="id">exact</span>: <span class="id">H</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#preimage">preimage</a></span> <span class="id">f</span> <span class="id">A</span>) <span class="id">fFA</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_within_filter">cvg_within_filter</a></span> {<span class="id"><a name="T:1399">T</a></span> <span class="id"><a name="U:1400">U</a></span>} {<span class="id"><a name="f:1401">f</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span>} (<span class="id"><a name="F:1402">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) {<span class="id"><a name="FF:1403">FF</a></span> : (<span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>) }<br/>
&nbsp;&nbsp;(<span class="id"><a name="G:1404">G</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">U</span>)) : <span class="kwd">forall</span> (<span class="id"><a name="D:1405">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>), (<span class="id">f</span> @ <span class="id">F</span>) --&gt; <span class="id">G</span> -&gt; (<span class="id">f</span> @ <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id">D</span> <span class="id">F</span>) --&gt; <span class="id">G</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof213')">Proof.</span></div>
<div class="proofscript" id="proof213">
 <span class="id">move</span>=&gt; ?;  <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_trans">cvg_trans</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#cvg_fmap2">cvg_fmap2</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#cvg_within">cvg_within</a></span> <span class="id">_</span>)). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cvg_app_within">cvg_app_within</a></span> {<span class="id"><a name="T:1406">T</a></span>} {<span class="id"><a name="U:1407">U</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id"><a name="f:1408">f</a></span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id"><a name="F:1409">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>))<br/>
&nbsp;&nbsp;(<span class="id"><a name="D:1410">D</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>): <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#cvg">cvg</a></span> (<span class="id">f</span> @ <span class="id">F</span>) -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#cvg">cvg</a></span> (<span class="id">f</span> @ <span class="id"><a href="mathcomp.analysis.topology.html#within">within</a></span> <span class="id">D</span> <span class="id">F</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof214')">Proof.</span></div>
<div class="proofscript" id="proof214">
 <span class="kwd">by</span> <span class="id">move</span> =&gt; <span class="id">FF</span> /<span class="id"><a href="mathcomp.analysis.topology.html#cvg_ex">cvg_ex</a></span> [<span class="id">l</span> <span class="id">H</span>]; <span class="id">apply</span>/<span class="id"><a href="mathcomp.analysis.topology.html#cvg_ex">cvg_ex</a></span>; <span class="kwd">exists</span> <span class="id">l</span>; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_within_filter">cvg_within_filter</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="nbhs_dnbhs">nbhs_dnbhs</a></span> {<span class="id"><a name="T:1411">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id"><a name="x:1412">x</a></span> : <span class="id">T</span>) : <span class="id">x</span>^' `=&gt;` <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof215')">Proof.</span></div>
<div class="proofscript" id="proof215">
 <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cvg_within">cvg_within</a></span>. Qed.</div>
<br/>
<div class="doc">meets </div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="meets_openr">meets_openr</a></span> {<span class="id"><a name="T:1413">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id"><a name="F:1414">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="x:1415">x</a></span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> `#` <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span> = <span class="id">F</span> `#` <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof216')">Proof.</span></div>
<div class="proofscript" id="proof216">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">propeqE</a></span>; <span class="id">split</span>; [<span class="id">exact</span>/<span class="id"><a href="mathcomp.classical.classical_sets.html#meetsSr">meetsSr</a></span>/<span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs_nbhs">open_nbhs_nbhs</a></span>|].<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">A</span> <span class="id">B</span> {}/<span class="id">P</span> <span class="id">P</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">nbhsE</a></span> =&gt; -[<span class="id">B</span>' /<span class="id">P</span> + <span class="id">sB</span>]; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#subsetI_neq0">subsetI_neq0</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="meets_openl">meets_openl</a></span> {<span class="id"><a name="T:1416">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>} (<span class="id"><a name="F:1417">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="x:1418">x</a></span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">x</span> `#` <span class="id">F</span> = <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">x</span> `#` <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof217')">Proof.</span></div>
<div class="proofscript" id="proof217">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#meetsC">meetsC</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#meets_openr">meets_openr</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#meetsC">meetsC</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="meets_globallyl">meets_globallyl</a></span> <span class="id"><a name="T:1419">T</a></span> (<span class="id"><a name="A:1420">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) <span class="id"><a name="G:1421">G</a></span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> <span class="id">A</span> `#` <span class="id">G</span> = <span class="kwd">forall</span> <span class="id"><a name="B:1422">B</a></span>, <span class="id">G</span> <span class="id">B</span> -&gt; <span class="id">A</span> `&amp;` <span class="id">B</span> !=<span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof218')">Proof.</span></div>
<div class="proofscript" id="proof218">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">propeqE</a></span>; <span class="id">split</span> =&gt; [/(<span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="kwd">fun</span>=&gt; <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">id</a></span>))//|<span class="id">clA</span> <span class="id">A</span>' <span class="id">B</span> <span class="id">sA</span>].<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">clA</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#subsetI_neq0">subsetI_neq0</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="meets_globallyr">meets_globallyr</a></span> <span class="id"><a name="T:1423">T</a></span> <span class="id"><a name="F:1424">F</a></span> (<span class="id"><a name="B:1425">B</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> `#` <span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> <span class="id">B</span> = <span class="kwd">forall</span> <span class="id"><a name="A:1426">A</a></span>, <span class="id">F</span> <span class="id">A</span> -&gt; <span class="id">A</span> `&amp;` <span class="id">B</span> !=<span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof219')">Proof.</span></div>
<div class="proofscript" id="proof219">
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#meetsC">meetsC</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#meets_globallyl">meets_globallyl</a></span>; <span class="id">under</span> <span class="id"><a href="mathcomp.classical.boolp.html#eq_forall">eq_forall</a></span> <span class="id">do</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setIC">setIC</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="meetsxx">meetsxx</a></span> <span class="id"><a name="T:1427">T</a></span> (<span class="id"><a name="F:1428">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="FF:1429">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Filter">Filter</a></span> <span class="id">F</span>) : <span class="id">F</span> `#` <span class="id">F</span> = ~ (<span class="id">F</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof220')">Proof.</span></div>
<div class="proofscript" id="proof220">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">propeqE</a></span>; <span class="id">split</span> =&gt; [<span class="id">FmF</span> <span class="id">F0</span>|]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">have</span> [<span class="id">x</span> []] := <span class="id">FmF</span> <span class="id">_</span> <span class="id">_</span> <span class="id">F0</span> <span class="id">F0</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">FN0</span> <span class="id">A</span> <span class="id">B</span> /<span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span> <span class="id">FAI</span> {}/<span class="id">FAI</span> <span class="id">FAB</span>; <span class="id">apply</span>/<span class="id"><a href="mathcomp.classical.classical_sets.html#set0P">set0P</a></span>/<span class="id">eqP</span> =&gt; <span class="id">AB0</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">AB0</span> <span class="kwd">in</span> <span class="id">FAB</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="proper_meetsxx">proper_meetsxx</a></span> <span class="id"><a name="T:1430">T</a></span> (<span class="id"><a name="F:1431">F</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">T</span>)) (<span class="id"><a name="FF:1432">FF</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> <span class="id">F</span>) : <span class="id">F</span> `#` <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof221')">Proof.</span></div>
<div class="proofscript" id="proof221">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#meetsxx">meetsxx</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_not_empty">filter_not_empty</a></span>. Qed.</div>
<br/>
<h2> Closed sets in topological spaces </h2>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="Closed">Closed</a></span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id"><a name="T:1433">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">topologicalType</a></span>}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="closure">closure</a></span> (<span class="id"><a name="A:1434">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Closed.T">T</a></span>) :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id"><a name="p:1435">p</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Closed.T">T</a></span> | <span class="kwd">forall</span> <span class="id"><a name="B:1436">B</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span> <span class="id">B</span> -&gt; <span class="id">A</span> `&amp;` <span class="id">B</span> !=<span class="id">set0</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="closure0">closure0</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#closure">closure</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span> = <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span> :&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Closed.T">T</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof222')">Proof.</span></div>
<div class="proofscript" id="proof222">
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">predeqE</a></span> =&gt; <span class="id">x</span>; <span class="id">split</span> =&gt; // /(<span class="id">_</span> <span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_nbhsT">filter_nbhsT</a></span> <span class="id">_</span>))/<span class="id"><a href="mathcomp.classical.classical_sets.html#set0P">set0P</a></span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0I">set0I</a></span> <span class="id">eqxx</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="closureEnbhs">closureEnbhs</a></span> <span class="id"><a name="A:1437">A</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#closure">closure</a></span> <span class="id">A</span> = [<span class="id">set</span> <span class="id"><a name="p:1438">p</a></span> | <span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> <span class="id">A</span> `#` <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs</a></span> <span class="id">p</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof223')">Proof.</span></div>
<div class="proofscript" id="proof223">
 <span class="kwd">by</span> <span class="id">under</span> <span class="id"><a href="mathcomp.classical.boolp.html#eq_fun">eq_fun</a></span> <span class="id">do</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#meets_globallyl">meets_globallyl</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="closureEonbhs">closureEonbhs</a></span> <span class="id"><a name="A:1439">A</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#closure">closure</a></span> <span class="id">A</span> = [<span class="id">set</span> <span class="id"><a name="p:1440">p</a></span> | <span class="id"><a href="mathcomp.analysis.topology.html#globally">globally</a></span> <span class="id">A</span> `#` <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">open_nbhs</a></span> <span class="id">p</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof224')">Proof.</span></div>
<div class="proofscript" id="proof224">
 <span class="kwd">by</span> <span class="id">under</span> <span class="id"><a href="mathcomp.classical.boolp.html#eq_fun">eq_fun</a></span> <span class="id">do</span> <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.analysis.topology.html#meets_openr">meets_openr</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#meets_globallyl">meets_globallyl</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="subset_closure">subset_closure</a></span> (<span class="id"><a name="A:1441">A</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#Closed.T">T</a></span>) : <span class="id">A</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#closure">closure</a></span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof225')">Proof.</span></div>
<div class="proofscript" id="proof225">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span> ??; <span class="kwd">exists</span> <span class="id">p</span>; <span class="id">split</span>=&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_singleton">nbhs_singleton</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="closureI">closure_eq0</a></span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">closure</span> <span class="id">A</span> = <span class="id">set0</span> -&gt; <span class="id">A</span> = <span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof226')">Proof.</span></div>
<div class="proofscript" id="proof226">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A0</span>; <span class="id">apply</span>/<span class="id">seteqP</span>; <span class="id">split</span> =&gt; //; <span class="id">rewrite</span> -<span class="id">A0</span>; <span class="id">exact</span>: <span class="id">subset_closure</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closureI</span> (<span class="id">A</span> <span class="id">B</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">closure</span> (<span class="id">A</span> `&amp;` <span class="id"><a name="U:1446">B</a></span>) `&lt;=` <span class="id">closure</span> <span class="id">A</span> `&amp;` <span class="id"><a name="y:1447">closure</a></span> <span class="id">B</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof227')">Proof.</span></div>
<div class="proofscript" id="proof227">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span> <span class="id">clABp</span>; <span class="id">split</span>=&gt; ? /<span class="id">clABp</span> [<span class="id">q</span> [[]]]; <span class="kwd">exists</span> <span class="id">q</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">limit_point</span> <span class="id">E</span> := [<span class="id">set</span> <span class="id">t</span> : <span class="id">T</span> |<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">U</span>, <span class="id">nbhs</span> <span class="id">t</span> <span class="id">U</span> -&gt; <span class="kwd">exists</span> <span class="id">y</span>, [/\ <span class="id">y</span> != <span class="id">t</span>, <span class="id">E</span> <span class="id">y</span> &amp; <span class="id">U</span> <span class="id">y</span>]].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">limit_pointEnbhs</span> <span class="id">E</span> :<br/>
&nbsp;&nbsp;<span class="id">limit_point</span> <span class="id">E</span> = [<span class="id">set</span> <span class="id">p</span> | <span class="id">globally</span> (<span class="id"><a href="mathcomp.classical.boolp.html#propeqE">E</a></span> `\ <span class="id">p</span>) `#` <span class="id">nbhs</span> <span class="id">p</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof228')">Proof.</span></div>
<div class="proofscript" id="proof228">
<span class="id">under</span> <span class="id">eq_fun</span> <span class="id">do</span> <span class="id">rewrite</span> <span class="id">meets_globallyl</span>; <span class="id"><a name="limit_pointEonbhs">rewrite</a></span> <span class="id">funeqE</span> =&gt; <span class="id"><a name="E:1450">p</a></span> /=.<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#limit_point">apply</a></span>/<span class="id">eq_forall2</span> =&gt; <span class="id">x</span> <span class="id">px</span>; <span class="id">apply</span>/<span class="id">eq_exists</span> =&gt; <span class="id">y</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span> =&gt; [[/<span class="id">eqP</span> ? ?]|[[? /<span class="id">eqP</span> ?]]]; <span class="id">do</span> 2?<span class="id">split</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">limit_pointEonbhs</span> <span class="id"><a name="subset_limit_point">E</a></span> :<br/>
&nbsp;&nbsp;<span class="id">limit_point</span> <span class="id">E</span> = [<span class="id"><a href="mathcomp.analysis.topology.html#limit_point">set</a></span> <span class="id">p</span> | <span class="id">globally</span> (<span class="id">E</span> `\ <span class="id">p</span>) `#` <span class="id">open_nbhs</span> <span class="id">p</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof229')">Proof.</span></div>
<div class="proofscript" id="proof229">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">limit_pointEnbhs</span>; <span class="id">under</span> <span class="id">eq_fun</span> <span class="id">do</span> <span class="id">rewrite</span> <span class="id">meets_openr</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="E:1453">subset_limit_point</a></span> <span class="id">E</span> : <span class="id">limit_point</span> <span class="id">E</span> `&lt;=` <span class="id">closure</span> <span class="id">E</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof230')">Proof.</span></div>
<div class="proofscript" id="proof230">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">t</span> <span class="id">Et</span> <span class="id">U</span> <span class="id">tU</span>; <span class="id">have</span> [<span class="id">p</span> [? ? ?]] := <span class="id">Et</span> <span class="id">_</span> <span class="id">tU</span>; <span class="kwd">exists</span> <span class="id">p</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closure_limit_point</span> <span class="id">E</span> : <span class="id">closure</span> <span class="id">E</span> = <span class="id">E</span> `|` <span class="id">limit_point</span> <span class="id">E</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof231')">Proof.</span></div>
<div class="proofscript" id="proof231">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">t</span>; <span class="id">split</span> =&gt; [<span class="id">cEt</span>|]; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>; [<span class="id">exact</span>: <span class="id">subset_closure</span>|<span class="id">exact</span>: <span class="id">subset_limit_point</span>].<br/>
<span class="id">have</span> [?|<span class="id">Et</span>] := <span class="id">pselect</span> (<span class="id">E</span> <span class="id">t</span>); [<span class="kwd">by</span> <span class="id">left</span>|<span class="id">right</span>=&gt; <span class="id">U</span> <span class="id">tU</span>; <span class="id">have</span> [<span class="id">p</span> []] := <span class="id">cEt</span> <span class="id"><a name="D:1455">_</a></span> <span class="id">tU</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">p</span>; <span class="id">split</span> =&gt; //; <span class="id">apply</span>/<span class="id">eqP</span> =&gt; <span class="id">pt</span>; <span class="id">apply</span>: <span class="id">Et</span>; <span class="id">rewrite</span> -<span class="id">pt</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">closed</span> (<span class="id">D</span> : <span class="id">set</span> <span class="id">T</span>) := <span class="id">closure</span> <span class="id">D</span> `&lt;=` <span class="id">D</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="f:1458">open_closedC</a></span> (<span class="id">D</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">open</span> <span class="id">D</span> -&gt; <span class="id">closed</span> (~` <span class="id">D</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof232')">Proof.</span></div>
<div class="proofscript" id="proof232">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">openE</span> =&gt; <span class="id">Dop</span> <span class="id">p</span> <span class="id">clNDp</span> /<span class="id">Dop</span> /<span class="id">clNDp</span> [? []]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_bigI</span> {<span class="id">I</span>} (<span class="id">D</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">closed</span> (<span class="id"><a name="closedI">f</a></span> <span class="id">i</span>)) -&gt; <span class="id"><a name="D:1461">closed</a></span> (\<span class="id">bigcap_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">D</span>) <span class="id">f</span> <span class="id"><a href="mathcomp.analysis.topology.html#closed">i</a></span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof233')">Proof.</span></div>
<div class="proofscript" id="proof233">
<span class="id">move</span>=&gt; <span class="id">fcl</span> <span class="id">t</span> <span class="id">clft</span> <span class="id">i</span> <span class="id">Di</span>; <span class="id">have</span> /<span class="id">fcl</span> := <span class="id">Di</span>; <span class="id">apply</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A</span> /<span class="id">clft</span> [<span class="id">s</span> [/(<span class="id">_</span> <span class="id">i</span> <span class="id">Di</span>)]]; <span class="kwd">exists</span> <span class="id">s</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closedI</span> (<span class="id">D</span> <span class="id">E</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">closed</span> <span class="id">D</span> -&gt; <span class="id">closed</span> <span class="id">E</span> -&gt; <span class="id">closed</span> (<span class="id">D</span> `&amp;` <span class="id">E</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof234')">Proof.</span></div>
<div class="proofscript" id="proof234">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Dcl</span> <span class="id">Ecl</span> <span class="id">p</span> <span class="id">clDEp</span>; <span class="id">split</span>; [<span class="id">apply</span>: <span class="id">Dcl</span>|<span class="id">apply</span>: <span class="id">Ecl</span>];<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">A</span> /<span class="id">clDEp</span> [<span class="id">q</span> [[]]]; <span class="kwd">exists</span> <span class="id">q</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closedT</span> : <span class="id">closed</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">setT</a></span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof235')">Proof.</span></div>
<div class="proofscript" id="proof235">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed0</span> : <span class="id">closed</span> <span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof236')">Proof.</span></div>
<div class="proofscript" id="proof236">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? /(<span class="id">_</span> <span class="id">setT</span>) [|? []] //; <span class="id">apply</span>: <span class="id">filterT</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closedE</span> : <span class="id">closed</span> = [<span class="id">set</span> <span class="id">A</span> : <span class="id">set</span> <span class="id">T</span> | <span class="kwd">forall</span> <span class="id">p</span>, ~ (\<span class="id">near</span> <span class="id">p</span>, ~ <span class="id">A</span> <span class="id">p</span>) -&gt; <span class="id">A</span> <span class="id">p</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof237')">Proof.</span></div>
<div class="proofscript" id="proof237">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">A</span>; <span class="id">split</span>=&gt; <span class="id">Acl</span> <span class="id">p</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">clAp</span>; <span class="id">apply</span>: <span class="id">Acl</span>; <span class="id">rewrite</span> -<span class="id">nbhs_nearE</span> =&gt; /<span class="id">clAp</span> [? []].<br/>
<span class="id">rewrite</span> -<span class="id">nbhs_nearE</span> <span class="id">nbhsE</span> =&gt; /<span class="id">asboolP</span>.<br/>
<span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">forallp_asboolPn2</span> <span class="id">clAp</span>.<br/>
<span class="id">apply</span>: <span class="id">Acl</span> =&gt; <span class="id">B</span>; <span class="id">rewrite</span> <span class="id">nbhsE</span> =&gt; - [<span class="id">C</span> [<span class="id">oC</span> <span class="id">pC</span>]].<br/>
<span class="id">have</span> /<span class="id">asboolP</span> := <span class="id">clAp</span> <span class="id">C</span>.<br/>
<span class="id">rewrite</span> <span class="id">asbool_or</span> 2!<span class="id">asbool_neg</span> =&gt; /<span class="id">orP</span>[/<span class="id">asboolP</span>/<span class="id">not_andP</span>[]//|/<span class="id">existsp_asboolPn</span> [<span class="id">q</span>]].<br/>
<span class="id">move</span>/<span class="id">asboolP</span>; <span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">imply_asboolPn</span>[+ /<span class="id">contrapT</span> <span class="id">Aq</span> <span class="id">sCB</span>] =&gt; /<span class="id">sCB</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">q</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_openC</span> (<span class="id">D</span> : <span class="id">set</span> <span class="id"><a name="D:1469">T</a></span>) : <span class="id">closed</span> <span class="id">D</span> -&gt; <span class="id">open</span> (~` <span class="id">D</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof238')">Proof.</span></div>
<div class="proofscript" id="proof238">
<span class="id">rewrite</span> <span class="id">closedE</span> <span class="id"><a href="mathcomp.classical.boolp.html#propext">openE</a></span> =&gt; <span class="id">Dcl</span> <span class="id">t</span> <span class="id">nDt</span>; <span class="id">apply</span>: <span class="id">contrapT</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">interior</span> <span class="id">nbhs_nearE</span> =&gt; /<span class="id">Dcl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closedC</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Closed.T">D</a></span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">closed</span> (~` <span class="id">D</span>) = <span class="id">open</span> <span class="id">D</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof239')">Proof.</span></div>
<div class="proofscript" id="proof239">
<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">propext</span>; <span class="id">split</span>=&gt; [/<span class="id">closed_openC</span>|]; [<span class="id">rewrite</span> <span class="id">setCK</span>|<span class="id">exact</span>: <span class="id">open_closedC</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">openC</span> (<span class="id">D</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">open</span> (~`<span class="id">D</span>) = <span class="id">closed</span> (<span class="id">D</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof240')">Proof.</span></div>
<div class="proofscript" id="proof240">
 <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">closedC</span> <span class="id">setCK</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_closure</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">closed</span> (<span class="id">closure</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">A</a></span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof241')">Proof.</span></div>
<div class="proofscript" id="proof241">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span> <span class="id">clclAp</span> <span class="id">B</span> /<span class="id">nbhs_interior</span> /<span class="id">clclAp</span> [<span class="id">q</span> [<span class="id">clAq</span> /<span class="id">clAq</span>]]. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">Closed</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_comp</span> {<span class="id">T</span> <span class="id">U</span> : <span class="id">topologicalType</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">D</span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#contra_not">set</a></span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> ~` <span class="id">f</span> @^-1` <span class="id">D</span>, <span class="id">continuous</span> <span class="id">f</span>} -&gt; <span class="id">closed</span> <span class="id">D</span> -&gt; <span class="id">closed</span> (<span class="id">f</span> @^-1` <span class="id">D</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof242')">Proof.</span></div>
<div class="proofscript" id="proof242">
<span class="id">rewrite</span> !<span class="id">closedE</span>=&gt; <span class="id">f_continuous</span> <span class="id">D_cl</span> <span class="id">x</span> /= <span class="id">xDf</span>.<br/>
<span class="id">apply</span>: <span class="id">D_cl</span>; <span class="id">apply</span>: <span class="id">contra_not</span> <span class="id">xDf</span> =&gt; <span class="id">fxD</span>.<br/>
<span class="id">have</span> <span class="id"><a name="V:1477">NDfx</a></span> : ~ <span class="id">D</span> (<span class="id">f</span> <span class="id">x</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>: <span class="id">fxD</span>; <span class="id">rewrite</span> -<span class="id">nbhs_nearE</span> <span class="id">nbhsE</span> =&gt; - [<span class="id"><a name="A:1481">A</a></span> [? ?]]; <span class="id">apply</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">f_continuous</span> <span class="id">fxD</span>; <span class="id">rewrite</span> <span class="id">inE</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_cvg</span> {<span class="id">T</span>} {<span class="id">V</span> : <span class="id">topologicalType</span>} {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">u_</span> : <span class="id">T</span> -&gt; <span class="id">V</span>) (<span class="id">A</span> : <span class="id">V</span> -&gt; <span class="kwd">Prop</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">closed</span> <span class="id">A</span> -&gt; (\<span class="kwd">forall</span> <span class="id">n</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">A</span> (<span class="id">u_</span> <span class="id">n</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">l</span>, <span class="id">u_</span> @ <span class="id">F</span> --&gt; <span class="id">l</span> -&gt; <span class="id">A</span> <span class="id">l</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof243')">Proof.</span></div>
<div class="proofscript" id="proof243">
<span class="id">move</span>=&gt; + <span class="id">FAu_</span> <span class="id">l</span> <span class="id">u_Fl</span>; <span class="id">apply</span> =&gt; <span class="id">B</span> /<span class="id">u_Fl</span> /=; <span class="id">rewrite</span> <span class="id">nbhs_filterE</span>.<br/>
<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">move</a></span>=&gt; /(<span class="id">filterI</span> <span class="id">FAu_</span>) =&gt; /<span class="id">filter_ex</span>[<span class="id">t</span> [<span class="id">Au_t</span> <span class="id">u_Bt</span>]]; <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.analysis.topology.html#closed">u_</a></span> <span class="id">t</span>).<br/>
Qed.</div>
<span class="kwd">Arguments</span> <span class="id">closed_cvg</span> {<span class="id">T</span> <span class="id">V</span> <span class="id">F</span> <span class="id">FF</span> <span class="id">u_</span>} <span class="id"><a href="mathcomp.analysis.topology.html#continuousP">_</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_closedP</span> (<span class="id">S</span> <span class="id">T</span> : <span class="id">topologicalType</span>) (<span class="id">f</span> : <span class="id">S</span> -&gt; <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">continuous</span> <span class="id">f</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id">A</span>, <span class="id">closed</span> <span class="id">A</span> -&gt; <span class="id">closed</span> (<span class="id">f</span> @^-1` <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof244')">Proof.</span></div>
<div class="proofscript" id="proof244">
<span class="id">rewrite</span> <span class="id">continuousP</span>; <span class="id">split</span>=&gt; <span class="id">ctsf</span> ? ?.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">openC</span> <span class="id">preimage_setC</span>; <span class="id">apply</span>: <span class="id">ctsf</span>; <span class="id"><a href="mathcomp.analysis.topology.html#closed">rewrite</a></span> <span class="id">openC</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">closedC</span> <span class="id">preimage_setC</span>; <span class="id"><a href="mathcomp.analysis.topology.html#openC">apply</a></span>: <span class="id">ctsf</span>; <span class="id">rewrite</span> <span class="id">closedC</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closedU</span> (<span class="id">T</span> : <span class="id"><a name="T:1491">topologicalType</a></span>) (<span class="id">D</span> <span class="id">E</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a name="s:1493">closed</a></span> <span class="id">D</span> -&gt; <span class="id">closed</span> <span class="id">E</span> -&gt; <span class="id">closed</span> (<span class="id">D</span> `|` <span class="id">E</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof245')">Proof.</span></div>
<div class="proofscript" id="proof245">
 <span class="kwd">by</span> <span class="id">rewrite</span> -?<span class="id">openC</span> <span class="id">setCU</span>; <span class="id"><a href="mathcomp.analysis.topology.html#closed">exact</a></span>: <span class="id">openI</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_bigsetU</span> (<span class="id">T</span> : <span class="id">topologicalType</span>) (<span class="id">I</span> : <span class="id">eqType</span>) (<span class="id">s</span> : <span class="id">seq</span> <span class="id">I</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>) : (<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">x</span> \<span class="kwd">in</span> <span class="id">s</span> -&gt; <span class="id">closed</span> (<span class="id">F</span> <span class="id">x</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">closed</span> (\<span class="id">big</span>[<span class="id">setU</span>/<span class="id">set0</span>]<span class="id">_</span>(<span class="id">x</span> &lt;- <span class="id">s</span>) <span class="id">F</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof246')">Proof.</span></div>
<div class="proofscript" id="proof246">
<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">scF</a></span>; <span class="id">rewrite</span> <span class="id">big_seq</span>.<br/>
<span class="kwd">by</span> <span class="id">elim</span>/<span class="id">big_ind</span> : <span class="id">_</span> =&gt; //; [<span class="id">exact</span>: <span class="id">closed0</span>|<span class="id">exact</span>: <span class="id">closedU</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_bigcup</span> (<span class="id">T</span> : <span class="id">topologicalType</span>) (<span class="id">I</span> : <span class="id">choiceType</span>) (<span class="id">A</span> : <span class="id">set</span> <span class="id">I</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#closed_bigsetU">T</a></span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span> <span class="id">A</span> -&gt; (<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">A</span> <span class="id">i</span> -&gt; <span class="id">closed</span> (<span class="id">F</span> <span class="id">i</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">closed</span> (\<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">A</span>) <span class="id">F</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof247')">Proof.</span></div>
<div class="proofscript" id="proof247">
<span class="id">move</span>=&gt; <span class="id">finA</span> <span class="id">cF</span>; <span class="id">rewrite</span> -<span class="id">bigsetU_fset_set</span>//; <span class="id">apply</span>: <span class="id">closed_bigsetU</span> =&gt; <span class="id">i</span>.<br/>
<span class="kwd">by</span> <span class="id"><a name="A:1506">rewrite</a></span> <span class="id">in_fset_set</span>// <span class="id">inE</span>; <span class="id">exact</span>: <span class="id">cF</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">closure_lemmas</span>.<br/>
<span class="kwd">Variable</span> <span class="id">T</span> : <span class="id">topologicalType</span>.<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> <span class="id">E</span> <span class="id">A</span> <span class="id">B</span> <span class="id">U</span> : <span class="id"><a name="A:1508">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#closure">T</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">closure_subset</span> <span class="id">A</span> <span class="id">B</span> : <span class="id">A</span> `&lt;=` <span class="id">B</span> -&gt; <span class="id">closure</span> <span class="id">A</span> `&lt;=` <span class="id">closure</span> <span class="id">B</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof248')">Proof.</span></div>
<div class="proofscript" id="proof248">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? <span class="id">CAx</span> ?; <span class="id">move</span>/<span class="id">CAx</span>; <span class="id">exact</span>/<span class="id">subsetI_neq0</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closureE</span> <span class="id">A</span> : <span class="id">closure</span> <span class="id">A</span> = <span class="id"><a href="mathcomp.analysis.topology.html#subset_closure">smallest</a></span> <span class="id">closed</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof249')">Proof.</span></div>
<div class="proofscript" id="proof249">
<span class="id">rewrite</span> <span class="id"><a name="closureC">eqEsubset</a></span>; <span class="id">split</span>=&gt; [<span class="id">x</span> ? <span class="id">B</span> [<span class="id">cB</span> <span class="id">AB</span>]|]; <span class="id">first</span> <span class="id">exact</span>/<span class="id"><a name="U:1510">cB</a></span>/(<span class="id"><a href="mathcomp.analysis.topology.html#open">closure_subset</a></span> <span class="id">AB</span>).<br/>
<span class="id">exact</span>: (<span class="id">smallest_sub</span> (@<span class="id">closed_closure</span> <span class="id">_</span> <span class="id">_</span>) (@<span class="id">subset_closure</span> <span class="id">_</span> <span class="id">_</span>)).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closureC</span> <span class="id">E</span> :<br/>
&nbsp;&nbsp;~` <span class="id">closure</span> <span class="id">E</span> = \<span class="id">bigcup_</span>(<span class="id">x</span> <span class="kwd">in</span> [<span class="id">set</span> <span class="id">U</span> | <span class="id">open</span> <span class="id">U</span> /\ <span class="id">U</span> `&lt;=` ~` <span class="id">E</span>]) <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof250')">Proof.</span></div>
<div class="proofscript" id="proof250">
<span class="id">rewrite</span> <span class="id">closureE</span> <span class="id">setC_bigcap</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id">t</span> [<span class="id">U</span> [? <span class="id">EU</span> <span class="id">Ut</span>]].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (~` <span class="id">U</span>) =&gt; //; <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">closed_openC</span>|<span class="id">exact</span>: <span class="id">subsetC</span>].<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -(<span class="id">setCK</span> <span class="id">E</span>); <span class="kwd">exists</span> (~` <span class="id">U</span>)=&gt; //; <span class="id">split</span>; [<span class="id">exact</span>:<span class="id">open_closedC</span>|<span class="id">exact</span>:<span class="id">subsetC</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closure_id</span> <span class="id">E</span> : <span class="id">closed</span> <span class="id">E</span> &lt;-&gt; <span class="id">E</span> = <span class="id">closure</span> <span class="id">E</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof251')">Proof.</span></div>
<div class="proofscript" id="proof251">
<span class="id">split</span>=&gt; [?|-&gt;]; <span class="id">last</span> <span class="id">exact</span>: <span class="id">closed_closure</span>.<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">subset_closure</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">closure_lemmas</span>.<br/>
<br/>
<h2> Compact sets </h2>
<br/>
<span class="kwd">Section</span> <span class="id">Compact</span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id">topologicalType</span>}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">cluster</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) := [<span class="id">set</span> <span class="id">p</span> : <span class="id">T</span> | <span class="id">F</span> `#` <span class="id">nbhs</span> <span class="id">p</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cluster_nbhs</span> <span class="id">t</span> : <span class="id">cluster</span> (<span class="id">nbhs</span> <span class="id">t</span>) <span class="id">t</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof252')">Proof.</span></div>
<div class="proofscript" id="proof252">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> /<span class="id">nbhs_singleton</span> <span class="id">At</span> /<span class="id">nbhs_singleton</span> <span class="id">Bt</span>; <span class="kwd">exists</span> <span class="id">t</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clusterEonbhs</span> <span class="id">F</span> : <span class="id">cluster</span> <span class="id">F</span> = [<span class="id">set</span> <span class="id">p</span> | <span class="id">F</span> `#` <span class="id">open_nbhs</span> <span class="id">p</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof253')">Proof.</span></div>
<div class="proofscript" id="proof253">
 <span class="kwd">by</span> <span class="id">under</span> <span class="id">eq_fun</span> <span class="id">do</span> <span class="id">rewrite</span> -<span class="id"><a name="closureEcluster">meets_openr</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clusterE</span> <span class="id">F</span> : <span class="id">cluster</span> <span class="id">F</span> = \<span class="id">bigcap_</span>(<span class="id">A</span> <span class="kwd">in</span> <span class="id">F</span>) (<span class="id">closure</span> <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof254')">Proof.</span></div>
<div class="proofscript" id="proof254">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a name="cvg_cluster">predeqE</a></span> =&gt; <span class="id">p</span>; <span class="id"><a name="G:1523">split</a></span>=&gt; <span class="id">cF</span> ????; <span class="id">apply</span>: <span class="id">cF</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closureEcluster</span> <span class="id">E</span> : <span class="id">closure</span> <span class="id">E</span> = <span class="id">cluster</span> (<span class="id">globally</span> <span class="id">E</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof255')">Proof.</span></div>
<div class="proofscript" id="proof255">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">closureEnbhs</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_cluster</span> <span class="id">F</span> <span class="id">G</span> : <span class="id">F</span> --&gt; <span class="id">G</span> -&gt; <span class="id">cluster</span> <span class="id">F</span> `&lt;=` <span class="id">cluster</span> <span class="id">G</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof256')">Proof.</span></div>
<div class="proofscript" id="proof256">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">sGF</span> <span class="id">p</span> <span class="id">Fp</span> <span class="id">P</span> <span class="id">Q</span> <span class="id">GP</span> <span class="id">Qp</span>; <span class="id">apply</span>: <span class="id">Fp</span> <span class="id">Qp</span>; <span class="id">apply</span>: <span class="id">sGF</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cluster_cvgE</span> <span class="id">F</span> :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">cluster</span> <span class="id">F</span> = [<span class="id">set</span> <span class="id">p</span> | <span class="kwd">exists2</span> <span class="id">G</span>, <span class="id">ProperFilter</span> <span class="id">G</span> &amp; <span class="id">G</span> --&gt; <span class="id">p</span> /\ <span class="id">F</span> `&lt;=` <span class="id">G</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof257')">Proof.</span></div>
<div class="proofscript" id="proof257">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">have</span> [<span class="id">F0</span>|<span class="id"><a href="mathcomp.classical.classical_sets.html#subset0">nF0</a></span>] := <span class="id">pselect</span> (<span class="id">F</span> <span class="id">set0</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span> -&gt; : <span class="id">cluster</span> <span class="id">F</span> = <span class="id">set0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">subset0</span> <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">clusterE</a></span> =&gt; <span class="id">x</span> /(<span class="id">_</span> <span class="id">set0</span> <span class="id">F0</span>); <span class="id">rewrite</span> <span class="id">closure0</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">esym</span>; <span class="id">rewrite</span> -<span class="id">subset0</span> =&gt; <span class="id">p</span> [? <span class="id">PG</span> [<span class="id">_</span> /(<span class="id">_</span> <span class="id">set0</span> <span class="id">F0</span>)]]; <span class="id">apply</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">PG</a></span>.<br/>
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id"><a href="mathcomp.analysis.topology.html#filterI">p</a></span>; <span class="id">have</span> <span class="id">PF</span> : <span class="id">ProperFilter</span> <span class="id">F</span> <span class="kwd">by</span> [].<br/>
<span class="id">split</span>=&gt; [<span class="id">clFp</span>|[<span class="id">G</span> <span class="id">Gproper</span> [<span class="id">cvGp</span> <span class="id">sFG</span>]] <span class="id">A</span> <span class="id">B</span>]; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">sFG</span> <span class="id">GA</span> /<span class="id">cvGp</span> <span class="id">GB</span>; <span class="id">apply</span>: (@<span class="id">filter_ex</span> <span class="id">_</span> <span class="id">G</span>); <span class="id">apply</span>: <span class="id">filterI</span>.<br/>
<span class="kwd">exists</span> (<span class="id">filter_from</span> (\<span class="id">bigcup_</span>(<span class="id"><a href="mathcomp.analysis.topology.html#filter_from_filter">A</a></span> <span class="kwd">in</span> <span class="id">F</span>) [<span class="id">set</span> <span class="id">A</span> `&amp;` <span class="id">B</span> | <span class="id">B</span> <span class="kwd">in</span> <span class="id">nbhs</span> <span class="id">p</span>]) <span class="id">id</span>).<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.classical_sets.html#setT">apply</a></span>: <span class="id">filter_from_proper</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">_</span> [<span class="id"><a href="mathcomp.analysis.topology.html#filterT">A</a></span> <span class="id">FA</span> [<span class="id">B</span> <span class="id">p_B</span> &lt;-]]; <span class="id">have</span> := <span class="id">clFp</span> <span class="id">_</span> <span class="id">_</span> <span class="id">FA</span> <span class="id">p_B</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">filter_from_filter</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">setT</span>; <span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">filterT</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">setT</span>; [<span class="id">apply</span>: <span class="id">filterT</span>|<span class="id">rewrite</span> <span class="id">setIT</span>].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">_</span> <span class="id">_</span> [<span class="id">A1</span> <span class="id">FA1</span> [<span class="id">B1</span> <span class="id">p_B1</span> &lt;-]] [<span class="id">A2</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setIACA">FA2</a></span> [<span class="id">B2</span> <span class="id">p_B2</span> &lt;-]].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">A1</span> `&amp;` <span class="id">B1</span> `&amp;` (<span class="id">A2</span> `&amp;` <span class="id">B2</span>)) =&gt; //; <span class="kwd">exists</span> (<span class="id">A1</span> `&amp;` <span class="id">A2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">filterI</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">B1</span> `&amp;` <span class="id">B2</span>); [<span class="id">apply</span>: <span class="id">filterI</span>|<span class="id">rewrite</span> <span class="id">setIACA</span>].<br/>
<span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">A</a></span> <span class="id">p_A</span>; <span class="kwd">exists</span> <span class="id">A</span> =&gt; //; <span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">filterT</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">A</span> =&gt; //; <span class="id"><a href="mathcomp.analysis.topology.html#Compact.T">rewrite</a></span> <span class="id">setIC</span> <span class="id">setIT</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">FA</span>; <span class="kwd">exists</span> <span class="id">A</span> =&gt; //; <span class="kwd">exists</span> <span class="id">A</span> =&gt; //; <span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">filterT</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">setIT</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closureEcvg</span> (<span class="id">E</span> : <span class="id">set</span> <span class="id">T</span>):<br/>
&nbsp;&nbsp;<span class="id">closure</span> <span class="id">E</span> =<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">p</span> | <span class="kwd">exists2</span> <span class="id">G</span>, <span class="id">ProperFilter</span> <span class="id">G</span> &amp; <span class="id">G</span> --&gt; <span class="id">p</span> /\ <span class="id">globally</span> <span class="id">E</span> `&lt;=` <span class="id">G</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof258')">Proof.</span></div>
<div class="proofscript" id="proof258">
 <span class="kwd">by</span> <span class="id"><a name="compact0">rewrite</a></span> <span class="id">closureEcluster</span> <span class="id">cluster_cvgE</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">compact</span> <span class="id">A</span> := <span class="kwd">forall</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)),<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">F</span> -&gt; <span class="id">F</span> <span class="id">A</span> -&gt; <span class="id">A</span> `&amp;` <span class="id">cluster</span> <span class="id">F</span> !=<span class="id">set0</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact0</span> : <span class="id">compact</span> <span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof259')">Proof.</span></div>
<div class="proofscript" id="proof259">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">F</span> <span class="id">FF</span> /<span class="id">filter_ex</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">subclosed_compact</span> (<span class="id">A</span> <span class="id">B</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">closed</span> <span class="id">A</span> -&gt; <span class="id">compact</span> <span class="id">B</span> -&gt; <span class="id">A</span> `&lt;=` <span class="id">B</span> -&gt; <span class="id">compact</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof260')">Proof.</span></div>
<div class="proofscript" id="proof260">
<span class="id">move</span>=&gt; <span class="id">Acl</span> <span class="id">Bco</span> <span class="id">sAB</span> <span class="id">F</span> <span class="id">Fproper</span> <span class="id">FA</span>.<br/>
<span class="id">have</span> [|<span class="id">p</span> [<span class="id">Bp</span> <span class="id">Fp</span>]] := <span class="id">Bco</span> <span class="id">F</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">filterS</span> <span class="id">FA</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">p</span>; <span class="id">split</span>=&gt; //; <span class="id">apply</span>: <span class="id">Acl</span>=&gt; <span class="id">C</span> <span class="id">Cp</span>; <span class="id">apply</span>: <span class="id">Fp</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a href="mathcomp.analysis.topology.html#closure">hausdorff_space</a></span> := <span class="kwd">forall</span> <span class="id">p</span> <span class="id">q</span> : <span class="id">T</span>, <span class="id">cluster</span> (<span class="id">nbhs</span> <span class="id">p</span>) <span class="id">q</span> -&gt; <span class="id">p</span> = <span class="id">q</span>.<br/>
<br/>
<span class="id">Typeclasses</span> <span class="kwd">Opaque</span> <span class="id">within</span>.<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id">within_nbhs_proper</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) <span class="id">p</span> :<br/>
&nbsp;&nbsp;<span class="id">infer</span> (<span class="id">closure</span> <span class="id">A</span> <span class="id">p</span>) -&gt; <span class="id">ProperFilter</span> (<span class="id">within</span> <span class="id">A</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">nbhs</a></span> <span class="id">p</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof261')">Proof.</span></div>
<div class="proofscript" id="proof261">
<span class="id">move</span>=&gt; <span class="id">clAp</span>; <span class="id">apply</span>: <span class="id">Build_ProperFilter</span> =&gt; <span class="id">B</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">clAp</span> [<span class="id">q</span> [<span class="id">Aq</span> <span class="id">AqsoBq</span>]]; <span class="kwd">exists</span> <span class="id">q</span>; <span class="id">apply</span>: <span class="id">AqsoBq</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_closed</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">hausdorff_space</span> -&gt; <span class="id">compact</span> <span class="id">A</span> -&gt; <span class="id">closed</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof262')">Proof.</span></div>
<div class="proofscript" id="proof262">
<span class="id">move</span>=&gt; <span class="id">hT</span> <span class="id">Aco</span> <span class="id">p</span> <span class="id">clAp</span>; <span class="id">have</span> <span class="id">pA</span> := !! @<span class="id">withinT</span> <span class="id">_</span> (<span class="id">nbhs</span> <span class="id">p</span>) <span class="id">A</span> <span class="id">_</span>.<br/>
<span class="id">have</span> [<span class="id">q</span> [<span class="id">Aq</span> <span class="id">clsAp_q</span>]] := !! <span class="id">Aco</span> <span class="id">_</span> <span class="id">_</span> <span class="id">pA</span>; <span class="id">rewrite</span> (<span class="id">hT</span> <span class="id">p</span> <span class="id">q</span>) //.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">cvg_cluster</span> <span class="id">clsAp_q</span>; <span class="id">apply</span>: <span class="id">cvg_within</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_set1</span> (<span class="id">x</span> : <span class="id">T</span>) : <span class="id">compact</span> [<span class="id">set</span> <span class="id">x</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof263')">Proof.</span></div>
<div class="proofscript" id="proof263">
<span class="id">move</span>=&gt; <span class="id">F</span> <span class="id">PF</span> <span class="id">Fx</span>; <span class="kwd">exists</span> <span class="id">x</span>; <span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> [].<br/>
<span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">B</span> <span class="id">nbhsB</span>; <span class="kwd">exists</span> <span class="id">x</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">nbhs_singleton</span>.<br/>
<span class="id">suff</span> [<span class="id">y</span> [<span class="id">Py</span> &lt;-//]] : <span class="id">P</span> `&amp;` [<span class="id">set</span> <span class="id">x</span>] !=<span class="id">set0</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filter_ex</span>; [<span class="id">exact</span>: <span class="id">PF</span>| <span class="id">exact</span>: <span class="id">filterI</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">Compact</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">hausdorff_space</span> : <span class="id">clear</span> <span class="id">implicits</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a href="mathcomp.analysis.topology.html#clopen">ClopenSets</a></span>.<br/>
<span class="kwd">Implicit</span> <span class="kwd">Type</span> <span class="id">T</span> : <span class="id">topologicalType</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">clopen</span> {<span class="id">T</span>} (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) := <span class="id">open</span> <span class="id">A</span> /\ <span class="id">closed</span> <span class="id">A</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopenI</span> {<span class="id">T</span>} (<span class="id">A</span> <span class="id">B</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">clopen</span> <span class="id">A</span> -&gt; <span class="id">clopen</span> <span class="id">B</span> -&gt; <span class="id">clopen</span> (<span class="id">A</span> `&amp;` <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof264')">Proof.</span></div>
<div class="proofscript" id="proof264">
 <span class="kwd">by</span> <span class="id">case</span>=&gt; ? ? [] ? ?; <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">openI</span> | <span class="id">exact</span>: <span class="id">closedI</span>]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopenU</span> {<span class="id">T</span>} (<span class="id">A</span> <span class="id">B</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">clopen</span> <span class="id">A</span> -&gt; <span class="id">clopen</span> <span class="id">B</span> -&gt; <span class="id">clopen</span> (<span class="id">A</span> `|` <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof265')">Proof.</span></div>
<div class="proofscript" id="proof265">
 <span class="kwd">by</span> <span class="id">case</span>=&gt; ? ? [] ? ?; <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">openU</span> | <span class="id">exact</span>: <span class="id">closedU</span>]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopenC</span> {<span class="id">T</span>} (<span class="id">A</span> <span class="id">B</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">clopen</span> <span class="id">A</span> -&gt; <span class="id">clopen</span> (~`<span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof266')">Proof.</span></div>
<div class="proofscript" id="proof266">
 <span class="kwd">by</span> <span class="id">case</span>=&gt; ? ?; <span class="id">split</span>;[<span class="id">exact</span>: <span class="id">closed_openC</span> | <span class="id">exact</span>: <span class="id">open_closedC</span> ]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopen0</span> {<span class="id">T</span>} : @<span class="id">clopen</span> <span class="id">T</span> <span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof267')">Proof.</span></div>
<div class="proofscript" id="proof267">
 <span class="kwd">by</span> <span class="id">split</span>; [<span class="id"><a name="U:1560">exact</a></span>: <span class="id">open0</span> | <span class="id">exact</span>: <span class="id"><a name="f:1561">closed0</a></span>]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopenT</span> {<span class="id">T</span>} : <span class="id">clopen</span> [<span class="id">set</span>: <span class="id">T</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof268')">Proof.</span></div>
<div class="proofscript" id="proof268">
 <span class="kwd">by</span> <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">openT</span> | <span class="id">exact</span>: <span class="id">closedT</span>]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopen_comp</span> {<span class="id">T</span> <span class="id">U</span> : <span class="id">topologicalType</span>} (<span class="id">f</span> : <span class="id"><a href="mathcomp.analysis.topology.html#ClopenSets">T</a></span> -&gt; <span class="id">U</span>) (<span class="id">A</span> : <span class="id">set</span> <span class="id">U</span>) :<br/>
&nbsp;<span class="id">clopen</span> <span class="id">A</span> -&gt; <span class="id">continuous</span> <span class="id">f</span> -&gt; <span class="id">clopen</span> (<span class="id">f</span> @^-1` <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof269')">Proof.</span></div>
<div class="proofscript" id="proof269">
 <span class="kwd">by</span> <span class="id">case</span>=&gt; ? ?; <span class="id">split</span>; [ <span class="id"><a href="mathcomp.analysis.topology.html#near_covering.X">exact</a></span>: <span class="id">open_comp</span> | <span class="id">exact</span>: <span class="id">closed_comp</span>]. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">ClopenSets</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">near_covering</span>.<br/>
<span class="kwd">Context</span> {<span class="id">X</span> : <span class="id">topologicalType</span>}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">near_covering</span> (<span class="id">K</span> : <span class="id">set</span> <span class="id">X</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">I</span> : <span class="kwd">Type</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">I</span>)) (<span class="id">P</span> : <span class="id">I</span> -&gt; <span class="id">X</span> -&gt; <span class="kwd">Prop</span>),<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">K</span> <span class="id">x</span> -&gt; \<span class="kwd">forall</span> <span class="id">x</span>' \<span class="id">near</span> <span class="id">x</span> &amp; <span class="id">i</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">P</span> <span class="id">i</span> <span class="id">x</span>') -&gt;<br/>
&nbsp;&nbsp;\<span class="id">near</span> <span class="id">F</span>, <span class="id">K</span> `&lt;=` <span class="id">P</span> <span class="id">F</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">near_covering_compact</span> : <span class="id">near_covering</span> `&lt;=` <span class="id">compact</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof270')">Proof.</span></div>
<div class="proofscript" id="proof270">
<span class="id">move</span>=&gt; <span class="id">K</span> <span class="id">locK</span> <span class="id">F</span> <span class="id">PF</span> <span class="id">FK</span>; <span class="id">apply</span>/<span class="id">set0P</span>/<span class="id">eqP</span>=&gt; <span class="id">KclstF0</span>; <span class="id">case</span>: (<span class="id">PF</span>) =&gt; + <span class="id">FF</span>; <span class="id">apply</span>.<br/>
<span class="id">rewrite</span> (<span class="id">_</span> : <span class="id">xpredp0</span> = <span class="id">set0</span>)// -(<span class="id">setICr</span> <span class="id">K</span>); <span class="id">apply</span>: <span class="id">filterI</span> =&gt; //.<br/>
<span class="id">have</span> /<span class="id">locK</span> : <span class="kwd">forall</span> <span class="id">x</span>, <span class="id">K</span> <span class="id">x</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;\<span class="kwd">forall</span> <span class="id">x</span>' \<span class="id">near</span> <span class="id">x</span> &amp; <span class="id">i</span> \<span class="id">near</span> <span class="id">powerset_filter_from</span> <span class="id">F</span>, (~` <span class="id">i</span>) <span class="id">x</span>'.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">Kx</span>; <span class="id">have</span> : ~ <span class="id">cluster</span> <span class="id">F</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">contraPnot</span> <span class="id">KclstF0</span> =&gt; <span class="id">clstFx</span>; <span class="id">apply</span>/<span class="id">eqP</span>/<span class="id">set0P</span>; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /<span class="id">existsNP</span> [<span class="id">U</span> /<span class="id">existsNP</span> [<span class="id">V</span> /<span class="id">not_implyP</span> [<span class="id">FU</span> /<span class="id">not_implyP</span> [<span class="id">nbhsV</span>]]]] <span class="id">UV0</span>.<br/>
&nbsp;&nbsp;<span class="id">near</span>=&gt; <span class="id">x</span>' <span class="id">W</span> =&gt; //= =&gt; <span class="id">Wx</span>'; <span class="id">apply</span>: <span class="id">UV0</span>; <span class="kwd">exists</span> <span class="id">x</span>'.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span>; [<span class="id">exact</span>: (<span class="id">near</span> (<span class="id">small_set_sub</span> <span class="id">FU</span>) <span class="id">W</span>) | <span class="id">exact</span>: (<span class="id">near</span> <span class="id">nbhsV</span> <span class="id">x</span>')].<br/>
<span class="id">case</span>=&gt; <span class="id">G</span> [<span class="id">GF</span> <span class="id">Gdown</span> [<span class="id">U</span> <span class="id">GU</span>]] <span class="id">GP</span>; <span class="id">apply</span>: (@<span class="id">filterS</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">U</span>); <span class="id">last</span> <span class="id">exact</span>: <span class="id">GF</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">y</span> <span class="id">Uy</span> <span class="id">Ky</span>; <span class="id">exact</span>: (<span class="id">GP</span> <span class="id">_</span> <span class="id">GU</span> <span class="id">y</span> <span class="id">Ky</span>).<br/>
<span class="id">Unshelve</span>. <span class="id"><a name="x:1578">all</a></span>: <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">compact_near_covering</span> : <span class="id">compact</span> `&lt;=` <span class="id">near_covering</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof271')">Proof.</span></div>
<div class="proofscript" id="proof271">
<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#filter_from_filter">K</a></span> <span class="id">cptK</span> <span class="id">I</span> <span class="id">F</span> <span class="id">P</span> <span class="id">FF</span> <span class="id">cover</span>.<br/>
<span class="id">pose</span> <span class="id">badPoints</span> := <span class="kwd">fun</span> <span class="id">U</span> =&gt; <span class="id">K</span> `\` [<span class="id">set</span> <span class="id">x</span> | <span class="id">K</span> <span class="id">x</span> /\ <span class="id">U</span> `&lt;=` <span class="id">P</span> ^~ <span class="id">x</span>].<br/>
<span class="id">pose</span> <span class="id">G</span> := <span class="id">filter_from</span> <span class="id">F</span> <span class="id">badPoints</span>.<br/>
<span class="id">have</span> <span class="id">FG</span> : <span class="id">Filter</span> <span class="id">G</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">filter_from_filter</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">exact</span>: <span class="id">filterT</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">L</span> <span class="id">R</span> <span class="id">FL</span> <span class="id">FR</span>; <span class="kwd">exists</span> (<span class="id">L</span> `&amp;` <span class="id">R</span>); <span class="id">first</span> <span class="id">exact</span>: <span class="id">filterI</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">badPoints</span> /= !<span class="id">setDIr</span> !<span class="id">setDv</span> !<span class="id">set0U</span> -<span class="id">setDUr</span>; <span class="id">apply</span>: <span class="id">setDS</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? [|] =&gt; + ? [? ?]; <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">exact</a></span>.<br/>
<span class="id">have</span> [[<span class="id">V</span> <span class="id">FV</span>]|<span class="id">G0</span>] := <span class="id">pselect</span> (<span class="id">G</span> <span class="id">set0</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">subset0</span> <span class="id">setD_eq0</span> =&gt; <span class="id">subK</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (@<span class="id">filterS</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">V</span>) =&gt; // ? ? ? /<span class="id">subK</span> [?]; <span class="id">exact</span>.<br/>
<span class="id">have</span> <span class="id">PG</span> : <span class="id">ProperFilter</span> <span class="id">G</span> <span class="kwd">by</span> [].<br/>
<span class="id">have</span> <span class="id">GK</span> : <span class="id">G</span> <span class="id">K</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">setT</span>; [<span class="id">exact</span>: <span class="id">filterT</span> | <span class="id">move</span>=&gt; ? []].<br/>
<span class="id">case</span>: (<span class="id">cptK</span> <span class="id">_</span> <span class="id">PG</span> <span class="id">GK</span>) =&gt; <span class="id">x</span> [<span class="id">Kx</span>].<br/>
<span class="id">have</span> [[/= <span class="id">U1</span> <span class="id">U2</span>] [<span class="id">U1x</span> <span class="id">FU2</span> <span class="id">subP</span>]] := <span class="id">cover</span> <span class="id">x</span> <span class="id">Kx</span>.<br/>
<span class="id">have</span> <span class="id">GP</span> : <span class="id">G</span> (<span class="id">badPoints</span> (<span class="id">P</span> ^~ <span class="id">x</span> `&amp;` <span class="id">U2</span>)).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">filterI</span> =&gt; //; <span class="kwd">exists</span> (<span class="id">P</span> ^~ <span class="id">x</span> `&amp;` <span class="id">U2</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? [].<br/>
&nbsp;&nbsp;<span class="id">near</span>=&gt; <span class="id">i</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">exact</span>: (<span class="id">near</span> <span class="id">FU2</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">subP</span> (<span class="id">x</span>, <span class="id">i</span>)); <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">nbhs_singleton</span>|<span class="id">exact</span>: (<span class="id">near</span> <span class="id">FU2</span> <span class="id">i</span>)].<br/>
<span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id"><a name="A:1579">_</a></span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#compact">GP</a></span> <span class="id">U1x</span>) =&gt; [[<span class="id">x</span>'[]]][] <span class="id">Kx</span>' /[<span class="id">swap</span>] <span class="id">U1x</span>'.<br/>
<span class="kwd">by</span> <span class="id">case</span>; <span class="id">split</span> =&gt; // <span class="id">i</span> [? ?]; <span class="id">exact</span>: (<span class="id">subP</span> (<span class="id">x</span>', <span class="id">i</span>)).<br/>
<span class="id">Unshelve</span>. <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_near_coveringP</span> <span class="id">A</span> : <span class="id">compact</span> <span class="id">A</span> &lt;-&gt; <span class="id">near_covering</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof272')">Proof.</span></div>
<div class="proofscript" id="proof272">
<span class="kwd">by</span> <span class="id">split</span>; [<span class="id"><a name="ultra_proper">exact</a></span>: <span class="id">compact_near_covering</span>| <span class="id">exact</span>: <span class="id">near_covering_compact</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">near_covering</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">Tychonoff</span>.<br/>
<br/>
<span class="kwd">Class</span> <span class="id">UltraFilter</span> <span class="id">T</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) := {<br/>
&nbsp;&nbsp;<span class="id">ultra_proper</span> :&gt; <span class="id">ProperFilter</span> <span class="id"><a href="mathcomp.analysis.topology.html#UltraFilter">F</a></span> ;<br/>
&nbsp;&nbsp;<span class="id">max_filter</span> : <span class="kwd">forall</span> <span class="id">G</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>), <span class="id">ProperFilter</span> <span class="id">G</span> -&gt; <span class="id">F</span> `&lt;=` <span class="id">G</span> -&gt; <span class="id">G</span> = <span class="id">F</span><br/>
}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">ultra_cvg_clusterE</span> (<span class="id">T</span> : <span class="id">topologicalType</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id">UltraFilter</span> <span class="id">F</span> -&gt; <span class="id">cluster</span> <span class="id">F</span> = [<span class="id">set</span> <span class="id">p</span> | <span class="id">F</span> --&gt; <span class="id">p</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof273')">Proof.</span></div>
<div class="proofscript" id="proof273">
<span class="id">move</span>=&gt; <span class="id">FU</span>; <span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">p</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">cluster_cvgE</span> =&gt; - [<span class="id">G</span> <span class="id">GF</span> [<span class="id">cvGp</span> /<span class="id">max_filter</span> &lt;-]].<br/>
<span class="kwd">by</span> <span class="id"><a name="G:1591">move</a></span>=&gt; <span class="id">cvFp</span>; <span class="id">rewrite</span> <span class="id">cluster_cvgE</span>; <span class="kwd">exists</span> <span class="id">F</span>; [<span class="id">apply</span>: <span class="id">ultra_proper</span>|<span class="id">split</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">ultraFilterLemma</span> <span class="id">T</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">F</span> -&gt; <span class="kwd">exists</span> <span class="id">G</span>, <span class="id">UltraFilter</span> <span class="id">G</span> /\ <span class="id">F</span> `&lt;=` <span class="id">G</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof274')">Proof.</span></div>
<div class="proofscript" id="proof274">
<span class="id">move</span>=&gt; <span class="id">FF</span>.<br/>
<span class="id">set</span> <span class="id">filter_preordset</span> := ({<span class="id">G</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>) &amp; <span class="id">ProperFilter</span> <span class="id">G</span> /\ <span class="id">F</span> `&lt;=` <span class="id">G</span>}).<br/>
<span class="id">set</span> <span class="id">preorder</span> := <span class="kwd">fun</span> <span class="id">G1</span> <span class="id">G2</span> : <span class="id">filter_preordset</span> =&gt; <span class="id">projT1</span> <span class="id">G1</span> `&lt;=` <span class="id">projT1</span> <span class="id">G2</span>.<br/>
<span class="id">suff</span> [<span class="id">G</span> <span class="id">Gmax</span>] : <span class="kwd">exists</span> <span class="id">G</span> : <span class="id">filter_preordset</span>, <span class="id">premaximal</span> <span class="id">preorder</span> <span class="id">G</span>.<br/>
&nbsp;&nbsp;<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#existT">have</a></span> [<span class="id">GF</span> <span class="id">sFG</span>] := <span class="id">projT2</span> <span class="id">G</span>; <span class="kwd">exists</span> (<span class="id">projT1</span> <span class="id">G</span>); <span class="id">split</span>=&gt; //; <span class="id">split</span>=&gt; // <span class="id">H</span> <span class="id">HF</span> <span class="id">sGH</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">sFH</span> : <span class="id">F</span> `&lt;=` <span class="id">H</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subset_trans</span> <span class="id">sGH</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">sHG</span> : <span class="id">preorder</span> (<span class="id">existT</span> <span class="id">_</span> <span class="id">H</span> (<span class="id">conj</span> <span class="id">HF</span> <span class="id">sFH</span>)) <span class="id">G</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">Gmax</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; ?; <span class="id">split</span>=&gt; [/<span class="id">sHG</span>|/<span class="id">sGH</span>].<br/>
<span class="id">have</span> <span class="id">sFF</span> : <span class="id">F</span> `&lt;=` <span class="id">F</span> <span class="kwd">by</span> [].<br/>
<span class="id">apply</span>: (<span class="id">ZL_preorder</span> ((<span class="id">existT</span> <span class="id">_</span> <span class="id">F</span> (<span class="id">conj</span> <span class="id">FF</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#conj">sFF</a></span>)) : <span class="id">filter_preordset</span>)) =&gt;<br/>
&nbsp;&nbsp;[?|<span class="id">G</span> <span class="id">H</span> <span class="id">I</span> <span class="id">sGH</span> <span class="id">sHI</span> ? /<span class="id">sGH</span> /<span class="id"><a href="mathcomp.classical.boolp.html#asbool_neg">sHI</a></span>|<span class="id">A</span> <span class="id">Atot</span>] //.<br/>
<span class="id">case</span>: (<span class="id">pselect</span> (<span class="id">A</span> !=<span class="id">set0</span>)) =&gt; [[<span class="id">G</span> <span class="id">AG</span>] | <span class="id">A0</span>]; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">existT</span> <span class="id">_</span> <span class="id">F</span> (<span class="id">conj</span> <span class="id">FF</span> <span class="id">sFF</span>)) =&gt; <span class="id">G</span> <span class="id">AG</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> /<span class="id">asboolP</span> := <span class="id">A0</span>; <span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">forallp_asboolPn</span> /(<span class="id">_</span> <span class="id">G</span>).<br/>
<span class="id">have</span> [<span class="id">GF</span> <span class="id">sFG</span>] := <span class="id">projT2</span> <span class="id">G</span>.<br/>
<span class="id">suff</span> <span class="id">UAF</span> : <span class="id">ProperFilter</span> (\<span class="id"><a name="H:1604">bigcup_</a></span>(<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">H</a></span> <span class="kwd">in</span> <span class="id">A</span>) <span class="id">projT1</span> <span class="id">H</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">sFUA</span> : <span class="id">F</span> `&lt;=` \<span class="id">bigcup_</span>(<span class="id">H</span> <span class="kwd">in</span> <span class="id">A</span>) <span class="id">projT1</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">B</span> <span class="id">FB</span>; <span class="kwd">exists</span> <span class="id">G</span> =&gt; //; <span class="id">apply</span>: <span class="id">sFG</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">existT</span> <span class="id">_</span> (\<span class="id">bigcup_</span>(<span class="id">H</span> <span class="kwd">in</span> <span class="id">A</span>) <span class="id">projT1</span> <span class="id">H</span>) (<span class="id">conj</span> <span class="id">UAF</span> <span class="id">sFUA</span>)) =&gt; <span class="id">H</span> <span class="id">AH</span> <span class="id">B</span> <span class="id">HB</span> /=.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">H</span>.<br/>
<span class="id">apply</span>: <span class="id">Build_ProperFilter</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">B</span> [<span class="id">H</span> <span class="id">AH</span> <span class="id">HB</span>]; <span class="id">have</span> [<span class="id">HF</span> <span class="id">_</span>] := <span class="id">projT2</span> <span class="id">H</span>; <span class="id">apply</span>: (@<span class="id">filter_ex</span> <span class="id">_</span> <span class="id">_</span> <span class="id">HF</span>).<br/>
<span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">G</span> =&gt; //; <span class="id">apply</span>: <span class="id">filterT</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">B</span> <span class="id">C</span> [<span class="id">HB</span> <span class="id">AHB</span> <span class="id">HBB</span>] [<span class="id">HC</span> <span class="id">AHC</span> <span class="id">HCC</span>]; <span class="id">have</span> [<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">sHBC</a></span>|<span class="id">sHCB</span>] := <span class="id">Atot</span> <span class="id">_</span> <span class="id">_</span> <span class="id">AHB</span> <span class="id">AHC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">HC</span> =&gt; //; <span class="id">have</span> [<span class="id">HCF</span> <span class="id">_</span>] := <span class="id">projT2</span> <span class="id">HC</span>; <span class="id">apply</span>: <span class="id">filterI</span> <span class="id">HCC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">sHBC</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">HB</span> =&gt; //; <span class="id">have</span> [<span class="id">HBF</span> <span class="id"><a name="compact_ultra">_</a></span>] := <span class="id">projT2</span> <span class="id">HB</span>; <span class="id">apply</span>: <span class="id">filterI</span> <span class="id">HBB</span> <span class="id">_</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">sHCB</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">B</span> <span class="id">C</span> <span class="id">SBC</span> [<span class="id"><a href="mathcomp.classical.classical_sets.html#set">H</a></span> <span class="id">AH</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">HB</a></span>]; <span class="kwd">exists</span> <span class="id">H</span> =&gt; //; <span class="id">have</span> [<span class="id">HF</span> <span class="id">_</span>] := <span class="id">projT2</span> <span class="id">H</span>.<br/>
<span class="id">exact</span>: <span class="id">filterS</span> <span class="id">HB</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_ultra</span> (<span class="id">T</span> : <span class="id">topologicalType</span>) :<br/>
&nbsp;&nbsp;<span class="id">compact</span> = [<span class="id">set</span> <span class="id">A</span> | <span class="kwd">forall</span> <span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>),<br/>
&nbsp;&nbsp;<span class="id">UltraFilter</span> <span class="id">F</span> -&gt; <span class="id">F</span> <span class="id">A</span> -&gt; <span class="id">A</span> `&amp;` [<span class="id">set</span> <span class="id">p</span> | <span class="id">F</span> --&gt; <span class="id">p</span>] !=<span class="id">set0</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof275')">Proof.</span></div>
<div class="proofscript" id="proof275">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">A</span>; <span class="id">split</span>=&gt; <span class="id">Aco</span> <span class="id">F</span> <span class="id">FF</span> <span class="id">FA</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> /<span class="id">Aco</span> [<span class="id">p</span> [?]] := <span class="id">FA</span>; <span class="id">rewrite</span> <span class="id">ultra_cvg_clusterE</span>; <span class="kwd">exists</span> <span class="id">p</span>.<br/>
<span class="id">have</span> [<span class="id">G</span> [<span class="id">GU</span> <span class="id">sFG</span>]] := <span class="id">ultraFilterLemma</span> <span class="id">FF</span>.<br/>
<span class="id">have</span> /<span class="id">Aco</span> [<span class="id">p</span> [<span class="id">Ap</span>]] : <span class="id">G</span> <span class="id">A</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">sFG</span>.<br/>
<span class="id">rewrite</span> /= -[<span class="id">_</span> --&gt; <span class="id">p</span>]/([<span class="id">set</span> <span class="id">_</span> | <span class="id">_</span>] <span class="id">p</span>) -<span class="id">ultra_cvg_clusterE</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; /(<span class="id">cvg_cluster</span> <span class="id">sFG</span>); <span class="kwd">exists</span> <span class="id">p</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">filter_image</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#setT">T</a></span> <span class="id">U</span> : <span class="kwd">Type</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; <span class="id">f</span> @` <span class="id">setT</span> = <span class="id">setT</span> -&gt; <span class="id">Filter</span> [<span class="id">set</span> <span class="id">f</span> @` <span class="id">A</span> | <span class="id">A</span> <span class="kwd">in</span> <span class="id">F</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof276')">Proof.</span></div>
<div class="proofscript" id="proof276">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">fsurj</span>; <span class="id">split</span>.<br/>
- <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">setT</span> =&gt; //; <span class="id">apply</span>: <span class="id">filterT</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">_</span> <span class="id">_</span> [<span class="id">A</span> <span class="id">FA</span> &lt;-] [<span class="id">B</span> <span class="id">FB</span> &lt;-].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">f</span> @^-1` (<span class="id">f</span> @` <span class="id">A</span> `&amp;` <span class="id">f</span> @` <span class="id">B</span>)); <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">image_preimage</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">sAB</span> : <span class="id">A</span> `&amp;` <span class="id">B</span> `&lt;=` <span class="id">f</span> @^-1` (<span class="id">f</span> @` <span class="id">A</span> `&amp;` <span class="id">f</span> @` <span class="id">B</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">x</span> [<span class="id">Ax</span> <span class="id">Bx</span>]; <span class="id">split</span>; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filterS</span> <span class="id">sAB</span> <span class="id">_</span>; <span class="id">apply</span>: <span class="id">filterI</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> <span class="id">sAB</span> [<span class="id">C</span> <span class="id">FC</span> <span class="id">fC_eqA</span>].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">f</span> @^-1` <span class="id">B</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">image_preimage</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filterS</span> <span class="id">FC</span> =&gt; <span class="id">p</span> <span class="id">Cp</span>; <span class="id">apply</span>: <span class="id">sAB</span>; <span class="id">rewrite</span> -<span class="id">fC_eqA</span>; <span class="kwd">exists</span> <span class="id">p</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">proper_image</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Build_ProperFilter">T</a></span> <span class="id">U</span> : <span class="kwd">Type</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">F</span> -&gt; <span class="id">f</span> @` <span class="id">setT</span> = <span class="id">setT</span> -&gt; <span class="id">ProperFilter</span> [<span class="id">set</span> <span class="id">f</span> @` <span class="id">A</span> | <span class="id">A</span> <span class="kwd">in</span> <span class="id">F</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof277')">Proof.</span></div>
<div class="proofscript" id="proof277">
<span class="id">move</span>=&gt; <span class="id"><a name="principal_filter_ultra">FF</a></span> <span class="id">fsurj</span>; <span class="id">apply</span>: <span class="id">Build_ProperFilter</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">filter_image</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">_</span> [<span class="id">A</span> <span class="id">FA</span> &lt;-]; <span class="id">have</span> /<span class="id">filter_ex</span> [<span class="id">p</span> <span class="id">Ap</span>] := <span class="id">FA</span>; <span class="kwd">exists</span> (<span class="id">f</span> <span class="id">p</span>); <span class="kwd">exists</span> <span class="id">p</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">principal_filter_ultra</span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">x</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">UltraFilter</span> (<span class="id">principal_filter</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof278')">Proof.</span></div>
<div class="proofscript" id="proof278">
<span class="id">split</span>=&gt; [|<span class="id">G</span> [<span class="id">G0</span> <span class="id">xG</span>] <span class="id">FG</span>]; <span class="id">first</span> <span class="id">exact</span>: <span class="id">principal_filter_proper</span>.<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; // <span class="id">U</span> <span class="id"><a name="in_ultra_setVsetC">GU</a></span>; <span class="id">apply</span>/<span class="id">principal_filterP</span>.<br/>
<span class="id">have</span> /(<span class="id">filterI</span> <span class="id">GU</span>): <span class="id">G</span> [<span class="id">set</span> <span class="id">x</span>] <span class="kwd">by</span> <span class="id">exact</span>/<span class="id">FG</span>/<span class="id">principal_filterP</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">setIC</span> <span class="id">set1I</span>; <span class="id">case</span>: <span class="id">ifPn</span> =&gt; // /[!<span class="id">inE</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">in_ultra_setVsetC</span> <span class="id">T</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">UltraFilter</span> <span class="id">F</span> -&gt; <span class="id">F</span> <span class="id">A</span> \/ <span class="id">F</span> (~` <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof279')">Proof.</span></div>
<div class="proofscript" id="proof279">
<span class="id">move</span>=&gt; <span class="id">FU</span>; <span class="id">case</span>: (<span class="id">pselect</span> (<span class="id">F</span> (~` <span class="id">A</span>))) =&gt; [|<span class="id">nFnA</span>]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">right</span>.<br/>
<span class="id">left</span>; <span class="id">suff</span> : <span class="id">ProperFilter</span> (<span class="id">filter_from</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filterT">F</a></span> `|` [<span class="id">set</span> <span class="id">A</span> `&amp;` <span class="id">B</span> | <span class="id">B</span> <span class="kwd">in</span> <span class="id">F</span>]) <span class="id">id</span>).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /<span class="id">max_filter</span> &lt;-; <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">B</span> <span class="id">FB</span>; <span class="kwd">exists</span> <span class="id">B</span> =&gt; //; <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">A</span> =&gt; //; <span class="id">right</span>; <span class="kwd">exists</span> <span class="id">setT</span>; [<span class="id">apply</span>: <span class="id">filterT</span>|<span class="id">rewrite</span> <span class="id">setIT</span>].<br/>
<span class="id">apply</span>: <span class="id">filter_from_proper</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">B</span> [|[<span class="id">C</span> <span class="id">FC</span> &lt;-]]; <span class="id">first</span> <span class="id">exact</span>: <span class="id">filter_ex</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">contrapT</span> =&gt; /<span class="id">asboolP</span>; <span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">forallp_asboolPn</span> <span class="id">AC0</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">nFnA</span>; <span class="id">apply</span>: <span class="id">filterS</span> <span class="id">FC</span> =&gt; <span class="id">p</span> <span class="id">Cp</span> <span class="id">Ap</span>; <span class="id">apply</span>: (<span class="id">AC0</span> <span class="id">p</span>).<br/>
<span class="id">apply</span>: <span class="id">filter_from_filter</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">A</span>; <span class="id">right</span>; <span class="kwd">exists</span> <span class="id">setT</span>; [<span class="id">apply</span>: <span class="id">filterT</span>|<span class="id">rewrite</span> <span class="id">setIT</span>].<br/>
<span class="id">move</span>=&gt; <span class="id">B</span> <span class="id">C</span> [<span class="id">FB</span>|[<span class="id">DB</span> <span class="id">FDB</span> &lt;-]].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; [<span class="id">FC</span>|[<span class="id">DC</span> <span class="id">FDC</span> &lt;-]]; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">B</span> `&amp;` <span class="id">C</span>)=&gt; //; <span class="id">left</span>; <span class="id">apply</span>: <span class="id">filterI</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">A</span> `&amp;` (<span class="id">B</span> `&amp;` <span class="id">DC</span>)); <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">setICA</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">right</span>; <span class="kwd">exists</span> (<span class="id">B</span> `&amp;` <span class="id">DC</span>) =&gt; //; <span class="id">apply</span>: <span class="id">filterI</span>.<br/>
<span class="id">move</span>=&gt; [<span class="id">FC</span>|[<span class="id">DC</span> <span class="id">FDC</span> &lt;-]].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">A</span> `&amp;` (<span class="id">DB</span> `&amp;` <span class="id">C</span>)); <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">setIA</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">right</span>; <span class="kwd">exists</span> (<span class="id">DB</span> `&amp;` <span class="id">C</span>) =&gt; //; <span class="id">apply</span>: <span class="id">filterI</span>.<br/>
<span class="kwd">exists</span> (<span class="id">A</span> `&amp;` (<span class="id">DB</span> `&amp;` <span class="id"><a name="F:1629">DC</a></span>)); <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ??; <span class="id">rewrite</span> <span class="id">setIACA</span> <span class="id">setIid</span>.<br/>
<span class="kwd">by</span> <span class="id">right</span>; <span class="kwd">exists</span> (<span class="id">DB</span> `&amp;` <span class="id">DC</span>) =&gt; //; <span class="id">apply</span>: <span class="id">filterI</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">ultra_image</span> (<span class="id">T</span> <span class="id">U</span> : <span class="kwd">Type</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="id">UltraFilter</span> <span class="id">F</span> -&gt; <span class="id">f</span> @` <span class="id">setT</span> = <span class="id">setT</span> -&gt; <span class="id">UltraFilter</span> [<span class="id">set</span> <span class="id">f</span> @` <span class="id">A</span> | <span class="id">A</span> <span class="kwd">in</span> <span class="id">F</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof280')">Proof.</span></div>
<div class="proofscript" id="proof280">
<span class="id">move</span>=&gt; <span class="id">FU</span> <span class="id">fsurj</span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">proper_image</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">G</span> <span class="id">GF</span> <span class="id">sfFG</span>; <span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">A</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">sfFG</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">GA</span>; <span class="kwd">exists</span> (<span class="id">f</span> @^-1` <span class="id">A</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">image_preimage</span>.<br/>
<span class="id">have</span> [//|<span class="id">FnAf</span>] := <span class="id">in_ultra_setVsetC</span> (<span class="id">f</span> @^-1` <span class="id">A</span>) <span class="id">FU</span>.<br/>
<span class="id">have</span> : <span class="id">G</span> (<span class="id">f</span> @` (~` (<span class="id">f</span> @^-1` <span class="id">A</span>))) <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">sfFG</span>; <span class="kwd">exists</span> (~` (<span class="id">f</span> @^-1` <span class="id">A</span>)).<br/>
<span class="id">suff</span> : ~ <span class="id">G</span> (<span class="id">f</span> @` (~` (<span class="id">f</span> @^-1` <span class="id">A</span>))) <span class="kwd">by</span> [].<br/>
<span class="id">rewrite</span> <span class="id">preimage_setC</span> <span class="id">image_preimage</span> // =&gt; <span class="id">GnA</span>.<br/>
<span class="kwd">by</span> <span class="id">have</span> /<span class="id">filter_ex</span> [? []] : <span class="id">G</span> (<span class="id">A</span> `&amp;` (~` <span class="id">A</span>)) <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filterI</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">tychonoff</span> (<span class="id">I</span> : <span class="id">eqType</span>) (<span class="id">T</span> : <span class="id">I</span> -&gt; <span class="id">topologicalType</span>)<br/>
&nbsp;&nbsp;(<span class="id">A</span> : <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">set</span> (<span class="id">T</span> <span class="id">i</span>)) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">compact</span> (<span class="id">A</span> <span class="id">i</span>)) -&gt;<br/>
&nbsp;&nbsp;@<span class="id">compact</span> (<span class="id">product_topologicalType</span> <span class="id">T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">set</span> <span class="id">f</span> : <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">T</span> <span class="id">i</span> | <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">A</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#ReflectT">i</a></span> (<span class="id">f</span> <span class="id">i</span>)].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof281')">Proof.</span></div>
<div class="proofscript" id="proof281">
<span class="id">move</span>=&gt; <span class="id">Aco</span>; <span class="id">rewrite</span> <span class="id">compact_ultra</span> =&gt; <span class="id">F</span> <span class="id">FU</span> <span class="id">FA</span>.<br/>
<span class="id">set</span> <span class="id">subst_coord</span> := <span class="kwd">fun</span> (<span class="id">i</span> : <span class="id">I</span>) (<span class="id">pi</span> : <span class="id">T</span> <span class="id">i</span>) (<span class="id">f</span> : <span class="kwd">forall</span> <span class="id">x</span> : <span class="id">I</span>, <span class="id">T</span> <span class="id">x</span>) (<span class="id">j</span> : <span class="id">I</span>) =&gt;<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">eqP</span> <span class="id">is</span> <span class="id">ReflectT</span> <span class="id">e</span> <span class="kwd">then</span> <span class="id">ecast</span> <span class="id">i</span> (<span class="id">T</span> <span class="id">i</span>) (<span class="id">esym</span> <span class="id">e</span>) <span class="id">pi</span> <span class="kwd">else</span> <span class="id">f</span> <span class="id">j</span>.<br/>
<span class="id">have</span> <span class="id">subst_coordT</span> <span class="id">i</span> <span class="id">pi</span> <span class="id">f</span> : <span class="id">subst_coord</span> <span class="id">i</span> <span class="id">pi</span> <span class="id">f</span> <span class="id">i</span> = <span class="id">pi</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">subst_coord</span>; <span class="id">case</span> <span class="id">eqP</span> =&gt; // <span class="id">e</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">eq_irrelevance</span> <span class="id">e</span> (<span class="id">erefl</span> <span class="id">_</span>)).<br/>
<span class="id">have</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">subst_coordN</a></span> <span class="id">i</span> <span class="id">pi</span> <span class="id">f</span> <span class="id">j</span> : <span class="id">i</span> != <span class="id">j</span> -&gt; <span class="id">subst_coord</span> <span class="id">i</span> <span class="id">pi</span> <span class="id">f</span> <span class="id">j</span> = <span class="id">f</span> <span class="id">j</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">inej</a></span>; <span class="id">rewrite</span> /<span class="id">subst_coord</span>; <span class="id">case</span>: <span class="id">eqP</span> =&gt; // <span class="id">e</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>: <span class="id">inej</span>; <span class="id">rewrite</span> {1}<span class="id">e</span> =&gt; /<span class="id">negP</span>.<br/>
<span class="id">have</span> <span class="id">pr_surj</span> <span class="id">i</span> : @^~ <span class="id">i</span> @` [<span class="id">set</span>: <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">T</span> <span class="id">i</span>] = <span class="id">setT</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">pi</span>; <span class="id">split</span>=&gt; // <span class="id">_</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">subst_coord</span> <span class="id">i</span> <span class="id">pi</span> (<span class="kwd">fun</span> <span class="id">_</span> =&gt; <span class="id">point</span>))=&gt; //; <span class="id">rewrite</span> <span class="id">subst_coordT</span>.<br/>
<span class="id">set</span> <span class="id"><a name="i:1676">pF</a></span> := <span class="kwd">fun</span> <span class="id">i</span> =&gt; [<span class="id">set</span> @^~ <span class="id">i</span> @` <span class="id">B</span> | <span class="id">B</span> <span class="kwd">in</span> <span class="id">F</span>].<br/>
<span class="id">have</span> <span class="id">pFultra</span> : <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">UltraFilter</span> (<span class="id">pF</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">i</span>; <span class="id">apply</span>: <span class="id">ultra_image</span> (<span class="id">pr_surj</span> <span class="id">i</span>).<br/>
<span class="id">have</span> <span class="id">pFA</span> : <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">pF</span> <span class="id">i</span> (<span class="id">A</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">i</span>; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">g</span> | <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">A</span> <span class="id">i</span> (<span class="id">g</span> <span class="id">i</span>)] =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">pi</span>; <span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">g</span> <span class="id">Ag</span> &lt;-]; <span class="id">apply</span>: <span class="id">Ag</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">Aipi</span>; <span class="id">have</span> [<span class="id">f</span> <span class="id">Af</span>] := <span class="id">filter_ex</span> <span class="id">FA</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">subst_coord</span> <span class="id">i</span> <span class="id">pi</span> <span class="id">f</span>); <span class="id">last</span> <span class="id">exact</span>: <span class="id">subst_coordT</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">j</span>; <span class="id">case</span>: (<span class="id">eqVneq</span> <span class="id">i</span> <span class="id">j</span>); <span class="id">first</span> <span class="kwd">by</span> <span class="id">case</span>: <span class="id">_</span> /; <span class="id">rewrite</span> <span class="id">subst_coordT</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">subst_coordN</span> -&gt;; <span class="id">apply</span>: <span class="id">Af</span>.<br/>
<span class="id">have</span> <span class="id">cvpFA</span> <span class="id">i</span> : <span class="id">A</span> <span class="id">i</span> `&amp;` [<span class="id">set</span> <span class="id">p</span> | <span class="id">pF</span> <span class="id">i</span> --&gt; <span class="id">p</span>] !=<span class="id">set0</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">ultra_cvg_clusterE</span>; <span class="id">apply</span>: <span class="id">Aco</span>.<br/>
<span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">i</span> =&gt; <span class="id">get</span> (<span class="id">A</span> <span class="id">i</span> `&amp;` [<span class="id">set</span> <span class="id">p</span> | <span class="id">pF</span> <span class="id">i</span> --&gt; <span class="id">p</span>])).<br/>
<span class="id"><a name="compact_cluster_set1">split</a></span>=&gt; [<span class="id">i</span>|]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">have</span> /<span class="id">getPex</span> [] := <span class="id">cvpFA</span> <span class="id">i</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">cvg_sup</span> =&gt; <span class="id">i</span>; <span class="id">apply</span>/<span class="id"><a href="mathcomp.analysis.topology.html#compact">cvg_image</a></span>=&gt; //; <span class="id">have</span> /<span class="id">getPex</span> [] := <span class="id">cvpFA</span> <span class="id">i</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">Tychonoff</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_cluster_set1</span> {<span class="id">T</span> : <span class="id">topologicalType</span>} (<span class="id">x</span> : <span class="id">T</span>) <span class="id">F</span> <span class="id">V</span> :<br/>
&nbsp;&nbsp;<span class="id">hausdorff_space</span> <span class="id">T</span> -&gt; <span class="id">compact</span> <span class="id">V</span> -&gt; <span class="id">nbhs</span> <span class="id"><a href="mathcomp.analysis.topology.html#open">x</a></span> <span class="id">V</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">F</span> -&gt; <span class="id">F</span> <span class="id">V</span> -&gt; <span class="id">cluster</span> <span class="id">F</span> = [<span class="id">set</span> <span class="id">x</span>] -&gt; <span class="id">F</span> --&gt; <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof282')">Proof.</span></div>
<div class="proofscript" id="proof282">
<span class="id">move</span>=&gt; ? <span class="id">cptV</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterS">nxV</a></span> <span class="id">PF</span> <span class="id">FV</span> <span class="id">clFx1</span> <span class="id">U</span> <span class="id">nbhsU</span>; <span class="id">rewrite</span> <span class="id">nbhs_simpl</span>.<br/>
<span class="id">wlog</span> <span class="id">oU</span> : <span class="id">U</span> <span class="id">nbhsU</span> / <span class="id">open</span> <span class="id">U</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /= <span class="id">nbhsE</span> <span class="kwd">in</span> <span class="id">nbhsU</span>; <span class="id">case</span>: <span class="id">nbhsU</span> =&gt; <span class="id">O</span> <span class="id">oO</span> <span class="id">OsubU</span> /(<span class="id">_</span> <span class="id">O</span>) <span class="id">WH</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">OsubU</span>); <span class="id">apply</span>: <span class="id">WH</span>; [<span class="id">exact</span>: <span class="id">open_nbhs_nbhs</span> | <span class="kwd">by</span> <span class="id">case</span>: <span class="id">oO</span>].<br/>
<span class="id">have</span> /<span class="id">compact_near_coveringP</span> : <span class="id">compact</span> (<span class="id">V</span> `\` <span class="id">U</span>).<br/>
&nbsp;&nbsp;<span class="id"><a name="W:1691">apply</a></span>: (<span class="id">subclosed_compact</span> <span class="id">_</span> <span class="id">cptV</span>) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">closedI</span>; [<span class="id">exact</span>: <span class="id">compact_closed</span> | <span class="id">exact</span>: <span class="id">open_closedC</span>].<br/>
<span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id">_</span> (<span class="id">powerset_filter_from</span> <span class="id">F</span>) (<span class="kwd">fun</span> <span class="id">W</span> <span class="id">x</span> =&gt; ~ <span class="id">W</span> <span class="id">x</span>))[].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">z</span> [<span class="id"><a href="mathcomp.classical.boolp.html#existsNP">Vz</a></span> ?]; <span class="id">have</span> <span class="id">zE</span> : <span class="id">x</span> &lt;&gt; <span class="id">z</span> <span class="kwd">by</span> <span class="id">move</span>/<span class="id"><a href="mathcomp.classical.boolp.html#existsNP">nbhs_singleton</a></span>: <span class="id">nbhsU</span> =&gt; /[<span class="id">swap</span>] -&gt;.<br/>
&nbsp;&nbsp;<span class="id">have</span> : ~ <span class="id">cluster</span> <span class="id">F</span> <span class="id">z</span> <span class="kwd">by</span> <span class="id">move</span>: <span class="id">zE</span>; <span class="id">apply</span>: <span class="id">contra_not</span>; <span class="id">rewrite</span> <span class="id">clFx1</span> =&gt; -&gt;.<br/>
&nbsp;&nbsp;<span class="id">case</span>/<span class="id">existsNP</span>=&gt; <span class="id">C</span> /<span class="id">existsPNP</span> [<span class="id">D</span>] <span class="id">FC</span> /<span class="id">existsNP</span> [<span class="id">Dz</span>] /<span class="id">set0P</span>/<span class="id">negP</span>/<span class="id">negPn</span>/<span class="id">eqP</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">setIC</span> =&gt; /<span class="id">disjoints_subset</span> <span class="id">CD0</span>; <span class="kwd">exists</span> (<span class="id">D</span>, [<span class="id">set</span> <span class="id">W</span> | <span class="id">F</span> <span class="id">W</span> /\ <span class="id">W</span> `&lt;=` <span class="id">C</span>]).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span>; <span class="id">rewrite</span> //= <span class="id">nbhs_simpl</span>; <span class="id">exact</span>: <span class="id">powerset_filter_fromP</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span> =&gt; <span class="id">t</span> <span class="id">W</span> [<span class="id">Dt</span>] [<span class="id">FW</span>] /<span class="id">subsetCP</span>; <span class="id">apply</span>; <span class="id">apply</span>: <span class="id">CD0</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">M</span> [<span class="id">MF</span> <span class="id">ME2</span> [<span class="id">W</span>] <span class="id">MW</span> /(<span class="id">_</span> <span class="id">_</span> <span class="id">MW</span>) <span class="id">VUW</span>].<br/>
<span class="id">apply</span>: (@<span class="id">filterS</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">V</a></span> `&amp;` <span class="id">W</span>)); <span class="id">last</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filterI</span> =&gt; //; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">exact</a></span>: <span class="id">MF</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">t</span> [<span class="id">Vt</span> <span class="id">Wt</span>]; <span class="id">apply</span>: <span class="id">contrapT</span> =&gt; <span class="id">Ut</span>; <span class="id">exact</span>: (<span class="id">VUW</span> <span class="id">t</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">Precompact</span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">X</span> : <span class="id">topologicalType</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">compactU</span> (<span class="id"><a href="mathcomp.analysis.topology.html#in_ultra_setVsetC">A</a></span> <span class="id">B</span> : <span class="id">set</span> <span class="id">X</span>) : <span class="id">compact</span> <span class="id">A</span> -&gt; <span class="id">compact</span> <span class="id">B</span> -&gt; <span class="id">compact</span> (<span class="id">A</span> `|` <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof283')">Proof.</span></div>
<div class="proofscript" id="proof283">
<span class="id">rewrite</span> <span class="id">compact_ultra</span> =&gt; <span class="id">cptA</span> <span class="id">cptB</span> <span class="id">F</span> <span class="id">UF</span> <span class="id">FAB</span>; <span class="id">rewrite</span> <span class="id">setIUl</span>.<br/>
<span class="id">have</span> [/<span class="id">cptA</span>[<span class="id">x</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterS">AFx</a></span>]|] := <span class="id">in_ultra_setVsetC</span> <span class="id">A</span> <span class="id">UF</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">x</span>; <span class="id">left</span>.<br/>
<span class="id">move</span>=&gt; /(<span class="id">filterI</span> <span class="id">FAB</span>); <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">setIUl</a></span> <span class="id">setICr</span> <span class="id">set0U</span> =&gt; <span class="id">FBA</span>.<br/>
<span class="id">have</span> /<span class="id">cptB</span>[<span class="id">x</span> <span class="id">BFx</span>] : <span class="id">F</span> <span class="id">B</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filterS</span> <span class="id">FBA</span>; <span class="id">exact</span>: <span class="id">subIsetr</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a name="i:1703">x</a></span>; <span class="id">right</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">bigsetU_compact</span> <span class="id">I</span> (<span class="id">F</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">X</span>) (<span class="id">s</span> : <span class="id">seq</span> <span class="id">I</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#compact0">P</a></span> : <span class="id">pred</span> <span class="id">I</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">P</span> <span class="id">i</span> -&gt; <span class="id">compact</span> (<span class="id">F</span> <span class="id">i</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">compact</span> (\<span class="id">big</span>[<span class="id">setU</span>/<span class="id">set0</span>]<span class="id">_</span>(<span class="id">i</span> &lt;- <span class="id">s</span> | <span class="id">P</span> <span class="id">i</span>) <span class="id">F</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof284')">Proof.</span></div>
<div class="proofscript" id="proof284">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">elim</span>/<span class="id">big_ind</span> : <span class="id">_</span> =&gt;//; [<span class="id">exact</span>:<span class="id">compact0</span>|<span class="id">exact</span>:<span class="id">compactU</span>]. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">compact_near</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">X</span>)) :=<br/>
&nbsp;&nbsp;<span class="kwd">exists2</span> <span class="id">U</span>, <span class="id">F</span> <span class="id">U</span> &amp; <span class="id">compact</span> <span class="id">U</span> /\ <span class="id">closed</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">U</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">precompact</span> (<span class="id">C</span> : <span class="id">set</span> <span class="id">X</span>) := <span class="id">compact_near</span> (<span class="id">globally</span> <span class="id">C</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#closure">precompactE</a></span> (<span class="id">C</span> : <span class="id">set</span> <span class="id">X</span>) : <span class="id">precompact</span> <span class="id">C</span> = <span class="id">compact</span> (<span class="id">closure</span> <span class="id">C</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof285')">Proof.</span></div>
<div class="proofscript" id="proof285">
<span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span>=&gt; [[<span class="id"><a href="mathcomp.analysis.topology.html#subclosed_compact">B</a></span> <span class="id">CsubB</span> [<span class="id">cptB</span> <span class="id">cB</span>]]|]; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">clC</span>; <span class="kwd">exists</span> (<span class="id">closure</span> <span class="id"><a href="mathcomp.analysis.topology.html#closure_id">C</a></span>) =&gt; //; <span class="id">first</span> <span class="id">exact</span>: <span class="id">subset_closure</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span> =&gt; //; <span class="id"><a name="precompact_subset">exact</a></span>: <span class="id">closed_closure</span>.<br/>
<span class="id">apply</span>: (<span class="id">subclosed_compact</span> <span class="id">_</span> <span class="id">cptB</span>); <span class="id">first</span> <span class="id"><a href="mathcomp.analysis.topology.html#precompact">exact</a></span>: <span class="id">closed_closure</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>/<span class="id">closure_id</span>: <span class="id">cB</span> =&gt; -&gt;; <span class="id">exact</span>: <span class="id">closure_subset</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">precompact_subset</span> (<span class="id">A</span> <span class="id"><a name="compact_precompact">B</a></span> : <span class="id">set</span> <span class="id">X</span>) :<br/>
&nbsp;&nbsp;<span class="id">A</span> `&lt;=` <span class="id"><a name="B:1714">B</a></span> -&gt; <span class="id">precompact</span> <span class="id">B</span> -&gt; <span class="id">precompact</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof286')">Proof.</span></div>
<div class="proofscript" id="proof286">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">AsubB</span> [<span class="id">B</span>' <span class="id">B</span>'<span class="id">subB</span> <span class="id">cptB</span>']; <span class="kwd">exists</span> <span class="id">B</span>' =&gt; // ? ?; <span class="id">exact</span>/<span class="id">B</span>'<span class="id">subB</span>/<span class="id">AsubB</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_precompact</span> (<span class="id">A</span> <span class="id">B</span> : <span class="id"><a href="mathcomp.analysis.topology.html#compact_closed">set</a></span> <span class="id">X</span>) :<br/>
&nbsp;&nbsp;<span class="id">hausdorff_space</span> <span class="id">X</span> -&gt; <span class="id">compact</span> <span class="id">A</span> -&gt; <span class="id">precompact</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof287')">Proof.</span></div>
<div class="proofscript" id="proof287">
<span class="id">move</span>=&gt; <span class="id">h</span> <span class="id">c</span>; <span class="id">rewrite</span> <span class="id">precompactE</span> ( <span class="id">_</span> : <span class="id">closure</span> <span class="id">A</span> = <span class="id">A</span>)//.<br/>
<span class="kwd">by</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">apply</a></span>/<span class="id">esym</span>/<span class="id">closure_id</span>; <span class="id">exact</span>: <span class="id">compact_closed</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">precompact_closed</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">X</span>) : <span class="id">closed</span> <span class="id">A</span> -&gt; <span class="id">precompact</span> <span class="id"><a href="mathcomp.analysis.topology.html#precompactE">A</a></span> = <span class="id">compact</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof288')">Proof.</span></div>
<div class="proofscript" id="proof288">
<span class="id">move</span>=&gt; <span class="id">clA</span>; <span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span>=&gt; [[<span class="id"><a name="A:1716">B</a></span> <span class="id">AsubB</span> [ + <span class="id">_</span> ]]|].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">subclosed_compact</span>; <span class="id">exact</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> {1}(<span class="id">_</span> : <span class="id">A</span> = <span class="id">closure</span> <span class="id">A</span>) ?<span class="id">precompactE</span>// -<span class="id">closure_id</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">locally_compact</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">X</span>) := [<span class="id">locally</span> <span class="id">precompact</span> <span class="id">A</span>].<br/>
<br/>
<span class="kwd">End</span> <span class="id">Precompact</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">product_spaces</span>.<br/>
<span class="kwd">Context</span> {<span class="id">I</span> : <span class="id">eqType</span>} {<span class="id">K</span> : <span class="id">I</span> -&gt; <span class="id">topologicalType</span>}.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">PK</span> := <span class="id">product_topologicalType</span> <span class="id">K</span>.<br/>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">proj_continuous</span> <span class="id">i</span> : <span class="id">continuous</span> (<span class="id">proj</span> <span class="id">i</span> : <span class="id">PK</span> -&gt; <span class="id">K</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof289')">Proof.</span></div>
<div class="proofscript" id="proof289">
<span class="id">move</span>=&gt; <span class="id">f</span>; <span class="id">have</span> /<span class="id">cvg_sup</span>/(<span class="id">_</span> <span class="id">i</span>)/<span class="id">cvg_image</span> : <span class="id">f</span> --&gt; <span class="id">f</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">cvg_id</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">h</span>; <span class="id">apply</span>: <span class="id">cvg_trans</span> (<span class="id">h</span> <span class="id">_</span>) =&gt; {<span class="id">h</span>}.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.classical.mathcomp_extra.html#dfwithin">move</a></span>=&gt; <span class="id">Q</span> /= [<span class="id">W</span> <span class="id">nbdW</span> &lt;-]; <span class="id">apply</span>: <span class="id">filterS</span> <span class="id"><a name="g:1720">nbdW</a></span>; <span class="id">exact</span>: <span class="id">preimage_image</span>.<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#product_spaces.K">eqEsubset</a></span>; <span class="id">split</span> =&gt; <span class="id">y</span> //; <span class="kwd">exists</span> (<span class="id">dfwith</span> (<span class="kwd">fun</span>=&gt; <span class="id">point</span>) <span class="id">i</span> <span class="id">y</span>) =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">dfwithin</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">dfwith_continuous</span> <span class="id">g</span> (<span class="id">i</span> : <span class="id">I</span>) : <span class="id">continuous</span> (<span class="id">dfwith</span> <span class="id">g</span> <span class="id">_</span> : <span class="id">K</span> <span class="id">i</span> -&gt; <span class="id">PK</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof290')">Proof.</span></div>
<div class="proofscript" id="proof290">
<span class="id">move</span>=&gt; <span class="id">z</span> <span class="id">U</span> [] <span class="id">P</span> [] [] <span class="id">Q</span> <span class="id">QfinP</span> &lt;- [] <span class="id">V</span> <span class="id">JV</span> <span class="id">Vpz</span>.<br/>
<span class="id">move</span>/(@<span class="id">preimage_subset</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">dfwith</span> <span class="id">g</span> <span class="id">i</span>))/<span class="id">filterS</span>; <span class="id">apply</span>.<br/>
<span class="id">apply</span>: (@<span class="id">filterS</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> ((<span class="id">dfwith</span> <span class="id">g</span> <span class="id">i</span>) @^-1` <span class="id">V</span>)); <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">V</span>.<br/>
<span class="id">have</span> [<span class="id">L</span> <span class="id">Lsub</span> /[<span class="id">dup</span>] <span class="id">VL</span> &lt;-] := <span class="id">QfinP</span> <span class="id">_</span> <span class="id">JV</span>; <span class="id">rewrite</span> <span class="id">preimage_bigcap</span>.<br/>
<span class="id">apply</span>: <span class="id">filter_bigI</span> =&gt; /= <span class="id">M</span> /[<span class="id">dup</span>] <span class="id">LM</span> /<span class="id">Lsub</span> /<span class="id">set_mem</span> [] <span class="id">w</span> <span class="id">_</span> [+] + /[<span class="id">dup</span>] + &lt;-.<br/>
<span class="id">have</span> [-&gt;|<span class="id">wnx</span>] := <span class="id">eqVneq</span> <span class="id">w</span> <span class="id">i</span> =&gt; <span class="id">N</span> <span class="id">oN</span> <span class="id">NM</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (@<span class="id"><a href="mathcomp.classical.mathcomp_extra.html#dfwithin">filterS</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">N</span>); <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id">rewrite</span> /= <span class="id">dfwithin</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">open_nbhs_nbhs</span>; <span class="id">split</span> =&gt; //; <span class="id">move</span>: <span class="id">Vpz</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">VL</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id"><a name="A:1723">LM</a></span>); <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.analysis.topology.html#open">NM</a></span> /= <span class="id">dfwithin</span>.<br/>
<span class="id"><a href="mathcomp.classical.mathcomp_extra.html#proj">apply</a></span>: <span class="id">nearW</span> =&gt; <span class="id">y</span> /=; <span class="id">move</span>: <span class="id">Vpz</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">VL</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">LM</span>); <span class="id">rewrite</span> -<span class="id">NM</span> /= ? <span class="id">dfwithout</span> // <span class="id">eq_sym</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">proj_open</span> <span class="id">i</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">PK</span>) : <span class="id">open</span> <span class="id">A</span> -&gt; <span class="id">open</span> (<span class="id">proj</span> <span class="id">i</span> @` <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof291')">Proof.</span></div>
<div class="proofscript" id="proof291">
<span class="id">move</span>=&gt; <span class="id">oA</span>; <span class="id">rewrite</span> <span class="id">openE</span> =&gt; <span class="id">z</span> [<span class="id">f</span> <span class="id">Af</span> &lt;-]; <span class="id">rewrite</span> <span class="id">openE</span> <span class="kwd">in</span> <span class="id">oA</span>.<br/>
<span class="id">have</span> {<span class="id">oA</span>} := <span class="id">oA</span> <span class="id">_</span> <span class="id">Af</span>; <span class="id">rewrite</span> /<span class="id">interior</span> =&gt; <span class="id">nAf</span>.<br/>
<span class="id">apply</span>: (@<span class="id">filterS</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> ((<span class="id">dfwith</span> <span class="id">f</span> <span class="id">i</span>) @^-1` <span class="id">A</span>)).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">w</span> <span class="id">Apw</span>; <span class="kwd">exists</span> (<span class="id">dfwith</span> <span class="id">f</span> <span class="id">i</span> <span class="id">w</span>) =&gt; //; <span class="id">rewrite</span> <span class="id">projK</span>.<br/>
<span class="id">apply</span>: <span class="id">dfwith_continuous</span> =&gt; /=; <span class="id">move</span>: <span class="id"><a href="mathcomp.analysis.topology.html#hausdorff_space">nAf</a></span>; <span class="id">congr</span> (<span class="id">nbhs</span> <span class="id">_</span> <span class="id">A</span>).<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">functional_extensionality_dep</span> =&gt; ?; <span class="id">case</span>: <span class="id">dfwithP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">hausdorff_product</span> :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">hausdorff_space</span> (<span class="id">K</span> <span class="id">x</span>)) -&gt; <span class="id">hausdorff_space</span> <span class="id">PK</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof292')">Proof.</span></div>
<div class="proofscript" id="proof292">
<span class="id"><a href="mathcomp.classical.mathcomp_extra.html#proj">move</a></span>=&gt; <span class="id">hsdfK</span> <span class="id">p</span> <span class="id">q</span> /= <span class="id">clstr</span>; <span class="id">apply</span>: <span class="id">functional_extensionality_dep</span> =&gt; <span class="id">x</span>.<br/>
<span class="id">apply</span>: <span class="id">hsdfK</span>; <span class="id">move</span>: <span class="id">clstr</span>; <span class="id">rewrite</span> ?<span class="id">cluster_cvgE</span> /= =&gt; -[<span class="id">G</span> <span class="id">PG</span> [<span class="id">GtoQ</span> <span class="id">psubG</span>]].<br/>
<span class="kwd">exists</span> (<span class="id">proj</span> <span class="id">x</span> @ <span class="id">G</span>); [<span class="id">exact</span>: <span class="id">fmap_proper_filter</span>|<span class="id">split</span>].<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">cvg_trans</span>; <span class="id">last</span> <span class="id">exact</span>: (@<span class="id">proj_continuous</span> <span class="id"><a name="finI">x</a></span> <span class="id">q</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">cvg_app</span>; <span class="id">exact</span>: <span class="id">GtoQ</span>.<br/>
<span class="id">move</span>/(<span class="id"><a href="mathcomp.classical.classical_sets.html#set">cvg_app</a></span> (<span class="id">proj</span> <span class="id">x</span>)): <span class="id"><a name="D':1729">psubG</a></span> =&gt; /<span class="id">cvg_trans</span>; <span class="id">apply</span>.<br/>
<span class="id">exact</span>: <span class="id">proj_continuous</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">product_spaces</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="finI_filter">finI</a></span> (<span class="id">I</span> : <span class="id">choiceType</span>) <span class="id">T</span> (<span class="id">D</span> : <span class="id"><a name="T:1733">set</a></span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">D</span>' : {<span class="id">fset</span> <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">I</a></span>}, {<span class="id">subset</span> <span class="id">D</span>' &lt;= <span class="id">D</span>} -&gt;<br/>
&nbsp;&nbsp;\<span class="id"><a href="mathcomp.analysis.topology.html#finI_from">bigcap_</a></span>(<span class="id">i</span> <span class="kwd">in</span> [<span class="id">set</span> <span class="id">i</span> | <span class="id">i</span> \<span class="kwd">in</span> <span class="id">D</span>']) <span class="id">f</span> <span class="id">i</span> !=<span class="id">set0</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">finI_filter</span> (<span class="id">I</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filter_from_filter">choiceType</a></span>) <span class="id">T</span> (<span class="id">D</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">finI</span> <span class="id">D</span> <span class="id">f</span> -&gt; <span class="id">ProperFilter</span> (<span class="id">filter_from</span> (<span class="id">finI_from</span> <span class="id">D</span> <span class="id">f</span>) <span class="id">id</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof293')">Proof.</span></div>
<div class="proofscript" id="proof293">
<span class="id">move</span>=&gt; <span class="id">finIf</span>; <span class="id">apply</span>: (<span class="id">filter_from_proper</span> (<span class="id">filter_from_filter</span> <span class="id">_</span> <span class="id">_</span>)).<br/>
- <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">setT</span>; <span class="kwd">exists</span> <span class="id">fset0</span> =&gt; //; <span class="id">rewrite</span> <span class="id">predeqE</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> [<span class="id">DA</span> <span class="id">sDA</span> <span class="id">IfA</span>] [<span class="id">DB</span> <span class="id">sDB</span> <span class="id">IfB</span>]; <span class="kwd">exists</span> (<span class="id">A</span> `&amp;` <span class="id">B</span>) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">DA</span> `|` <span class="id">DB</span>)%<span class="id">fset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">rewrite</span> <span class="id">inE</span> =&gt; /<span class="id">orP</span> [/<span class="id">sDA</span>|/<span class="id">sDB</span>].<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> -<span class="id">IfA</span> -<span class="id">IfB</span> <span class="id">predeqE</span> =&gt; <span class="id">p</span>; <span class="id">split</span>=&gt; [<span class="id">Ifp</span>|[<span class="id">IfAp</span> <span class="id">IfBp</span>] <span class="id">i</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span>=&gt; <span class="id">i</span> <span class="id">Di</span>; <span class="id">apply</span>: <span class="id">Ifp</span>; <span class="id">rewrite</span> /= <span class="id"><a name="F:1737">inE</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">Di</a></span> // <span class="id">orbC</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> /= <span class="id">inE</span> =&gt; /<span class="id">orP</span> []; [<span class="id">apply</span>: <span class="id">IfAp</span>|<span class="id">apply</span>: <span class="id">IfBp</span>].<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">_</span> [?? &lt;-]; <span class="id">apply</span>: <span class="id">finIf</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">filter_finI</span> (<span class="id">T</span> : <span class="id">pointedType</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">D</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>))<br/>
&nbsp;&nbsp;(<span class="id">f</span> : <span class="id">set</span> <span class="id">T</span> -&gt; <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">F</span> -&gt; (<span class="kwd">forall</span> <span class="id">A</span>, <span class="id">D</span> <span class="id">A</span> -&gt; <span class="id">F</span> (<span class="id">f</span> <span class="id">A</span>)) -&gt; <span class="id">finI</span> <span class="id">D</span> <span class="id">f</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof294')">Proof.</span></div>
<div class="proofscript" id="proof294">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">sDFf</a></span> <span class="id">D</span>' <span class="id">sD</span>; <span class="id">apply</span>: (@<span class="id">filter_ex</span> <span class="id"><a name="A:1745">_</a></span> <span class="id">F</span>); <span class="id">apply</span>: <span class="id">filter_bigI</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A</span> /<span class="id">sD</span>; <span class="id">rewrite</span> <span class="id">inE</span> =&gt; /<span class="id">sDFf</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">finite_subset_cover</span> (<span class="id">I</span> : <span class="id">choiceType</span>) (<span class="id">D</span> : <span class="id">set</span> <span class="id">I</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">U</span> (<span class="id">F</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">U</span>) (<span class="id">A</span> : <span class="id"><a name="A:1749">set</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">U</a></span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">exists2</span> <span class="id">D</span>' : {<span class="id">fset</span> <span class="id">I</span>}, {<span class="id">subset</span> <span class="id">D</span>' &lt;= <span class="id">D</span>} &amp; <span class="id">A</span> `&lt;=` <span class="id">cover</span> [<span class="id">set</span>` <span class="id">D</span>'] <span class="id">F</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">Covers</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">T</span> : <span class="id">topologicalType</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">cover_compact</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id"><a name="A:1754">I</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">choiceType</a></span>) (<span class="id">D</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>),<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">open</span> (<span class="id">f</span> <span class="id">i</span>)) -&gt; <span class="id">A</span> `&lt;=` <span class="id">cover</span> <span class="id">D</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">finite_subset_cover</span> <span class="id">D</span> <span class="id">f</span> <span class="id">A</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">open_fam_of</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) <span class="id">I</span> (<span class="id">D</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">exists2</span> <span class="id">g</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>, (<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">open</span> (<span class="id"><a href="mathcomp.analysis.topology.html#open_fam_of">g</a></span> <span class="id">i</span>)) &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">f</span> <span class="id">i</span> = <span class="id">A</span> `&amp;` <span class="id">g</span> <span class="id">i</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cover_compactE</span> : <span class="id">cover_compact</span> =<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">A</span> | <span class="kwd">forall</span> (<span class="id">I</span> : <span class="id">choiceType</span>) (<span class="id">D</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">open_fam_of</span> <span class="id">A</span> <span class="id">D</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span> `&lt;=` <span class="id">cover</span> <span class="id">D</span> <span class="id">f</span> -&gt; <span class="id">finite_subset_cover</span> <span class="id">D</span> <span class="id">f</span> <span class="id">A</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof295')">Proof.</span></div>
<div class="proofscript" id="proof295">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">A</span>; <span class="id">split</span>=&gt; [<span class="id">Aco</span> <span class="id">I</span> <span class="id">D</span> <span class="id">f</span> [<span class="id">g</span> <span class="id">gop</span> <span class="id">feAg</span>] <span class="id">fcov</span>|<span class="id">Aco</span> <span class="id">I</span> <span class="id">D</span> <span class="id">f</span> <span class="id">fop</span> <span class="id">fcov</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">gcov</span> : <span class="id">A</span> `&lt;=` \<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">D</span>) <span class="id">g</span> <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span> /<span class="id">fcov</span> [<span class="id">i</span> <span class="id">Di</span>]; <span class="id">rewrite</span> <span class="id">feAg</span> // =&gt; - []; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">D</span>' <span class="id">sD</span> <span class="id">sgcov</span>] := <span class="id">Aco</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">gop</span> <span class="id">gcov</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">D</span>' =&gt; // <span class="id">p</span> <span class="id">Ap</span>; <span class="id">have</span> /<span class="id">sgcov</span> [<span class="id">i</span> <span class="id">D</span>'<span class="id">i</span> <span class="id">gip</span>] := <span class="id">Ap</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">i</span> =&gt; //; <span class="id">rewrite</span> <span class="id">feAg</span> //; <span class="id">have</span> /<span class="id">sD</span> := <span class="id">D</span>'<span class="id">i</span>; <span class="id">rewrite</span> <span class="id">inE</span>.<br/>
<span class="id">have</span> <span class="id">Afcov</span> : <span class="id">A</span> `&lt;=` \<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">D</span>) (<span class="id">A</span> `&amp;` <span class="id">f</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span> <span class="id">Ap</span>; <span class="id">have</span> /<span class="id">fcov</span> [<span class="id">i</span> ??] := <span class="id">Ap</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
<span class="id">have</span> <span class="id">Afop</span> : <span class="id">open_fam_of</span> <span class="id">A</span> <span class="id">D</span> (<span class="kwd">fun</span> <span class="id"><a name="A:1769">i</a></span> =&gt; <span class="id">A</span> `&amp;` <span class="id"><a name="I:1770">f</a></span> <span class="id">i</span>) <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a name="f:1772">f</a></span>.<br/>
<span class="id">have</span> [<span class="id"><a href="mathcomp.classical.classical_sets.html#set">D</a></span>' <span class="id">sD</span> <span class="id">sAfcov</span>] := <span class="id">Aco</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Afop</span> <span class="id">Afcov</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">D</span>' =&gt; // <span class="id">p</span> /<span class="id">sAfcov</span> [<span class="id">i</span> ? []]; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">closed_fam_of</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) <span class="id"><a href="mathcomp.analysis.topology.html#compact">I</a></span> (<span class="id">D</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id"><a name="A:1777">f</a></span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">exists2</span> <span class="id"><a name="D:1779">g</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">I</a></span> -&gt; <span class="id">set</span> <span class="id">T</span>, (<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">closed</span> (<span class="id">g</span> <span class="id">i</span>)) &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">f</span> <span class="id">i</span> = <span class="id"><a name="i:1781">A</a></span> `&amp;` <span class="id">g</span> <span class="id">i</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_In0</span> :<br/>
&nbsp;&nbsp;<span class="id">compact</span> = [<span class="id">set</span> <span class="id">A</span> | <span class="kwd">forall</span> (<span class="id">I</span> : <span class="id">choiceType</span>) (<span class="id">D</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.boolp.html#pselect">closed_fam_of</a></span> <span class="id">A</span> <span class="id"><a name="i:1782">D</a></span> <span class="id">f</span> -&gt; <span class="id">finI</span> <span class="id">D</span> <span class="id">f</span> -&gt; \<span class="id">bigcap_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">D</span>) <span class="id">f</span> <span class="id">i</span> !=<span class="id">set0</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof296')">Proof.</span></div>
<div class="proofscript" id="proof296">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id"><a href="mathcomp.classical.boolp.html#forallp_asboolPn">A</a></span>; <span class="id">split</span>=&gt; [<span class="id">Aco</span> <span class="id">I</span> <span class="id">D</span> <span class="id">f</span> [<span class="id">g</span> <span class="id">gcl</span> <span class="id">feAg</span>] <span class="id">finIf</span>|<span class="id">Aco</span> <span class="id">F</span> <span class="id">FF</span> <span class="id">FA</span>].<br/>
&nbsp;&nbsp;<span class="id">case</span>: (<span class="id">pselect</span> (<span class="kwd">exists</span> <span class="id"><a href="mathcomp.analysis.topology.html#finI_filter">i</a></span>, <span class="id">D</span> <span class="id">i</span>)) =&gt; [[<span class="id">i</span> <span class="id">Di</span>] | /<span class="id">asboolP</span>]; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">forallp_asboolPn</span> <span class="id">D0</span>; <span class="kwd">exists</span> <span class="id">point</span> =&gt; ? /<span class="id">D0</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [|<span class="id">p</span> [<span class="id">Ap</span> <span class="id">clfinIfp</span>]] := <span class="id">Aco</span> <span class="id">_</span> (<span class="id">finI_filter</span> <span class="id">finIf</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">f</span> <span class="id">i</span>); [<span class="id">apply</span>: <span class="id">finI_from1</span>|<span class="id">rewrite</span> <span class="id">feAg</span> // =&gt; ? []].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">p</span> =&gt; <span class="id">j</span> <span class="id">Dj</span>; <span class="id">rewrite</span> <span class="id">feAg</span> //; <span class="id">split</span>=&gt; //; <span class="id">apply</span>: <span class="id">gcl</span> =&gt; // <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">clfinIfp</span>; <span class="kwd">exists</span> (<span class="id">f</span> <span class="id">j</span>); [<span class="id">apply</span>: <span class="id">finI_from1</span>|<span class="id">rewrite</span> <span class="id">feAg</span> // =&gt; ? []].<br/>
<span class="id">have</span> <span class="id">finIAclF</span> : <span class="id">finI</span> <span class="id">F</span> (<span class="kwd">fun</span> <span class="id">B</span> =&gt; <span class="id">A</span> `&amp;` <span class="id">closure</span> <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (@<span class="id">filter_finI</span> <span class="id">_</span> <span class="id">F</span>) =&gt; <span class="id">B</span> <span class="id">FB</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filterI</span> =&gt; //; <span class="id">apply</span>: <span class="id">filterS</span> <span class="id">FB</span>; <span class="id">apply</span>: <span class="id">subset_closure</span>.<br/>
<span class="id">have</span> [|<span class="id">p</span> <span class="id">AclFIp</span>] := <span class="id">Aco</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">finIAclF</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">closure</span>=&gt; //; <span class="id">move</span>=&gt; ??; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#compact">closed_closure</a></span>.<br/>
<span class="kwd">exists</span> <span class="id">p</span>; <span class="id">split</span>=&gt; [|<span class="id">B</span> <span class="id">C</span> <span class="id"><a href="mathcomp.analysis.topology.html#compact_In0">FB</a></span> <span class="id">p_C</span>]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">have</span> /<span class="id">AclFIp</span> [] := <span class="id">FA</span>.<br/>
<span class="kwd">by</span> <span class="id">have</span> /<span class="id">AclFIp</span> [<span class="id">_</span>] := <span class="id">FB</span>; <span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">p_C</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_cover</span> : <span class="id">compact</span> = <span class="id">cover_compact</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof297')">Proof.</span></div>
<div class="proofscript" id="proof297">
<span class="id">rewrite</span> <span class="id">compact_In0</span> <span class="id">cover_compactE</span> <span class="id">predeqE</span> =&gt; <span class="id">A</span>.<br/>
<span class="id">split</span>=&gt; [<span class="id">Aco</span> <span class="id">I</span> <span class="id">D</span> <span class="id">f</span> [<span class="id">g</span> <span class="id">gop</span> <span class="id">feAg</span>] <span class="id">fcov</span>|<span class="id">Aco</span> <span class="id">I</span> <span class="id">D</span> <span class="id">f</span> [<span class="id">g</span> <span class="id">gcl</span> <span class="id">feAg</span>]].<br/>
&nbsp;&nbsp;<span class="id">case</span>: (<span class="id">pselect</span> (<span class="kwd">exists</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span>)) =&gt; [[<span class="id">j</span> <span class="id">Dj</span>] | /<span class="id">asboolP</span>]; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">forallp_asboolPn</span> <span class="id">D0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">fset0</span> =&gt; // ? /<span class="id">fcov</span> [? /<span class="id">D0</span>].<br/>
&nbsp;&nbsp;<span class="id">apply</span>/<span class="id">exists2P</span>; <span class="id">apply</span>: <span class="id">contrapT</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /<span class="id">asboolP</span>; <span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">forallp_asboolPn</span> <span class="id">sfncov</span>.<br/>
&nbsp;&nbsp;<span class="id">suff</span> [<span class="id">p</span> <span class="id">IAnfp</span>] : \<span class="id">bigcap_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">D</span>) (<span class="id">A</span> `\` <span class="id">f</span> <span class="id">i</span>) !=<span class="id">set0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> /<span class="id">IAnfp</span> [<span class="id">Ap</span> <span class="id">_</span>] := <span class="id">Dj</span>; <span class="id">have</span> /<span class="id">fcov</span> [<span class="id">k</span> /<span class="id">IAnfp</span> [<span class="id">_</span>]] := <span class="id">Ap</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">Aco</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">i</span> =&gt; ~` <span class="id">g</span> <span class="id">i</span>) =&gt; <span class="id">i</span> <span class="id">Di</span>; <span class="id">first</span> <span class="id">exact</span>/<span class="id">open_closedC</span>/<span class="id">gop</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">p</span>; <span class="id">split</span>=&gt; [[<span class="id">Ap</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#cover">nfip</a></span>] | [<span class="id">Ap</span> <span class="id">ngip</span>]]; <span class="id">split</span>=&gt; //.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">gip</span>; <span class="id">apply</span>: <span class="id">nfip</span>; <span class="id">rewrite</span> <span class="id">feAg</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">feAg</span> // =&gt; - [].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">D</span>' <span class="id">sD</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> /<span class="id">asboolP</span> : ~ <span class="id">A</span> `&lt;=` <span class="id">cover</span> [<span class="id">set</span>` <span class="id">D</span>'] <span class="id">f</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">sAIf</span>; <span class="id">exact</span>: (<span class="id">sfncov</span> <span class="id">D</span>').<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">existsp_asboolPn</span> [<span class="id">p</span> /<span class="id">asboolP</span>].<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">imply_asboolPn</span> [<span class="id">Ap</span> <span class="id">nUfp</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">p</span> =&gt; <span class="id">i</span> <span class="id">D</span>'<span class="id">i</span>; <span class="id">split</span>=&gt; // <span class="id">fip</span>; <span class="id">apply</span>: <span class="id">nUfp</span>; <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.boolp.html#contraPP">i</a></span>.<br/>
<span class="id">case</span>: (<span class="id">pselect</span> (<span class="kwd">exists</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span>)) =&gt; [[<span class="id">j</span> <span class="id">Dj</span>] | /<span class="id">asboolP</span>]; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">forallp_asboolPn</span> <span class="id">D0</span> =&gt; <span class="id">_</span>; <span class="kwd">exists</span> <span class="id">point</span> =&gt; ? /<span class="id">D0</span>.<br/>
<span class="id">apply</span>: <span class="id">contraPP</span> =&gt; /<span class="id">asboolP</span>; <span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">forallp_asboolPn</span> <span class="id">If0</span>.<br/>
<span class="id">apply</span>/<span class="id">asboolP</span>; <span class="id">rewrite</span> <span class="id">asbool_neg</span>; <span class="id">apply</span>/<span class="id">existsp_asboolPn</span>.<br/>
<span class="id">have</span> <span class="id">Anfcov</span> : <span class="id">A</span> `&lt;=` \<span class="id"><a href="mathcomp.classical.boolp.html#imply_asboolPn">bigcup_</a></span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">D</span>) (<span class="id">A</span> `\` <span class="id">f</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">p</span> <span class="id">Ap</span>; <span class="id">have</span> /<span class="id">asboolP</span> := <span class="id">If0</span> <span class="id">p</span>; <span class="id">rewrite</span> <span class="id">asbool_neg</span> =&gt; /<span class="id">existsp_asboolPn</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; [<span class="id">i</span> /<span class="id">asboolP</span>]; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#closed_openC">asbool_neg</a></span> =&gt; /<span class="id">imply_asboolPn</span> [<span class="id">Di</span> <span class="id">nfip</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">i</span>.<br/>
<span class="id">have</span> <span class="id">Anfop</span> : <span class="id">open_fam_of</span> <span class="id">A</span> <span class="id">D</span> (<span class="kwd">fun</span> <span class="id">i</span> =&gt; <span class="id">A</span> `\` <span class="id">f</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">i</span> =&gt; ~` <span class="id">g</span> <span class="id">i</span>) =&gt; <span class="id">i</span> <span class="id">Di</span>; <span class="id">first</span> <span class="id">exact</span>/<span class="id">closed_openC</span>/<span class="id">gcl</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">p</span>; <span class="id">split</span>=&gt; [[<span class="id">Ap</span> <span class="id">nfip</span>] | [<span class="id">Ap</span> <span class="id">ngip</span>]]; <span class="id">split</span>=&gt; //.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a name="i:1799">move</a></span>=&gt; <span class="id">gip</span>; <span class="id">apply</span>: <span class="id">nfip</span>; <span class="id">rewrite</span> <span class="id">feAg</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">feAg</span> // =&gt; - [].<br/>
<span class="id">have</span> [<span class="id">D</span>' <span class="id">sD</span> <span class="id">sAnfcov</span>] := <span class="id">Aco</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Anfop</span> <span class="id">Anfcov</span>.<br/>
<span class="id">wlog</span> [<span class="id">k</span> <span class="id">D</span>'<span class="id">k</span>] : <span class="id">D</span>' <span class="id">sD</span> <span class="id">sAnfcov</span> / <span class="kwd">exists</span> <span class="id">i</span>, <span class="id">i</span> \<span class="kwd">in</span> <span class="id">D</span>'.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /(<span class="id">_</span> (<span class="id">D</span>' `|` [<span class="id">fset</span> <span class="id">j</span>])%<span class="id">fset</span>); <span class="id">apply</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">k</a></span>; <span class="id">rewrite</span> !<span class="id">inE</span> =&gt; /<span class="id">orP</span> [/<span class="id">sD</span>|/<span class="id">eqP</span>-&gt;] //; <span class="id">rewrite</span> <span class="id">inE</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span> /<span class="id">sAnfcov</span> [<span class="id">i</span> <span class="id">D</span>'<span class="id">i</span> <span class="id">Anfip</span>]; <span class="kwd">exists</span> <span class="id">i</span> =&gt; //=; <span class="id">rewrite</span> !<span class="id">inE</span> <span class="id">D</span>'<span class="id">i</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">j</span>; <span class="id">rewrite</span> !<span class="id">inE</span> <span class="id">orbC</span> <span class="id">eq_refl</span>.<br/>
<span class="kwd">exists</span> <span class="id">D</span>' =&gt; /(<span class="id">_</span> <span class="id">sD</span>) [<span class="id">p</span> <span class="id">Ifp</span>].<br/>
<span class="id">have</span> /<span class="id">Ifp</span> := <span class="id">D</span>'<span class="id"><a name="X:1800">k</a></span>; <span class="id">rewrite</span> <span class="id">feAg</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">have</span> /<span class="id">sD</span> := <span class="id"><a href="mathcomp.classical.cardinality.html#finite_set">D</a></span>'<span class="id">k</span>; <span class="id">rewrite</span> <span class="id">inE</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [/<span class="id">sAnfcov</span> [<span class="id"><a href="mathcomp.classical.cardinality.html#finite_setP">i</a></span> <span class="id">D</span>'<span class="id">i</span> [<span class="id">_</span> <span class="id">nfip</span>]] <span class="id">_</span>]; <span class="id">have</span> /<span class="id">Ifp</span> := <span class="id">D</span>'<span class="id">i</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">Covers</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">finite_compact</span> {<span class="id">X</span> : <span class="id">topologicalType</span>} (<span class="id">A</span> : <span class="id">set</span> <span class="id">X</span>) :<br/>
&nbsp;&nbsp;<span class="id">finite_set</span> <span class="id">A</span> -&gt; <span class="id">compact</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof298')">Proof.</span></div>
<div class="proofscript" id="proof298">
<span class="id">case</span>/<span class="id">finite_setP</span>=&gt; <span class="id">n</span>; <span class="id">elim</span>: <span class="id">n</span> <span class="id">A</span> =&gt; [<span class="id">A</span>|<span class="id">n</span> <span class="id">ih</span> <span class="id">A</span> /<span class="id">eq_cardSP</span>[<span class="id">x</span> <span class="id">Ax</span> /<span class="id">ih</span> ?]].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">II0</span> <span class="id">card_eq0</span> =&gt; /<span class="id">eqP</span> -&gt;; <span class="id">exact</span>: <span class="id">compact0</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -(<span class="id">setD1K</span> <span class="id">Ax</span>); <span class="id">apply</span>: <span class="id">compactU</span> =&gt; //; <span class="id">exact</span>: <span class="id">compact_set1</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopen_countable</span> {<span class="id">T</span> : <span class="id">topologicalType</span>}:<br/>
&nbsp;&nbsp;<span class="id">compact</span> [<span class="id">set</span>: <span class="id">T</span>] -&gt; @<span class="id">second_countable</span> <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">countable</a></span> (@<span class="id">clopen</span> <span class="id"><a name="x:1804">T</a></span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof299')">Proof.</span></div>
<div class="proofscript" id="proof299">
<span class="id">move</span>=&gt; <span class="id">cmpT</span> [<span class="id">B</span> /<span class="id">fset_subset_countable</span> <span class="id">cntB</span>] [<span class="id">obase</span> <span class="id"><a href="mathcomp.analysis.topology.html#cover_compact">Bbase</a></span>].<br/>
<span class="id">apply</span>/(<span class="id">card_le_trans</span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#compact_cover">cntB</a></span>)/<span class="id">pcard_surjP</span>.<br/>
<span class="id">pose</span> <span class="id">f</span> := <span class="kwd">fun</span> <span class="id">F</span> : {<span class="id">fset</span> <span class="id">set</span> <span class="id">T</span>} =&gt; \<span class="id">bigcup_</span>(<span class="id">x</span> <span class="kwd">in</span> [<span class="id">set</span>` <span class="id">F</span>]) <span class="id">x</span>; <span class="kwd">exists</span> <span class="id">f</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">D</span> [] <span class="id">oD</span> <span class="id">cD</span> /=; <span class="id">have</span> <span class="id">cmpt</span> : <span class="id">cover_compact</span> <span class="id">D</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">compact_cover</span>; <span class="id">exact</span>: (<span class="id">subclosed_compact</span> <span class="id">_</span> <span class="id">cmpT</span>).<br/>
<span class="id">have</span> <span class="id">h</span> (<span class="id">x</span> : <span class="id">T</span>) : <span class="kwd">exists</span> <span class="id">V</span> : <span class="id">set</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#conj">T</a></span>, <span class="id">D</span> <span class="id">x</span> -&gt; [/\ <span class="id">B</span> <span class="id">V</span>, <span class="id">nbhs</span> <span class="id">x</span> <span class="id">V</span> &amp; <span class="id">V</span> `&lt;=` <span class="id">D</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">Dx</span>|] := <span class="id">pselect</span> (<span class="id">D</span> <span class="id">x</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="kwd">exists</span> <span class="id">set0</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id"><a name="z:1807">V</a></span> [<span class="id">BV</span> <span class="id">Vx</span> <span class="id">VD</span>]] := <span class="id">Bbase</span> <span class="id">x</span> <span class="id">D</span> (<span class="id">open_nbhs_nbhs</span> (<span class="id">conj</span> <span class="id">oD</span> <span class="id">Dx</span>)).<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">V</span> =&gt; <span class="id">_</span>; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: <span class="id">open_nbhs_nbhs</span>; <span class="id">split</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">obase</span>.<br/>
<span class="id">pose</span> <span class="id">h</span>' := <span class="kwd">fun</span> <span class="id">z</span> =&gt; <span class="id">projT1</span> (<span class="id">cid</span> (<span class="id">h</span> <span class="id">z</span>)).<br/>
<span class="id">have</span> [<span class="id">fs</span> <span class="id">fsD</span> <span class="id">DsubC</span>] : <span class="id">finite_subset_cover</span> <span class="id">D</span> <span class="id">h</span>' <span class="id">D</span>.<br/>
&nbsp;&nbsp;<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">apply</a></span>: <span class="id">cmpt</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">z</span> <span class="id">Dz</span>; <span class="id">apply</span>: <span class="id">obase</span>; <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">h</span> <span class="id">z</span>)) <span class="id">Dz</span>.<br/>
&nbsp;&nbsp;- <span class="id">move</span>=&gt; <span class="id">z</span> <span class="id">Dz</span>; <span class="kwd">exists</span> <span class="id">z</span> =&gt; //; <span class="id">apply</span>: <span class="id">nbhs_singleton</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">h</span> <span class="id">z</span>)) <span class="id">Dz</span>.<br/>
<span class="kwd">exists</span> [<span class="id">fset</span> <span class="id">h</span>' <span class="id">z</span> | <span class="id">z</span> <span class="kwd">in</span> <span class="id">fs</span>]%<span class="id">fset</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">U</span>/<span class="id">imfsetP</span> [<span class="id">z</span> /=] /<span class="id">fsD</span> /<span class="id">set_mem</span> <span class="id">Dz</span> -&gt;; <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">rewrite</a></span> <span class="id"><a href="mathcomp.classical.boolp.html#cid">inE</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">h</span> <span class="id">z</span>)) <span class="id">Dz</span>.<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id">z</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>=&gt; <span class="id">y</span> /<span class="id">imfsetP</span> [<span class="id">x</span> /= /<span class="id">fsD</span>/<span class="id">set_mem</span> <span class="id">Dx</span> -&gt;]; <span class="id">move</span>: <span class="id">z</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">h</a></span> <span class="id">x</span>)) <span class="id">Dx</span>.<br/>
<span class="id">move</span>=&gt; /<span class="id">DsubC</span> /= [<span class="id">y</span> /= <span class="id">yfs</span> <span class="id">hyz</span>]; <span class="kwd">exists</span> (<span class="id">h</span>' <span class="id">y</span>) =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">set_imfset</span> /=; <span class="kwd">exists</span> <span class="id">y</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">separated_topologicalType</span>.<br/>
<span class="kwd">Variable</span> (<span class="id">T</span> : <span class="id">topologicalType</span>).<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> <span class="id">x</span> <span class="id">y</span> : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">T</a></span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">kolmogorov_space</span> := <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id"><a name="A:1816">x</a></span> != <span class="id">y</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>, (<span class="id">A</span> \<span class="kwd">in</span> <span class="id">nbhs</span> <span class="id">x</span> /\ <span class="id">y</span> \<span class="kwd">in</span> ~` <span class="id">A</span>) \/ (<span class="id">A</span> \<span class="kwd">in</span> <span class="id">nbhs</span> <span class="id">y</span> /\ <span class="id">x</span> \<span class="kwd">in</span> ~` <span class="id">A</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">accessible_space</span> := <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">x</span> != <span class="id">y</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>, <span class="id"><a href="mathcomp.classical.classical_sets.html#setCK">open</a></span> <span class="id">A</span> /\ <span class="id">x</span> \<span class="kwd">in</span> <span class="id">A</span> /\ <span class="id">y</span> \<span class="kwd">in</span> ~` <span class="id">A</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">accessible_closed_set1</span> : <span class="id">accessible_space</span> -&gt; <span class="kwd">forall</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">x</a></span>, <span class="id">closed</span> [<span class="id">set</span> <span class="id">x</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof300')">Proof.</span></div>
<div class="proofscript" id="proof300">
<span class="id">move</span>=&gt; <span class="id">T1</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#subsetC1">x</a></span>; <span class="id">rewrite</span> -[<span class="id">X</span> <span class="kwd">in</span> <span class="id">closed</span> <span class="id">X</span>]<span class="id">setCK</span>; <span class="id">apply</span>: <span class="id">open_closedC</span>.<br/>
<span class="id">rewrite</span> <span class="id">openE</span> =&gt; <span class="id">y</span> /<span class="id">eqP</span> /<span class="id">T1</span> [<span class="id">U</span> [<span class="id">oU</span> [<span class="id">yU</span> <span class="id">xU</span>]]].<br/>
<span class="id">rewrite</span> /<span class="id">interior</span> <span class="id">nbhsE</span> /=; <span class="kwd">exists</span> <span class="id">U</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">subsetC1</span>.<br/>
<span class="kwd">by</span> <span class="id">split</span>=&gt; //; <span class="id">exact</span>: <span class="id">set_mem</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">accessible_kolmogorov</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">accessible_space</a></span> -&gt; <span class="id">kolmogorov_space</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof301')">Proof.</span></div>
<div class="proofscript" id="proof301">
<span class="id">move</span>=&gt; <span class="id">T1</span> <span class="id">x</span> <span class="id">y</span> /<span class="id">T1</span> [<span class="id">A</span> [<span class="id">oA</span> [<span class="id">xA</span> <span class="id">yA</span>]]]; <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">A</a></span>; <span class="id">left</span>; <span class="id">split</span>=&gt; //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">nbhsE</span> <span class="id">inE</span>; <span class="kwd">exists</span> <span class="id">A</span> =&gt; //; <span class="id">rewrite</span> <span class="id">inE</span> <span class="kwd">in</span> <span class="id">xA</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">accessible_finite_set_closed</span> :<br/>
&nbsp;&nbsp;<span class="id">accessible_space</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>, <span class="id"><a href="mathcomp.analysis.topology.html#accessible_closed_set1">finite_set</a></span> <span class="id">A</span> -&gt; <span class="id">closed</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof302')">Proof.</span></div>
<div class="proofscript" id="proof302">
<span class="id">split</span> =&gt; [<span class="id">TT1</span> <span class="id">A</span> <span class="id">fA</span>|<span class="id">h</span> <span class="id">x</span> <span class="id">y</span> <span class="id">xy</span>].<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> -(<span class="id">fsbig_setU_set1</span> <span class="id">fA</span>) <span class="id">fsbig_finite</span>//=.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">closed_bigsetU</span> =&gt; <span class="id">x</span> <span class="id">xA</span>; <span class="id">exact</span>: <span class="id">accessible_closed_set1</span>.<br/>
<span class="kwd">exists</span> (~` [<span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">y</a></span>]); <span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">openC</span>; <span class="id">exact</span>: <span class="id">h</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> !<span class="id">inE</span>/=; <span class="id">split</span>=&gt; [|/<span class="id">eqP</span>]; [<span class="id">exact</span>/<span class="id">eqP</span>|<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#cluster">eqxx</a></span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">close</span> <span class="id">x</span> <span class="id">y</span> : <span class="kwd">Prop</span> := <span class="kwd">forall</span> <span class="id">M</span>, <span class="id">open_nbhs</span> <span class="id">y</span> <span class="id">M</span> -&gt; <span class="id">closure</span> <span class="id">M</span> <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">closeEnbhs</span> <span class="id">x</span> : <span class="id">close</span> <span class="id">x</span> = <span class="id">cluster</span> (<span class="id">nbhs</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof303')">Proof.</span></div>
<div class="proofscript" id="proof303">
<span class="id">transitivity</span> (<span class="id">cluster</span> (<span class="id">open_nbhs</span> <span class="id">x</span>)); <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">cluster</span>; <span class="id">under</span> <span class="id">eq_fun</span> <span class="id">do</span> <span class="id">rewrite</span> -<span class="id">meets_openl</span>.<br/>
<span class="id">rewrite</span> <span class="id">clusterEonbhs</span> /<span class="id">close</span> <span class="id">funeqE</span> =&gt; <span class="id">y</span> /=; <span class="id">rewrite</span> <span class="id">meetsC</span> /<span class="id">meets</span>.<br/>
<span class="id">apply</span>/<span class="id">eq_forall</span> =&gt; <span class="id">A</span>; <span class="id">rewrite</span> <span class="id">forall_swap</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">closureEonbhs</span>/= <span class="id">meets_globallyl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closeEonbhs</span> <span class="id">x</span> : <span class="id">close</span> <span class="id">x</span> = [<span class="id">set</span> <span class="id">y</span> | <span class="id">open_nbhs</span> <span class="id">x</span> `#` <span class="id">open_nbhs</span> <span class="id">y</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof304')">Proof.</span></div>
<div class="proofscript" id="proof304">
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">closeEnbhs</span>; <span class="id">under</span> <span class="id">eq_fun</span> <span class="id">do</span> <span class="id">rewrite</span> -<span class="id">meets_openl</span> -<span class="id">meets_openr</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">close_sym</span> <span class="id"><a href="mathcomp.analysis.topology.html#close">x</a></span> <span class="id">y</span> : <span class="id">close</span> <span class="id">x</span> <span class="id">y</span> -&gt; <span class="id">close</span> <span class="id">y</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof305')">Proof.</span></div>
<div class="proofscript" id="proof305">
 <span class="kwd">by</span> <span class="id">rewrite</span> !<span class="id">closeEnbhs</span> /<span class="id">cluster</span>/= <span class="id">meetsC</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_close</span> {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>} <span class="id">x</span> <span class="id">y</span> : <span class="id">F</span> --&gt; <span class="id">x</span> -&gt; <span class="id">F</span> --&gt; <span class="id"><a href="mathcomp.analysis.topology.html#cvg_close">y</a></span> -&gt; <span class="id">close</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">x</a></span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof306')">Proof.</span></div>
<div class="proofscript" id="proof306">
<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">sub_meets</span> <span class="id">sx</span> /<span class="id">sx</span>; <span class="id">rewrite</span> <span class="id">closeEnbhs</span>; <span class="id">apply</span>; <span class="id"><a name="F2:1834">apply</a></span>/<span class="id">proper_meetsxx</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">close_refl</span> <span class="id">x</span> : <span class="id">close</span> <span class="id">x</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof307')">Proof.</span></div>
<div class="proofscript" id="proof307">
 <span class="id">exact</span>: (@<span class="id">cvg_close</span> (<span class="id">nbhs</span> <span class="id">x</span>)). Qed.</div>
<span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">close_refl</span> : <span class="id"><a href="mathcomp.analysis.topology.html#cvg_trans">core</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">close_cvg</span> (<span class="id">F1</span> <span class="id">F2</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) {<span class="id">FF2</span> : <span class="id">ProperFilter</span> <span class="id">F2</span>} :<br/>
&nbsp;&nbsp;<span class="id">F1</span> --&gt; <span class="id">F2</span> -&gt; <span class="id">F2</span> --&gt; <span class="id">F1</span> -&gt; <span class="id">close</span> (<span class="id">lim</span> <span class="id">F1</span>) (<span class="id">lim</span> <span class="id">F2</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof308')">Proof.</span></div>
<div class="proofscript" id="proof308">
<span class="id">move</span>=&gt; <span class="id">F12</span> <span class="id">F21</span>.<br/>
<span class="id">have</span> [/(<span class="id">cvg_trans</span> <span class="id"><a href="mathcomp.analysis.topology.html#dvgP">F21</a></span>) <span class="id">F2l</span>|<span class="id">dvgF1</span>] := <span class="id">pselect</span> (<span class="id">cvg</span> <span class="id">F1</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (@<span class="id">cvg_close</span> <span class="id">F2</span>) =&gt; //; <span class="id">apply</span>: <span class="id">cvgP</span> <span class="id">F2l</span>.<br/>
<span class="id">have</span> [/(<span class="id">cvg_trans</span> <span class="id">F12</span>)/<span class="id">cvgP</span>//|<span class="id">dvgF2</span>] := <span class="id">pselect</span> (<span class="id"><a name="F:1839">cvg</a></span> <span class="id"><a name="FF:1840">F2</a></span>).<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">rewrite</a></span> <span class="id">dvgP</span> // <span class="id">dvgP</span> //; <span class="id">exact</span>/<span class="id"><a href="mathcomp.analysis.topology.html#separated_topologicalType.T">close_refl</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvgx_close</span> <span class="id">x</span> <span class="id">y</span> : <span class="id">x</span> --&gt; <span class="id">y</span> -&gt; <span class="id">close</span> <span class="id">x</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof309')">Proof.</span></div>
<div class="proofscript" id="proof309">
 <span class="id">exact</span>: <span class="id">cvg_close</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvgi_close</span> <span class="id">T</span>' {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>} (<span class="id">f</span> : <span class="id">T</span>' -&gt; <span class="id">set</span> <span class="id">T</span>) (<span class="id">l</span> <span class="id">l</span>' : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;{<span class="id">near</span> <span class="id">F</span>, <span class="id">is_fun</span> <span class="id">f</span>} -&gt; <span class="id">f</span> `@ <span class="id"><a href="mathcomp.analysis.topology.html#filter_app">F</a></span> --&gt; <span class="id">l</span> -&gt; <span class="id">f</span> `@ <span class="id">F</span> --&gt; <span class="id">l</span>' -&gt; <span class="id">close</span> <span class="id">l</span> <span class="id">l</span>'.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof310')">Proof.</span></div>
<div class="proofscript" id="proof310">
<span class="id">move</span>=&gt; <span class="id">f_prop</span> <span class="id">fFl</span> <span class="id">fFl</span>'.<br/>
<span class="id">suff</span> <span class="id">f_totalfun</span>: <span class="id">infer</span> {<span class="id">near</span> <span class="id">F</span>, <span class="id">is_totalfun</span> <span class="id">f</span>} <span class="kwd">by</span> <span class="id">exact</span>: <span class="id">cvg_close</span> <span class="id">fFl</span> <span class="id">fFl</span>'.<br/>
<span class="id">apply</span>: <span class="id">filter_app</span> <span class="id">f_prop</span>; <span class="id">near</span> <span class="id">do</span> <span class="id">split</span>=&gt; //=.<br/>
<span class="id">have</span>: (<span class="id">f</span> `@ <span class="id">F</span>) <span class="id">setT</span> <span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvgi_close">apply</a></span>: <span class="id">fFl</span>; <span class="id">apply</span>: <span class="id"><a name="open_hausdorff">filterT</a></span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">fmapiE</span>; <span class="id">apply</span>: <span class="id">filterS</span> =&gt; <span class="id"><a name="x:1844">x</a></span> [<span class="id">y</span> []]; <span class="kwd">exists</span> <span class="id">y</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<span class="kwd">Definition</span> <span class="id">cvg_toi_locally_close</span> := @<span class="id">cvgi_close</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_hausdorff</span> : <span class="id">hausdorff_space</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">T</a></span> =<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">x</span> != <span class="id">y</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">exists2</span> <span class="id">AB</span>, (<span class="id">x</span> \<span class="kwd">in</span> <span class="id">AB</span>.1 /\ <span class="id">y</span> \<span class="kwd">in</span> <span class="id">AB</span>.2) &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[/\ <span class="id">open</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#rwP">AB</a></span>.1, <span class="id">open</span> <span class="id">AB</span>.2 &amp; <span class="id">AB</span>.1 `&amp;` <span class="id">AB</span>.2 == <span class="id">set0</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof311')">Proof.</span></div>
<div class="proofscript" id="proof311">
<span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span> =&gt; [<span class="id">T_filterT2</span>|<span class="id">T_openT2</span>] <span class="id">x</span> <span class="id">y</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> := @<span class="id">contra_not</span> <span class="id"><a href="mathcomp.classical.boolp.html#existsp_asboolPn">_</a></span> <span class="id">_</span> (<span class="id">T_filterT2</span> <span class="id">x</span> <span class="id">y</span>); <span class="id">rewrite</span> (<span class="id">rwP</span> <span class="id">eqP</span>) (<span class="id">rwP</span> <span class="id">negP</span>).  <span class="comment">(*&nbsp;change&nbsp;@contra_not&nbsp;_&nbsp;_&nbsp;to&nbsp;contra_not&nbsp;when&nbsp;requiring&nbsp;MathComp&nbsp;&gt;&nbsp;1.14&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /[<span class="id">apply</span>] /<span class="id">asboolPn</span>/<span class="id">existsp_asboolPn</span>[<span class="id">A</span>]; <span class="id">rewrite</span> -<span class="id">existsNE</span> =&gt; -[<span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> [<span class="id">nbhs</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">_</a></span> <span class="id">_</span> -&gt; <span class="id">_</span>](<span class="id">rwP</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negbK">imply_asboolP</a></span>) =&gt; /<span class="id">negP</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">asbool_imply</span> !<span class="id">negb_imply</span> =&gt; /<span class="id">andP</span>[/<span class="id">asboolP</span> <span class="id">xA</span>] /<span class="id">andP</span>[/<span class="id">asboolP</span> <span class="id">yB</span>].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /<span class="id">asboolPn</span>; <span class="id">rewrite</span> -<span class="id">set0P</span> =&gt; /<span class="id">negP</span>; <span class="id">rewrite</span> <span class="id">negbK</span> =&gt; /<span class="id">eqP</span> <span class="id">AIB_eq0</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>: <span class="id">xA</span> <span class="id">yB</span>; <span class="id">rewrite</span> !<span class="id">nbhsE</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; - [<span class="id">oA</span> [<span class="id">oA_open</span> <span class="id">oAx</span>] <span class="id">oAA</span>] [<span class="id">oB</span> [<span class="id">oB_open</span> <span class="id">oBx</span>] <span class="id">oBB</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">oA</span>, <span class="id">oB</span>); <span class="id">rewrite</span> ?<span class="id">inE</span>; <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs_nbhs">split</a></span> =&gt; //; <span class="id">apply</span>: <span class="id">subsetI_eq0</span> <span class="id">AIB_eq0</span>.<br/>
<span class="id">apply</span>: <span class="id">contraPP</span> =&gt; /<span class="id">eqP</span> /<span class="id">T_openT2</span>[[/=<span class="id">A</span> <span class="id">B</span>]].<br/>
<span class="id">rewrite</span> !<span class="id">inE</span> =&gt; - [<span class="id">xA</span> <span class="id">yB</span>] [<span class="id">Aopen</span> <span class="id">Bopen</span> /<span class="id">eqP</span> <span class="id">AIB_eq0</span>].<br/>
<span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id">A</span> <span class="id">B</span> (<span class="id">open_nbhs_nbhs</span> <span class="id">_</span>) (<span class="id">open_nbhs_nbhs</span> <span class="id">_</span>)).<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">set0P</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">_</span>)/<span class="id">negP</span>; <span class="id">apply</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">hausdorff_accessible</span> : <span class="id">hausdorff_space</span> <span class="id">T</span> -&gt; <span class="id">accessible_space</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof312')">Proof.</span></div>
<div class="proofscript" id="proof312">
<span class="id">rewrite</span> <span class="id">open_hausdorff</span> =&gt; <span class="id">hsdfT</span> =&gt; <span class="id">x</span> <span class="id">y</span> /<span class="id">hsdfT</span> [[<span class="id">U</span> <span class="id">V</span>] [<span class="id">xU</span> <span class="id"><a href="mathcomp.analysis.topology.html#hausdorff_space">yV</a></span>]] [/= ? ? /<span class="id">eqP</span>].<br/>
<span class="id">rewrite</span> <span class="id">setIC</span> =&gt; /<span class="id">disjoints_subset</span> <span class="id">VUc</span>; <span class="kwd">exists</span> <span class="id">U</span>; <span class="id">repeat</span> <span class="id">split</span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">inE</span>; <span class="id">apply</span>: <span class="id">VUc</span>; <span class="id">rewrite</span> -<span class="id">inE</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">sep</span> : <span class="id">hausdorff_space</span> <span class="id">T</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">closeE</span> <span class="id">x</span> <span class="id">y</span> : <span class="id">close</span> <span class="id">x</span> <span class="id">y</span> = (<span class="id">x</span> = <span class="id">y</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof313')">Proof.</span></div>
<div class="proofscript" id="proof313">
<span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; -&gt;; <span class="id"><a name="FF:1854">exact</a></span>: <span class="id">close_refl</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">closeEnbhs</span>; <span class="id">exact</span>: <span class="id">sep</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">close_eq</span> <span class="id">x</span> <span class="id">y</span> : <span class="id">close</span> <span class="id"><a href="mathcomp.analysis.topology.html#closeE">x</a></span> <span class="id">y</span> -&gt; <span class="id">x</span> = <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof314')">Proof.</span></div>
<div class="proofscript" id="proof314">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">closeE</span>. Qed.</div>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="x:1856">cvg_unique</a></span> {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>} : <span class="id">is_subset1</span> [<span class="id">set</span> <span class="id">x</span> : <span class="id">T</span> | <span class="id">F</span> --&gt; <span class="id">x</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof315')">Proof.</span></div>
<div class="proofscript" id="proof315">
 <span class="id">move</span>=&gt; <span class="id">Fx</span> <span class="id">Fy</span>; <span class="id">rewrite</span> -<span class="id">closeE</span> //; <span class="id">exact</span>: (@<span class="id">cvg_close</span> <span class="id">F</span>). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_eq</span> <span class="id">x</span> <span class="id">y</span> : <span class="id">x</span> --&gt; <span class="id">y</span> -&gt; <span class="id"><a name="U:1859">x</a></span> = <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof316')">Proof.</span></div>
<div class="proofscript" id="proof316">
 <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">closeE</span> //; <span class="id"><a name="f:1862">apply</a></span>: <span class="id">cvg_close</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">lim_id</span> <span class="id">x</span> : <span class="id">lim</span> <span class="id">x</span> = <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof317')">Proof.</span></div>
<div class="proofscript" id="proof317">
 <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">esym</span>/<span class="id">cvg_eq</span>/<span class="id">cvg_ex</span>; <span class="kwd">exists</span> <span class="id">x</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_lim</span> {<span class="id">U</span> : <span class="kwd">Type</span>} {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>} (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">T</span>) (<span class="id">l</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">l</span> -&gt; <span class="id">lim</span> (<span class="id">f</span> @ <span class="id">F</span>) = <span class="id">l</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof318')">Proof.</span></div>
<div class="proofscript" id="proof318">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /[<span class="id">dup</span>] /<span class="id">cvgP</span> /<span class="id">cvg_unique</span>; <span class="id">apply</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">lim_near_cst</span> {<span class="id"><a name="lim_cst">U</a></span>} {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id"><a name="F:1871">ProperFilter</a></span> <span class="id">F</span>} (<span class="id">l</span> : <span class="id">T</span>) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">T</span>) :<br/>
&nbsp;&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">f</span> <span class="id">x</span> = <span class="id">l</span>) -&gt; <span class="id">lim</span> (<span class="id">f</span> @ <span class="id">F</span>) = <span class="id">l</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof319')">Proof.</span></div>
<div class="proofscript" id="proof319">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">cvg_near_cst</span>/<span class="id">cvg_lim</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">lim_cst</span> {<span class="id"><a name="FF:1876">U</a></span>} {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>} (<span class="id">k</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id">lim</span> ((<span class="kwd">fun</span> <span class="id">_</span> : <span class="id">U</span> =&gt; <span class="id">k</span>) @ <span class="id">F</span>) = <span class="id">k</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof320')">Proof.</span></div>
<div class="proofscript" id="proof320">
 <span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#separated_topologicalType.T">apply</a></span>: <span class="id">cvg_lim</span>; <span class="id">apply</span>: <span class="id">cvg_cst</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvgi_unique</span> {<span class="id"><a href="mathcomp.analysis.topology.html#closeE">U</a></span> : <span class="kwd">Type</span>} {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>} (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;{<span class="id">near</span> <span class="id">F</span>, <span class="id">is_fun</span> <span class="id">f</span>} -&gt; <span class="id">is_subset1</span> [<span class="id"><a href="mathcomp.analysis.topology.html#separated_topologicalType.T">set</a></span> <span class="id">x</span> : <span class="id">T</span> | <span class="id"><a name="l:1883">f</a></span> `@ <span class="id">F</span> --&gt; <span class="id">x</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof321')">Proof.</span></div>
<div class="proofscript" id="proof321">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">ffun</span> <span class="id">fx</span> <span class="id">fy</span>; <span class="id">rewrite</span> -<span class="id">closeE</span> //; <span class="id">exact</span>: <span class="id">cvgi_close</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvgi_lim</span> {<span class="id">U</span>} {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>} (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">T</span> -&gt; <span class="kwd">Prop</span>) (<span class="id">l</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> (<span class="kwd">fun</span> <span class="id">x</span> : <span class="id">U</span> =&gt; <span class="id">is_subset1</span> (<span class="id">f</span> <span class="id">x</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">f</span> `@ <span class="id">F</span> --&gt; <span class="id">l</span> -&gt; <span class="id">lim</span> (<span class="id">f</span> `@ <span class="id">F</span>) = <span class="id">l</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof322')">Proof.</span></div>
<div class="proofscript" id="proof322">
<span class="id">move</span>=&gt; <span class="id">f_prop</span> <span class="id">fl</span>; <span class="id">apply</span>: <span class="id">get_unique</span> =&gt; // <span class="id">l</span>' <span class="id">fl</span>'; <span class="id">exact</span>: <span class="id">cvgi_unique</span> <span class="id">_</span> <span class="id">fl</span>' <span class="id">fl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">separated_topologicalType</span>.<br/>
<br/>
#[<span class="id">deprecated</span>(<span class="id">since</span>="<span class="id">mathcomp</span>-<span class="id">analysis</span> 0.6.0", <span class="id">note</span>="<span class="id">renamed</span> <span class="id">to</span> `<span class="id">cvg_lim</span>`")]<br/>
<span class="kwd">Notation</span> <span class="id">cvg_map_lim</span> := <span class="id">cvg_lim</span> (<span class="id">only</span> <span class="id">parsing</span>).<br/>
#[<span class="id">deprecated</span>(<span class="id">since</span>="<span class="id">mathcomp</span>-<span class="id">analysis</span> 0.6.0", <span class="id">note</span>="<span class="id">renamed</span> <span class="id">to</span> `<span class="id"><a name="B:1887">cvgi_lim</a></span>`")]<br/>
<span class="kwd">Notation</span> <span class="id">cvgi_map_lim</span> := <span class="id">cvgi_lim</span> (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<br/>
<span class="kwd">Section</span> <span class="id">connected_sets</span>.<br/>
<span class="kwd">Variable</span> <span class="id">T</span> : <span class="id">topologicalType</span>.<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> <span class="id">A</span> <span class="id">B</span> <span class="id"><a href="mathcomp.analysis.topology.html#connected_sets.T">C</a></span> <span class="id">D</span> : <span class="id">set</span> <span class="id">T</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">connected</span> <span class="id">A</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">B</span>, <span class="id">B</span> !=<span class="id">set0</span> -&gt; (<span class="kwd">exists2</span> <span class="id">C</span>, <span class="id"><a name="B:1893">open</a></span> <span class="id">C</span> &amp; <span class="id">B</span> = <span class="id">A</span> `&amp;` <span class="id">C</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">exists2</span> <span class="id">C</span>, <span class="id">closed</span> <span class="id">C</span> &amp; <span class="id">B</span> = <span class="id">A</span> `&amp;` <span class="id">C</span>) -&gt; <span class="id">B</span> = <span class="id">A</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected0</span> : <span class="id">connected</span> (@<span class="id">set0</span> <span class="id">T</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof323')">Proof.</span></div>
<div class="proofscript" id="proof323">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? [? ?]; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setIC">set0I</a></span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">separated</span> <span class="id">A</span> <span class="id">B</span> :=<br/>
&nbsp;&nbsp;(<span class="id">closure</span> <span class="id"><a name="B:1897">A</a></span>) `&amp;` <span class="id">B</span> = <span class="id">set0</span> /\ <span class="id">A</span> `&amp;` (<span class="id">closure</span> <span class="id">B</span>) = <span class="id">set0</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">separatedC</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">A</a></span> <span class="id">B</span> : <span class="id">separated</span> <span class="id">A</span> <span class="id">B</span> = <span class="id">separated</span> <span class="id">B</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof324')">Proof.</span></div>
<div class="proofscript" id="proof324">
 <span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">separated</span> <span class="id">andC</span> <span class="id">setIC</span> (<span class="id">setIC</span> <span class="id">_</span> <span class="id">B</span>). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">separated_disjoint</span> <span class="id">A</span> <span class="id">B</span> : <span class="id">separated</span> <span class="id">A</span> <span class="id">B</span> -&gt; <span class="id">A</span> `&amp;` <span class="id">B</span> = <span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof325')">Proof.</span></div>
<div class="proofscript" id="proof325">
<span class="id">move</span>=&gt; <span class="id">AB</span>; <span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">x</span>; <span class="id">split</span> =&gt; // -[<span class="id">Ax</span> <span class="id">Bx</span>].<br/>
<span class="kwd">by</span> <span class="id">move</span>: <span class="id">AB</span>; <span class="id">rewrite</span> /<span class="id">separated</span> =&gt; -[&lt;- <span class="id">_</span>]; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: <span class="id">subset_closure</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connectedPn</span> <span class="id">A</span> : ~ <span class="id">connected</span> <span class="id">A</span> &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">E</span> : <span class="id">bool</span> -&gt; <span class="id">set</span> <span class="id">T</span>, [/\ <span class="kwd">forall</span> <span class="id">b</span>, <span class="id">E</span> <span class="id">b</span> !=<span class="id">set0</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span> = <span class="id">E</span> <span class="id">false</span> `|` <span class="id">E</span> <span class="id">true</span> &amp; <span class="id">separated</span> (<span class="id">E</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setD">false</a></span>) (<span class="id"><a href="mathcomp.analysis.topology.html#closure">E</a></span> <span class="id">true</span>)].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof326')">Proof.</span></div>
<div class="proofscript" id="proof326">
<span class="id">rewrite</span> -<span class="id">propeqE</span>; <span class="id">apply</span>: <span class="id">notLR</span>; <span class="id">rewrite</span> <span class="id">propeqE</span>.<br/>
<span class="id">split</span>=&gt; [<span class="id">conE</span> [<span class="id">E</span> [<span class="id">E0</span> <span class="id">EU</span> [<span class="id">E1</span> <span class="id">E2</span>]]]|<span class="id">conE</span> <span class="id">B</span> <span class="id">B0</span> [<span class="id">C</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setU0">oC</a></span> <span class="id">BAC</span>] [<span class="id">D</span> <span class="id">cD</span> <span class="id">BAD</span>]].<br/>
&nbsp;&nbsp;<span class="id">suff</span> : <span class="id">E</span> <span class="id">true</span> = <span class="id">A</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>/<span class="id">esym</span>/(<span class="id">congr1</span> (<span class="id">setD</span>^~ (<span class="id">closure</span> (<span class="id">E</span> <span class="id">true</span>)))); <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#closure">EU</a></span> <span class="id">setDUl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span> := @<span class="id">subset_closure</span> <span class="id">_</span> (<span class="id">E</span> <span class="id">true</span>); <span class="id">rewrite</span> -<span class="id">setD_eq0</span> =&gt; -&gt;; <span class="id">rewrite</span> <span class="id">setU0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>/<span class="id">setDidPl</span> : <span class="id">E2</span> =&gt; -&gt;; <span class="id">exact</span>/<span class="id">eqP</span>/<span class="id">set0P</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id">conE</span> <span class="id">_</span> (<span class="id">E0</span> <span class="id">true</span>)).<br/>
&nbsp;&nbsp;- <span class="kwd">exists</span> (~` (<span class="id">closure</span> (<span class="id">E</span> <span class="id">false</span>))); <span class="id">first</span> <span class="id">exact</span>/<span class="id">closed_openC</span>/<span class="id">closed_closure</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">EU</span> <span class="id">setIUl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span> /<span class="id">subsets_disjoint</span> -&gt; := @<span class="id">subset_closure</span> <span class="id">_</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#esym">E</a></span> <span class="id">false</span>); <span class="id">rewrite</span> <span class="id">set0U</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">esym</span>/<span class="id">setIidPl</span>/<span class="id">disjoints_subset</span>; <span class="id">rewrite</span> <span class="id"><a name="i:1901">setIC</a></span>.<br/>
&nbsp;&nbsp;- <span class="kwd">exists</span> (<span class="id">closure</span> (<span class="id">E</span> <span class="id">true</span>)); <span class="id">first</span> <span class="id">exact</span>: <span class="id">closed_closure</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">EU</span> <span class="id">setIUl</span> <span class="id">E2</span> <span class="id">set0U</span>; <span class="id">exact</span>/<span class="id">esym</span>/<span class="id">setIidPl</span>/<span class="id">subset_closure</span>.<br/>
<span class="id"><a href="mathcomp.classical.classical_sets.html#setCK">apply</a></span>: <span class="id">contrapT</span> =&gt; <span class="id">AF</span>; <span class="id">apply</span>: <span class="id">conE</span>.<br/>
<span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setIidPl">i</a></span> =&gt; <span class="kwd">if</span> <span class="id">i</span> <span class="id">is</span> <span class="id">false</span> <span class="kwd">then</span> <span class="id">A</span> `\` <span class="id"><a href="mathcomp.classical.classical_sets.html#setIUr">C</a></span> <span class="kwd">else</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setUCl">A</a></span> `&amp;` <span class="id">C</span>); <span class="id">split</span>.<br/>
- <span class="id">case</span>=&gt; /=; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.classical.classical_sets.html#disjoints_subset">BAC</a></span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>/<span class="id">set0P</span>/<span class="id">eqP</span> =&gt; /<span class="id">disjoints_subset</span>; <span class="id">rewrite</span> <span class="id">setCK</span> =&gt; <span class="id">EC</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">AF</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setDE">BAC</a></span>; <span class="id">exact</span>/<span class="id">setIidPl</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">setDE</span> -<span class="id">setIUr</span> <span class="id">setUCl</span> <span class="id">setIT</span>.<br/>
- <span class="id">split</span>.<br/>
&nbsp;&nbsp;+ <span class="id">rewrite</span> <span class="id">setIC</span>; <span class="id">apply</span>/<span class="id">disjoints_subset</span>; <span class="id">rewrite</span> <span class="id">closureC</span> =&gt; <span class="id">x</span> [? ?].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">C</span> =&gt; //; <span class="id">split</span>=&gt; //; <span class="id">rewrite</span> <span class="id">setDE</span> <span class="id">setCI</span> <span class="id">setCK</span>; <span class="id">right</span>.<br/>
&nbsp;&nbsp;+ <span class="id">apply</span>/<span class="id">disjoints_subset</span> =&gt; <span class="id">y</span> -[<span class="id">Ay</span> <span class="id">Cy</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> -<span class="id">BAC</span> <span class="id">BAD</span> =&gt; /<span class="id">closureI</span>[<span class="id">_</span>]; <span class="id">move</span>/<span class="id">closure_id</span> : <span class="id">cD</span> =&gt; &lt;- <span class="id">Dy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> : <span class="id">B</span> <span class="id">y</span>; [<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">BAD</span>; <span class="id">split</span>|<span class="id">rewrite</span> <span class="id">BAC</span> =&gt; -[]].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connectedP</span> <span class="id">A</span> : <span class="id">connected</span> <span class="id">A</span> &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">E</span> : <span class="id">bool</span> -&gt; <span class="id">set</span> <span class="id">T</span>, ~ [/\ <span class="kwd">forall</span> <span class="id">b</span>, <span class="id">E</span> <span class="id">b</span> !=<span class="id">set0</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a name="C:1910">A</a></span> = <span class="id"><a href="mathcomp.analysis.topology.html#separated">E</a></span> <span class="id">false</span> `|` <span class="id">E</span> <span class="id">true</span> &amp; <span class="id">separated</span> (<span class="id">E</span> <span class="id">false</span>) (<span class="id">E</span> <span class="id">true</span>)].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof327')">Proof.</span></div>
<div class="proofscript" id="proof327">
<span class="id">rewrite</span> -<span class="id">propeqE</span> <span class="id">forallNE</span>; <span class="id">apply</span>: <span class="id">notRL</span>; <span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">exact</span>: <span class="id">connectedPn</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_subset</span> <span class="id">A</span> <span class="id">B</span> <span class="id">C</span> : <span class="id">separated</span> <span class="id">A</span> <span class="id">B</span> -&gt; <span class="id">C</span> `&lt;=` <span class="id">A</span> `|` <span class="id">B</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">connected</span> <span class="id">C</span> -&gt; <span class="id">C</span> `&lt;=` <span class="id">A</span> \/ <span class="id">C</span> `&lt;=` <span class="id">B</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof328')">Proof.</span></div>
<div class="proofscript" id="proof328">
<span class="id">move</span>=&gt; <span class="id">AB</span> <span class="id">CAB</span>; <span class="id">have</span> -&gt; : <span class="id">C</span> = (<span class="id">C</span> `&amp;` <span class="id">A</span>) `|` (<span class="id">C</span> `&amp;` <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">x</span>; <span class="id">split</span>=&gt; [<span class="id">Cx</span>|[] [] //].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [<span class="id">Ax</span>|<span class="id">Bx</span>] := <span class="id">CAB</span> <span class="id">_</span> <span class="id">Cx</span>; [<span class="id">left</span>|<span class="id"><a href="mathcomp.classical.classical_sets.html#set0U">right</a></span>].<br/>
<span class="id">move</span>/<span class="id">connectedP</span>/(<span class="id">_</span> (<span class="kwd">fun</span> <span class="id">b</span> =&gt; <span class="kwd">if</span> <span class="id">b</span> <span class="kwd">then</span> <span class="id">C</span> `&amp;` <span class="id">B</span> <span class="kwd">else</span> <span class="id">C</span> `&amp;` <span class="id">A</span>)) =&gt; /<span class="id">not_and3P</span>[]//.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>/<span class="id">existsNP</span> =&gt; [<span class="id">b</span> /<span class="id">set0P</span>/<span class="id">negP</span>/<span class="id">negPn</span>]; <span class="id">case</span>: <span class="id">b</span> =&gt; /<span class="id">eqP</span> -&gt;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> !(<span class="id">setU0</span>,<span class="id">set0U</span>); [<span class="id">left</span>|<span class="id">right</span>]; <span class="id">apply</span>: <span class="id">subIset</span>; <span class="id">right</span>.<br/>
<span class="id">case</span>/<span class="id">not_andP</span> =&gt; /<span class="id">eqP</span>/<span class="id">set0P</span>[<span class="id">x</span> []].<br/>
- <span class="id">move</span>=&gt; /<span class="id">closureI</span>[<span class="id">cCx</span> <span class="id">cAx</span>] [<span class="id">Cx</span> <span class="id">Bx</span>]; <span class="id">exfalso</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>: <span class="id">AB</span>; <span class="id">rewrite</span> /<span class="id">separated</span> =&gt; -[] + <span class="id"><a href="mathcomp.analysis.topology.html#connected">_</a></span>; <span class="id">apply</span>/<span class="id">eqP</span>/<span class="id">set0P</span>; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
- <span class="id">move</span>=&gt; [<span class="id">Cx</span> <span class="id">Ax</span>] /<span class="id">closureI</span>[<span class="id">cCx</span> <span class="id">cBx</span>]; <span class="id">exfalso</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>: <span class="id">AB</span>; <span class="id">rewrite</span> /<span class="id">separated</span> =&gt; -[] <span class="id">_</span>; <span class="id">apply</span>/<span class="id">eqP</span>/<span class="id">set0P</span>; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected1</span> <span class="id">x</span> : <span class="id">connected</span> [<span class="id">set</span> <span class="id">x</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof329')">Proof.</span></div>
<div class="proofscript" id="proof329">
<span class="id">move</span>=&gt; <span class="id">X</span> [<span class="id">y</span> +] [<span class="id">O</span> <span class="id">Oopen</span> <span class="id">XO</span>] [<span class="id">C</span> <span class="id">Cclosed</span> <span class="id">XC</span>]; <span class="id">rewrite</span> <span class="id">XO</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [{<span class="id">y</span>}-&gt; <span class="id">Ox</span>]; <span class="id">apply</span>/<span class="id">seteqP</span>; <span class="id">split</span>=&gt; <span class="id">y</span> =&gt; [[-&gt;//]|-&gt;].<br/>
Qed.</div>
<span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">connected1</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">bigcup_connected</span> <span class="id">I</span> (<span class="id">A</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>) (<span class="id">P</span> : <span class="id">I</span> -&gt; <span class="kwd">Prop</span>) :<br/>
&nbsp;&nbsp;\<span class="id">bigcap_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">P</span>) (<span class="id">A</span> <span class="id">i</span>) !=<span class="id">set0</span> -&gt; (<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">P</span> <span class="id">i</span> -&gt; <span class="id">connected</span> (<span class="id">A</span> <span class="id">i</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">connected</span> (\<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">P</span>) (<span class="id">A</span> <span class="id">i</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof330')">Proof.</span></div>
<div class="proofscript" id="proof330">
<span class="id"><a href="mathcomp.classical.boolp.html#predeqE">move</a></span>=&gt; [<span class="id">c</span> <span class="id">AIc</span>] <span class="id">cA</span>; <span class="id">have</span> [[<span class="id">i</span> <span class="id">Pi</span>]|] := <span class="id">pselect</span> (<span class="kwd">exists</span> <span class="id">i</span>, <span class="id">P</span> <span class="id">i</span>); <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>/<span class="id">forallNP</span> =&gt; <span class="id">P0</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">_</span> : <span class="id">P</span> = <span class="id">set0</span>) ?<span class="id">bigcup_set0</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">connected0</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">x</span>; <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">P0</span>.<br/>
<span class="id">apply</span>/<span class="id">connectedP</span> =&gt; [<span class="id">E</span> [<span class="id">E0</span> <span class="id">EU</span> <span class="id">sE</span>]].<br/>
<span class="id">wlog</span> <span class="id">E0c</span> : <span class="id">E</span> <span class="id">E0</span> <span class="id">EU</span> <span class="id">sE</span> / <span class="id">E</span> <span class="id">false</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">G</span>; <span class="id">have</span> : (\<span class="id"><a href="mathcomp.analysis.topology.html#separatedC">bigcup_</a></span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">P</span>) <span class="id">A</span> <span class="id">i</span>) <span class="id">c</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0P">i</a></span> =&gt; //; <span class="id">exact</span>: <span class="id">AIc</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">EU</span> =&gt; -[<span class="id">E0c</span>|<span class="id">E1c</span>]; <span class="id">first</span> <span class="id">exact</span>: <span class="id">G</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">G</span> (<span class="id">E</span> \<span class="id">o</span> <span class="id">negb</span>)) =&gt; //;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">case</span> =&gt; /=|<span class="id">rewrite</span> <span class="id">EU</span> <span class="id">setUC</span>|<span class="id">rewrite</span> <span class="id">separatedC</span>].<br/>
<span class="id">move</span>: (<span class="id">E0</span> <span class="id">true</span>) =&gt; /<span class="id">set0P</span>/<span class="id">eqP</span>; <span class="id">apply</span>.<br/>
<span class="id">have</span> [/<span class="id">eqP</span> //|/<span class="id">set0P</span>[<span class="id">d</span> <span class="id">E1d</span>]] := <span class="id">boolP</span> (<span class="id">E</span> <span class="id">true</span> == <span class="id">set0</span>).<br/>
<span class="id">have</span> : \<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">P</span>) <span class="id">A</span> <span class="id">i</span> `&lt;=` <span class="id">E</span> <span class="id">false</span>.<br/>
&nbsp;&nbsp;<span class="id">suff</span> <span class="id">AE</span> : <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">P</span> <span class="id">i</span> -&gt; <span class="id">A</span> <span class="id">i</span> `&lt;=` <span class="id">E</span> <span class="id">false</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">x</span> [<span class="id">j</span> ? ?]; <span class="id">exact</span>: (<span class="id">AE</span> <span class="id">j</span>).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#separated_disjoint">j</a></span> <span class="id">Pj</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>: (@<span class="id">connected_subset</span> <span class="id">_</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0P">_</a></span> (<span class="id">A</span> <span class="id">j</span>) <span class="id">sE</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> -<span class="id">EU</span> =&gt; /(<span class="id">_</span> (<span class="id">bigcup_sup</span> <span class="id">_</span>) (<span class="id">cA</span> <span class="id">_</span> <span class="id">Pj</span>)) [//| | <span class="id">AjE1</span>]; <span class="id">first</span> <span class="id">exact</span>.<br/>
&nbsp;&nbsp;<span class="id">exfalso</span>; <span class="id">have</span> <span class="id">E1c</span> := <span class="id">AjE1</span> <span class="id">_</span> (<span class="id">AIc</span> <span class="id">_</span> <span class="id">Pj</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>/<span class="id">separated_disjoint</span> : <span class="id">sE</span>; <span class="id">apply</span>/<span class="id">eqP</span>/<span class="id">set0P</span>; <span class="kwd">exists</span> <span class="id">c</span>.<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#connected">rewrite</a></span> <span class="id">EU</span> <span class="id">subUset</span> =&gt; -[<span class="id">_</span>] /(<span class="id">_</span> <span class="id">_</span> <span class="id">E1d</span>) <span class="id">E0d</span>; <span class="id">exfalso</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>/<span class="id">separated_disjoint</span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#bigcup2inE">sE</a></span>; <span class="id">apply</span>/<span class="id">eqP</span>/<span class="id">set0P</span>; <span class="kwd">exists</span> <span class="id">d</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connectedU</span> <span class="id">A</span> <span class="id">B</span> : <span class="id">A</span> `&amp;` <span class="id">B</span> !=<span class="id">set0</span> -&gt; <span class="id">connected</span> <span class="id">A</span> -&gt; <span class="id">connected</span> <span class="id">B</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="id">connected</span> (<span class="id">A</span> `|` <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof331')">Proof.</span></div>
<div class="proofscript" id="proof331">
<span class="id">move</span>=&gt; [<span class="id">x</span> [<span class="id">Ax</span> <span class="id">Bx</span>]] <span class="id">Ac</span> <span class="id">Bc</span>; <span class="id">rewrite</span> -<span class="id">bigcup2inE</span>; <span class="id">apply</span>: <span class="id">bigcup_connected</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">x</span> =&gt; //= -[|[|[]]].<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [|[|[]]].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_closure</span> <span class="id">A</span> : <span class="id">connected</span> <span class="id">A</span> -&gt; <span class="id">connected</span> (<span class="id">closure</span> <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof332')">Proof.</span></div>
<div class="proofscript" id="proof332">
<span class="id">move</span>=&gt; <span class="id">ctdA</span> <span class="id">U</span> <span class="id">U0</span> [<span class="id">C1</span> <span class="id">oC1</span> <span class="id">C1E</span>] [<span class="id">C2</span> <span class="id">cC2</span> <span class="id">C2E</span>]; <span class="id">rewrite</span> <span class="id">eqEsubset</span> <span class="id">C2E</span>; <span class="id">split</span> =&gt; //.<br/>
<span class="id">suff</span> : <span class="id">A</span> `&lt;=` <span class="id">U</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>/<span class="id">closure_subset</span>; <span class="id">rewrite</span> [<span class="id">_</span> `&amp;` <span class="id">_</span>](<span class="id">iffLR</span> (<span class="id">closure_id</span> <span class="id">_</span>)) ?<span class="id">C2E</span>//.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">closedI</span> =&gt; //; <span class="id">exact</span>: <span class="id">closed_closure</span>.<br/>
<span class="id">rewrite</span> -<span class="id">setIidPl</span>; <span class="id">apply</span>: <span class="id">ctdA</span>.<br/>
- <span class="id">move</span>: <span class="id">U0</span>; <span class="id">rewrite</span> <span class="id">C1E</span> =&gt; -[<span class="id">z</span> [<span class="id"><a href="mathcomp.classical.classical_sets.html#setIA">clAx</a></span> <span class="id">C1z</span>]]; <span class="id">have</span> [] := <span class="id">clAx</span> <span class="id">C1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">open_nbhs_nbhs</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">w</span> [<span class="id">Aw</span> <span class="id">C1w</span>]; <span class="kwd">exists</span> <span class="id"><a href="mathcomp.analysis.topology.html#subset_closure">w</a></span>; <span class="id">rewrite</span> <span class="id">setIA</span> (<span class="id">setIidl</span> (@<span class="id">subset_closure</span> <span class="id">_</span> <span class="id">_</span>)).<br/>
- <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">C1</span> =&gt; //; <span class="id"><a name="x:1927">rewrite</a></span> <span class="id">C1E</span> <span class="id">setIA</span> (<span class="id">setIidl</span> (@<span class="id">subset_closure</span> <span class="id">_</span> <span class="id">_</span>)).<br/>
- <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.analysis.topology.html#connected">C2</a></span> =&gt; //; <span class="id">rewrite</span> <span class="id">C2E</span> <span class="id">setIA</span> (<span class="id">setIidl</span> (@<span class="id">subset_closure</span> <span class="id">_</span> <span class="id">_</span>)).<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">connected_component</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) (<span class="id">x</span> : <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;\<span class="id">bigcup_</span>(<span class="id">A</span> <span class="kwd">in</span> [<span class="id">set</span> <span class="id">C</span> : <span class="id">set</span> <span class="id">T</span> | [/\ <span class="id">C</span> <span class="id">x</span>, <span class="id">C</span> `&lt;=` <span class="id">A</span> &amp; <span class="id">connected</span> <span class="id">C</span>]]) <span class="id">A</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">component_connected</span> <span class="id">A</span> <span class="id">x</span> : <span class="id">connected</span> (<span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof333')">Proof.</span></div>
<div class="proofscript" id="proof333">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">bigcup_connected</span>; [<span class="kwd">exists</span> <span class="id">x</span> =&gt; <span class="id"><a name="x:1935">C</a></span> []|<span class="id">move</span>=&gt; <span class="id">C</span> []]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_component_sub</span> <span class="id">A</span> <span class="id">x</span> : <span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof334')">Proof.</span></div>
<div class="proofscript" id="proof334">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">y</span> [<span class="id">B</span> [<span class="id">_</span> + <span class="id">_</span>]] =&gt; /[<span class="id">apply</span>]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_component_id</span> <span class="id">A</span> <span class="id">x</span> :<br/>
&nbsp;&nbsp;<span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">connected</span> <span class="id">A</span> -&gt; <span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span> = <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof335')">Proof.</span></div>
<div class="proofscript" id="proof335">
<span class="id">move</span>=&gt; <span class="id">Ax</span> <span class="id">Ac</span>; <span class="id">apply</span>/<span class="id">seteqP</span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">connected_component_sub</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">y</span> <span class="id">Ay</span>; <span class="kwd">exists</span> <span class="id">A</span> =&gt; //; <span class="id">split</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_component_out</span> <span class="id">A</span> <span class="id">x</span> :<br/>
&nbsp;&nbsp;~ <span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span> = <span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof336')">Proof.</span></div>
<div class="proofscript" id="proof336">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">NAx</span>; <span class="id">rewrite</span> -<span class="id">subset0</span> =&gt; <span class="id">y</span> [<span class="id">B</span> [/[<span class="id">swap</span>]/[<span class="id">apply</span>]]]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_component_max</span> <span class="id">A</span> <span class="id">B</span> <span class="id">x</span> : <span class="id">B</span> <span class="id">x</span> -&gt; <span class="id">B</span> `&lt;=` <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">connected</span> <span class="id">B</span> -&gt; <span class="id">B</span> `&lt;=` <span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof337')">Proof.</span></div>
<div class="proofscript" id="proof337">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Bx</span> <span class="id">BA</span> <span class="id">Bc</span> <span class="id">y</span> <span class="id">By</span>; <span class="kwd">exists</span> <span class="id">B</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_component_refl</span> <span class="id">A</span> <span class="id">x</span> : <span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">connected_component</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqP">A</a></span> <span class="id">x</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof338')">Proof.</span></div>
<div class="proofscript" id="proof338">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Ax</span>; <span class="kwd">exists</span> [<span class="id"><a href="mathcomp.analysis.topology.html#connected_component_sub">set</a></span> <span class="id">x</span>] =&gt; //; <span class="id">split</span> =&gt; // <span class="id">_</span> -&gt;. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#connected_component">connected_component_cover</a></span> <span class="id">A</span> :<br/>
&nbsp;&nbsp;\<span class="id">bigcup_</span>(<span class="id">A</span> <span class="kwd">in</span> <span class="id">connected_component</span> <span class="id">A</span> @` <span class="id">A</span>) <span class="id">A</span> = <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof339')">Proof.</span></div>
<div class="proofscript" id="proof339">
<span class="id">apply</span>/<span class="id">predeqP</span> =&gt; <span class="id"><a name="y:1947">x</a></span>; <span class="id">split</span>=&gt; [[<span class="id">B</span> [<span class="id">y</span> <span class="id">By</span> &lt;- /<span class="id">connected_component_sub</span>//]]|<span class="id">Ax</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span>) =&gt; //; <span class="id">apply</span>: <span class="id">connected_component_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_component_sym</span> <span class="id">A</span> <span class="id">x</span> <span class="id">y</span> :<br/>
&nbsp;&nbsp;<span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span> <span class="id">y</span> -&gt; <span class="id">connected_component</span> <span class="id">A</span> <span class="id">y</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof340')">Proof.</span></div>
<div class="proofscript" id="proof340">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">B</span> [*]]; <span class="kwd">exists</span> <span class="id">B</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_component_trans</span> <span class="id">A</span> <span class="id">y</span> <span class="id">x</span> <span class="id">z</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span> <span class="id">y</span> -&gt; <span class="id">connected_component</span> <span class="id">A</span> <span class="id">y</span> <span class="id">z</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">connected_component</span> <span class="id"><a name="same_connected_component">A</a></span> <span class="id">x</span> <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof341')">Proof.</span></div>
<div class="proofscript" id="proof341">
<span class="id">move</span>=&gt; [<span class="id">B</span> [<span class="id"><a name="A:1952">Bx</a></span> <span class="id">BA</span> <span class="id">Ac</span> <span class="id">Ay</span>]] [<span class="id">C</span> [<span class="id">Cy</span> <span class="id">CA</span> <span class="id">Cc</span> <span class="id">Cz</span>]]; <span class="kwd">exists</span> (<span class="id">B</span> `|` <span class="id">C</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">right</span>.<br/>
<span class="kwd">by</span> <span class="id">split</span>; [<span class="id">left</span> | <span class="id">rewrite</span> <span class="id">subUset</span> | <span class="id">apply</span>: <span class="id">connectedU</span>=&gt; //; <span class="kwd">exists</span> <span class="id">y</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">same_connected_component</span> <span class="id">A</span> <span class="id">x</span> <span class="id">y</span> : <span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span> <span class="id">y</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span> = <span class="id"><a name="A:1955">connected_component</a></span> <span class="id">A</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof342')">Proof.</span></div>
<div class="proofscript" id="proof342">
<span class="id">move</span>=&gt; <span class="id">Axy</span>; <span class="id">apply</span>/<span class="id">seteqP</span>; <span class="id">split</span> =&gt; <span class="id">z</span>; <span class="id">apply</span>: <span class="id">connected_component_trans</span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">connected_component_sym</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">component_closed</span> <span class="id">A</span> <span class="id">x</span> : <span class="id">closed</span> <span class="id">A</span> -&gt; <span class="id">closed</span> (<span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof343')">Proof.</span></div>
<div class="proofscript" id="proof343">
<span class="id">move</span>=&gt; <span class="id">clA</span>; <span class="id">have</span> [<span class="id">Ax</span>|<span class="id">Ax</span>] := <span class="id">pselect</span> (<span class="id">A</span> <span class="id">x</span>); <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">connected_component_out</span> //; <span class="id">exact</span>: <span class="id">closed0</span>.<br/>
<span class="id">rewrite</span> <span class="id">closure_id</span> <span class="id">eqEsubset</span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">subset_closure</span>.<br/>
<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#closure_subset">z</a></span> <span class="id">Axz</span>; <span class="kwd">exists</span> (<span class="id">closure</span> (<span class="id">connected_component</span> <span class="id">A</span> <span class="id">x</span>)) =&gt; //.<br/>
<span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>/<span class="id">subset_closure</span>/<span class="id">connected_component_refl</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> [<span class="id">X</span> <span class="kwd">in</span> <span class="id">_</span> `&lt;=` <span class="id">X</span>](<span class="id">closure_id</span> <span class="id">A</span>).1//.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">closure_subset</span>; <span class="id">exact</span>: <span class="id">connected_component_sub</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">connected_closure</span>; <span class="id">exact</span>: <span class="id">component_connected</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopen_separatedP</span> <span class="id">A</span> : <span class="id">clopen</span> <span class="id">A</span> &lt;-&gt; <span class="id">separated</span> <span class="id">A</span> (~` <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof344')">Proof.</span></div>
<div class="proofscript" id="proof344">
<span class="id">split</span>=&gt; [[<span class="id">oA</span> <span class="id">cA</span>]|[] /[!(@<span class="id">disjoints_subset</span> <span class="id">T</span>)] /[!(@<span class="id">setCK</span> <span class="id">T</span>)] <span class="id">clAA</span> <span class="id">AclA</span>].<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">separated</span> -((<span class="id">closure_id</span> <span class="id">A</span>).1 <span class="id">cA</span>) <span class="id"><a href="mathcomp.analysis.topology.html#closedC">setICr</a></span> ; <span class="id">split</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -((<span class="id">closure_id</span> <span class="id">_</span>).1 (<span class="id">open_closedC</span> <span class="id">oA</span>)) <span class="id">setICr</span>.<br/>
<span class="id">split</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">closure_id</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">subset_closure</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id"><a name="DiscreteTopology">closedC</a></span> <span class="id">closure_id</span> <span class="id">eqEsubset</span>; <span class="id">split</span>;<br/>
&nbsp;&nbsp;[<span class="id">exact</span>: <span class="id">subset_closure</span>|<span class="id">exact</span>: <span class="id">subsetCr</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">connected_sets</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">connected</span> {<span class="id">T</span>}.<br/>
<span class="kwd">Arguments</span> <span class="id">connected_component</span> {<span class="id">T</span>}.<br/>
<span class="kwd">Section</span> <span class="id">DiscreteTopology</span>.<br/>
<span class="kwd">Section</span> <span class="id">DiscreteMixin</span>.<br/>
<span class="kwd">Context</span> {<span class="id">X</span> : <span class="kwd">Type</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_sing</span> (<span class="id">p</span> : <span class="id">X</span>) (<span class="id">A</span> : <span class="id">set</span> <span class="id">X</span>) : <span class="id">principal_filter</span> <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id">A</span> <span class="id">p</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof345')">Proof.</span></div>
<div class="proofscript" id="proof345">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">principal_filterP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_nbhs</span> (<span class="id">p</span> : <span class="id">X</span>) (<span class="id">A</span> : <span class="id">set</span> <span class="id">X</span>) :<br/>
&nbsp;&nbsp;<span class="id">principal_filter</span> <span class="id">p</span> <span class="id">A</span> -&gt; <span class="id">principal_filter</span> <span class="id">p</span> (<span class="id">principal_filter</span>^~ <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof346')">Proof.</span></div>
<div class="proofscript" id="proof346">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">exact</span>/<span class="id">principal_filterP</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">discrete_topological_mixin</span> :=<br/>
&nbsp;&nbsp;<span class="id">topologyOfFilterMixin</span> <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">principal_filter_proper</a></span> <span class="id">discrete_sing</span> <span class="id">discrete_nbhs</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">DiscreteMixin</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">discrete_space</span> (<span class="id">X</span> : <span class="id">topologicalType</span>) :=<br/>
&nbsp;&nbsp;@<span class="id">nbhs</span> <span class="id">X</span> <span class="id"><a href="mathcomp.analysis.topology.html#DiscreteTopology.dsc">_</a></span> = @<span class="id">principal_filter</span> <span class="id">X</span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">X</span> : <span class="id">topologicalType</span>} {<span class="id"><a name="x:1968">dsc</a></span>: <span class="id">discrete_space</span> <span class="id">X</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_open</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">X</span>) : <span class="id">open</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof347')">Proof.</span></div>
<div class="proofscript" id="proof347">
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">openE</span> =&gt; ? ?; <span class="id">rewrite</span> /<span class="id">interior</span> <span class="id">dsc</span>; <span class="id"><a name="A:1969">exact</a></span>/<span class="id">principal_filterP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_set1</span> (<span class="id">x</span> : <span class="id">X</span>) : <span class="id">nbhs</span> <span class="id">x</span> [<span class="id">set</span> <span class="id">x</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof348')">Proof.</span></div>
<div class="proofscript" id="proof348">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a name="discrete_cvg">open_nbhs_nbhs</a></span>; <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#DiscreteTopology.X">discrete_open</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_closed</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">X</span>) : <span class="id">closed</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof349')">Proof.</span></div>
<div class="proofscript" id="proof349">
 <span class="kwd">by</span> <span class="id">rewrite</span> -[<span class="id">A</span>]<span class="id">setCK</span> <span class="id">closedC</span>; <span class="id">exact</span>: <span class="id">discrete_open</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_cvg</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">X</span>)) (<span class="id">x</span> : <span class="id">X</span>) :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; <span class="id">F</span> --&gt; <span class="id">x</span> &lt;-&gt; <span class="id">F</span> [<span class="id">set</span> <span class="id">x</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof350')">Proof.</span></div>
<div class="proofscript" id="proof350">
<span class="id">rewrite</span> /<span class="id">filter_of</span> <span class="id">dsc</span> <span class="id">nbhs_simpl</span>; <span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">exact</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Fx</span> <span class="id">U</span> /<span class="id">principal_filterP</span> ?; <span class="id"><a name="bool_discrete_topology">apply</a></span>: <span class="id">filterS</span> <span class="id">Fx</span> =&gt; ? -&gt;.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_hausdorff</span> : <span class="id">hausdorff_space</span> <span class="id">X</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof351')">Proof.</span></div>
<div class="proofscript" id="proof351">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span> <span class="id">q</span> /(<span class="id"><a name="discrete_bool">_</a></span> <span class="id">_</span> <span class="id">_</span> (<span class="id">discrete_set1</span> <span class="id">p</span>) (<span class="id">discrete_set1</span> <span class="id">q</span>))[<span class="id">x</span> [] -&gt; -&gt;].<br/>
Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id">bool_discrete_topology</span> : <span class="id">topologicalType</span> :=<br/>
&nbsp;&nbsp;<span class="id">TopologicalType</span> <span class="id">bool</span> <span class="id">discrete_topological_mixin</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_bool</span> : <span class="id">discrete_space</span> <span class="id">bool_discrete_topology</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof352')">Proof.</span></div>
<div class="proofscript" id="proof352">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">bool_compact</span> : <span class="id">compact</span> [<span class="id">set</span>: <span class="id">bool</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof353')">Proof.</span></div>
<div class="proofscript" id="proof353">
 <span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">rewrite</a></span> <span class="id">setT_bool</span>; <span class="id">apply</span>/<span class="id">compactU</span>; <span class="id">exact</span>: <span class="id">compact_set1</span>. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">DiscreteTopology</span>.<br/>
<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">discrete_bool</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">perfect_sets</span>.<br/>
<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> (<span class="id">T</span> : <span class="id">topologicalType</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">perfect_set</a></span> {<span class="id">T</span>} (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) := <span class="id">closed</span> <span class="id">A</span> /\ <span class="id">limit_point</span> <span class="id">A</span> = <span class="id">A</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">perfectTP</span> {<span class="id">T</span>} : <span class="id">perfect_set</span> [<span class="id">set</span>: <span class="id">T</span>] &lt;-&gt; <span class="kwd">forall</span> <span class="id">x</span> : <span class="id">T</span>, ~ <span class="id">open</span> [<span class="id">set</span> <span class="id">x</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof354')">Proof.</span></div>
<div class="proofscript" id="proof354">
<span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>=&gt; <span class="id">_</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">case</span>=&gt; <span class="id">_</span> + <span class="id">x</span> <span class="id">Ox</span> =&gt; /(<span class="id">_</span> <span class="id">x</span> <span class="id">I</span> [<span class="id">set</span> <span class="id">x</span>]).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>; [<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">open_nbhs_nbhs</span>; <span class="id">split</span> |] =&gt; <span class="id">y</span> [+ <span class="id">_</span>] =&gt; /[<span class="id">swap</span>] -&gt; /<span class="id">eqP</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">NOx</span>; <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">closedT</span> |]; <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id"><a name="y:1976">x</a></span> // <span class="id">_</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">U</span>; <span class="id">rewrite</span> <span class="id">nbhsE</span>; <span class="id">case</span>=&gt; <span class="id">V</span> [] <span class="id">oV</span> <span class="id">Vx</span> <span class="id">VU</span>.<br/>
<span class="id">have</span> <span class="id">Vnx</span>: <span class="id">V</span> != [<span class="id">set</span> <span class="id">x</span>] <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">eqP</span> =&gt; <span class="id">M</span>; <span class="id">apply</span>: (<span class="id">NOx</span> <span class="id">x</span>); <span class="id">rewrite</span> -<span class="id">M</span>.<br/>
<span class="id">have</span> /<span class="id">existsNP</span> [<span class="id">y</span> /<span class="id">existsNP</span> [<span class="id">Vy</span> <span class="id">Ynx</span>]] : ~ <span class="kwd">forall</span> <span class="id">y</span>, <span class="id"><a name="perfect_prod">V</a></span> <span class="id">y</span> -&gt; <span class="id">y</span> = <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>/<span class="id">negP</span>: <span class="id">Vnx</span>; <span class="id">apply</span>: <span class="id">contra_not</span> =&gt; <span class="id">Vxy</span>; <span class="id">apply</span>/<span class="id">eqP</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span> =&gt; // ? -&gt;.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">y</span>; <span class="id">split</span> =&gt; //; [<span class="id">exact</span>/<span class="id">eqP</span> | <span class="id"><a href="mathcomp.analysis.topology.html#perfectTP">exact</a></span>: <span class="id">VU</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">perfect_prod</span> {<span class="id">I</span> : <span class="kwd">Type</span>} (<span class="id">i</span> : <span class="id">I</span>) (<span class="id">K</span> : <span class="id">I</span> -&gt; <span class="id">topologicalType</span>) :<br/>
&nbsp;&nbsp;<span class="id">perfect_set</span> [<span class="id">set</span>: <span class="id">K</span> <span class="id">i</span>] -&gt; <span class="id">perfect_set</span> [<span class="id">set</span>: <span class="id">product_topologicalType</span> <span class="id">K</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof355')">Proof.</span></div>
<div class="proofscript" id="proof355">
<span class="id">move</span>=&gt; /<span class="id">perfectTP</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">KPo</a></span>; <span class="id">apply</span>/<span class="id">perfectTP</span> =&gt; <span class="id">f</span> <span class="id">oF</span>; <span class="id">apply</span>: (<span class="id">KPo</span> (<span class="id">f</span> <span class="id">i</span>)).<br/>
<span class="id">rewrite</span> (<span class="id">_</span> : [<span class="id">set</span> <span class="id">f</span> <span class="id">i</span>] = <span class="id">proj</span> <span class="id">i</span> @` [<span class="id">set</span> <span class="id">f</span>]).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#nat_topologicalType">apply</a></span>: (@<span class="id">proj_open</span> (<span class="id">classicType_choiceType</span> <span class="id">I</span>) <span class="id">_</span> <span class="id">i</span>); <span class="id"><a name="i:1981">exact</a></span>: <span class="id">oF</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; ? //; [<span class="id">move</span>=&gt; -&gt; /=; <span class="kwd">exists</span> <span class="id">f</span> | <span class="id">case</span>=&gt; <span class="id">g</span> -&gt;].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">perfect_diagonal</span> (<span class="id">K</span> : <span class="id">nat_topologicalType</span> -&gt; <span class="id">topologicalType</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="kwd">exists</span> (<span class="id">xy</span>: <span class="id">K</span> <span class="id">i</span> * <span class="id">K</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">i</a></span>), <span class="id">xy</span>.1 != <span class="id">xy</span>.2) -&gt;<br/>
&nbsp;&nbsp;<span class="id">perfect_set</span> [<span class="id">set</span>: <span class="id">product_topologicalType</span> <span class="id">K</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof356')">Proof.</span></div>
<div class="proofscript" id="proof356">
<span class="id">move</span>=&gt; <span class="id">npts</span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">closedT</span>.<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id">f</span> // <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">_</a></span>.<br/>
<span class="id">pose</span> <span class="id">distincts</span> (<span class="id">i</span> : <span class="id">nat</span>) := <span class="id">projT1</span> (<span class="id">sigW</span> (<span class="id">npts</span> <span class="id">i</span>)).<br/>
<span class="id">pose</span> <span class="id">derange</span> (<span class="id">i</span> : <span class="id">nat</span>) (<span class="id">z</span> : <span class="id"><a href="mathcomp.analysis.topology.html#product_topologicalType">K</a></span> <span class="id">i</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">z</span> == (<span class="id">distincts</span> <span class="id">i</span>).1 <span class="kwd">then</span> (<span class="id">distincts</span> <span class="id">i</span>).2 <span class="kwd">else</span> (<span class="id">distincts</span> <span class="id">i</span>).1.<br/>
<span class="id">pose</span> <span class="id">g</span> (<span class="id">N</span> <span class="id">i</span> : <span class="id">nat</span>) := <span class="kwd">if</span> (<span class="id">i</span> &lt; <span class="id">N</span>)%<span class="id">nat</span> <span class="kwd">then</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterS">f</a></span> <span class="id">i</span> <span class="kwd">else</span> <span class="id">derange</span> <span class="id">_</span> (<span class="id">f</span> <span class="id">i</span>).<br/>
<span class="id">have</span> <span class="id">gcvg</span> : <span class="id">g</span> @ \<span class="id">oo</span> --&gt; (<span class="id">f</span> : <span class="id">product_topologicalType</span> <span class="id">K</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>/(@<span class="id">cvg_sup</span> (<span class="id">product_topologicalType</span> <span class="id">K</span>)) =&gt; <span class="id">N</span> <span class="id">U</span> [<span class="id">V</span>] [][<span class="id">W</span>] <span class="id">oW</span> &lt;- <span class="id">WfN</span> <span class="id">WU</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">WU</span>); <span class="id">rewrite</span> <span class="id">nbhs_simpl</span> /<span class="id">g</span>; <span class="kwd">exists</span> <span class="id">N</span>.+1 =&gt; // <span class="id">i</span> /= -&gt;.<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> /<span class="id">gcvg</span>; <span class="id">rewrite</span> <span class="id">nbhs_simpl</span>; <span class="id">case</span>=&gt; <span class="id">N</span> <span class="id">_</span> <span class="id">An</span>.<br/>
<span class="kwd">exists</span> (<span class="id">g</span> <span class="id">N</span>); <span class="id">split</span> =&gt; //; <span class="id">last</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">An</span>; <span class="id">rewrite</span> /= ?<span class="id">leqnn</span> //.<br/>
<span class="id">apply</span>/<span class="id">eqP</span> =&gt; <span class="id">M</span>; <span class="id">suff</span>: <span class="id">g</span> <span class="id">N</span> <span class="id">N</span> != <span class="id">f</span> <span class="id">N</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">M</span>; <span class="id">move</span>/<span class="id">eqP</span>.<br/>
<span class="id">rewrite</span> /<span class="id">g</span> <span class="id">ltnn</span> /<span class="id">derange</span> <span class="id">eq_sym</span>; <span class="id">case</span>: (<span class="id">eqVneq</span> (<span class="id">f</span> <span class="id">N</span>) (<span class="id">distincts</span> <span class="id">N</span>).1) =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; -&gt;; <span class="id">have</span> := <span class="id">projT2</span> (<span class="id">sigW</span> (<span class="id">npts</span> <span class="id">N</span>)).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">perfect_set2</span> {<span class="id">T</span>} : <span class="id">perfect_set</span> [<span class="id">set</span>: <span class="id">T</span>] &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>), <span class="id">open</span> <span class="id">U</span> -&gt; <span class="id">U</span> !=<span class="id">set0</span> -&gt; <br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">x</span> <span class="id">y</span>, [/\ <span class="id">U</span> <span class="id">x</span>, <span class="id">U</span> <span class="id">y</span> &amp; <span class="id">x</span> != <span class="id">y</span>] .<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof357')">Proof.</span></div>
<div class="proofscript" id="proof357">
<span class="id">apply</span>: <span class="id">iff_trans</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">perfectTP</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">nx1</span> <span class="id">U</span> <span class="id">oU</span> [] <span class="id">x</span> <span class="id">Ux</span>; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> : <span class="id">U</span> &lt;&gt; [<span class="id">set</span> <span class="id">x</span>] <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Ux1</span>; <span class="id">apply</span>: (<span class="id">nx1</span> <span class="id">x</span>); <span class="id">rewrite</span> -<span class="id">Ux1</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">contra_notP</span>; <span class="id">move</span>/<span class="id">not_existsP</span>/<span class="id">contrapT</span>=&gt; <span class="id">Uyx</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>.<br/>
&nbsp;&nbsp;(<span class="id">split</span> =&gt; //; <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? -&gt;); <span class="id">move</span>=&gt; <span class="id">y</span> <span class="id">Uy</span>; <span class="id">have</span>  /<span class="id">not_and3P</span> := <span class="id">Uyx</span> <span class="id">y</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span> =&gt; // /<span class="id">negP</span>; <span class="id">rewrite</span> <span class="id">negbK</span> =&gt; /<span class="id">eqP</span> -&gt;.<br/>
<span class="id">move</span>=&gt; <span class="id">Unxy</span> <span class="id">x</span> <span class="id">Ox</span>; <span class="id">have</span> [] := <span class="id">Unxy</span> <span class="id">_</span> <span class="id">Ox</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">x</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">y</span> [] ? [-&gt;] -&gt; /<span class="id">eqP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">perfect_sets</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">totally_disconnected</span>.<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> <span class="id">T</span> : <span class="id">topologicalType</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">totally_disconnected</span> {<span class="id">T</span>} (<span class="id"><a href="mathcomp.analysis.topology.html#discrete_open">A</a></span> : <span class="id">set</span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id"><a href="mathcomp.analysis.topology.html#discrete_closed">x</a></span>, <span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">connected_component</span> <span class="id"><a name="zero_dimension_totally_disconnected">A</a></span> <span class="id">x</span> = [<span class="id">set</span> <span class="id">x</span>].<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">zero_dimensional</span> <span class="id"><a href="mathcomp.analysis.topology.html#zero_dimensional">T</a></span> :=<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">x</span> != <span class="id">y</span> -&gt; <span class="kwd">exists</span> <span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>, [/\ <span class="id">clopen</span> <span class="id">U</span>, <span class="id">U</span> <span class="id">x</span> &amp; ~ <span class="id">U</span> <span class="id">y</span>]).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">zero_dimension_prod</a></span> (<span class="id">I</span> : <span class="id">choiceType</span>) (<span class="id">T</span> : <span class="id">I</span> -&gt; <span class="id">topologicalType</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">zero_dimensional</span> (<span class="id">T</span> <span class="id">i</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">zero_dimensional</span> (<span class="id">product_topologicalType</span> <span class="id">T</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof358')">Proof.</span></div>
<div class="proofscript" id="proof358">
<span class="id">move</span>=&gt; <span class="id">dctTI</span> <span class="id">x</span> <span class="id">y</span> /<span class="id">eqP</span> <span class="id">xneqy</span>.<br/>
<span class="id">have</span> [<span class="id">i</span>/<span class="id">eqP</span>/<span class="id">dctTI</span> [<span class="id">U</span> [<span class="id">clU</span> <span class="id">Ux</span> <span class="id">nUy</span>]]] : <span class="kwd">exists</span> <span class="id">i</span>, <span class="id">x</span> <span class="id">i</span> &lt;&gt; <span class="id">y</span> <span class="id">i</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">existsNP</span>=&gt; <span class="id">W</span>; <span class="id">exact</span>/<span class="id">xneqy</span>/<span class="id">functional_extensionality_dep</span>.<br/>
<span class="kwd">exists</span> (<span class="id">proj</span> <span class="id">i</span> @^-1` <span class="id">U</span>); <span class="id">split</span> =&gt; //; <span class="id">apply</span>: <span class="id">clopen_comp</span> =&gt; //.<br/>
<span class="id">exact</span>/<span class="id"><a href="mathcomp.analysis.topology.html#filter_from">proj_continuous</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_zero_dimension</span> {<span class="id">T</span>} : <span class="id">discrete_space</span> <span class="id">T</span> -&gt; <span class="id">zero_dimensional</span> <span class="id">T</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof359')">Proof.</span></div>
<div class="proofscript" id="proof359">
<span class="id">move</span>=&gt; <span class="id">dctT</span> <span class="id">x</span> <span class="id">y</span> <span class="id">xny</span>; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">x</span>]; <span class="id">split</span> =&gt; //; <span class="id">last</span> <span class="id">exact</span>/<span class="id">nesym</span>/<span class="id">eqP</span>.<br/>
<span class="kwd">by</span> <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">discrete_open</span> | <span class="id">exact</span>: <span class="id">discrete_closed</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">zero_dimension_totally_disconnected</span> {<span class="id">T</span>} :<br/>
&nbsp;&nbsp;<span class="id">zero_dimensional</span> <span class="id">T</span> -&gt; <span class="id">totally_disconnected</span> [<span class="id">set</span>: <span class="id">T</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof360')">Proof.</span></div>
<div class="proofscript" id="proof360">
<span class="id">move</span>=&gt; <span class="id">zdA</span> <span class="id">x</span> <span class="id">_</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>.<br/>
<span class="id">split</span>=&gt; [<span class="id">z</span> [<span class="id">R</span> [<span class="id">Rx</span> <span class="id">_</span> <span class="id">ctdR</span> <span class="id">Rz</span>]]|<span class="id">_</span> -&gt;]; <span class="id">last</span> <span class="id">exact</span>: <span class="id">connected_component_refl</span>.<br/>
<span class="id">apply</span>: <span class="id">contrapT</span> =&gt; /<span class="id">eqP</span> <span class="id">znx</span>; <span class="id">have</span> [<span class="id">U</span> [[<span class="id">oU</span> <span class="id">cU</span>] <span class="id">Uz</span> <span class="id">Ux</span>]] := <span class="id">zdA</span> <span class="id">_</span> <span class="id">_</span>  <span class="id">znx</span>.<br/>
<span class="id">suff</span> : <span class="id">R</span> `&amp;` <span class="id">U</span> = <span class="id">R</span> <span class="kwd">by</span> <span class="id">move</span>: <span class="id">Rx</span> =&gt; /[<span class="id">swap</span>] &lt;- [].<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">ctdR</span>; [<span class="kwd">exists</span> <span class="id">z</span>|<span class="kwd">exists</span> <span class="id">U</span>|<span class="kwd">exists</span> <span class="id">U</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">totally_disconnected_cvg</span> {<span class="id">T</span> : <span class="id">topologicalType</span>} (<span class="id">x</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">hausdorff_space</span> <span class="id">T</span> -&gt; <span class="id">zero_dimensional</span> <span class="id">T</span> -&gt; <span class="id">compact</span> [<span class="id">set</span>: <span class="id">T</span>] -&gt;<br/>
&nbsp;&nbsp;<span class="id">filter_from</span> [<span class="id">set</span> <span class="id">D</span> : <span class="id">set</span> <span class="id">T</span> | <span class="id">D</span> <span class="id">x</span> /\ <span class="id">clopen</span> <span class="id">D</span>] <span class="id">id</span> --&gt; <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#contra_notN">x</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof361')">Proof.</span></div>
<div class="proofscript" id="proof361">
<span class="id">pose</span> <span class="id">F</span> := <span class="id">filter_from</span> [<span class="id">set</span> <span class="id">D</span> : <span class="id">set</span> <span class="id">T</span> | <span class="id">D</span> <span class="id">x</span> /\ <span class="id">clopen</span> <span class="id">D</span>] <span class="id">id</span>.<br/>
<span class="id">have</span> <span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">filter_from_filter</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">clopenT</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#near_powerset_filter_fromP">move</a></span>=&gt; <span class="id">A</span> <span class="id">B</span> [? ?] [? ?]; <span class="kwd">exists</span> (<span class="id">A</span> `&amp;` <span class="id">B</span>) =&gt; //; <span class="id">split</span>=&gt; //; <span class="id">exact</span>: <span class="id">clopenI</span>.<br/>
<span class="id">have</span> <span class="id">PF</span> : <span class="id">ProperFilter</span> <span class="id">F</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filter_from_proper</span>; <span class="id">move</span>=&gt; ? [? <span class="id">_</span>]; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">hsdfT</span> <span class="id">zdT</span> <span class="id">cmpT</span> <span class="id">U</span> <span class="id">Ux</span>; <span class="id">rewrite</span> <span class="id">nbhs_simpl</span> -/<span class="id">F</span>.<br/>
<span class="id">wlog</span> <span class="id">oU</span> : <span class="id">U</span> <span class="id">Ux</span> / <span class="id">open</span> <span class="id">U</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>: <span class="id">Ux</span>; <span class="id">rewrite</span> /= <span class="id">nbhsE</span> =&gt; -[] <span class="id">V</span> [? ?] /<span class="id">filterS</span> + /(<span class="id">_</span> <span class="id">V</span>) <span class="id"><a name="A:2008">P</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>; <span class="id">apply</span>: <span class="id">P</span> =&gt; //; <span class="kwd">exists</span> <span class="id">V</span>.<br/>
<span class="id">have</span> /(<span class="id">iffLR</span> (<span class="id">compact_near_coveringP</span> <span class="id">_</span>)) : <span class="id">compact</span> (~` <span class="id">U</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">subclosed_compact</span> <span class="id">_</span> <span class="id">cmpT</span>) =&gt; //; <span class="id">exact</span>: <span class="id">open_closedC</span>.<br/>
<span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">setC</span> (<span class="id">powerset_filter_from_filter</span> <span class="id">PF</span>))[].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">y</span> <span class="id">nUy</span>; <span class="id">have</span> /<span class="id">zdT</span> [<span class="id">C</span> [[<span class="id">oC</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterS">cC</a></span>] <span class="id">Cx</span> <span class="id">Cy</span>]] : <span class="id">x</span> != <span class="id">y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">contra_notN</span> <span class="id">nUy</span> =&gt; /<span class="id">eqP</span> &lt;-; <span class="id">exact</span>: <span class="id">nbhs_singleton</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (~` <span class="id">C</span>, [<span class="id">set</span> <span class="id">U</span> | <span class="id">U</span> `&lt;=` <span class="id">C</span>]); <span class="id">first</span> <span class="id"><a href="mathcomp.analysis.topology.html#set_nbhs_filter">split</a></span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">open_nbhs_nbhs</span>; <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">closed_openC</span>.<br/>
&nbsp;&nbsp;- <span class="id">apply</span>/<span class="id"><a href="mathcomp.analysis.topology.html#set_nbhs.T">near_powerset_filter_fromP</a></span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id">exact</span>: <span class="id">subset_trans</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">C</span> =&gt; //; <span class="kwd">exists</span> <span class="id">C</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">i</span> <span class="id">j</span> [? /<span class="id">subsetC</span>]; <span class="id">apply</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">D</span> [<span class="id">DF</span> <span class="id">_</span> [<span class="id">C</span> <span class="id">DC</span>]]/(<span class="id">_</span> <span class="id">_</span> <span class="id">DC</span>)/<span class="id">subsetC2</span>/<span class="id">filterS</span>; <span class="id">apply</span>; <span class="id">exact</span>: <span class="id">DF</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">totally_disconnected</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">set_nbhs</span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id">topologicalType</span>} (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>).<br/>
<span class="kwd">Definition</span> <span class="id">set_nbhs</span> := \<span class="id">bigcap_</span>(<span class="id">x</span> <span class="kwd">in</span> <span class="id">A</span>) (<span class="id">nbhs</span> <span class="id">x</span>).<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id">set_nbhs_filter</span> : <span class="id">Filter</span> <span class="id">set_nbhs</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof362')">Proof.</span></div>
<div class="proofscript" id="proof362">
<span class="id">split</span> =&gt; <span class="id">P</span> <span class="id">Q</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">exact</span>: <span class="id">filterT</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Px</span> <span class="id">Qx</span> <span class="id">x</span> <span class="id">Ax</span>; <span class="id">apply</span>: <span class="id">filterI</span>; [<span class="id">exact</span>: <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">Px</a></span> | <span class="id">exact</span>: <span class="id">Qx</span>].<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">PQ</span> + <span class="id">x</span> <span class="id">Ax</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">Ax</span>)/<span class="id">filterS</span>; <span class="id">exact</span>.<br/>
Qed.</div>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id">set_nbhs_pfilter</span> : <span class="id">A</span>!=<span class="id">set0</span> -&gt; <span class="id">ProperFilter</span> <span class="id">set_nbhs</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof363')">Proof.</span></div>
<div class="proofscript" id="proof363">
<span class="id">case</span>=&gt; <span class="id">x</span> <span class="id">Ax</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">set_nbhs_filter</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>/(<span class="id">_</span> <span class="id">x</span> <span class="id">Ax</span>)/<span class="id">nbhs_singleton</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">set_nbhsP</span> (<span class="id">B</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id">set_nbhs</span> <span class="id">B</span> &lt;-&gt; (<span class="kwd">exists</span> <span class="id">C</span>, [/\ <span class="id">open</span> <span class="id">C</span>, <span class="id">A</span> `&lt;=` <span class="id">C</span> &amp; <span class="id">C</span> `&lt;=` <span class="id">B</span>]).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof364')">Proof.</span></div>
<div class="proofscript" id="proof364">
<span class="id">split</span>; <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">V</span> [? <span class="id">AV</span> /<span class="id">filterS</span> +] <span class="id">x</span> /<span class="id">AV</span> ?; <span class="id">apply</span>; <span class="id">apply</span>: <span class="id">open_nbhs_nbhs</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">snB</span>; <span class="id">have</span> <span class="id">Ux</span> <span class="id">x</span> : <span class="kwd">exists</span> <span class="id">U</span>, <span class="id">A</span> <span class="id">x</span> -&gt; [/\ <span class="id">U</span> <span class="id">x</span>, <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_">open</a></span> <span class="id">U</span> &amp; <span class="id">U</span> `&lt;=` <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> [/<span class="id">snB</span>|?] := <span class="id">pselect</span> (<span class="id">A</span> <span class="id">x</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">point</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">nbhsE</span> =&gt; -[<span class="id">V</span> [? ? ?]]; <span class="kwd">exists</span> <span class="id">V</span>.<br/>
<span class="kwd">exists</span> (\<span class="id">bigcup_</span>(<span class="id">x</span> <span class="kwd">in</span> <span class="id">A</span>) (<span class="id">projT1</span> (<span class="id"><a name="Uniform.entourage">cid</a></span> (<span class="id">Ux</span> <span class="id">x</span>)))); <span class="id">split</span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">bigcup_open</span> =&gt; <span class="id">x</span> <span class="id">Ax</span>; <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">Ux</span> <span class="id">x</span>)).<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">Ax</span>; <span class="kwd">exists</span> <span class="id">x</span> =&gt; //; <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">Ux</span> <span class="id">x</span>)).<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">x</span> [<span class="id">y</span> <span class="id">Ay</span>]; <span class="id">have</span> [//| <span class="id">_</span> <span class="id">_</span>] := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">Ux</span> <span class="id">y</span>)); <span class="id">exact</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">set_nbhs</span>.<br/>
<br/>
<h1> Uniform spaces </h1>
<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "<span class="id">A</span> ^-1" := ([<span class="id">set</span> <span class="id">xy</span> | <span class="id">A</span> (<span class="id">xy</span>.2, <span class="id">xy</span>.1)]) : <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "'<span class="id">to_set</span>' <span class="id">A</span> <span class="id">x</span>" := ([<span class="id">set</span> <span class="id">y</span> | <span class="id">A</span> (<span class="id">x</span>, <span class="id"><a name="Uniform.base">y</a></span>)])<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">A</span> <span class="kwd">at</span> <span class="id">level</span> 0) : <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">nbhs_</span> {<span class="id">T</span> <span class="id">T</span>'} (<span class="id">ent</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>'))) (<span class="id">x</span> : <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="id"><a name="Uniform.sort">filter_from</a></span> <span class="id">ent</span> (<span class="kwd">fun</span> <span class="id">A</span> =&gt; <span class="id">to_set</span> <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.sort">A</a></span> <span class="id">x</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_E</span> {<span class="id">T</span> <span class="id">T</span>'} (<span class="id">ent</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>'))) <span class="id">x</span> :<br/>
&nbsp;&nbsp;<span class="id">nbhs_</span> <span class="id">ent</span> <span class="id">x</span> = <span class="id">filter_from</span> <span class="id">ent</span> (<span class="kwd">fun</span> <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.Pack">A</a></span> =&gt; <span class="id">to_set</span> <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.ClassDef.cT">A</a></span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof365')">Proof.</span></div>
<div class="proofscript" id="proof365">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Module</span> <span class="id">Uniform</span>.<br/>
<br/>
<span class="kwd">Record</span> <span class="id">mixin_of</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Uniform.class">M</a></span> : <span class="kwd">Type</span>) (<span class="id">nbhs</span> : <span class="id">M</span> -&gt; <span class="id">set</span> (<span class="id">set</span> <span class="id">M</span>)) := <span class="id">Mixin</span> {<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#Uniform.ClassDef.cT">entourage</a></span> : (<span class="id">M</span> * <span class="id">M</span> -&gt; <span class="kwd">Prop</span>) -&gt; <span class="kwd">Prop</span> ;<br/>
&nbsp;&nbsp;<span class="id">entourage_filter</span> : <span class="id">Filter</span> <span class="id">entourage</span> ;<br/>
&nbsp;&nbsp;<span class="id">entourage_refl</span> : <span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt; [<span class="id">set</span> <span class="id">xy</span> | <span class="id">xy</span>.1 = <span class="id">xy</span>.2] `&lt;=` <span class="id">A</span> ;<br/>
&nbsp;&nbsp;<span class="id">entourage_inv</span> : <span class="kwd">forall</span> <span class="id">A</span>, <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.mixin_of">entourage</a></span> <span class="id">A</span> -&gt; <span class="id">entourage</span> (<span class="id"><a name="bT:2056">A</a></span>^-1)%<span class="id">classic</span> ;<br/>
&nbsp;&nbsp;<span class="id">entourage_split_ex</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="kwd">exists2</span> <span class="id">B</span>, <span class="id"><a name="m':2058">entourage</a></span> <span class="id">B</span> &amp; <span class="id">B</span> \; <span class="id">B</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.mixin_of">A</a></span> ;<br/>
&nbsp;&nbsp;<span class="id">nbhsE</span> : <span class="id">nbhs</span> = <span class="id">nbhs_</span> <span class="id">entourage</span><br/>
}.<br/>
<br/>
<span class="kwd">Record</span> <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.Class">class_of</a></span> (<span class="id">M</span> : <span class="kwd">Type</span>) := <span class="kwd">Class</span> {<br/>
&nbsp;&nbsp;<span class="id">base</span> : <span class="id">Topological.class_of</span> <span class="id">M</span>;<br/>
&nbsp;&nbsp;<span class="id">mixin</span> : <span class="id"><a name="Uniform.choiceType">mixin_of</a></span> (<span class="id">Filtered.nbhs_op</span> <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.ClassDef.cT">base</a></span>)<br/>
}.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">ClassDef</span>.<br/>
<br/>
<span class="kwd">Structure</span> <span class="id">type</span> := <span class="id">Pack</span> { <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.xclass">sort</a></span>; <span class="id">_</span> : <span class="id">class_of</span> <span class="id"><a name="Uniform.filteredType">sort</a></span> }.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Variables</span> (<span class="id">T</span> : <span class="kwd">Type</span>) (<span class="id">cT</span> : <span class="id">type</span>).<br/>
<span class="kwd">Definition</span> <span class="id">class</span> := <span class="kwd">let</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.ClassDef">Pack</a></span> <span class="id">_</span> <span class="id">c</span> := <span class="id">cT</span> <span class="kwd">return</span> <span class="id">class_of</span> <span class="id">cT</span> <span class="kwd">in</span> <span class="id">c</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">clone</span> <span class="id">c</span> <span class="id">of</span> <span class="id">phant_id</span> <span class="id">class</span> <span class="id">c</span> := @<span class="id">Pack</span> <span class="id">T</span> <span class="id">c</span>.<br/>
<span class="kwd">Let</span> <span class="id">xT</span> := <span class="kwd">let</span>: <span class="id">Pack</span> <span class="id">T</span> <span class="id">_</span> := <span class="id">cT</span> <span class="kwd">in</span> <span class="id">T</span>.<br/>
<span class="kwd">Notation</span> <span class="id">xclass</span> := (<span class="id">class</span> : <span class="id">class_of</span> <span class="id">xT</span>).<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.eqType">Topological.class_of</a></span>.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">mixin</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">mixin_of</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">pack</span> <span class="id">nbhs</span> (<span class="id">m</span> : @<span class="id">mixin_of</span> <span class="id">T</span> <span class="id">nbhs</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">bT</span> (<span class="id">b</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.pointedType">Topological.class_of</a></span> <span class="id">T</span>) <span class="id">of</span> <span class="id">phant_id</span> (@<span class="id">Topological.class</span> <span class="id">bT</span>) <span class="id">b</span> =&gt;<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.filteredType">m</a></span>'   <span class="id">of</span> <span class="id">phant_id</span> <span class="id">m</span> (<span class="id">m</span>' : @<span class="id">mixin_of</span> <span class="id">T</span> (<span class="id">Filtered.nbhs_op</span> <span class="id">b</span>)) =&gt;<br/>
&nbsp;&nbsp;@<span class="id">Pack</span> <span class="id">T</span> (@<span class="kwd">Class</span> <span class="id">_</span> <span class="id">b</span> <span class="id">m</span>').<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">eqType</span> := @<span class="id">Equality.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">choiceType</span> := @<span class="id">Choice.Pack</span> <span class="id">cT</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#idfun">xclass</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id">pointedType</span> := @<span class="id">Pointed.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">filteredType</span> := @<span class="id">Filtered.Pack</span> <span class="id">cT</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">topologicalType</span> := @<span class="id">Topological.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">ClassDef</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">Exports</span>.<br/>
<br/>
<span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Topological.class_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">mixin</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">mixin_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">eqType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Equality.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">eqType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">choiceType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Choice.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="nbhs:2060">choiceType</a></span>.<br/>
<span class="kwd">Coercion</span> <span class="id">pointedType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Pointed.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">filteredType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Filtered.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filteredType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">topologicalType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Topological.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topologicalType</span>.<br/>
<span class="kwd">Notation</span> <span class="id">uniformType</span> := <span class="id">type</span>.<br/>
<span class="kwd">Notation</span> <span class="id">UniformType</span> <span class="id">T</span> <span class="id">m</span> := (@<span class="id">pack</span> <span class="id">T</span> <span class="id">_</span> <span class="id">m</span> <span class="id">_</span> <span class="id">_</span> <span class="id">idfun</span> <span class="id">_</span> <span class="id">idfun</span>).<br/>
<span class="kwd">Notation</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">UniformMixin</a></span> := <span class="id">Mixin</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">uniformType</span>' '<span class="id">of</span>' <span class="id">T</span> '<span class="kwd">for</span>' <span class="id">cT</span> ]" := (@<span class="id">clone</span> <span class="id">T</span> <span class="id">cT</span> <span class="id">_</span> <span class="id">idfun</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">uniformType</span>'  '<span class="id">of</span>'  <span class="id">T</span>  '<span class="kwd">for</span>'  <span class="id">cT</span> ]") : <span class="id">form_scope</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">uniformType</span>' '<span class="id">of</span>' <span class="id">T</span> ]" := (@<span class="id">clone</span> <span class="id">T</span> <span class="id">_</span> <span class="id">_</span> <span class="id">id</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">uniformType</span>'  '<span class="id">of</span>'  <span class="id">T</span> ]") : <span class="id">form_scope</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">Exports</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">Uniform</span>.<br/>
<br/>
<span class="kwd">Export</span> <span class="id">Uniform.Exports</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">UniformTopology</span>.<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id">topologyOfEntourageMixin</span> (<span class="id">T</span> : <span class="kwd">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id">nbhs</span> : <span class="id">T</span> -&gt; <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">m</span> : <span class="id">Uniform.mixin_of</span> <span class="id">nbhs</span>) :<br/>
&nbsp;&nbsp;<span class="id">Topological.mixin_of</span> <span class="id">nbhs</span> := <span class="id">topologyOfFilterMixin</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof366')">Next Obligation.</span></div>
<div class="proofscript" id="proof366">
<span class="id">move</span>=&gt; <span class="id">T</span> <span class="id">nbhsT</span> <span class="id">m</span> <span class="id">p</span>.<br/>
<span class="id">rewrite</span> (<span class="id">Uniform.nbhsE</span> <span class="id">m</span>) <span class="id">nbhs_E</span>; <span class="id"><a href="mathcomp.analysis.topology.html#entourage">apply</a></span>: <span class="id">filter_from_proper</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a name="nbhs_entourageE">move</a></span>=&gt; <span class="id">A</span> <span class="id">entA</span>; <span class="kwd">exists</span> <span class="id">p</span>; <span class="id">apply</span>: <span class="id">Uniform.entourage_refl</span> <span class="id">entA</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<span class="id">apply</span>: <span class="id">filter_from_filter</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">apply</span>: @<span class="id">filterT</span> (<span class="id">Uniform.entourage_filter</span> <span class="id">m</span>).<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> <span class="id">entA</span> <span class="id">entB</span>; <span class="kwd">exists</span> (<span class="id">A</span> `&amp;` <span class="id">B</span>) =&gt; //.<br/>
<span class="id">exact</span>: (@<span class="id">filterI</span> <span class="id"><a name="filter_from_entourageE">_</a></span> <span class="id">_</span> (<span class="id">Uniform.entourage_filter</span> <span class="id">m</span>)).<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof367')">Next Obligation.</span></div>
<div class="proofscript" id="proof367">
<span class="id">move</span>=&gt; <span class="id">T</span> <span class="id">nbhsT</span> <span class="id">m</span> <span class="id">p</span> <span class="id">A</span>; <span class="id"><a name="A:2071">rewrite</a></span> (<span class="id">Uniform.nbhsE</span> <span class="id">m</span>) <span class="id">nbhs_E</span>  =&gt; - [<span class="id">B</span> <span class="id">entB</span> <span class="id">sBpA</span>].<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">sBpA</span>; <span class="id">apply</span>: <span class="id">Uniform.entourage_refl</span> <span class="id">entB</span> <span class="id">_</span> <span class="id">_</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof368')">Next Obligation.</span></div>
<div class="proofscript" id="proof368">
<span class="id">move</span>=&gt; <span class="id">T</span> <span class="id">nbhsT</span> <span class="id">m</span> <span class="id">p</span> <span class="id">A</span>; <span class="id">rewrite</span> (<span class="id">Uniform.nbhsE</span> <span class="id">m</span>) <span class="id">nbhs_E</span> =&gt; - [<span class="id">B</span> <span class="id">entB</span> <span class="id">sBpA</span>].<br/>
<span class="id">have</span> /<span class="id"><a name="M:2072">Uniform.entourage_split_ex</a></span> [<span class="id">C</span> <span class="id">entC</span> <span class="id">sC2B</span>] := <span class="id">entB</span>.<br/>
<span class="kwd">exists</span> <span class="id">C</span> =&gt; // <span class="id">q</span> <span class="id">Cpq</span>; <span class="id">rewrite</span> <span class="id">nbhs_E</span>; <span class="kwd">exists</span> <span class="id">C</span> =&gt; // <span class="id">r</span> <span class="id"><a name="filter_inv">Cqr</a></span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">sBpA</span>/<span class="id">sC2B</span>; <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">q</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">UniformTopology</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">entourage</span> {<span class="id">M</span> : <span class="id">uniformType</span>} := <span class="id">Uniform.entourage</span> (<span class="id">Uniform.class</span> <span class="id">M</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_entourageE</span> {<span class="id">M</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filterT">uniformType</a></span>} : <span class="id">nbhs_</span> (@<span class="id">entourage</span> <span class="id">M</span>) = <span class="id">nbhs</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof369')">Proof.</span></div>
<div class="proofscript" id="proof369">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#S">M</a></span>=&gt; [?[?[]]]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_sym</span> {<span class="id">X</span> <span class="id">Y</span> : <span class="kwd">Type</span>} <span class="id">E</span> (<span class="id">x</span> : <span class="id">X</span>) (<span class="id">y</span> : <span class="id">Y</span>) :<br/>
&nbsp;&nbsp;<span class="id">E</span> (<span class="id">x</span>, <span class="id">y</span>) &lt;-&gt; (<span class="id">E</span> ^-1)%<span class="id">classic</span> (<span class="id">y</span>, <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof370')">Proof.</span></div>
<div class="proofscript" id="proof370">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">filter_from_entourageE</span> {<span class="id">M</span> : <span class="id">uniformType</span>} <span class="id">x</span> :<br/>
&nbsp;&nbsp;<span class="id">filter_from</span> (@<span class="id">entourage</span> <span class="id">M</span>) (<span class="kwd">fun</span> <span class="id">A</span> =&gt; <span class="id">to_set</span> <span class="id">A</span> <span class="id">x</span>) = <span class="id">nbhs</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof371')">Proof.</span></div>
<div class="proofscript" id="proof371">
 <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">nbhs_entourageE</span>. Qed.</div>
<br/>
<span class="kwd">Module</span> <span class="kwd">Export</span> <span class="id">NbhsEntourage</span>.<br/>
<span class="kwd">Definition</span> <span class="id">nbhs_simpl</span> :=<br/>
&nbsp;&nbsp;(<span class="id">nbhs_simpl</span>,@<span class="id">filter_from_entourageE</span>,@<span class="id">nbhs_entourageE</span>).<br/>
<span class="kwd">End</span> <span class="id">NbhsEntourage</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhsP</span> {<span class="id">M</span> : <span class="id">uniformType</span>} (<span class="id">x</span> : <span class="id">M</span>) <span class="id">P</span> : <span class="id">nbhs</span> <span class="id">x</span> <span class="id">P</span> &lt;-&gt; <span class="id">nbhs_</span> <span class="id">entourage</span> <span class="id">x</span> <span class="id">P</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof372')">Proof.</span></div>
<div class="proofscript" id="proof372">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">nbhs_simpl</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">filter_inv</span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>))) :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; <span class="id">Filter</span> [<span class="id">set</span> (<span class="id">V</span>^-1)%<span class="id">classic</span> | <span class="id">V</span> <span class="kwd">in</span> <span class="id"><a href="mathcomp.analysis.topology.html#uniformType1.M">F</a></span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof373')">Proof.</span></div>
<div class="proofscript" id="proof373">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id"><a href="mathcomp.analysis.topology.html#filterT">split</a></span> =&gt; /=.<br/>
- <span class="kwd">by</span> <span class="kwd">exists</span> [<span class="id">set</span>: <span class="id">T</span> * <span class="id">T</span>] =&gt; //; <span class="id"><a href="mathcomp.analysis.topology.html#uniformType1.M">exact</a></span>: <span class="id">filterT</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> [<span class="id">R</span> <span class="id">FR</span> &lt;-] [<span class="id">S</span> <span class="id">FS</span> &lt;-]; <span class="kwd">exists</span> (<span class="id">R</span> `&amp;` <span class="id">S</span>) =&gt; //; <span class="id">exact</span>: <span class="id">filterI</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> <span class="id">PQ</span> [<span class="id">R</span> <span class="id">FR</span> <span class="id">RP</span>]; <span class="kwd">exists</span> <span class="id">Q</span>^-1%<span class="id">classic</span> =&gt; //; <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>; <span class="id">case</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#entourage_split_ex">filterS</a></span> <span class="id">FR</span>; <span class="id">case</span>=&gt; ? ? /= ?; <span class="id">apply</span>: <span class="id">PQ</span>; <span class="id">rewrite</span> -<span class="id">RP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">uniformType1</span>.<br/>
<span class="kwd">Context</span> {<span class="id">M</span> : <span class="id">uniformType</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_refl</span> (<span class="id">A</span> : <span class="id">set</span> (<span class="id">M</span> * <span class="id">M</span>)) <span class="id">x</span> : <span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="id">A</span> (<span class="id">x</span>, <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof374')">Proof.</span></div>
<div class="proofscript" id="proof374">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">entA</span>; <span class="id">apply</span>: <span class="id">Uniform.entourage_refl</span> <span class="id">entA</span> <span class="id">_</span> <span class="id">_</span>. Qed.</div>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id">entourage_pfilter</span> : <span class="id">ProperFilter</span> (@<span class="id">entourage</span> <span class="id">M</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof375')">Proof.</span></div>
<div class="proofscript" id="proof375">
<span class="id">apply</span>: <span class="id">Build_ProperFilter</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">Uniform.entourage_filter</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">entA</span>; <span class="kwd">exists</span> (<span class="id">point</span>, <span class="id">point</span>); <span class="id">apply</span>: <span class="id">entourage_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourageT</span> : <span class="id">entourage</span> [<span class="id">set</span>: <span class="id">M</span> * <span class="id">M</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof376')">Proof.</span></div>
<div class="proofscript" id="proof376">
 <span class="id">exact</span>: <span class="id">filterT</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_inv</span> (<span class="id">A</span> : <span class="id">set</span> (<span class="id">M</span> * <span class="id">M</span>)) : <span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="id">entourage</span> (<span class="id">A</span>^-1)%<span class="id">classic</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof377')">Proof.</span></div>
<div class="proofscript" id="proof377">
 <span class="id"><a href="mathcomp.analysis.topology.html#split_ent">exact</a></span>: <span class="id">Uniform.entourage_inv</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_split_ex</span> (<span class="id">A</span> : <span class="id">set</span> (<span class="id">M</span> * <span class="id">M</span>)) :<br/>
&nbsp;&nbsp;<span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="kwd">exists2</span> <span class="id">B</span>, <span class="id">entourage</span> <span class="id">B</span> &amp; <span class="id">B</span> \; <span class="id">B</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof378')">Proof.</span></div>
<div class="proofscript" id="proof378">
 <span class="id">exact</span>: <span class="id">Uniform.entourage_split_ex</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">split_ent</span> (<span class="id">A</span> : <span class="id">set</span> (<span class="id">M</span> * <span class="id">M</span>)) :=<br/>
&nbsp;&nbsp;<span class="id">get</span> (<span class="id">entourage</span> `&amp;` [<span class="id">set</span> <span class="id">B</span> | <span class="id">B</span> \; <span class="id">B</span> `&lt;=` <span class="id">A</span>]).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#uniformType1.M">split_entP</a></span> (<span class="id">A</span> : <span class="id">set</span> (<span class="id">M</span> * <span class="id">M</span>)) : <span class="id">entourage</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">entourage</span> (<span class="id">split_ent</span> <span class="id">A</span>) /\ <span class="id">split_ent</span> <span class="id">A</span> \; <span class="id">split_ent</span> <span class="id">A</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof379')">Proof.</span></div>
<div class="proofscript" id="proof379">
 <span class="kwd">by</span> <span class="id">move</span>/<span class="id">entourage_split_ex</span>/<span class="id">exists2P</span>/<span class="id">getPex</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_split_ent</span> (<span class="id"><a name="A:2104">A</a></span> : <span class="id">set</span> (<span class="id">M</span> * <span class="id">M</span>)) : <span class="id">entourage</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">entourage</span> (<span class="id">split_ent</span> <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof380')">Proof.</span></div>
<div class="proofscript" id="proof380">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">split_entP</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">subset_split_ent</span> (<span class="id">A</span> : <span class="id"><a name="FF:2109">set</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Filter">M</a></span> * <span class="id">M</span>)) : <span class="id"><a name="p:2110">entourage</a></span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">split_ent</span> <span class="id">A</span> \; <span class="id"><a href="mathcomp.analysis.topology.html#entourage">split_ent</a></span> <span class="id">A</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof381')">Proof.</span></div>
<div class="proofscript" id="proof381">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">split_entP</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_split</span> (<span class="id">z</span> <span class="id">x</span> <span class="id">y</span> : <span class="id">M</span>) <span class="id">A</span> : <span class="id">entourage</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">split_ent</span> <span class="id">A</span> (<span class="id">x</span>,<span class="id">z</span>) -&gt; <span class="id">split_ent</span> <span class="id">A</span> (<span class="id">z</span>,<span class="id">y</span>) -&gt; <span class="id">A</span> (<span class="id">x</span>,<span class="id">y</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof382')">Proof.</span></div>
<div class="proofscript" id="proof382">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">subset_split_ent</span> <span class="id">sA</span> ??; <span class="id">apply</span>: <span class="id">sA</span>; <span class="kwd">exists</span> <span class="id">z</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_entourage</span> (<span class="id">x</span> : <span class="id">M</span>) <span class="id">A</span> : <span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="id">nbhs</span> <span class="id">x</span> (<span class="id">to_set</span> <span class="id">A</span> <span class="id"><a href="mathcomp.analysis.topology.html#split_ent">x</a></span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof383')">Proof.</span></div>
<div class="proofscript" id="proof383">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">apply</span>/<span class="id">nbhsP</span>; <span class="kwd">exists</span> <span class="id">A</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_entourageP</span> <span class="id">F</span> (<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>) (<span class="id">p</span> : <span class="id">M</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">p</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt; \<span class="kwd">forall</span> <span class="id">q</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">A</span> (<span class="id">p</span>, <span class="id">q</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof384')">Proof.</span></div>
<div class="proofscript" id="proof384">
 <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">filter_fromP</span> !<span class="id">nbhs_simpl</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_entourage</span> {<span class="id">F</span>} {<span class="id"><a href="mathcomp.analysis.topology.html#entourage_split_ent">FF</a></span> : <span class="id">Filter</span> <span class="id">F</span>} (<span class="id">y</span> : <span class="id">M</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">y</span> -&gt; <span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt; \<span class="kwd">forall</span> <span class="id">y</span>' \<span class="id">near</span> <span class="id">F</span>, <span class="id">A</span> (<span class="id">y</span>,<span class="id">y</span>').<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof385')">Proof.</span></div>
<div class="proofscript" id="proof385">
 <span class="kwd">by</span> <span class="id">move</span>/<span class="id">cvg_entourageP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_app_entourageP</span> <span class="id">T</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">M</span>) <span class="id">F</span> (<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>) <span class="id">p</span> :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">p</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt; \<span class="kwd">forall</span> <span class="id">t</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">A</span> (<span class="id">p</span>, <span class="id">f</span> <span class="id">t</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof386')">Proof.</span></div>
<div class="proofscript" id="proof386">
 <span class="id">exact</span>: <span class="id">cvg_entourageP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_invI</span> (<span class="id">E</span> : <span class="id">set</span> (<span class="id"><a name="M:2115">M</a></span> * <span class="id"><a href="mathcomp.analysis.topology.html#uniformType">M</a></span>)) :<br/>
&nbsp;&nbsp;<span class="id">entourage</span> <span class="id">E</span> -&gt; <span class="id">entourage</span> (<span class="id">E</span> `&amp;` <span class="id">E</span>^-1)%<span class="id">classic</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof387')">Proof.</span></div>
<div class="proofscript" id="proof387">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">apply</span>: <span class="id">filterI</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">entourage_inv</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#split_ent">split_ent_subset</a></span> (<span class="id">E</span> : <span class="id">set</span> (<span class="id">M</span> * <span class="id">M</span>)) : <span class="id">entourage</span> <span class="id">E</span> -&gt; <span class="id">split_ent</span> <span class="id">E</span> `&lt;=` <span class="id">E</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof388')">Proof.</span></div>
<div class="proofscript" id="proof388">
<span class="id">move</span>=&gt; <span class="id">entE</span>; <span class="id">case</span>=&gt; <span class="id">x</span> <span class="id">y</span> <span class="id">splitxy</span>; <span class="id">apply</span>: <span class="id">subset_split_ent</span> =&gt; //; <span class="kwd">exists</span> <span class="id">y</span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">entourage_refl</span>; <span class="id">exact</span>: <span class="id"><a name="continuous_withinNx">entourage_split_ent</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">uniformType1</span>.<br/>
<br/>
#[<span class="id">global</span>]<br/>
<span class="kwd">Hint</span> <span class="id">Extern</span> 0 (<span class="id">entourage</span> (<span class="id">split_ent</span> <span class="id">_</span>)) =&gt; <span class="id">exact</span>: <span class="id">entourage_split_ent</span> : <span class="id">core</span>.<br/>
#[<span class="id">global</span>]<br/>
<span class="kwd">Hint</span> <span class="id">Extern</span> 0 (<span class="id">entourage</span> (<span class="id">get</span> <span class="id">_</span>)) =&gt; <span class="id">exact</span>: <span class="id">entourage_split_ent</span> : <span class="id">core</span>.<br/>
#[<span class="id">global</span>]<br/>
<span class="kwd">Hint</span> <span class="id">Extern</span> 0 (<span class="id">entourage</span> (<span class="id">_</span>^-1)%<span class="id">classic</span>) =&gt; <span class="id">exact</span>: <span class="id">entourage_inv</span> : <span class="id">core</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">entourage_split</span> {<span class="id">M</span>} <span class="id">z</span> {<span class="id">x</span> <span class="id"><a href="mathcomp.analysis.topology.html#near_simpl">y</a></span> <span class="id">A</span>}.<br/>
#[<span class="id">global</span>]<br/>
<span class="kwd">Hint</span> <span class="id">Extern</span> 0 (<span class="id">nbhs</span> <span class="id">_</span> (<span class="id">to_set</span> <span class="id">_</span> <span class="id">_</span>)) =&gt; <span class="id">exact</span>: <span class="id">nbhs_entourage</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">ent_closure</span> {<span class="id">M</span> : <span class="id">uniformType</span>} (<span class="id">x</span> : <span class="id">M</span>) <span class="id">E</span> : <span class="id">entourage</span> <span class="id">E</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">closure</span> (<span class="id">to_set</span> (<span class="id">split_ent</span> <span class="id">E</span>) <span class="id">x</span>) `&lt;=` <span class="id">to_set</span> <span class="id">E</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof389')">Proof.</span></div>
<div class="proofscript" id="proof389">
<span class="id">pose</span> <span class="id">E</span>' := (<span class="id">split_ent</span> <span class="id">E</span>) `&amp;` ((<span class="id">split_ent</span> <span class="id">E</span>)^-1)%<span class="id">classic</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">entE</span> <span class="id">z</span> /(<span class="id">_</span> [<span class="id">set</span> <span class="id">y</span> | <span class="id">E</span>' (<span class="id">z</span>, <span class="id">y</span>)])[].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">nbhs_entourageE</span>; <span class="kwd">exists</span> <span class="id">E</span>' =&gt; //; <span class="id">exact</span>: <span class="id">filterI</span>.<br/>
<span class="kwd">by</span> <span class="id"><a name="Q:2126">move</a></span>=&gt; <span class="id">y</span> [/=] + [<span class="id">_</span>]; <span class="id">exact</span>: <span class="id">entourage_split</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_withinNx</span> {<span class="id">U</span> <span class="id">V</span> : <span class="id">uniformType</span>} (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">x</a></span> :<br/>
&nbsp;&nbsp;{<span class="kwd">for</span> <span class="id">x</span>, <span class="id">continuous</span> <span class="id">f</span>} &lt;-&gt; <span class="id"><a name="A:2130">f</a></span> @ <span class="id">x</span>^' --&gt; <span class="id">f</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof390')">Proof.</span></div>
<div class="proofscript" id="proof390">
<span class="id">split</span>=&gt; - <span class="id">cfx</span> <span class="id">P</span> /= <span class="id">fxP</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">dnbhs</span> !<span class="id">near_simpl</span> <span class="id">near_withinE</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">dnbhs</span>; <span class="id">apply</span>: <span class="id">cvg_within</span>; <span class="id">apply</span>: <span class="id">cfx</span>.<br/>
<span class="id">rewrite</span> !<span class="id">nbhs_nearE</span> !<span class="id"><a href="mathcomp.classical.classical_sets.html#unsquash">near_map</a></span> !<span class="id">near_nbhs</span> <span class="kwd">in</span> <span class="id">fxP</span> *; <span class="id">have</span> /= := <span class="id">cfx</span> <span class="id">P</span> <span class="id">fxP</span>.<br/>
<span class="id">rewrite</span> !<span class="id">near_simpl</span> <span class="id">near_withinE</span> <span class="id">near_simpl</span> =&gt; <span class="id">Pf</span>; <span class="id">near</span>=&gt; <span class="id">y</span>.<br/>
<span class="kwd">by</span> <span class="id">have</span> [-&gt;|] := <span class="id">eqVneq</span> <span class="id">y</span> <span class="id">x</span>; [<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">nbhs_singleton</span>|<span class="id">near</span>: <span class="id">y</span>].<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">countable_uniformity</span> (<span class="id">T</span> : <span class="id">uniformType</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">R</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> * <span class="id"><a name="open_nbhs_entourage">T</a></span>)), [/\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">countable</span> <span class="id">R</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">R</span> `&lt;=` <span class="id">entourage</span> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">P</span>, <span class="id">entourage</span> <span class="id">P</span> -&gt; <span class="kwd">exists2</span> <span class="id">Q</span>, <span class="id">R</span> <span class="id">Q</span> &amp; <span class="id">Q</span> `&lt;=` <span class="id">P</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">countable_uniformityP</span> {<span class="id">T</span> : <span class="id">uniformType</span>} :<br/>
&nbsp;&nbsp;<span class="id">countable_uniformity</span> <span class="id">T</span> &lt;-&gt; <span class="kwd">exists2</span> <span class="id">f</span> : <span class="id">nat</span> -&gt; <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="kwd">exists</span> <span class="id">N</span>, <span class="id">f</span> <span class="id">N</span> `&lt;=` <span class="id">A</span>) &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a href="mathcomp.analysis.topology.html#entourage">n</a></span>, <span class="id">entourage</span> (<span class="id">f</span> <span class="id">n</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof391')">Proof.</span></div>
<div class="proofscript" id="proof391">
<span class="id">split</span>=&gt; [[<span class="id">M</span> []]|[<span class="id">f</span> <span class="id">fsubE</span> <span class="id">entf</span>]].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /<span class="id">pfcard_geP</span>[-&gt; <span class="id">_</span> /(<span class="id">_</span> <span class="id">_</span> <span class="id">entourageT</span>)[]//|/<span class="id">unsquash</span> <span class="id">f</span> <span class="id">eM</span> <span class="id">Msub</span>].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">f</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_entourage">n</a></span>; <span class="id">apply</span>: <span class="id">eM</span>; <span class="id">exact</span>: <span class="id">funS</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? /<span class="id">Msub</span> [<span class="id">Q</span> + ?] =&gt; /(@<span class="id">surj</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">f</span>)[<span class="id">n</span> <span class="id">_</span> <span class="id">fQ</span>]; <span class="kwd">exists</span> <span class="id">n</span>; <span class="id">rewrite</span> <span class="id">fQ</span>.<br/>
<span class="kwd">exists</span> (<span class="id">range</span> <span class="id">f</span>); <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">card_image_le</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">E</span> [<span class="id">n</span> <span class="id">_</span>] &lt;-; <span class="id">exact</span>: <span class="id">entf</span>.<br/>
<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsP">move</a></span>=&gt; <span class="id">E</span> /<span class="id">fsubE</span> [<span class="id">n</span> <span class="id">fnA</span>]; <span class="kwd">exists</span> (<span class="id">f</span> <span class="id">n</span>) =&gt; //; <span class="kwd">exists</span> <span class="id">n</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">uniform_closeness</span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id">U</span> : <span class="id">uniformType</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_nbhs_entourage</span> (<span class="id">x</span> : <span class="id">U</span>) (<span class="id">A</span> : <span class="id">set</span> (<span class="id">U</span> * <span class="id">U</span>)) :<br/>
&nbsp;&nbsp;<span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="id">open_nbhs</span> <span class="id">x</span> (<span class="id">to_set</span> <span class="id">A</span> <span class="id">x</span>)^°.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof392')">Proof.</span></div>
<div class="proofscript" id="proof392">
<span class="id">move</span>=&gt; <span class="id">entA</span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">open_interior</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">nbhs_singleton</span>; <span class="id">apply</span>: <span class="id">nbhs_interior</span>; <span class="id">apply</span>: <span class="id">nbhs_entourage</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_close</span> (<span class="id">x</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsP">y</a></span> : <span class="id">U</span>) : <span class="id">close</span> <span class="id">x</span> <span class="id">y</span> = <span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="id">A</span> (<span class="id">x</span>, <span class="id">y</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof393')">Proof.</span></div>
<div class="proofscript" id="proof393">
<span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span>=&gt; [<span class="id">cxy</span> <span class="id">A</span> <span class="id">entA</span>|<span class="id">cxy</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> /<span class="id">entourage_split_ent</span> <span class="id">entsA</span> := <span class="id">entA</span>; <span class="id">rewrite</span> <span class="id">closeEnbhs</span> <span class="kwd">in</span> <span class="id">cxy</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">yl</span> := <span class="id">nbhs_entourage</span> <span class="id">_</span> (<span class="id">entourage_inv</span> <span class="id">entsA</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">yr</span> := <span class="id">nbhs_entourage</span> <span class="id">_</span> <span class="id">entsA</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">z</span> [<span class="id">zx</span> <span class="id">zy</span>]] := <span class="id">cxy</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">yr</span> <span class="id">x</span>) (<span class="id">yl</span> <span class="id">y</span>).<br/>
&nbsp;&nbsp;<span class="id">exact</span>: (<span class="id">entourage_split</span> <span class="id">z</span>).<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#cvgP">rewrite</a></span> <span class="id">closeEnbhs</span> =&gt; <span class="id">A</span> <span class="id">B</span> /<span class="id">nbhsP</span>[<span class="id"><a href="mathcomp.analysis.topology.html#cvg_close">E1</a></span> <span class="id">entE1</span> <span class="id">sE1A</span>] /<span class="id">nbhsP</span>[<span class="id">E2</span> <span class="id">entE2</span> <span class="id">sE2B</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">y</span>; <span class="id">split</span>;[<span class="id">apply</span>: <span class="id">sE1A</span>; <span class="id">apply</span>: <span class="id">cxy</span>|<span class="id">apply</span>: <span class="id">sE2B</span>; <span class="id"><a name="unif_continuous">apply</a></span>: <span class="id">entourage_refl</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">close_trans</span> (<span class="id">y</span> <span class="id">x</span> <span class="id">z</span> : <span class="id">U</span>) : <span class="id">close</span> <span class="id">x</span> <span class="id">y</span> -&gt; <span class="id">close</span> <span class="id">y</span> <span class="id">z</span> -&gt; <span class="id">close</span> <span class="id">x</span> <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof394')">Proof.</span></div>
<div class="proofscript" id="proof394">
<span class="id">rewrite</span> !<span class="id">entourage_close</span> =&gt; <span class="id">cxy</span> <span class="id">cyz</span> <span class="id">A</span> <span class="id">entA</span>.<br/>
<span class="id">exact</span>: <span class="id"><a name="prod_Uniform">entourage_split</a></span> (<span class="id">cxy</span> <span class="id">_</span> <span class="id">_</span>) (<span class="id">cyz</span> <span class="id">_</span> <span class="id">_</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">close_cvgxx</span> (<span class="id">x</span> <span class="id">y</span> : <span class="id">U</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#prod_Uniform.V">close</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#prod_Uniform.U">x</a></span> <span class="id">y</span> -&gt; <span class="id">x</span> --&gt; <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof395')">Proof.</span></div>
<div class="proofscript" id="proof395">
<span class="id">rewrite</span> <span class="id">entourage_close</span> =&gt; <span class="id"><a href="mathcomp.analysis.topology.html#prod_Uniform.U">cxy</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#prod_Uniform.V">P</a></span> /= /<span class="id"><a href="mathcomp.analysis.topology.html#prod_Uniform.U">nbhsP</a></span>[<span class="id">A</span> <span class="id">entA</span> <span class="id">sAP</span>].<br/>
<span class="id">apply</span>/<span class="id">nbhsP</span>; <span class="kwd">exists</span> (<span class="id">split_ent</span> <span class="id">A</span>) =&gt; // <span class="id">z</span> <span class="id">xz</span>; <span class="id">apply</span>: <span class="id">sAP</span>.<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> <span class="id"><a name="xy:2154">x</a></span>) =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">have</span> := <span class="id">cxy</span> <span class="id">_</span> (<span class="id">entourage_inv</span> (<span class="id">entourage_split_ent</span> <span class="id">entA</span>)).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#entourage">cvg_closeP</a></span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">U</span>)) (<span class="id">l</span> : <span class="id">U</span>) : <span class="id">ProperFilter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">l</span> &lt;-&gt; ([<span class="id">cvg</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">U</span>] /\ <span class="id">close</span> (<span class="id">lim</span> <span class="id">F</span>) <span class="id">l</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof396')">Proof.</span></div>
<div class="proofscript" id="proof396">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">split</span>=&gt; [<span class="id">Fl</span>|[<span class="id">cvF</span>]<span class="id">Cl</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> /<span class="id">cvgP</span> := <span class="id">Fl</span>; <span class="id">split</span>=&gt; //; <span class="id">apply</span>: (@<span class="id">cvg_close</span> <span class="id">_</span> <span class="id">F</span>).<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">cvg_trans</span> (<span class="id">close_cvgxx</span> <span class="id">Cl</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">uniform_closeness</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">unif_continuous</span> (<span class="id">U</span> <span class="id">V</span> : <span class="id">uniformType</span>) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :=<br/>
&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">xy</span> =&gt; (<span class="id">f</span> <span class="id">xy</span>.1, <span class="id">f</span> <span class="id"><a href="mathcomp.analysis.topology.html#prod_ent">xy</a></span>.2)) @ <span class="id">entourage</span> --&gt; <span class="id">entourage</span>.<br/>
<br/>
<div class="doc">product of two uniform spaces </div>
<br/>
<span class="kwd">Section</span> <span class="id">prod_Uniform</span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">U</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setMTT">V</a></span> : <span class="id">uniformType</span>}.<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterT">A</a></span> : <span class="id">set</span> ((<span class="id">U</span> * <span class="id">V</span>) * (<span class="id">U</span> * <span class="id">V</span>)).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterS">prod_ent</a></span> :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">A</span> : <span class="id">set</span> ((<span class="id">U</span> * <span class="id">V</span>) * (<span class="id">U</span> * <span class="id">V</span>)) |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">filter_prod</span> (@<span class="id">entourage</span> <span class="id">U</span>) (@<span class="id">entourage</span> <span class="id">V</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">set</span> ((<span class="id">xy</span>.1.1,<span class="id">xy</span>.2.1),(<span class="id">xy</span>.1.2,<span class="id">xy</span>.2.2)) | <span class="id">xy</span> <span class="kwd">in</span> <span class="id">A</span>]].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">prod_entP</span> (<span class="id">A</span> : <span class="id">set</span> (<span class="id">U</span> * <span class="id">U</span>)) (<span class="id">B</span> : <span class="id">set</span> (<span class="id">V</span> * <span class="id">V</span>)) :<br/>
&nbsp;&nbsp;<span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="id">entourage</span> <span class="id">B</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">prod_ent</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id">A</span> (<span class="id">xy</span>.1.1, <span class="id">xy</span>.2.1) /\ <span class="id">B</span> (<span class="id">xy</span>.1.2, <span class="id">xy</span>.2.2)].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof397')">Proof.</span></div>
<div class="proofscript" id="proof397">
<span class="id">move</span>=&gt; <span class="id">entA</span> <span class="id">entB</span>; <span class="kwd">exists</span> (<span class="id">A</span>,<span class="id">B</span>) =&gt; // <span class="id">xy</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#surjective_pairing">ABxy</a></span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> ((<span class="id">xy</span>.1.1, <span class="id">xy</span>.2.1),(<span class="id">xy</span>.1.2,<span class="id">xy</span>.2.2)); <span class="id">rewrite</span> /= -!<span class="id">surjective_pairing</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">prod_ent_filter</span> : <span class="id">Filter</span> <span class="id">prod_ent</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof398')">Proof.</span></div>
<div class="proofscript" id="proof398">
<span class="id">have</span> <span class="id">prodF</span> := <span class="id">filter_prod_filter</span> (@<span class="id">entourage_pfilter</span> <span class="id">U</span>) (@<span class="id">entourage_pfilter</span> <span class="id">V</span>).<br/>
<span class="id">split</span>; <span class="id">rewrite</span> /<span class="id">prod_ent</span>; <span class="id">last</span> 1 <span class="id">first</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> <span class="id">sAB</span> /=; <span class="id">apply</span>: <span class="id">filterS</span> =&gt; ? [<span class="id">xy</span> /<span class="id">sAB</span> ??]; <span class="kwd">exists</span> <span class="id">xy</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">setMTT</span>; <span class="id">apply</span>: <span class="id">prod_entP</span> <span class="id">filterT</span> <span class="id">filterT</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> /= <span class="id">entA</span> <span class="id">entB</span>; <span class="id">apply</span>: <span class="id">filterS</span> (<span class="id">filterI</span> <span class="id">entA</span> <span class="id">entB</span>) =&gt; <span class="id">xy</span> [].<br/>
<span class="id">move</span>=&gt; [<span class="id">zt</span> <span class="id">Azt</span> <span class="id">ztexy</span>] [<span class="id">zt</span>' <span class="id">Bzt</span>' <span class="id">zt</span>'<span class="id">exy</span>]; <span class="kwd">exists</span> <span class="id">zt</span> =&gt; //; <span class="id"><a href="mathcomp.analysis.topology.html#filterS">split</a></span>=&gt; //.<br/>
<span class="id">move</span>/<span class="id">eqP</span>: <span class="id">ztexy</span>; <span class="id">rewrite</span> -<span class="id">zt</span>'<span class="id">exy</span> !<span class="id">xpair_eqE</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">andbACA</span> -!<span class="id">xpair_eqE</span> -!<span class="id">surjective_pairing</span> =&gt; /<span class="id">eqP</span>-&gt;.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">prod_ent_refl</span> <span class="id">A</span> : <span class="id">prod_ent</span> <span class="id">A</span> -&gt; [<span class="id">set</span> <span class="id">xy</span> | <span class="id">xy</span>.1 = <span class="id">xy</span>.2] `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof399')">Proof.</span></div>
<div class="proofscript" id="proof399">
<span class="id">move</span>=&gt; [<span class="id">B</span> [<span class="id">entB1</span> <span class="id"><a href="mathcomp.analysis.topology.html#prod_ent">entB2</a></span>] <span class="id">sBA</span>] <span class="id">xy</span> /<span class="id">eqP</span>.<br/>
<span class="id">rewrite</span> [<span class="id">_</span>.1]<span class="id">surjective_pairing</span> [<span class="id">xy</span>.2]<span class="id">surjective_pairing</span> <span class="id">xpair_eqE</span>.<br/>
<span class="id">move</span>=&gt; /<span class="id">andP</span> [/<span class="id">eqP</span> <span class="id">xy1e</span> /<span class="id">eqP</span> <span class="id">xy2e</span>].<br/>
<span class="id">have</span> /<span class="id">sBA</span> : (<span class="id">B</span>.1 `*` <span class="id">B</span>.2) ((<span class="id">xy</span>.1.1, <span class="id"><a href="mathcomp.analysis.topology.html#prod_entP">xy</a></span>.2.1), (<span class="id">xy</span>.1.2, <span class="id"><a href="mathcomp.analysis.topology.html#entourage_split_ent">xy</a></span>.2.2)).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">xy1e</span> <span class="id">xy2e</span>; <span class="id">split</span>=&gt; /=; <span class="id">apply</span>: <span class="id">entourage_refl</span>.<br/>
<span class="id">move</span>=&gt; [<span class="id">zt</span> <span class="id">Azt</span> /<span class="id">eqP</span>]; <span class="id">rewrite</span> !<span class="id">xpair_eqE</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">andbACA</span> -!<span class="id">xpair_eqE</span> -!<span class="id">surjective_pairing</span> =&gt; /<span class="id">eqP</span>&lt;-.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">prod_ent_inv</span> <span class="id">A</span> : <span class="id">prod_ent</span> <span class="id">A</span> -&gt; <span class="id">prod_ent</span> (<span class="id">A</span>^-1)%<span class="id">classic</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof400')">Proof.</span></div>
<div class="proofscript" id="proof400">
<span class="id">move</span>=&gt; [<span class="id">B</span> [/<span class="id">entourage_inv</span> <span class="id">entB1</span> /<span class="id">entourage_inv</span> <span class="id">entB2</span>] <span class="id">sBA</span>].<br/>
<span class="id">have</span>:= <span class="id">prod_entP</span> <span class="id">entB1</span> <span class="id">entB2</span>; <span class="id">rewrite</span> /<span class="id">prod_ent</span>/=; <span class="id">apply</span>: <span class="id">filterS</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">_</span> [<span class="id">p</span> /(<span class="id">sBA</span> (<span class="id">_</span>,<span class="id">_</span>)) [[<span class="id">x</span> <span class="id">y</span>] ? <span class="id">xyE</span>] &lt;-]; <span class="kwd">exists</span> (<span class="id">y</span>,<span class="id">x</span>) =&gt; //; <span class="id">move</span>/<span class="id">eqP</span>: <span class="id">xyE</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> !<span class="id">xpair_eqE</span> =&gt; /<span class="id">andP</span>[/<span class="id">andP</span>[/<span class="id">eqP</span>-&gt; /<span class="id">eqP</span>-&gt;] /<span class="id">andP</span>[/<span class="id">eqP</span>-&gt; /<span class="id">eqP</span>-&gt;]].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">prod_ent_split</span> <span class="id">A</span> : <span class="id">prod_ent</span> <span class="id">A</span> -&gt; <span class="kwd">exists2</span> <span class="id">B</span>, <span class="id">prod_ent</span> <span class="id">B</span> &amp; <span class="id">B</span> \; <span class="id">B</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof401')">Proof.</span></div>
<div class="proofscript" id="proof401">
<span class="id">move</span>=&gt; [<span class="id">B</span> [<span class="id">entB1</span> <span class="id">entB2</span>]] <span class="id">sBA</span>; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id">split_ent</span> <span class="id">B</span>.1 (<span class="id">xy</span>.1.1,<span class="id">xy</span>.2.1) /\<br/>
&nbsp;&nbsp;<span class="id">split_ent</span> <span class="id">B</span>.2 (<span class="id">xy</span>.1.2,<span class="id">xy</span>.2.2)].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">prod_entP</span>; <span class="id">apply</span>: <span class="id">entourage_split_ent</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">xy</span> [<span class="id">uv</span> /= [<span class="id">hB1xyuv1</span> <span class="id">hB2xyuv1</span>] [<span class="id">hB1xyuv2</span> <span class="id">hB2xyuv2</span>]].<br/>
<span class="id">have</span> /<span class="id">sBA</span> : (<span class="id">B</span>.1 `*` <span class="id">B</span>.2) ((<span class="id">xy</span>.1.1, <span class="id">xy</span>.2.1),(<span class="id">xy</span>.1.2,<span class="id">xy</span>.2.2)).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span>=&gt; /=; <span class="id">apply</span>: <span class="id">subset_split_ent</span> =&gt; //; [<span class="kwd">exists</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#surjective_pairing">uv</a></span>.1|<span class="kwd">exists</span> <span class="id">uv</span>.2].<br/>
<span class="id">move</span>=&gt; [<span class="id">zt</span> <span class="id">Azt</span> /<span class="id">eqP</span>]; <span class="id">rewrite</span> !<span class="id">xpair_eqE</span> <span class="id">andbACA</span> -!<span class="id">xpair_eqE</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -!<span class="id">surjective_pairing</span> =&gt; /<span class="id">eqP</span>&lt;-.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">prod_ent_nbhsE</span> : <span class="id">nbhs</span> = <span class="id">nbhs_</span> <span class="id">prod_ent</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof402')">Proof.</span></div>
<div class="proofscript" id="proof402">
<span class="id">rewrite</span> <span class="id">predeq2E</span> =&gt; <span class="id">xy</span> <span class="id">A</span>; <span class="id">split</span>=&gt; [[<span class="id"><a href="mathcomp.analysis.topology.html#uniformType">B</a></span> []] | [<span class="id">B</span> [<span class="id">C</span> [<span class="id">entC1</span> <span class="id">entC2</span>] <span class="id">sCB</span>] <span class="id">sBA</span>]].<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> -!<span class="id">nbhs_entourageE</span> =&gt; - [<span class="id">C1</span> <span class="id">entC1</span> <span class="id">sCB1</span>] [<span class="id">C2</span> <span class="id">entC2</span> <span class="id">sCB2</span>] <span class="id">sBA</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">C1</a></span> (<span class="id">xy</span>.1.1, <span class="id">xy</span>.2.1) /\ <span class="id">C2</span> (<span class="id">xy</span>.1.2, <span class="id">xy</span>.2.2)].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#matrix_Uniform.m">prod_entP</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">uv</span> [/= /<span class="id">sCB1</span> <span class="id">Buv1</span> /<span class="id">sCB2</span> /(<span class="id">conj</span> <span class="id">Buv1</span>) /<span class="id">sBA</span>].<br/>
<span class="kwd">exists</span> (<span class="id">to_set</span> (<span class="id">C</span>.1) (<span class="id">xy</span>.1), <span class="id">to_set</span> (<span class="id">C</span>.2) (<span class="id">xy</span>.2)).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -!<span class="id">nbhs_entourageE</span>; <span class="id">split</span>; [<span class="kwd">exists</span> <span class="id">C</span>.1|<span class="kwd">exists</span> <span class="id">C</span>.2].<br/>
<span class="id">move</span>=&gt; <span class="id">uv</span> [/= <span class="id"><a name="j:2176">Cxyuv1</a></span> <span class="id">Cxyuv2</span>]; <span class="id">apply</span>: <span class="id">sBA</span>.<br/>
<span class="id">have</span> /<span class="id">sCB</span> : (<span class="id">C</span>.1 `*` <span class="id">C</span>.2) ((<span class="id"><a href="mathcomp.analysis.topology.html#Filter">xy</a></span>.1,<span class="id">uv</span>.1),(<span class="id">xy</span>.2,<span class="id">uv</span>.2)) <span class="kwd">by</span> [].<br/>
<span class="id">move</span>=&gt; [<span class="id">zt</span> <span class="id">Bzt</span> /<span class="id">eqP</span>]; <span class="id">rewrite</span> !<span class="id">xpair_eqE</span> <span class="id">andbACA</span> -!<span class="id">xpair_eqE</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> /= -!<span class="id">surjective_pairing</span> =&gt; /<span class="id">eqP</span>&lt;-.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">prod_uniformType_mixin</span> :=<br/>
&nbsp;&nbsp;<span class="id">Uniform.Mixin</span> <span class="id">prod_ent_filter</span> <span class="id">prod_ent_refl</span> <span class="id">prod_ent_inv</span> <span class="id">prod_ent_split</span><br/>
&nbsp;&nbsp;<span class="id">prod_ent_nbhsE</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">prod_Uniform</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">prod_uniformType</span> (<span class="id">U</span> <span class="id">V</span> : <span class="id">uniformType</span>) :=<br/>
&nbsp;&nbsp;<span class="id">UniformType</span> (<span class="id">U</span> * <span class="id">V</span>) (@<span class="id">prod_uniformType_mixin</span> <span class="id">U</span> <span class="id">V</span>).<br/>
<br/>
<div class="doc">matrices </div>
<br/>
<span class="kwd">Section</span> <span class="id">matrix_Uniform</span>.<br/>
<br/>
<span class="kwd">Variables</span> (<span class="id">m</span> <span class="id">n</span> : <span class="id">nat</span>) (<span class="id">T</span> : <span class="id">uniformType</span>).<br/>
<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> <span class="id">A</span> : <span class="id">set</span> ('<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) * '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>)).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">mx_ent</span> :=<br/>
&nbsp;&nbsp;<span class="id">filter_from</span><br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">P</span> : '<span class="id">I_m</span> -&gt; '<span class="id">I_n</span> -&gt; <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>) | <span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span>, <span class="id">entourage</span> (<span class="id">P</span> <span class="id">i</span> <span class="id">j</span>)]<br/>
&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">P</span> =&gt; [<span class="id">set</span> <span class="id">MN</span> : '<span class="id"><a name="B:2192">M</a></span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) * '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span>, <span class="id">P</span> <span class="id">i</span> <span class="id">j</span> (<span class="id">MN</span>.1 <span class="id">i</span> <span class="id">j</span>, <span class="id">MN</span>.2 <span class="id">i</span> <span class="id">j</span>)]).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">mx_ent_filter</span> : <span class="id">Filter</span> <span class="id">mx_ent</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof403')">Proof.</span></div>
<div class="proofscript" id="proof403">
<span class="id">apply</span>: <span class="id">filter_from_filter</span> =&gt; [|<span class="id">A</span> <span class="id">B</span> <span class="id">entA</span> <span class="id">entB</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">_</span> <span class="id">_</span> =&gt; <span class="id">setT</span>) =&gt; <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#matrix_Uniform.m">_</a></span>; <span class="id"><a href="mathcomp.analysis.topology.html#matrix_Uniform.n">apply</a></span>: <span class="id">filterT</span>.<br/>
<span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">i</span> <span class="id">j</span> =&gt; <span class="id">A</span> <span class="id">i</span> <span class="id">j</span> `&amp;` <span class="id">B</span> <span class="id"><a href="mathcomp.analysis.topology.html#entourage">i</a></span> <span class="id">j</span>); <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ??; <span class="id">apply</span>: <span class="id">filterI</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">MN</span> <span class="id">ABMN</span>; <span class="id">split</span>=&gt; <span class="id">i</span> <span class="id">j</span>; <span class="id">have</span> [] := <span class="id">ABMN</span> <span class="id">i</span> <span class="id"><a name="C:2207">j</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">mx_ent_refl</span> <span class="id">A</span> : <span class="id">mx_ent</span> <span class="id">A</span> -&gt; [<span class="id">set</span> <span class="id">MN</span> | <span class="id">MN</span>.1 = <span class="id">MN</span>.2] `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof404')">Proof.</span></div>
<div class="proofscript" id="proof404">
<span class="id">move</span>=&gt; [<span class="id">B</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#getPex">entB</a></span> <span class="id">sBA</span>] <span class="id">MN</span> <span class="id">MN1e2</span>; <span class="id">apply</span>: <span class="id">sBA</span> =&gt; <span class="id">i</span> <span class="id">j</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">MN1e2</span>; <span class="id">apply</span>: <span class="id">entourage_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">mx_ent_inv</span> <span class="id">A</span> : <span class="id">mx_ent</span> <span class="id">A</span> -&gt; <span class="id">mx_ent</span> (<span class="id">A</span>^-1)%<span class="id">classic</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof405')">Proof.</span></div>
<div class="proofscript" id="proof405">
<span class="id">move</span>=&gt; [<span class="id">B</span> <span class="id">entB</span> <span class="id">sBA</span>]; <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">i</span> <span class="id">j</span> =&gt; ((<span class="id">B</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_entourageE">i</a></span> <span class="id">j</span>)^-1)%<span class="id">classic</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">j</span>; <span class="id">apply</span>: <span class="id">entourage_inv</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">MN</span> <span class="id">BMN</span>; <span class="id">apply</span>: <span class="id">sBA</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">mx_ent_split</span> <span class="id">A</span> : <span class="id">mx_ent</span> <span class="id">A</span> -&gt; <span class="kwd">exists2</span> <span class="id">B</span>, <span class="id">mx_ent</span> <span class="id">B</span> &amp; <span class="id">B</span> \; <span class="id">B</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof406')">Proof.</span></div>
<div class="proofscript" id="proof406">
<span class="id">move</span>=&gt; [<span class="id">B</span> <span class="id">entB</span> <span class="id">sBA</span>].<br/>
<span class="id"><a name="MN:2222">have</a></span> <span class="id">Bsplit</span> : <span class="kwd">forall</span> <span class="id">i</span> <span class="id"><a href="mathcomp.analysis.topology.html#matrix_Uniform.T">j</a></span>, <span class="kwd">exists</span> <span class="id">C</span>, <span class="id">entourage</span> <span class="id">C</span> /\ <span class="id"><a href="mathcomp.classical.classical_sets.html#get">C</a></span> \; <span class="id">C</span> `&lt;=` <span class="id">B</span> <span class="id">i</span> <span class="id">j</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ??; <span class="id">apply</span>/<span class="id">exists2P</span>/<span class="id">entourage_split_ex</span>.<br/>
<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">MN</span> : '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) * '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) |<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span>, <span class="id">get</span> [<span class="id">set</span> <span class="id">C</span> | <span class="id">entourage</span> <span class="id">C</span> /\ <span class="id">C</span> \; <span class="id">C</span> `&lt;=` <span class="id">B</span> <span class="id">i</span> <span class="id">j</span>]<br/>
&nbsp;&nbsp;(<span class="id">MN</span>.1 <span class="id">i</span> <span class="id">j</span>, <span class="id">MN</span>.2 <span class="id">i</span> <span class="id">j</span>)].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">i</span> <span class="id">j</span> =&gt; <span class="id">get</span> [<span class="id">set</span> <span class="id">C</span> | <span class="id">entourage</span> <span class="id">C</span> /\ <span class="id">C</span> \; <span class="id">C</span> `&lt;=` <span class="id">B</span> <span class="id">i</span> <span class="id">j</span>]).<br/>
<span class="id">move</span>=&gt; <span class="id">MN</span> [<span class="id">P</span> <span class="id">CMN1P</span> <span class="id">CPMN2</span>]; <span class="id">apply</span>/<span class="id">sBA</span> =&gt; <span class="id">i</span> <span class="id">j</span>.<br/>
<span class="id">have</span> /<span class="id">getPex</span> [<span class="id">_</span>] := <span class="id">Bsplit</span> <span class="id">i</span> <span class="id">j</span>; <span class="id">apply</span>; <span class="kwd">exists</span> (<span class="id">P</span> <span class="id">i</span> <span class="id">j</span>); <span class="id">first</span> <span class="id">exact</span>: <span class="id">CMN1P</span>.<br/>
<span class="id">exact</span>: <span class="id">CPMN2</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">mx_ent_nbhsE</span> : <span class="id">nbhs</span> = <span class="id"><a href="mathcomp.analysis.topology.html#mx_ent_inv">nbhs_</a></span> <span class="id">mx_ent</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof407')">Proof.</span></div>
<div class="proofscript" id="proof407">
<span class="id">rewrite</span> <span class="id">predeq2E</span> =&gt; <span class="id">M</span> <span class="id">A</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; [<span class="id">B</span>]; <span class="id">rewrite</span> -<span class="id">nbhs_entourageE</span> =&gt; <span class="id">M_B</span> <span class="id">sBA</span>.<br/>
&nbsp;&nbsp;<span class="id">set</span> <span class="id">sB</span> := <span class="kwd">fun</span> <span class="id">i</span> <span class="id">j</span> =&gt; [<span class="id">set</span> <span class="id">C</span> | <span class="id">entourage</span> <span class="id">C</span> /\ <span class="id">to_set</span> <span class="id">C</span> (<span class="id">M</span> <span class="id">i</span> <span class="id">j</span>) `&lt;=` <span class="id"><a name="T:2236">B</a></span> <span class="id">i</span> <span class="id"><a href="mathcomp.analysis.topology.html#uniformType">j</a></span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> {}<span class="id"><a name="m:2237">M_B</a></span> : <span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span>, <span class="id">sB</span> <span class="id">i</span> <span class="id">j</span> !=<span class="id">set0</span> <span class="kwd">by</span> <span class="id"><a name="FF:2240">move</a></span>=&gt; ??; <span class="id">apply</span>/<span class="id">exists2P</span>/<span class="id">M_B</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">MN</span> : '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) * '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) | <span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">get</span> (<span class="id">sB</span> <span class="id"><a name="i:2244">i</a></span> <span class="id"><a name="j:2245">j</a></span>) (<span class="id">MN</span>.1 <span class="id">i</span> <span class="id">j</span>, <span class="id">MN</span>.2 <span class="id">i</span> <span class="id">j</span>)].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">i</span> <span class="id">j</span> =&gt; <span class="id">get</span> (<span class="id">sB</span> <span class="id">i</span> <span class="id">j</span>)) =&gt; // <span class="id">i</span> <span class="id">j</span>; <span class="id">have</span> /<span class="id">getPex</span> [] := <span class="id">M_B</span> <span class="id">i</span> <span class="id">j</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">N</span> <span class="id">CMN</span>; <span class="id">apply</span>/<span class="id">sBA</span> =&gt; <span class="id">i</span> <span class="id">j</span>; <span class="id">have</span> /<span class="id">getPex</span> [<span class="id">_</span>] := <span class="id">M_B</span> <span class="id">i</span> <span class="id">j</span>; <span class="id">apply</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>/<span class="id">CMN</span>.<br/>
<span class="id">move</span>=&gt; [<span class="id">B</span> [<span class="id">C</span> <span class="id">entC</span> <span class="id">sCB</span>] <span class="id">sBA</span>]; <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">i</span> <span class="id">j</span> =&gt; <span class="id"><a name="ij:2250">to_set</a></span> (<span class="id">C</span> <span class="id">i</span> <span class="id">j</span>) (<span class="id">M</span> <span class="id">i</span> <span class="id">j</span>)).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">nbhs_entourageE</span> =&gt; <span class="id">i</span> <span class="id">j</span>; <span class="kwd">exists</span> (<span class="id">C</span> <span class="id">i</span> <span class="id">j</span>).<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">N</span> <span class="id">CMN</span>; <span class="id">apply</span>/<span class="id">sBA</span>/<span class="id">sCB</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">matrix_uniformType_mixin</span> :=<br/>
&nbsp;&nbsp;<span class="id">Uniform.Mixin</span> <span class="id">mx_ent_filter</span> <span class="id">mx_ent_refl</span> <span class="id">mx_ent_inv</span> <span class="id">mx_ent_split</span><br/>
&nbsp;&nbsp;<span class="id">mx_ent_nbhsE</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">matrix_uniformType</span> :=<br/>
&nbsp;&nbsp;<span class="id">UniformType</span> '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) <span class="id">matrix_uniformType_mixin</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">matrix_Uniform</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_mx_entourageP</span> (<span class="id">T</span> : <span class="id">uniformType</span>) <span class="id">m</span> <span class="id">n</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> '<span class="id">M</span>[<span class="id"><a name="fct_Uniform.U">T</a></span>]<span class="id">_</span>(<span class="id"><a href="mathcomp.analysis.topology.html#uniformType">m</a></span>,<span class="id">n</span>)))<br/>
&nbsp;&nbsp;(<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>) (<span class="id"><a name="fct_ent">M</a></span> : '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>,<span class="id"><a href="mathcomp.analysis.topology.html#filter_from">n</a></span>)) :<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">M</span> &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt; \<span class="kwd">forall</span> <span class="id">N</span> \<span class="id"><a name="t:2262">near</a></span> <span class="id">F</span>,<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span>, <span class="id">A</span> (<span class="id">M</span> <span class="id">i</span> <span class="id">j</span>, (<span class="id">N</span> : '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>,<span class="id">n</span>)) <span class="id">i</span> <span class="id">j</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof408')">Proof.</span></div>
<div class="proofscript" id="proof408">
<span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_from_filter">filter_fromP</a></span> =&gt; <span class="id">FM</span> <span class="id">A</span> ?; <span class="id">apply</span>: (<span class="id">FM</span> (<span class="kwd">fun</span> <span class="id">i</span> <span class="id">j</span> =&gt; <span class="id">to_set</span> <span class="id">A</span> (<span class="id">M</span> <span class="id">i</span> <span class="id">j</span>))).<br/>
<span class="id">move</span>=&gt; <span class="id">FM</span>; <span class="id">apply</span>/<span class="id">cvg_entourageP</span> =&gt; <span class="id">A</span> [<span class="id">P</span> <span class="id">entP</span> <span class="id">sPA</span>]; <span class="id">near</span>=&gt; <span class="id">N</span>.<br/>
<span class="id">apply</span>: <span class="id">sPA</span> =&gt; /=; <span class="id">near</span>: <span class="id">N</span>; <span class="id">set</span> <span class="id">Q</span> := \<span class="id">bigcap_ij</span> <span class="id">P</span> <span class="id">ij</span>.1 <span class="id">ij</span>.2.<br/>
<span class="id">apply</span>: <span class="id">filterS</span> (<span class="id">FM</span> <span class="id">Q</span> <span class="id">_</span>); <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">N</span> <span class="id">QN</span> <span class="id">i</span> <span class="id">j</span>; <span class="id">apply</span>: (<span class="id">QN</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">i</span>, <span class="id">j</span>)).<br/>
<span class="id">have</span> -&gt; : <span class="id">Q</span> =<br/>
&nbsp;&nbsp;\<span class="id">bigcap_</span>(<span class="id">ij</span> <span class="kwd">in</span> [<span class="id">set</span> <span class="id">k</span> | <span class="id">k</span> \<span class="kwd">in</span> [<span class="id">fset</span> <span class="id">x</span> <span class="kwd">in</span> <span class="id">predT</span>]%<span class="id">fset</span>]) <span class="id">P</span> <span class="id">ij</span>.1 <span class="id"><a name="fct_ent_inv">ij</a></span>.2.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">t</span>; <span class="id">split</span>=&gt; <span class="id">Qt</span> <span class="id">ij</span> <span class="id">_</span>; <span class="id">apply</span>: <span class="id">Qt</span> =&gt; //=; <span class="id">rewrite</span> !<span class="id">inE</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filter_bigI</span> =&gt; ??; <span class="id">apply</span>: <span class="id">entP</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<div class="doc">Functional metric spaces </div>
<br/>
<span class="kwd">Section</span> <span class="id">fct_Uniform</span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id">T</span> : <span class="id">choiceType</span>) (<span class="id">U</span> : <span class="id">uniformType</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">fct_ent</span> :=<br/>
&nbsp;&nbsp;<span class="id">filter_from</span><br/>
&nbsp;&nbsp;(@<span class="id">entourage</span> <span class="id">U</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">P</span> =&gt; [<span class="id">set</span> <span class="id">fg</span> | <span class="kwd">forall</span> <span class="id">t</span> : <span class="id">T</span>, <span class="id">P</span> (<span class="id">fg</span>.1 <span class="id">t</span>, <span class="id">fg</span>.2 <span class="id">t</span>)]).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">fct_ent_filter</span> : <span class="id">Filter</span> <span class="id">fct_ent</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof409')">Proof.</span></div>
<div class="proofscript" id="proof409">
<span class="id">apply</span>: <span class="id">filter_from_filter</span>; <span class="id"><a href="mathcomp.analysis.topology.html#split_ent">first</a></span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">apply</span>: <span class="id">filterT</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span> <span class="id">entA</span> <span class="id">entB</span>.<br/>
<span class="kwd">exists</span> (<span class="id"><a href="mathcomp.analysis.topology.html#entourage_split">A</a></span> `&amp;` <span class="id">B</span>); <span class="id">first</span> <span class="id">exact</span>: <span class="id">filterI</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">fg</span> <span class="id">ABfg</span>; <span class="id">split</span>=&gt; <span class="id">t</span>; <span class="id">have</span> [] := <span class="id">ABfg</span> <span class="id">t</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">fct_ent_refl</span> <span class="id">A</span> : <span class="id">fct_ent</span> <span class="id">A</span> -&gt; [<span class="id">set</span> <span class="id">fg</span> | <span class="id">fg</span>.1 = <span class="id">fg</span>.2] `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof410')">Proof.</span></div>
<div class="proofscript" id="proof410">
<span class="id">move</span>=&gt; [<span class="id">B</span> <span class="id">entB</span> <span class="id">sBA</span>] <span class="id">fg</span> <span class="id">feg</span>; <span class="id">apply</span>/<span class="id">sBA</span> =&gt; <span class="id">t</span>; <span class="id">rewrite</span> <span class="id">feg</span>.<br/>
<span class="id">exact</span>: <span class="id">entourage_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">fct_ent_inv</span> <span class="id">A</span> : <span class="id">fct_ent</span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Source">fct_ent</a></span> (<span class="id">A</span>^-1)%<span class="id">classic</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof411')">Proof.</span></div>
<div class="proofscript" id="proof411">
<span class="id">move</span>=&gt; [<span class="id">B</span> <span class="id">entB</span> <span class="id">sBA</span>]; <span class="kwd">exists</span> (<span class="id">B</span>^-1)%<span class="id">classic</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">entourage_inv</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">fg</span> <span class="id">Bgf</span>; <span class="id">apply</span>/<span class="id">sBA</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">fct_ent_split</span> <span class="id">A</span> : <span class="id">fct_ent</span> <span class="id">A</span> -&gt; <span class="kwd">exists2</span> <span class="id">B</span>, <span class="id">fct_ent</span> <span class="id">B</span> &amp; <span class="id">B</span> \; <span class="id"><a href="mathcomp.analysis.topology.html#fct_Uniform">B</a></span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof412')">Proof.</span></div>
<div class="proofscript" id="proof412">
<span class="id">move</span>=&gt; [<span class="id">B</span> <span class="id">entB</span> <span class="id">sBA</span>].<br/>
<span class="comment">(*&nbsp;have&nbsp;Bsplit&nbsp;:&nbsp;exists&nbsp;C,&nbsp;entourage&nbsp;C&nbsp;/\&nbsp;C&nbsp;\o&nbsp;C&nbsp;`&lt;=`&nbsp;B.&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;exact/exists2P/entourage_split_ex.&nbsp;*)</span><br/>
<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">fg</span> | <span class="kwd">forall</span> <span class="id">t</span>, <span class="id">split_ent</span> <span class="id">B</span> (<span class="id">fg</span>.1 <span class="id">t</span>, <span class="id">fg</span>.2 <span class="id">t</span>)].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">split_ent</span> <span class="id">B</span>).<br/>
<span class="id">move</span>=&gt; <span class="id">fg</span> [<span class="id">h</span> <span class="id">spBfh</span> <span class="id">spBhg</span>].<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">sBA</span> =&gt; <span class="id">t</span>; <span class="id">apply</span>: <span class="id">entourage_split</span> (<span class="id">spBfh</span> <span class="id">t</span>) (<span class="id">spBhg</span> <span class="id">t</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">fct_uniformType_mixin</span> :=<br/>
&nbsp;&nbsp;<span class="id">UniformMixin</span> <span class="id">fct_ent_filter</span> <span class="id">fct_ent_refl</span> <span class="id">fct_ent_inv</span> <span class="id">fct_ent_split</span> <span class="id">erefl</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">fct_topologicalTypeMixin</span> :=<br/>
&nbsp;&nbsp;<span class="id">topologyOfEntourageMixin</span> <span class="id">fct_uniformType_mixin</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">generic_source_filter</span> := @<span class="id">Filtered.Source</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">nbhs_</span> <span class="id">fct_ent</span>).<br/>
<span class="kwd">Canonical</span> <span class="id">fct_topologicalType</span> :=<br/>
&nbsp;&nbsp;<span class="id">TopologicalType</span> (<span class="id">T</span> -&gt; <span class="id">U</span>) <span class="id">fct_topologicalTypeMixin</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">fct_uniformType</span> := <span class="id">UniformType</span> (<span class="id">T</span> -&gt; <span class="id">U</span>) <span class="id">fct_uniformType_mixin</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">fct_Uniform</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_fct_entourageP</span> (<span class="id">T</span> : <span class="id">choiceType</span>) (<span class="id">U</span> : <span class="id">uniformType</span>)<br/>
&nbsp;&nbsp;(<span class="id"><a name="T':2296">F</a></span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> -&gt; <span class="id">U</span>))) (<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a name="x:2298">F</a></span> --&gt; <span class="id">f</span> &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;\<span class="kwd">forall</span> <span class="id">g</span> \<span class="id">near</span> <span class="id">F</span>, <span class="kwd">forall</span> <span class="id">t</span>, <span class="id">A</span> (<span class="id">f</span> <span class="id">t</span>, <span class="id">g</span> <span class="id">t</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof413')">Proof.</span></div>
<div class="proofscript" id="proof413">
<span class="id"><a name="T:2302">split</a></span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /<span class="id">cvg_entourageP</span> <span class="id">Ff</span> <span class="id">A</span> <span class="id">entA</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">Ff</span> [<span class="id">set</span> <span class="id">fg</span> | <span class="kwd">forall</span> <span class="id">t</span> : <span class="id">T</span>, <span class="id">A</span> (<span class="id">fg</span>.1 <span class="id">t</span>, <span class="id"><a name="e:2306">fg</a></span>.2 <span class="id">t</span>)]); <span class="kwd">exists</span> <span class="id">A</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">Ff</span>; <span class="id">apply</span>/<span class="id">cvg_entourageP</span> =&gt; <span class="id">A</span> [<span class="id">P</span> <span class="id">entP</span> <span class="id"><a name="map_pair">sPA</a></span>].<br/>
<span class="kwd">by</span> <span class="id">near</span>=&gt; <span class="id"><a name="f:2310">g</a></span> <span class="id">do</span> <span class="id">apply</span>: <span class="id">sPA</span>; <span class="id">apply</span>: <span class="id">Ff</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">entourage_set</span> (<span class="id">U</span> : <span class="id">uniformType</span>) (<span class="id">A</span> : <span class="id"><a name="weak_uniform.U">set</a></span> ((<span class="id">set</span> <span class="id">U</span>) * (<span class="id">set</span> <span class="id">U</span>))) :=<br/>
&nbsp;&nbsp;<span class="kwd">exists2</span> <span class="id">B</span>, <span class="id">entourage</span> <span class="id">B</span> &amp; <span class="kwd">forall</span> <span class="id">PQ</span>, <span class="id">A</span> <span class="id">PQ</span> -&gt; <span class="kwd">forall</span> <span class="id">p</span> <span class="id">q</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">PQ</span>.1 <span class="id">p</span> -&gt; <span class="id">PQ</span>.2 <span class="id">q</span> -&gt; <span class="id">B</span> (<span class="id">p</span>,<span class="id">q</span>).<br/>
<span class="kwd">Canonical</span> <span class="id">set_filter_source</span> (<span class="id">U</span> : <span class="id">uniformType</span>) :=<br/>
&nbsp;&nbsp;@<span class="id">Filtered.Source</span> <span class="kwd">Prop</span> <span class="id">_</span> <span class="id">U</span> (<span class="kwd">fun</span> <span class="id">A</span> =&gt; <span class="id">nbhs_</span> (@<span class="id">entourage_set</span> <span class="id">U</span>) <span class="id">A</span>).<br/>
<br/>
<h1> PseudoMetric spaces defined using balls </h1>
<br/>
<span class="kwd">Definition</span> <span class="id">entourage_</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">T</span> <span class="id">T</span>'} (<span class="id">ball</span> : <span class="id">T</span> -&gt; <span class="id">R</span> -&gt; <span class="id">set</span> <span class="id">T</span>') :=<br/>
&nbsp;&nbsp;@<span class="id">filter_from</span> <span class="id"><a name="A:2316">R</a></span> <span class="id">_</span> [<span class="id">set</span> <span class="id">x</span> | 0 &lt; <span class="id">x</span>] (<span class="kwd">fun</span> <span class="id">e</span> =&gt; [<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span> <span class="id">xy</span>.2]).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_E</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">T</span> <span class="id">T</span>'} (<span class="id"><a href="mathcomp.analysis.topology.html#entourage_refl">ball</a></span> : <span class="id">T</span> -&gt; <span class="id">R</span> -&gt; <span class="id">set</span> <span class="id">T</span>') :<br/>
&nbsp;&nbsp;<span class="id">entourage_</span> <span class="id">ball</span> =<br/>
&nbsp;&nbsp;@<span class="id">filter_from</span> <span class="id">R</span> <span class="id">_</span> [<span class="id">set</span> <span class="id">x</span> | 0 &lt; <span class="id">x</span>] (<span class="kwd">fun</span> <span class="id">e</span> =&gt; [<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span> <span class="id">xy</span>.2]).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof414')">Proof.</span></div>
<div class="proofscript" id="proof414">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">map_pair</span> {<span class="id">S</span> <span class="id">U</span>} (<span class="id">f</span> : <span class="id">S</span> -&gt; <span class="id">U</span>) (<span class="id">x</span> : (<span class="id">S</span> * <span class="id">S</span>)) : (<span class="id">U</span> * <span class="id">U</span>) :=<br/>
&nbsp;&nbsp;(<span class="id">f</span> <span class="id">x</span>.1, <span class="id">f</span> <span class="id">x</span>.2).<br/>
<br/>
<span class="kwd">Section</span> <span class="id">weak_uniform</span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id">pS</span> : <span class="id">pointedType</span>) (<span class="id">U</span> : <span class="id">uniformType</span>) (<span class="id">f</span> : <span class="id">pS</span> -&gt; <span class="id">U</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">S</span> := <span class="id">weak_topologicalType</span> <span class="id">f</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">weak_ent</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">S</span> * <span class="id">S</span>)) :=<br/>
&nbsp;&nbsp;<span class="id">filter_from</span> (@<span class="id">entourage</span> <span class="id">U</span>) (<span class="kwd">fun</span> <span class="id">V</span> =&gt; (<span class="id">map_pair</span> <span class="id">f</span>)@^-1` <span class="id">V</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_ent_filter</span> : <span class="id">Filter</span> <span class="id">weak_ent</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof415')">Proof.</span></div>
<div class="proofscript" id="proof415">
<span class="id">apply</span>: <span class="id">filter_from_filter</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_">setT</a></span>; <span class="id"><a href="mathcomp.analysis.topology.html#weak_ent">exact</a></span>: <span class="id">entourageT</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> ??; (<span class="kwd">exists</span> (<span class="id">P</span> `&amp;` <span class="id">Q</span>); <span class="id">first</span> <span class="id">exact</span>: <span class="id">filterI</span>) =&gt; ?.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_ent_refl</span> <span class="id">A</span> : <span class="id">weak_ent</span> <span class="id">A</span> -&gt; [<span class="id">set</span> <span class="id">fg</span> | <span class="id"><a href="mathcomp.analysis.topology.html#nbhsP">fg</a></span>.1 = <span class="id">fg</span>.2] `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof416')">Proof.</span></div>
<div class="proofscript" id="proof416">
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">B</span> ? <span class="id">sBA</span>] [<span class="id">x</span> <span class="id">y</span>] /= -&gt;; <span class="id">apply</span>/<span class="id">sBA</span>; <span class="id">exact</span>: <span class="id">entourage_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_ent_inv</span> <span class="id">A</span> : <span class="id">weak_ent</span> <span class="id">A</span> -&gt; <span class="id">weak_ent</span> (<span class="id">A</span>^-1)%<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">classic</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof417')">Proof.</span></div>
<div class="proofscript" id="proof417">
<span class="id">move</span>=&gt; [<span class="id">B</span> ? <span class="id">sBA</span>]; <span class="kwd">exists</span> (<span class="id">B</span>^-1)%<span class="id">classic</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#weak_uniform.U">entourage_inv</a></span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; ??; <span class="id">exact</span>/<span class="id">sBA</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_ent_split</span> <span class="id">A</span> : <span class="id">weak_ent</span> <span class="id">A</span> -&gt; <span class="kwd">exists2</span> <span class="id">B</span>, <span class="id">weak_ent</span> <span class="id">B</span> &amp; <span class="id">B</span> \; <span class="id">B</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof418')">Proof.</span></div>
<div class="proofscript" id="proof418">
<span class="id">move</span>=&gt; [<span class="id">B</span> <span class="id">entB</span> <span class="id">sBA</span>]; <span class="id">have</span> : <span class="kwd">exists</span> <span class="id">C</span>, <span class="id">entourage</span> <span class="id">C</span> /\ <span class="id">C</span> \; <span class="id">C</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#weak_uniform.S">B</a></span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>/<span class="id">exists2P</span>/<span class="id"><a href="mathcomp.analysis.topology.html#weak_ent_filter">entourage_split_ex</a></span>.<br/>
<span class="id">case</span>=&gt; <span class="id">C</span> [<span class="id"><a href="mathcomp.analysis.topology.html#weak_ent_inv">entC</a></span> <span class="id">CsubB</span>]; <span class="kwd">exists</span> ((<span class="id">map_pair</span> <span class="id">f</span>)@^-1` <span class="id">C</span>); <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">C</span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">x</span> <span class="id">y</span> [<span class="id"><a href="mathcomp.analysis.topology.html#UniformType">a</a></span> ? ?]; <span class="id">apply</span>/<span class="id"><a href="mathcomp.analysis.topology.html#weak_uniform_mixin">sBA</a></span>/<span class="id">CsubB</span>; <span class="kwd">exists</span> (<span class="id">f</span> <span class="id">a</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_ent_nbhs</span> : <span class="id">nbhs</span> = <span class="id">nbhs_</span> <span class="id">weak_ent</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof419')">Proof.</span></div>
<div class="proofscript" id="proof419">
<span class="id">rewrite</span> <span class="id">predeq2E</span> =&gt; <span class="id">x</span> <span class="id">V</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>=&gt; [? [[<span class="id">B</span>  ? &lt;-] ? <span class="id">BsubV</span>]]; <span class="id">have</span>: <span class="id">nbhs</span> (<span class="id">f</span> <span class="id">x</span>) <span class="id">B</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">open_nbhs_nbhs</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /<span class="id">nbhsP</span> [<span class="id">W</span> ? <span class="id">WsubB</span>]; <span class="kwd">exists</span> ((<span class="id">map_pair</span> <span class="id">f</span>) @^-1` <span class="id">W</span>); <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">W</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt;??; <span class="id"><a href="mathcomp.analysis.topology.html#sup_uniform.T">exact</a></span>/<span class="id">BsubV</span>/<span class="id">WsubB</span>.<br/>
<span class="id">case</span>=&gt; <span class="id">W</span> [<span class="id">V</span>' <span class="id">entV</span>' <span class="id">V</span>'<span class="id">subW</span>] /<span class="id">filterS</span>; <span class="id">apply</span>.<br/>
<span class="id">have</span> : <span class="id">nbhs</span> (<span class="id">f</span> <span class="id">x</span>) <span class="id">to_set</span> <span class="id">V</span>' (<span class="id">f</span> <span class="id">x</span>) <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">nbhsP</span>; <span class="kwd">exists</span> <span class="id">V</span>'.<br/>
<span class="id">rewrite</span> (@<span class="id"><a name="IEnt_pointT">nbhsE</a></span> <span class="id">U</span>) =&gt; [[<span class="id">O</span> [<span class="id"><a href="mathcomp.analysis.topology.html#sup_uniform.I">openU</a></span> <span class="id">Ofx</span> <span class="id">Osub</span>]]].<br/>
(<span class="kwd">exists</span> (<span class="id">f</span> @^-1` <span class="id">O</span>); <span class="id">repeat</span> <span class="id">split</span> =&gt; //); <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">O</span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">w</span> ? ; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#sup_uniform.T">V</a></span>'<span class="id">subW</span>; <span class="id">exact</span>: <span class="id">Osub</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">weak_uniform_mixin</span> :=<br/>
&nbsp;&nbsp;@<span class="id">UniformMixin</span> <span class="id">S</span> <span class="id">nbhs</span> <span class="id">weak_ent</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">weak_ent_filter</span> <span class="id">weak_ent_refl</span> <span class="id">weak_ent_inv</span> <span class="id">weak_ent_split</span> <span class="id"><a href="mathcomp.analysis.topology.html#Filter">weak_ent_nbhs</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">weak_uniformType</span> :=<br/>
&nbsp;&nbsp;<span class="id">UniformType</span> <span class="id">S</span> <span class="id">weak_uniform_mixin</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">weak_uniform</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">sup_uniform</span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id">T</span> : <span class="id">pointedType</span>) (<span class="id">Ii</span> : <span class="kwd">Type</span>) (<span class="id">Tc</span> : <span class="id">Ii</span> -&gt; <span class="id"><a name="fg:2332">Uniform.class_of</a></span> <span class="id">T</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">I</span> : <span class="id">choiceType</span> := <span class="id">classicType_choiceType</span> <span class="id">Ii</span>.<br/>
<span class="kwd">Let</span> <span class="id">TS</span> := <span class="kwd">fun</span> <span class="id">i</span> =&gt; <span class="id">Uniform.Pack</span> (<span class="id">Tc</span> <span class="id">i</span>).<br/>
<span class="kwd">Let</span> <span class="id">Tt</span> := @<span class="id">sup_topologicalType</span> <span class="id"><a href="mathcomp.analysis.topology.html#sup_ent">T</a></span> <span class="id">I</span> <span class="id">Tc</span>.<br/>
<span class="kwd">Let</span> <span class="id">ent_of</span> (<span class="id">p</span> : <span class="id">I</span> * <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>)) := `[&lt; @<span class="id">entourage</span> (<span class="id">TS</span> <span class="id">p</span>.1) <span class="id">p</span>.2&gt;].<br/>
<span class="kwd">Let</span> <span class="id">IEnt</span> := <span class="id">ChoiceType</span> {<span class="id">p</span> : (<span class="id">I</span> * <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>)) | <span class="id">ent_of</span> <span class="id">p</span>} (<span class="id">sig_choiceMixin</span> <span class="id">_</span>).<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">IEnt_pointT</span> (<span class="id">i</span> : <span class="id">I</span>) : <span class="id">ent_of</span> (<span class="id">i</span>, <span class="id">setT</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof420')">Proof.</span></div>
<div class="proofscript" id="proof420">
 <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">asboolP</span>; <span class="id">exact</span>: <span class="id">entourageT</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">sup_ent</span> : (<span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>))) :=<br/>
&nbsp;&nbsp;<span class="id">filter_from</span> (<span class="id"><a name="w:2335">finI_from</a></span> [<span class="id">set</span>: <span class="id">IEnt</span>] (<span class="kwd">fun</span> <span class="id">p</span> =&gt; (<span class="id">projT1</span> <span class="id">p</span>).2)) <span class="id">id</span>.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">IEntP</span> := <span class="id">move</span>=&gt; [[ /= + + /[<span class="id">dup</span>] /<span class="id">asboolP</span>]].<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">sup_ent_filter</span> : <span class="id">Filter</span> <span class="id">sup_ent</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof421')">Proof.</span></div>
<div class="proofscript" id="proof421">
<span class="id">apply</span>: <span class="id">finI_filter</span>; <span class="id">move</span>=&gt; <span class="id">J</span> <span class="id">JsubEnt</span> /=; <span class="kwd">exists</span> (<span class="id">point</span>, <span class="id">point</span>).<br/>
<span class="kwd">by</span> <span class="id">IEntP</span> =&gt; <span class="id">i</span> <span class="id">b</span> /= /<span class="id">entourage_refl</span> ? ? <span class="id">_</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">sup_ent_refl</span> <span class="id">A</span> : <span class="id">sup_ent</span> <span class="id">A</span> -&gt; [<span class="id">set</span> <span class="id">fg</span> | <span class="id">fg</span>.1 = <span class="id">fg</span>.2] `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof422')">Proof.</span></div>
<div class="proofscript" id="proof422">
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id"><a href="mathcomp.analysis.topology.html#sup_uniform.IEnt">B</a></span> [<span class="id">F</span> ? &lt;-] <span class="id">BA</span>] [??] /= -&gt;; <span class="id">apply</span>/<span class="id">BA</span>; <span class="id">IEntP</span> =&gt; <span class="id">i</span> <span class="id">w</span> /= /<span class="id">entourage_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">sup_ent_inv</span> <span class="id">A</span> : <span class="id">sup_ent</span> <span class="id"><a href="mathcomp.classical.boolp.html#asboolP">A</a></span> -&gt; <span class="id">sup_ent</span> (<span class="id">A</span>^-1)%<span class="id">classic</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof423')">Proof.</span></div>
<div class="proofscript" id="proof423">
<span class="id">move</span>=&gt; [<span class="id">B</span> [<span class="id">F</span> ? <span class="id">FB</span>] <span class="id">BA</span>]; <span class="kwd">exists</span> (<span class="id">B</span>^-1)%<span class="id">classic</span>; <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#exist">last</a></span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">exact</span>: <span class="id">BA</span>.<br/>
<span class="id">have</span> <span class="id">inv</span> : <span class="kwd">forall</span> <span class="id">ie</span> : <span class="id">IEnt</span>, <span class="id">ent_of</span> ((<span class="id">projT1</span> <span class="id">ie</span>).1, ((<span class="id">projT1</span> <span class="id">ie</span>).2)^-1)%<span class="id">classic</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">IEntP</span>=&gt; ?? /<span class="id">entourage_inv</span> ??; <span class="id">exact</span>/<span class="id">asboolP</span>.<br/>
<span class="kwd">exists</span> [<span class="id">fset</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; @<span class="id">exist</span> (<span class="id">I</span> * <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>)) <span class="id">_</span> <span class="id">_</span> (<span class="id">inv</span> <span class="id">x</span>)) <span class="id">w</span> | <span class="id">w</span> <span class="kwd">in</span> <span class="id">F</span>]%<span class="id">fset</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? /<span class="id">imfsetP</span>; <span class="id">IEntP</span> =&gt; ???? -&gt;; <span class="id">exact</span>: <span class="id">in_setT</span>.<br/>
<span class="id">rewrite</span> -<span class="id">FB</span> <span class="id">eqEsubset</span>; <span class="id">split</span>; <span class="id">case</span>=&gt; <span class="id">x</span> <span class="id">y</span> + <span class="id">ie</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /(<span class="id">_</span> (<span class="id">exist</span> <span class="id">ent_of</span> <span class="id">_</span> (<span class="id">inv</span> <span class="id">ie</span>))) + ?; <span class="id">apply</span>; <span class="id">apply</span>/<span class="id">imfsetP</span>; <span class="kwd">exists</span> <span class="id">ie</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; + /<span class="id">imfsetP</span> [<span class="id">v</span> <span class="id">vW</span> -&gt;]; <span class="id">exact</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">sup_ent_split</span> <span class="id">A</span> : <span class="id">sup_ent</span> <span class="id">A</span> -&gt; <span class="kwd">exists2</span> <span class="id">B</span>, <span class="id">sup_ent</span> <span class="id">B</span> &amp; <span class="id">B</span> \; <span class="id">B</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof424')">Proof.</span></div>
<div class="proofscript" id="proof424">
<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">have</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#sup_uniform.Tt">spt</a></span> : (<span class="kwd">forall</span> <span class="id"><a href="mathcomp.analysis.topology.html#sup_ent">ie</a></span> : <span class="id">IEnt</span>, <span class="id">ent_of</span> ((<span class="id">projT1</span> <span class="id">ie</span>).1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;((@<span class="id">split_ent</span> (<span class="id">TS</span> (<span class="id">projT1</span> <span class="id">ie</span>).1) (<span class="id">projT1</span> <span class="id">ie</span>).2)))).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>=&gt; [[/= ??] /<span class="id">asboolP</span>/<span class="id">entourage_split_ent</span> ?]; <span class="id">exact</span>/<span class="id">asboolP</span>.<br/>
<span class="id">pose</span> <span class="id">g</span> : (<span class="id">IEnt</span> -&gt; <span class="id">IEnt</span>) := <span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">exist</span> <span class="id">ent_of</span> <span class="id">_</span> (<span class="id">spt</span> <span class="id">x</span>).<br/>
<span class="id">case</span> =&gt; <span class="id">W</span> [<span class="id">F</span> <span class="id">_</span> &lt;-] <span class="id">sA</span>; <span class="kwd">exists</span> (\<span class="id">bigcap_</span>(<span class="id">x</span> <span class="kwd">in</span> [<span class="id">set</span>` <span class="id">F</span>]) (<span class="id">projT1</span> (<span class="id">g</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterT">x</a></span>)).2).<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (\<span class="id">bigcap_</span>(<span class="id">ie</span> <span class="kwd">in</span> [<span class="id">set</span>`<span class="id">F</span>]) (<span class="id">projT1</span> (<span class="id">g</span> <span class="id">ie</span>)).2) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> [<span class="id">fset</span> (<span class="id">g</span> <span class="id">ie</span>) | <span class="id">ie</span> <span class="kwd">in</span> <span class="id">F</span>]%<span class="id">fset</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; /= ??; <span class="id">exact</span>: <span class="id">in_setT</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>; <span class="id">case</span>=&gt; <span class="id">x</span> <span class="id">y</span> <span class="id">Igxy</span> <span class="id">ie</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span> =&gt; ?; <span class="id">apply</span>/(<span class="id">Igxy</span> (<span class="id">g</span> <span class="id">ie</span>))/<span class="id">imfsetP</span>; <span class="kwd">exists</span> <span class="id">ie</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">imfsetP</span> [?? -&gt;]; <span class="id">exact</span>: <span class="id">Igxy</span>.<br/>
<span class="id">case</span> =&gt; ?? [<span class="id">z</span> <span class="id">Fxz</span> <span class="id">Fzy</span>]; <span class="id">apply</span>: <span class="id">sA</span>; <span class="id">IEntP</span>=&gt; <span class="id">i</span> <span class="id">e</span> ? ? <span class="id">eF</span>.<br/>
<span class="id">apply</span>: ((@<span class="id">entourage_split</span> (<span class="id">TS</span> <span class="id">i</span>)) <span class="id">z</span>) =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: (<span class="id">Fxz</span> <span class="id">_</span> <span class="id">eF</span>).<br/>
<span class="id">exact</span>: (<span class="id">Fzy</span> <span class="id">_</span> <span class="id">eF</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">sup_ent_nbhs</span> : @<span class="id">nbhs</span> <span class="id">Tt</span> <span class="id">Tt</span> = <span class="id">nbhs_</span> <span class="id">sup_ent</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof425')">Proof.</span></div>
<div class="proofscript" id="proof425">
<span class="id">rewrite</span> <span class="id">predeq2E</span> =&gt; <span class="id">x</span> <span class="id">V</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">nbhs_of_open</span> =&gt; [[? [[<span class="id">B</span>  + &lt;-] [<span class="id">W</span> <span class="id">BW</span> <span class="id">Wx</span>] <span class="id">BV</span>]]] =&gt; /(<span class="id">_</span> <span class="id">W</span> <span class="id">BW</span>) [].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">F</span> <span class="id">Fsup</span> <span class="id">Weq</span>; <span class="id">move</span>: <span class="id">Weq</span> <span class="id">Wx</span> <span class="id">BW</span> =&gt; &lt;- <span class="id">Fx</span> <span class="id">BF</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span> (<span class="id">pselect</span> ([<span class="id">set</span>: <span class="id">I</span>] = <span class="id">set0</span>)) =&gt; [<span class="id">I0</span> | /<span class="id">eqP</span>/<span class="id">set0P</span> [<span class="id">i0</span> <span class="id">_</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">suff</span> -&gt; : <span class="id">V</span> = <span class="id">setT</span>  <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">apply</span>: <span class="id"><a name="w:2358">filterT</a></span>; <span class="id">exact</span>: <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">sup_ent_filter</a></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> -<span class="id">subTset</span> =&gt; ??; <span class="id">apply</span>: <span class="id">BV</span>; <span class="kwd">exists</span> (\<span class="id">bigcap_</span>(<span class="id">i</span> <span class="kwd">in</span> [<span class="id"><a name="w:2360">set</a></span>` <span class="id">F</span>]) <span class="id">i</span>) =&gt; //.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">w</span> /<span class="id">Fsup</span>/<span class="id">set_mem</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">sup_subbase</a></span> <span class="id">I0</span> <span class="id">bigcup_set0</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">f</span> : <span class="kwd">forall</span> <span class="id">w</span>, {<span class="id">p</span> : <span class="id">IEnt</span> |  <span class="id">w</span> \<span class="kwd">in</span> <span class="id">F</span> -&gt; <span class="id">to_set</span> ((<span class="id">projT1</span> <span class="id">p</span>).2) <span class="id">x</span> `&lt;=` <span class="id">w</span>}.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>=&gt; /= <span class="id">v</span>; <span class="id">apply</span>: <span class="id">cid</span>; <span class="id">case</span> (<span class="id">pselect</span> (<span class="id">v</span> \<span class="kwd">in</span> <span class="id">F</span>)); <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="kwd">exists</span> (<span class="id">exist</span> <span class="id">ent_of</span> <span class="id">_</span> (<span class="id">IEnt_pointT</span> <span class="id"><a href="mathcomp.analysis.topology.html#sup_uniform.IEnt">i0</a></span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>=&gt; /[<span class="id">dup</span>] /<span class="id">Fx</span> <span class="id">vx</span> /<span class="id">Fsup</span>/<span class="id">set_mem</span> [<span class="id">i</span> <span class="id">_</span>]; <span class="id">rewrite</span> <span class="id">openE</span> =&gt; /(<span class="id">_</span> <span class="id">x</span> <span class="id">vx</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /(@<span class="id">nbhsP</span> (<span class="id">TS</span> <span class="id">i</span>)) [<span class="id">w</span> /<span class="id">asboolP</span> <span class="id">ent</span> ?]; <span class="kwd">exists</span> (<span class="id">exist</span> <span class="id">_</span> (<span class="id">i</span>, <span class="id">w</span>) <span class="id">ent</span>).<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (\<span class="id">bigcap_</span>(<span class="id">w</span> <span class="kwd">in</span> [<span class="id">set</span>` <span class="id">F</span>]) (<span class="id">projT1</span> (<span class="id">projT1</span> (<span class="id">f</span> <span class="id">w</span>))).2); <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">v</span> /= <span class="id">Fgw</span>; <span class="id">apply</span>: <span class="id">BV</span>; <span class="kwd">exists</span> (\<span class="id">bigcap_</span>(<span class="id">i</span> <span class="kwd">in</span> [<span class="id">set</span>` <span class="id">F</span>]) <span class="id">i</span>) =&gt; //.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">w</span> /[<span class="id">dup</span>] ? /<span class="id">Fgw</span> /= /(<span class="id">projT2</span> (<span class="id">f</span> <span class="id">w</span>)); <span class="id">exact</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (\<span class="id">bigcap_</span>(<span class="id">w</span> <span class="kwd">in</span> [<span class="id">set</span>` <span class="id">F</span>]) (<span class="id">projT1</span> (<span class="id">projT1</span> (<span class="id">f</span> <span class="id">w</span>))).2) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> [<span class="id">fset</span> (<span class="kwd">fun</span> <span class="id">i</span> =&gt; (<span class="id">projT1</span> (<span class="id">f</span> <span class="id">i</span>))) <span class="id">w</span> | <span class="id">w</span> <span class="kwd">in</span> <span class="id">F</span>]%<span class="id">fset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">u</span> ?; <span class="id">exact</span>: <span class="id">in_setT</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id">y</span> + <span class="id">z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt;/(<span class="id">_</span> (<span class="id">projT1</span> (<span class="id">f</span> <span class="id">z</span>))) =&gt; + ?; <span class="id">apply</span>; <span class="id">apply</span>/<span class="id">imfsetP</span>; <span class="kwd">exists</span> <span class="id">z</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Fgy</span> /<span class="id">imfsetP</span> [/= <span class="id">u</span> <span class="id">uF</span> -&gt;]; <span class="id">exact</span>: <span class="id">Fgy</span>.<br/>
<span class="id">case</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#sup_ent_nbhs">E</a></span> [<span class="id">D</span> [/= <span class="id">F</span> <span class="id">FsubEnt</span> &lt;-] <span class="id">FsubE</span> <span class="id">EsubV</span>]; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#UniformType">filterS</a></span> <span class="id">EsubV</span>).<br/>
<span class="id">pose</span> <span class="id">f</span> : <span class="id">IEnt</span> -&gt; <span class="id">set</span> <span class="id">T</span> := <span class="kwd">fun</span> <span class="id">w</span> =&gt;<br/>
&nbsp;&nbsp;@<span class="id">interior</span> (<span class="id">TS</span> (<span class="id">projT1</span> <span class="id">w</span>).1) (<span class="id">to_set</span> ((<span class="id">projT1</span> <span class="id">w</span>).2) (<span class="id">x</span>)).<br/>
<span class="kwd">exists</span> (\<span class="id"><a href="mathcomp.analysis.topology.html#sup_uniform.TS">bigcap_</a></span>(<span class="id">w</span> <span class="kwd">in</span> [<span class="id">set</span>` <span class="id">F</span>]) <span class="id">f</span> <span class="id">w</span>); <span class="id">repeat</span> <span class="id">split</span>.<br/>
- <span class="kwd">exists</span> [<span class="id">set</span> \<span class="id">bigcap_</span>(<span class="id">w</span> <span class="kwd">in</span> [<span class="id">set</span>` <span class="id">F</span>]) <span class="id">f</span> <span class="id">w</span>]; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">bigcup_set1</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; ? -&gt;; <span class="kwd">exists</span> [<span class="id">fset</span> <span class="id">f</span> <span class="id">w</span> | <span class="id">w</span> <span class="kwd">in</span> <span class="id">F</span>]%<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">fset</a></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>=&gt; /= ? /<span class="id">imfsetP</span> [[[/= <span class="id">i</span> <span class="id">w</span> /[<span class="id">dup</span>] /<span class="id">asboolP</span> <span class="id">entw</span> ? <span class="id">Fiw</span> -&gt;]]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">mem_set</span>; <span class="id">rewrite</span> /<span class="id">f</span> /=; <span class="kwd">exists</span> <span class="id">i</span> =&gt; //; <span class="id">exact</span>: <span class="id">open_interior</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">set_imfset</span> <span class="id">bigcap_image</span> //=.<br/>
- <span class="kwd">by</span> <span class="id">IEntP</span>=&gt; ? ? /<span class="id">open_nbhs_entourage</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#sub_bigcap">entw</a></span> ??; <span class="id">apply</span> <span class="id">entw</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">t</span> /= <span class="id">Ifwt</span>; <span class="id">apply</span>: <span class="id">FsubE</span> =&gt; <span class="id">it</span> /<span class="id">Ifwt</span>/<span class="id">interior_subset</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">sup_uniform_mixin</span>:=<br/>
&nbsp;&nbsp;@<span class="id">UniformMixin</span> <span class="id">Tt</span> <span class="id">nbhs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sup_ent</span> <span class="id">sup_ent_filter</span> <span class="id">sup_ent_refl</span> <span class="id">sup_ent_inv</span> <span class="id">sup_ent_split</span> <span class="id">sup_ent_nbhs</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">sup_uniformType</span> := <span class="id">UniformType</span> <span class="id">Tt</span> <span class="id">sup_uniform_mixin</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">countable_sup_ent</span> :<br/>
&nbsp;&nbsp;<span class="id">countable</span> [<span class="id">set</span>: <span class="id">Ii</span>] -&gt; (<span class="kwd">forall</span> <span class="id">n</span>, <span class="id">countable_uniformity</span> (<span class="id">TS</span> <span class="id">n</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">countable_uniformity</span> <span class="id">sup_uniformType</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof426')">Proof.</span></div>
<div class="proofscript" id="proof426">
<span class="id">move</span>=&gt; <span class="id">Icnt</span> <span class="id">countable_ent</span>; <span class="id">pose</span> <span class="id">f</span> <span class="id">n</span> := <span class="id">cid</span> (<span class="id">countable_ent</span> <span class="id">n</span>).<br/>
<span class="id">pose</span> <span class="id">g</span> (<span class="id">n</span> : <span class="id">Ii</span>) : <span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>)) := <span class="id">projT1</span> (<span class="id">f</span> <span class="id">n</span>).<br/>
<span class="id"><a href="mathcomp.classical.boolp.html#asboolP">have</a></span> [<span class="id">I0</span> | /<span class="id">set0P</span> [<span class="id">i0</span> <span class="id">_</span>]] := <span class="id">eqVneq</span> [<span class="id">set</span>: <span class="id">I</span>] <span class="id">set0</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">setT</span>]; <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">countable1</span>|<span class="id">move</span>=&gt; <span class="id">A</span> -&gt;; <span class="id">exact</span>: <span class="id">entourageT</span>|].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">P</span> [<span class="id">w</span> [<span class="id">A</span> <span class="id">_</span>]] &lt;- <span class="id">subP</span>; <span class="kwd">exists</span> <span class="id">setT</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">subset_trans</span> <span class="id">subP</span>; <span class="id">apply</span>: <span class="id">sub_bigcap</span> =&gt; <span class="id">i</span> <span class="id">_</span> ? <span class="id">_</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">suff</span> : [<span class="id">set</span>: <span class="id">I</span>] (<span class="id">projT1</span> <span class="id">i</span>).1 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">I0</span>.<br/>
<span class="kwd">exists</span> (<span class="id">finI_from</span> (\<span class="id">bigcup_n</span> <span class="id">g</span> <span class="id">n</span>) <span class="id">id</span>); <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#svalP">split</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">finI_from_countable</span>/<span class="id">bigcup_countable</span> =&gt; //<span class="id">i</span> <span class="id">_</span>; <span class="id">case</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#sup_uniform.IEnt">projT2</a></span> (<span class="id">f</span> <span class="id">i</span>)).<br/>
- <span class="id">move</span>=&gt; <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">E</a></span> [<span class="id">A</span> <span class="id">AsubGn</span> <span class="id">AE</span>]; <span class="kwd">exists</span> <span class="id">E</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id"><a href="mathcomp.classical.boolp.html#asboolP">h</a></span> (<span class="id">w</span> : <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>)) : { <span class="id">p</span> : <span class="id">IEnt</span> | <span class="id">w</span> \<span class="kwd">in</span> <span class="id">A</span> -&gt; <span class="id">w</span> = (<span class="id"><a name="x:2383">projT1</a></span> <span class="id">p</span>).2 }.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">cid</span>; <span class="id">have</span> [|] := <span class="id">boolP</span> (<span class="id">w</span> \<span class="kwd">in</span> <span class="id">A</span>); <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">exist</span> <span class="id">ent_of</span> <span class="id">_</span> (<span class="id">IEnt_pointT</span> <span class="id">i0</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>=&gt; /[<span class="id"><a href="mathcomp.analysis.topology.html#sup_uniform.ent_of">dup</a></span>] /<span class="id">AsubGn</span> /<span class="id">set_mem</span> [<span class="id">n</span> <span class="id">_</span> <span class="id">gnw</span>] <span class="id">wA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">suff</span> <span class="id">ent</span> : <span class="id">ent_of</span> (<span class="id">n</span>, <span class="id">w</span>) <span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">exist</span> <span class="id">ent_of</span> (<span class="id">n</span>, <span class="id">w</span>) <span class="id">ent</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">asboolP</span>; <span class="id">have</span> [<span class="id">_</span> + <span class="id">_</span>] := <span class="id">projT2</span> (<span class="id">f</span> <span class="id">n</span>); <span class="id">exact</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> [<span class="id">fset</span> <span class="id">sval</span> (<span class="id">h</span> <span class="id">w</span>) | <span class="id">w</span> <span class="kwd">in</span> <span class="id">A</span>]%<span class="id">fset</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">exact</span>: <span class="id">in_setT</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> -<span class="id">AE</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id">t</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">Ia</a></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">w</span> <span class="id">Aw</span>; <span class="id">rewrite</span> (<span class="id">svalP</span> (<span class="id">h</span> <span class="id">w</span>) <span class="id">Aw</span>); <span class="id">apply</span>/<span class="id">Ia</span>/<span class="id">imfsetP</span>; <span class="kwd">exists</span> <span class="id">w</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>=&gt; [[<span class="id">n</span> <span class="id">w</span>]] <span class="id">p</span> /<span class="id">imfsetP</span> [<span class="id">x</span> /= <span class="id">xA</span> <span class="id">M</span>]; <span class="id">apply</span>: <span class="id">Ia</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">_</span> : <span class="id">w</span> = <span class="id">x</span>) // (<span class="id">svalP</span> (<span class="id">h</span> <span class="id">x</span>) <span class="id">xA</span>) -<span class="id">M</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">E</span> [<span class="id">w</span>] [ <span class="id">A</span> <span class="id">_</span> <span class="id">wIA</span> <span class="id">wsubE</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">ent_Ip</span> (<span class="id">i</span> : <span class="id">IEnt</span>) : @<span class="id">entourage</span> (<span class="id">TS</span> (<span class="id">projT1</span> <span class="id">i</span>).1) (<span class="id">projT1</span> <span class="id">i</span>).2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">asboolP</span>; <span class="id">exact</span>: (<span class="id">projT2</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="id">pose</span> <span class="id">h</span> (<span class="id"><a href="mathcomp.analysis.topology.html#sup_uniformType">i</a></span> : <span class="id">IEnt</span>) : {<span class="id">x</span> : <span class="id">set</span> (<span class="id">T</span> * <span class="id"><a href="mathcomp.analysis.topology.html#class">T</a></span>) | <span class="id">_</span>} := <span class="id">cid2</span> (<span class="id">and3_rec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">_</span> <span class="id">_</span> <span class="id">P</span> =&gt; <span class="id">P</span>) (<span class="id">projT2</span> (<span class="id">f</span> (<span class="id">projT1</span> <span class="id">i</span>).1)) (<span class="id">projT1</span> <span class="id">i</span>).2 (<span class="id">ent_Ip</span> <span class="id">i</span>)).<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">ehi</span> (<span class="id"><a name="discrete_uniform">i</a></span> : <span class="id">IEnt</span>) : <span class="id">ent_of</span> ((<span class="id">projT1</span> <span class="id"><a name="T:2394">i</a></span>).1, <span class="id">projT1</span> (<span class="id">h</span> <span class="id">i</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span>/<span class="id">asboolP</span> =&gt; /=; <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">h</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">have</a></span> [<span class="id">_</span> + <span class="id">_</span> ? ?] := <span class="id">projT2</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#range">f</a></span> (<span class="id">projT1</span> <span class="id">i</span>).1); <span class="id">exact</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span> <span class="id">AH</span> := [<span class="id">fset</span> <span class="id">projT1</span> (<span class="id">h</span> <span class="id">w</span>) | <span class="id">w</span> <span class="kwd">in</span> <span class="id">A</span>]%<span class="id">fset</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (\<span class="id">bigcap_</span>(<span class="id">i</span> <span class="kwd">in</span> [<span class="id">set</span>` <span class="id">AH</span>]) <span class="id">i</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">AH</span> =&gt; // <span class="id">p</span> /<span class="id">imfsetP</span> [<span class="id">i</span> <span class="id">iA</span> -&gt;]; <span class="id">rewrite</span> <span class="id">inE</span> //.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">projT1</span> <span class="id">i</span>).1 =&gt; //; <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">h</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">subset_trans</span> <span class="id">wsubE</span>; <span class="id">rewrite</span> -<span class="id">wIA</span> =&gt; ? <span class="id">It</span> <span class="id">i</span> ?.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [?] := <span class="id">projT2</span> (<span class="id">h</span> <span class="id">i</span>); <span class="id">apply</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#range">It</a></span>; <span class="id">apply</span>/<span class="id">imfsetP</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">sup_uniform</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">product_uniform</span>.<br/>
<br/>
<span class="kwd">Variable</span> (<span class="id">I</span> : <span class="id">choiceType</span>) (<span class="id">T</span> : <span class="id">I</span> -&gt; <span class="id">uniformType</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">product_uniformType</span> :=<br/>
&nbsp;&nbsp;<span class="id">sup_uniformType</span> (<span class="kwd">fun</span> <span class="id">i</span> =&gt; <span class="id"><a name="x:2399">Uniform.class</a></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">weak_uniformType</span> (<span class="kwd">fun</span> <span class="id">f</span> : <span class="id">dep_arrow_pointedType</span> <span class="id">T</span> =&gt; <span class="id">f</span> <span class="id">i</span>))).<br/>
<br/>
<span class="kwd">End</span> <span class="id">product_uniform</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">discrete_uniform</span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id">topologicalType</span>} {<span class="id">dsc</span>: <span class="id">discrete_space</span> <span class="id"><a href="mathcomp.analysis.topology.html#UniformType">T</a></span>}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">discrete_ent</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>)) :=<br/>
&nbsp;&nbsp;<span class="id">globally</span> (<span class="id">range</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; (<span class="id">x</span>, <span class="id">x</span>))).<br/>
<br/>
<span class="id"><a name="PseudoMetric.mixin_of">Program</a></span> <span class="kwd">Definition</span> <span class="id">discrete_uniform_mixin</span> :=<br/>
&nbsp;&nbsp;@<span class="id">UniformMixin</span> <span class="id">T</span> <span class="id">nbhs</span> <span class="id">discrete_ent</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a name="PseudoMetric.ball">_</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof427')">Next Obligation.</span></div>
<div class="proofscript" id="proof427">
<span class="kwd">by</span> <span class="id">move</span>=&gt; ? + <span class="id">x</span> <span class="id">x12</span>; <span class="id">apply</span>; <span class="kwd">exists</span> <span class="id"><a name="e:2407">x</a></span>.1; <span class="id">rewrite</span> // {2}<span class="id">x12</span> -<span class="id">surjective_pairing</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof428')">Next Obligation.</span></div>
<div class="proofscript" id="proof428">
<span class="kwd">by</span> <span class="id">move</span>=&gt; ? <span class="id">dA</span> <span class="id">x</span> [<span class="id">i</span> <span class="id">_</span> &lt;-]; <span class="id">apply</span>: <span class="id">dA</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof429')">Next Obligation.</span></div>
<div class="proofscript" id="proof429">
<span class="id">move</span>=&gt; ? <span class="id">dA</span>; <span class="kwd">exists</span> (<span class="id">range</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; (<span class="id">x</span>, <span class="id">x</span>))) =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">set_compose_diag</span> =&gt; <span class="id">x</span> [<span class="id">i</span> <span class="id">_</span> &lt;-]; <span class="id">apply</span>: <span class="id">dA</span>; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof430')">Next Obligation.</span></div>
<div class="proofscript" id="proof430">
<span class="id">rewrite</span> <span class="id">dsc</span> <span class="id">predeq2E</span> =&gt; <span class="id">x</span> <span class="id">V</span>; <span class="id">split</span> =&gt; [].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.mixin_of">Px</a></span>; <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Uniform.entourage">range</a></span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; (<span class="id">x</span>, <span class="id">x</span>))) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">z</span> [<span class="id">i</span> <span class="id">_</span>] [+ &lt;-] =&gt; -&gt;; <span class="id">exact</span>/<span class="id">principal_filterP</span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">U</span> <span class="id">dV</span> <span class="id">UV</span>; <span class="id">apply</span>/<span class="id">principal_filterP</span>/<span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.sort">UV</a></span>/<span class="id">dV</span>; <span class="kwd">exists</span> <span class="id">x</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">discrete_uniformType</span> := <span class="id"><a name="PseudoMetric.ClassDef.cT">UniformType</a></span> <span class="id">T</span> <span class="id">discrete_uniform_mixin</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">discrete_uniform</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">PseudoMetric</span>.<br/>
<br/>
<span class="kwd">Record</span> <span class="id"><a name="PseudoMetric.clone">mixin_of</a></span> (<span class="id">R</span> : <span class="id">numDomainType</span>) (<span class="id">M</span> : <span class="kwd">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">entourage</span> : <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.Pack">set</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#T">set</a></span> (<span class="id">M</span> * <span class="id">M</span>))) := <span class="id">Mixin</span> {<br/>
&nbsp;&nbsp;<span class="id">ball</span> : <span class="id">M</span> -&gt; <span class="id">R</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.class_of">M</a></span> -&gt; <span class="kwd">Prop</span> ;<br/>
&nbsp;&nbsp;<span class="id">ball_center</span> : <span class="kwd">forall</span> <span class="id">x</span> (<span class="id">e</span> : <span class="id">R</span>), 0 &lt; <span class="id">e</span> -&gt; <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">x</span> ;<br/>
&nbsp;&nbsp;<span class="id">ball_sym</span> : <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> (<span class="id">e</span> : <span class="id">R</span>), <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span> -&gt; <span class="id">ball</span> <span class="id">y</span> <span class="id">e</span> <span class="id">x</span> ;<br/>
&nbsp;&nbsp;<span class="id">ball_triangle</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">z</span> <span class="id">e1</span> <span class="id">e2</span>, <span class="id">ball</span> <span class="id">x</span> <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.class_of">e1</a></span> <span class="id">y</span> -&gt; <span class="id">ball</span> <span class="id">y</span> <span class="id">e2</span> <span class="id">z</span> -&gt; <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#phant_id">ball</a></span> <span class="id">x</span> (<span class="id">e1</span> + <span class="id">e2</span>) <span class="id">z</span>;<br/>
&nbsp;&nbsp;<span class="id">entourageE</span> : <span class="id">entourage</span> = <span class="id">entourage_</span> <span class="id">ball</span><br/>
}.<br/>
<br/>
<span class="kwd">Record</span> <span class="id">class_of</span> (<span class="id">R</span> : <span class="id">numDomainType</span>) (<span class="id">M</span> : <span class="kwd">Type</span>) := <span class="kwd">Class</span> {<br/>
&nbsp;&nbsp;<span class="id">base</span> : <span class="id">Uniform.class_of</span> <span class="id">M</span>;<br/>
&nbsp;&nbsp;<span class="id">mixin</span> : <span class="id">mixin_of</span> <span class="id">R</span> (<span class="id">Uniform.entourage</span> <span class="id">base</span>)<br/>
}.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">ClassDef</span>.<br/>
<span class="kwd">Variable</span> <span class="id">R</span> : <span class="id">numDomainType</span>.<br/>
<span class="kwd">Structure</span> <span class="id">type</span> := <span class="id">Pack</span> { <span class="id">sort</span>; <span class="id">_</span> : <span class="id">class_of</span> <span class="id">R</span> <span class="id">sort</span> }.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Variables</span> (<span class="id">T</span> : <span class="kwd">Type</span>) (<span class="id">cT</span> : <span class="id">type</span>).<br/>
<span class="kwd">Definition</span> <span class="id">class</span> := <span class="kwd">let</span>: <span class="id">Pack</span> <span class="id">_</span> <span class="id">c</span> := <span class="id">cT</span> <span class="kwd">return</span> <span class="id">class_of</span> <span class="id">R</span> <span class="id">cT</span> <span class="kwd">in</span> <span class="id">c</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">clone</span> <span class="id">c</span> <span class="id">of</span> <span class="id">phant_id</span> <span class="id">class</span> <span class="id">c</span> := @<span class="id">Pack</span> <span class="id">T</span> <span class="id">c</span>.<br/>
<span class="kwd">Let</span> <span class="id">xT</span> := <span class="kwd">let</span>: <span class="id">Pack</span> <span class="id">T</span> <span class="id">_</span> := <span class="id">cT</span> <span class="kwd">in</span> <span class="id">T</span>.<br/>
<span class="kwd">Notation</span> <span class="id">xclass</span> := (<span class="id">class</span> : <span class="id">class_of</span> <span class="id">R</span> <span class="id">xT</span>).<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Uniform.class_of</span>.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">mixin</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">mixin_of</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">pack</span> <span class="id">ent</span> (<span class="id">m</span> : @<span class="id">mixin_of</span> <span class="id">R</span> <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.choiceType">T</a></span> <span class="id">ent</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">bT</span> (<span class="id">b</span> : <span class="id">Uniform.class_of</span> <span class="id">T</span>) <span class="id">of</span> <span class="id">phant_id</span> (@<span class="id">Uniform.class</span> <span class="id">bT</span>) <span class="id">b</span> =&gt;<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">m</span>'   <span class="id">of</span> <span class="id">phant_id</span> <span class="id">m</span> (<span class="id">m</span>' : @<span class="id">mixin_of</span> <span class="id">R</span> <span class="id">T</span> (<span class="id">Uniform.entourage</span> <span class="id">b</span>)) =&gt;<br/>
&nbsp;&nbsp;@<span class="id">Pack</span> <span class="id">T</span> (@<span class="kwd">Class</span> <span class="id">R</span> <span class="id">_</span> <span class="id">b</span> <span class="id">m</span>').<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">eqType</span> := @<span class="id">Equality.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">choiceType</span> := @<span class="id">Choice.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">pointedType</span> := @<span class="id">Pointed.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">filteredType</span> := @<span class="id">Filtered.Pack</span> <span class="id">cT</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">topologicalType</span> := @<span class="id">Topological.Pack</span> <span class="id">cT</span> <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.Mixin">xclass</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id">uniformType</span> := @<span class="id">Uniform.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.clone">ClassDef</a></span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">Exports</span>.<br/>
<br/>
<span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Uniform.class_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">mixin</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">mixin_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">eqType</span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">type</a></span> &gt;-&gt; <span class="id">Equality.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">eqType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">choiceType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Choice.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">choiceType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">pointedType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Pointed.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">filteredType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Filtered.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filteredType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">topologicalType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Topological.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topologicalType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">uniformType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Uniform.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniformType</span>.<br/>
<span class="kwd">Notation</span> <span class="id">pseudoMetricType</span> := <span class="id">type</span>.<br/>
<span class="kwd">Notation</span> <span class="id">PseudoMetricType</span> <span class="id">T</span> <span class="id">m</span> := (@<span class="id">pack</span> <span class="id">_</span> <span class="id">T</span> <span class="id">_</span> <span class="id">m</span> <span class="id">_</span> <span class="id">_</span> <span class="id">idfun</span> <span class="id">_</span> <span class="id">idfun</span>).<br/>
<span class="kwd">Notation</span> <span class="id">PseudoMetricMixin</span> := <span class="id">Mixin</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">pseudoMetricType</span>' <span class="id">R</span> '<span class="id">of</span>' <span class="id">T</span> '<span class="kwd">for</span>' <span class="id">cT</span> ]" := (@<span class="id">clone</span> <span class="id">R</span> <span class="id">T</span> <span class="id">cT</span> <span class="id">_</span> <span class="id">idfun</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">pseudoMetricType</span>'  <span class="id">R</span>  '<span class="id">of</span>'  <span class="id">T</span>  '<span class="kwd">for</span>'  <span class="id">cT</span> ]") : <span class="id">form_scope</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">pseudoMetricType</span>' <span class="id">R</span> '<span class="id">of</span>' <span class="id">T</span> ]" := (@<span class="id">clone</span> <span class="id">R</span> <span class="id">T</span> <span class="id">_</span> <span class="id">_</span> <span class="id">id</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">pseudoMetricType</span>'  <span class="id">R</span>  '<span class="id">of</span>'  <span class="id">T</span> ]") : <span class="id">form_scope</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">Exports</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">PseudoMetric</span>.<br/>
<br/>
<span class="kwd">Export</span> <span class="id">PseudoMetric.Exports</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">PseudoMetricUniformity</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">ball_le</span> (<span class="id">R</span> : <span class="id">numDomainType</span>) (<span class="id">M</span> : <span class="kwd">Type</span>) (<span class="id">ent</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">M</span> * <span class="id">M</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">m</span> : <span class="id"><a href="mathcomp.analysis.signed.html#posnumP">PseudoMetric.mixin_of</a></span> <span class="id">R</span> <span class="id">ent</span>) :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">x</span> : <span class="id">M</span>), {<span class="id">homo</span> <span class="id">PseudoMetric.ball</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#subsetI">m</a></span> <span class="id">x</span> : <span class="id">e1</span> <span class="id">e2</span> / <span class="id">e1</span> &lt;= <span class="id">e2</span> &gt;-&gt; <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetricUniformity.ball_le">e1</a></span> `&lt;=` <span class="id">e2</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof431')">Proof.</span></div>
<div class="proofscript" id="proof431">
<span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">e1</span> <span class="id">e2</span> + <span class="id">y</span> <span class="id">xe1_y</span>.<br/>
<span class="id">rewrite</span> <span class="id">le_eqVlt</span> =&gt; /<span class="id">predU1P</span>[&lt;- //|]; <span class="id">rewrite</span> -<span class="id">subr_gt0</span> =&gt; <span class="id">lt12</span>.<br/>
<span class="id">rewrite</span> -[<span class="id">e2</span>](<span class="id">subrK</span> <span class="id">e1</span>); <span class="id">apply</span>: <span class="id">PseudoMetric.ball_triangle</span> <span class="id">xe1_y</span>.<br/>
<span class="id">suff</span> : <span class="id">PseudoMetric.ball</span> <span class="id">m</span> <span class="id">x</span> (<span class="id">PosNum</span> <span class="id">lt12</span>)%:<span class="id">num</span> <span class="id">x</span> <span class="kwd">by</span> [].<br/>
<span class="id">exact</span>: <span class="id">PseudoMetric.ball_center</span>.<br/>
Qed.</div>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id">uniformityOfBallMixin</span> (<span class="id">R</span> : <span class="id">numFieldType</span>) (<span class="id">T</span> : <span class="kwd">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id">ent</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>))) (<span class="id">nbhs</span> : <span class="id">T</span> -&gt; <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">nbhsE</span> : <span class="id">nbhs</span> = <span class="id">nbhs_</span> <span class="id">ent</span>)<br/>
&nbsp;&nbsp;(<span class="id">m</span> : <span class="id">PseudoMetric.mixin_of</span> <span class="id">R</span> <span class="id">ent</span>) : <span class="id">Uniform.mixin_of</span> <span class="id">nbhs</span> :=<br/>
&nbsp;&nbsp;<span class="id">UniformMixin</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">nbhsE</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof432')">Next Obligation.</span></div>
<div class="proofscript" id="proof432">
<span class="id">move</span>=&gt; <span class="id"><a name="xy:2453">R</a></span> <span class="id">T</span> <span class="id">ent</span> <span class="id">nbhs</span> <span class="id">nbhsE</span> <span class="id">m</span>; <span class="id">rewrite</span> (<span class="id">PseudoMetric.entourageE</span> <span class="id">m</span>).<br/>
<span class="id">apply</span>: <span class="id">filter_from_filter</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> 1 =&gt; /=.<br/>
<span class="id">move</span>=&gt; <span class="id">_</span> <span class="id">_</span> /<span class="id">posnumP</span>[<span class="id">e1</span>] /<span class="id">posnumP</span>[<span class="id">e2</span>]; <span class="kwd">exists</span> (<span class="id">Num.min</span> <span class="id">e1</span> <span class="id">e2</span>)%:<span class="id">num</span> =&gt; //=.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">subsetI</span>; <span class="id">split</span>=&gt; ?; <span class="id">apply</span>: <span class="id">ball_le</span>;<br/>
&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> -<span class="id">leEsub</span>// <span class="id">le_minl</span> <span class="id">lexx</span> ?<span class="id">orbT</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof433')">Next Obligation.</span></div>
<div class="proofscript" id="proof433">
<span class="id">move</span>=&gt; <span class="id">R</span> <span class="id">T</span> <span class="id">ent</span> <span class="id">nbhs</span> <span class="id">nbhsE</span> <span class="id">m</span> <span class="id">A</span>; <span class="id">rewrite</span> (<span class="id">PseudoMetric.entourageE</span> <span class="id">m</span>).<br/>
<span class="id">move</span>=&gt; [<span class="id">e</span> <span class="id">egt0</span> <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType">sbeA</a></span>] <span class="id">xy</span> <span class="id">xey</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#entourage_">sbeA</a></span>; <span class="id">rewrite</span> /= <span class="id">xey</span>; <span class="id">exact</span>: <span class="id">PseudoMetric.ball_center</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof434')">Next Obligation.</span></div>
<div class="proofscript" id="proof434">
<span class="id">move</span>=&gt; <span class="id">R</span> <span class="id">T</span> <span class="id">ent</span> <span class="id">nbhs</span> <span class="id">nbhsE</span> <span class="id">m</span> <span class="id">A</span>; <span class="id">rewrite</span> (<span class="id">PseudoMetric.entourageE</span> <span class="id">m</span>) =&gt; - [<span class="id">e</span> <span class="id">egt0</span> <span class="id">sbeA</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">e</span> =&gt; // <span class="id">xy</span> <span class="id">xye</span>; <span class="id">apply</span>: <span class="id">sbeA</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#ball">PseudoMetric.ball_sym</a></span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof435')">Next Obligation.</span></div>
<div class="proofscript" id="proof435">
<span class="id">move</span>=&gt; <span class="id">R</span> <span class="id">T</span> <span class="id">ent</span> <span class="id">nbhs</span> <span class="id">nbhsE</span> <span class="id">m</span> <span class="id">A</span>; <span class="id">rewrite</span> (<span class="id">PseudoMetric.entourageE</span> <span class="id">m</span>).<br/>
<span class="id">move</span>=&gt; [<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>] <span class="id">sbeA</span>].<br/>
<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id">PseudoMetric.ball</span> <span class="id">m</span> <span class="id">xy</span>.1 (<span class="id">e</span>%:<span class="id">num</span> / 2) <span class="id">xy</span>.2].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">e</span>%:<span class="id">num</span> / 2) =&gt; /=.<br/>
<span class="id">move</span>=&gt; <span class="id">xy</span> [<span class="id">z</span> <span class="id">xzhe</span> <span class="id">zyhe</span>]; <span class="id">apply</span>: <span class="id">sbeA</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> [<span class="id">e</span>%:<span class="id">num</span>]<span class="id">splitr</span>; <span class="id">apply</span>: <span class="id">PseudoMetric.ball_triangle</span> <span class="id">zyhe</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">PseudoMetricUniformity</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">ball</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">M</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetric.ball</span> (<span class="id">PseudoMetric.class</span> <span class="id">M</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_ballE</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">M</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>}<br/>
&nbsp;&nbsp;: <span class="id">entourage_</span> (@<span class="id">ball</span> <span class="id">R</span> <span class="id">M</span>) = <span class="id">entourage</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof436')">Proof.</span></div>
<div class="proofscript" id="proof436">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id">M</span>=&gt; [?[?[]]]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_from_ballE</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">M</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} :<br/>
&nbsp;&nbsp;@<span class="id">filter_from</span> <span class="id">R</span> <span class="id">_</span> [<span class="id">set</span> <span class="id">x</span> : <span class="id">R</span> | 0 &lt; <span class="id">x</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">e</span> =&gt; [<span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#ball">xy</a></span> | @<span class="id">ball</span> <span class="id">R</span> <span class="id">M</span> <span class="id">xy</span>.1 <span class="id">e</span> <span class="id">xy</span>.2]) = <span class="id">entourage</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof437')">Proof.</span></div>
<div class="proofscript" id="proof437">
 <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">entourage_ballE</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">entourage_ball</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} (<span class="id">M</span> : <span class="id"><a name="filter_from_ballE">pseudoMetricType</a></span> <span class="id">R</span>)<br/>
&nbsp;&nbsp;(<span class="id">e</span> : {<span class="id">posnum</span> <span class="id">R</span>}) : <span class="id">entourage</span> [<span class="id">set</span> <span class="id">xy</span> : <span class="id">M</span> * <span class="id">M</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span>%:<span class="id">num</span> <span class="id">xy</span>.2].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof438')">Proof.</span></div>
<div class="proofscript" id="proof438">
 <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">entourage_ballE</span>; <span class="kwd">exists</span> <span class="id">e</span>%:<span class="id">num</span> =&gt; /=. Qed.</div>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">entourage_ball</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">nbhs_ball_</span> {<span class="id">R</span> : <span class="id"><a href="mathcomp.analysis.topology.html#filter_from_ballE">numDomainType</a></span>} {<span class="id">T</span> <span class="id">T</span>'} (<span class="id">ball</span> : <span class="id">T</span> -&gt; <span class="id">R</span> -&gt; <span class="id">set</span> <span class="id">T</span>')<br/>
&nbsp;&nbsp;(<span class="id">x</span> : <span class="id">T</span>) := @<span class="id">filter_from</span> <span class="id">R</span> <span class="id">_</span> [<span class="id">set</span> <span class="id">e</span> | <span class="id">e</span> &gt; 0] (<span class="id">ball</span> <span class="id">x</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">nbhs_ball</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">M</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} :=<br/>
&nbsp;&nbsp;<span class="id">nbhs_ball_</span> (@<span class="id">ball</span> <span class="id">R</span> <span class="id">M</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_ballE</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">M</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} : (@<span class="id">nbhs_ball</span> <span class="id">R</span> <span class="id"><a href="mathcomp.analysis.topology.html#ball">M</a></span>) = <span class="id">nbhs</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof439')">Proof.</span></div>
<div class="proofscript" id="proof439">
<span class="id">rewrite</span> <span class="id">predeq2E</span> =&gt; <span class="id">x</span> <span class="id">P</span>; <span class="id">rewrite</span> -<span class="id">nbhs_entourageE</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>] <span class="id">sbxeP</span>]; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span>%:<span class="id">num</span> <span class="id">xy</span>.2].<br/>
<span class="id">rewrite</span> -<span class="id">entourage_ballE</span>; <span class="id">move</span>=&gt; [<span class="id">A</span> [<span class="id">e</span> <span class="id">egt0</span> <span class="id">sbeA</span>] <span class="id">sAP</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">e</span> =&gt; // ??; <span class="id">apply</span>/<span class="id">sAP</span>/<span class="id">sbeA</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">filter_from_ballE</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">M</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} <span class="id">x</span> :<br/>
&nbsp;&nbsp;@<span class="id">filter_from</span> <span class="id">R</span> <span class="id">_</span> [<span class="id"><a name="e:2498">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType_numDomainType.R">x</a></span> : <span class="id">R</span> | 0 &lt; <span class="id">x</span>] (@<span class="id">ball</span> <span class="id">R</span> <span class="id">M</span> <span class="id">x</span>) = <span class="id">nbhs</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof440')">Proof.</span></div>
<div class="proofscript" id="proof440">
 <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">nbhs_ballE</span>. Qed.</div>
<br/>
<span class="kwd">Module</span> <span class="kwd">Export</span> <span class="id">NbhsBall</span>.<br/>
<span class="kwd">Definition</span> <span class="id">nbhs_simpl</span> := (<span class="id">nbhs_simpl</span>,@<span class="id">filter_from_ballE</span>,@<span class="id">nbhs_ballE</span>).<br/>
<span class="kwd">End</span> <span class="id">NbhsBall</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_ballP</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">M</span> : <span class="id"><a name="e2:2506">pseudoMetricType</a></span> <span class="id">R</span>} (<span class="id">x</span> : <span class="id">M</span>) <span class="id">P</span> :<br/>
&nbsp;&nbsp;<span class="id">nbhs</span> <span class="id">x</span> <span class="id">P</span> &lt;-&gt; <span class="id">nbhs_ball</span> <span class="id">x</span> <span class="id">P</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof441')">Proof.</span></div>
<div class="proofscript" id="proof441">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">nbhs_simpl</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">ball_center</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} (<span class="id"><a name="eps:2508">M</a></span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>) (<span class="id">x</span> : <span class="id">M</span>)<br/>
&nbsp;&nbsp;(<span class="id">e</span> : {<span class="id">posnum</span> <span class="id">R</span>}) : <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span>%:<span class="id">num</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof442')">Proof.</span></div>
<div class="proofscript" id="proof442">
 <span class="id">exact</span>: <span class="id">PseudoMetric.ball_center</span>. Qed.</div>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">ball_center</span> : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a href="mathcomp.analysis.topology.html#ball">pseudoMetricType_numDomainType</a></span>.<br/>
<span class="kwd">Context</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">M</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">ballxx</span> (<span class="id">x</span> : <span class="id">M</span>) (<span class="id">e</span> : <span class="id">R</span>) : 0 &lt; <span class="id">e</span> -&gt; <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof443')">Proof.</span></div>
<div class="proofscript" id="proof443">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType_numDomainType.M">e_gt0</a></span>; <span class="id"><a name="e2:2513">apply</a></span>: <span class="id">ball_center</span> (<span class="id">PosNum</span> <span class="id">e_gt0</span>). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">ball_sym</span> (<span class="id">x</span> <span class="id">y</span> : <span class="id">M</span>) (<span class="id">e</span> : <span class="id">R</span>) : <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span> -&gt; <span class="id">ball</span> <span class="id">y</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof444')">Proof.</span></div>
<div class="proofscript" id="proof444">
 <span class="id">exact</span>: <span class="id">PseudoMetric.ball_sym</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">ball_symE</span> (<span class="id">x</span> <span class="id">y</span> : <span class="id">M</span>) (<span class="id">e</span> : <span class="id">R</span>) : <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span> = <span class="id">ball</span> <span class="id">y</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof445')">Proof.</span></div>
<div class="proofscript" id="proof445">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span>; <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">exact</a></span>/<span class="id">ball_sym</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">ball_triangle</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Build_ProperFilter">y</a></span> <span class="id">x</span> <span class="id">z</span> : <span class="id">M</span>) (<span class="id">e1</span> <span class="id">e2</span> : <span class="id">R</span>) :<br/>
&nbsp;&nbsp;<span class="id">ball</span> <span class="id">x</span> <span class="id">e1</span> <span class="id">y</span> -&gt; <span class="id">ball</span> <span class="id">y</span> <span class="id">e2</span> <span class="id">z</span> -&gt; <span class="id">ball</span> <span class="id">x</span> (<span class="id">e1</span> + <span class="id">e2</span>) <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof446')">Proof.</span></div>
<div class="proofscript" id="proof446">
 <span class="id">exact</span>: <span class="id">PseudoMetric.ball_triangle</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhsx_ballx</span> (<span class="id">x</span> : <span class="id"><a name="y:2514">M</a></span>) (<span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType_numDomainType.M">eps</a></span> : {<span class="id">posnum</span> <span class="id">R</span>}) : <span class="id">nbhs</span> <span class="id">x</span> (<span class="id">ball</span> <span class="id">x</span> <span class="id"><a name="y':2516">eps</a></span>%:<span class="id">num</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof447')">Proof.</span></div>
<div class="proofscript" id="proof447">
 <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">nbhs_ballP</span>; <span class="kwd">exists</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsx_ballx">eps</a></span>%:<span class="id">num</span> =&gt; /=. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_nbhs_ball</span> (<span class="id">x</span> : <span class="id">M</span>) (<span class="id">eps</span> : {<span class="id">posnum</span> <span class="id">R</span>}) : <span class="id">open_nbhs</span> <span class="id">x</span> ((<span class="id">ball</span> <span class="id">x</span> <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType_numDomainType.R">eps</a></span>%:<span class="id">num</span>)^°).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof448')">Proof.</span></div>
<div class="proofscript" id="proof448">
<span class="id"><a name="y':2521">split</a></span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">open_interior</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">nbhs_singleton</span>; <span class="id">apply</span>: <span class="id">nbhs_interior</span>; <span class="id">apply</span>:<span class="id">nbhsx_ballx</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">le_ball</span> (<span class="id">x</span> : <span class="id">M</span>) (<span class="id">e1</span> <span class="id">e2</span> : <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType_numDomainType.M">R</a></span>) : <span class="id">e1</span> &lt;= <span class="id">e2</span> -&gt; <span class="id">ball</span> <span class="id">x</span> <span class="id">e1</span> `&lt;=` <span class="id">ball</span> <span class="id">x</span> <span class="id">e2</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof449')">Proof.</span></div>
<div class="proofscript" id="proof449">
<span class="id">move</span>=&gt; <span class="id">le12</span> <span class="id">y</span>. <span class="id">case</span>: <span class="id">comparableP</span> <span class="id">le12</span> =&gt; [<span class="id">lte12</span> <span class="id">_</span>|//|//|-&gt;//].<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -[<span class="id">e2</span>](<span class="id">subrK</span> <span class="id">e1</span>); <span class="id">apply</span>/<span class="id"><a href="mathcomp.analysis.topology.html#fcvg_ballP">ball_triangle</a></span>/<span class="id">ballxx</span>; <span class="id">rewrite</span> <span class="id">subr_gt0</span>.<br/>
Qed.</div>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id">entourage_proper_filter</span> : <span class="id">ProperFilter</span> (@<span class="id">entourage</span> <span class="id">M</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof450')">Proof.</span></div>
<div class="proofscript" id="proof450">
<span class="id">apply</span>: <span class="id">Build_ProperFilter</span>; <span class="id">rewrite</span> -<span class="id">entourage_ballE</span> =&gt; <span class="id">A</span> [<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>] <span class="id">sbeA</span>].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">point</span>, <span class="id">point</span>); <span class="id">apply</span>: <span class="id">sbeA</span>; <span class="id">apply</span>: <span class="id">ballxx</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">near_ball</span> (<span class="id">y</span> : <span class="id">M</span>) (<span class="id">eps</span> : {<span class="id">posnum</span> <span class="id"><a href="mathcomp.analysis.topology.html#ball">R</a></span>}) :<br/>
&nbsp;&nbsp;&nbsp;\<span class="kwd">forall</span> <span class="id">y</span>' \<span class="id">near</span> <span class="id">y</span>, <span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span>%:<span class="id">num</span> <span class="id">y</span>'.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof451')">Proof.</span></div>
<div class="proofscript" id="proof451">
 <span class="id">exact</span>: <span class="id">nbhsx_ballx</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">fcvg_ballP</span> {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>} (<span class="id">y</span> : <span class="id">M</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">y</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id">eps</span> : <span class="id">R</span>, 0 &lt; <span class="id">eps</span> -&gt; \<span class="kwd">forall</span> <span class="id">y</span>' \<span class="id">near</span> <span class="id">F</span>, <span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span> <span class="id"><a href="mathcomp.analysis.topology.html#fcvg_ballP">y</a></span>'.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof452')">Proof.</span></div>
<div class="proofscript" id="proof452">
 <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">filter_fromP</span> !<span class="id">nbhs_simpl</span> /=. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">__deprecated__cvg_ballPpos</span> {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>} (<span class="id">y</span> : <span class="id">M</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">y</span> &lt;-&gt; <span class="kwd">forall</span> <span class="id">eps</span> : {<span class="id">posnum</span> <span class="id">R</span>}, \<span class="kwd">forall</span> <span class="id">y</span>' \<span class="id">near</span> <span class="id">F</span>, <span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span>%:<span class="id"><a name="cvgi_ballP">num</a></span> <span class="id">y</span>'.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof453')">Proof.</span></div>
<div class="proofscript" id="proof453">
<span class="id">split</span> =&gt; [/<span class="id">fcvg_ballP</span> + <span class="id">eps</span>|<span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType_numDomainType.M">pos</a></span>]; <span class="id">first</span> <span class="id">exact</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">fcvg_ballP</span>=&gt; <span class="id">_</span>/<span class="id"><a name="eps:2551">posnumP</a></span>[<span class="id">eps</span>] //.<br/>
Qed.</div>
#[<span class="id">deprecated</span>(<span class="id">since</span>="<span class="id">mathcomp</span>-<span class="id">analysis</span> 0.6.0",<br/>
&nbsp;&nbsp;<span class="id">note</span>="<span class="id">use</span> <span class="id">a</span> <span class="id">combination</span> <span class="id">of</span> `<span class="id">cvg_ballP</span>` <span class="id">and</span> `<span class="id">posnumP</span>`")]<br/>
<span class="kwd">Notation</span> <span class="id">cvg_ballPpos</span> := <span class="id">__deprecated__cvg_ballPpos</span> (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">fcvg_ball</span> {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>} (<span class="id">y</span> : <span class="id">M</span>) :<br/>
&nbsp;&nbsp;<span class="id">F</span> --&gt; <span class="id">y</span> -&gt; <span class="kwd">forall</span> <span class="id">eps</span> : <span class="id">R</span>, 0 &lt; <span class="id">eps</span> -&gt; \<span class="kwd">forall</span> <span class="id">y</span>' \<span class="id">near</span> <span class="id">F</span>, <span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span> <span class="id">y</span>'.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof454')">Proof.</span></div>
<div class="proofscript" id="proof454">
 <span class="kwd">by</span> <span class="id">move</span>/<span class="id">fcvg_ballP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_ballP</span> {<span class="id">T</span>} {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">M</span>) <span class="id">y</span> :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id"><a name="FF:2556">y</a></span> &lt;-&gt; <span class="kwd">forall</span> <span class="id">eps</span> : <span class="id">R</span>, 0 &lt; <span class="id">eps</span> -&gt; \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span> (<span class="id">f</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof455')">Proof.</span></div>
<div class="proofscript" id="proof455">
 <span class="id">exact</span>: <span class="id">fcvg_ballP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_ball</span> {<span class="id">T</span>} {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">M</span>) <span class="id">y</span> :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F</span> --&gt; <span class="id">y</span> -&gt; <span class="kwd">forall</span> <span class="id">eps</span> : <span class="id">R</span>, 0 &lt; <span class="id">eps</span> -&gt; \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span> (<span class="id">f</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof456')">Proof.</span></div>
<div class="proofscript" id="proof456">
 <span class="id">exact</span>: <span class="id">fcvg_ball</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvgi_ballP</span> <span class="id">T</span> {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">M</span> -&gt; <span class="kwd">Prop</span>) <span class="id">y</span> :<br/>
&nbsp;&nbsp;<span class="id">f</span> `@ <span class="id">F</span> --&gt; <span class="id">y</span> &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">eps</span> : <span class="id">R</span>, 0 &lt; <span class="id">eps</span> -&gt; \<span class="kwd">forall</span> <span class="id">x</span> \<span class="id">near</span> <span class="id">F</span>, <span class="kwd">exists</span> <span class="id">z</span>, <span class="id">f</span> <span class="id">x</span> <span class="id">z</span> /\ <span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span> <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof457')">Proof.</span></div>
<div class="proofscript" id="proof457">
<span class="id">split</span>=&gt; [<span class="id">Fy</span> <span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">eps</span>] |<span class="id">Fy</span> <span class="id">P</span>] /=; <span class="id">first</span> <span class="id">exact</span>/<span class="id">Fy</span>/<span class="id">nbhsx_ballx</span>.<br/>
<span class="id">move</span>=&gt; /<span class="id">nbhs_ballP</span>[<span class="id">_</span> /<span class="id">posnumP</span>[<span class="id">eps</span>] <span class="id">subP</span>].<br/>
<span class="id">rewrite</span> <span class="id">near_simpl</span> <span class="id">near_mapi</span>; <span class="id">near</span>=&gt; <span class="id">x</span>.<br/>
<span class="id">have</span> [//|<span class="id">z</span> [<span class="id">fxz</span> <span class="id">yz</span>]] := <span class="id"><a href="mathcomp.analysis.topology.html#ball">near</a></span> (<span class="id">Fy</span> <span class="id">_</span> (<span class="id">gt0</span> <span class="id">eps</span>)) <span class="id">x</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">z</span> =&gt; //; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: <span class="id">subP</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="id">end_near</span>. Qed.</div>
<span class="kwd">Definition</span> <span class="id">cvg_toi_locally</span> := @<span class="id">cvgi_ballP</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvgi_ball</span> <span class="id">T</span> {<span class="id">F</span>} {<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">M</span> -&gt; <span class="kwd">Prop</span>) <span class="id">y</span> :<br/>
&nbsp;&nbsp;<span class="id">f</span> `@ <span class="id">F</span> --&gt; <span class="id">y</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">eps</span> : <span class="id">R</span>, 0 &lt; <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType_numFieldType.M">eps</a></span> -&gt; <span class="id">F</span> [<span class="id">set</span> <span class="id">x</span> | <span class="kwd">exists</span> <span class="id">z</span>, <span class="id">f</span> <span class="id">x</span> <span class="id">z</span> /\ <span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span> <span class="id">z</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof458')">Proof.</span></div>
<div class="proofscript" id="proof458">
 <span class="kwd">by</span> <span class="id">move</span>/<span class="id">cvgi_ballP</span>. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.topology.html#ball_sym">pseudoMetricType_numDomainType</a></span>.<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">nbhsx_ballx</span> : <span class="id">core</span>.<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType_numFieldType.R">close_refl</a></span> : <span class="id">core</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">close_cvg</span> {<span class="id">T</span>} <span class="id">F1</span> <span class="id">F2</span> {<span class="id">FF2</span>} <span class="id">_</span>.<br/>
<br/>
#[<span class="id">deprecated</span>(<span class="id">since</span>="<span class="id">mathcomp</span>-<span class="id">analysis</span> 0.6.0", <span class="id">note</span>="<span class="id">renamed</span> `<span class="id">cvg_ball</span>`")]<br/>
<span class="kwd">Notation</span> <span class="id">app_cvg_locally</span> := <span class="id"><a href="mathcomp.analysis.topology.html#meets_globallyr">cvg_ball</a></span> (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<br/>
<span class="kwd">Section</span> <span class="id">pseudoMetricType_numFieldType</span>.<br/>
<span class="kwd">Context</span> {<span class="id">R</span> : <span class="id">numFieldType</span>} {<span class="id">M</span> : <span class="id"><a href="mathcomp.analysis.topology.html#ball_splitl">pseudoMetricType</a></span> <span class="id">R</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">ball_split</span> (<span class="id">z</span> <span class="id">x</span> <span class="id">y</span> : <span class="id"><a href="mathcomp.analysis.topology.html#closeEnbhs">M</a></span>) (<span class="id">e</span> : <span class="id">R</span>) :<br/>
&nbsp;&nbsp;<span class="id">ball</span> <span class="id">x</span> (<span class="id">e</span> / 2) <span class="id">z</span> -&gt; <span class="id">ball</span> <span class="id">z</span> (<span class="id">e</span> / 2) <span class="id">y</span> -&gt; <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof459')">Proof.</span></div>
<div class="proofscript" id="proof459">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">ball_triangle</span> <span class="id">h</span> /<span class="id">h</span>; <span class="id">rewrite</span> -<span class="id">splitr</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">ball_splitr</span> (<span class="id">z</span> <span class="id">x</span> <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType_numFieldType">y</a></span> : <span class="id">M</span>) (<span class="id">e</span> : <span class="id">R</span>) :<br/>
&nbsp;&nbsp;<span class="id">ball</span> <span class="id">z</span> (<span class="id">e</span> / 2) <span class="id">x</span> -&gt; <span class="id">ball</span> <span class="id">z</span> (<span class="id">e</span> / 2) <span class="id">y</span> -&gt; <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof460')">Proof.</span></div>
<div class="proofscript" id="proof460">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">ball_sym</span> /<span class="id">ball_split</span>; <span class="id">apply</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">ball_splitl</span> (<span class="id">z</span> <span class="id">x</span> <span class="id">y</span> : <span class="id">M</span>) (<span class="id">e</span> : <span class="id">R</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a name="a:2581">ball</a></span> <span class="id">x</span> (<span class="id">e</span> / 2) <span class="id">z</span> -&gt; <span class="id">ball</span> <span class="id">y</span> (<span class="id">e</span> / 2) <span class="id">z</span> -&gt; <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof461')">Proof.</span></div>
<div class="proofscript" id="proof461">
 <span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#ball">move</a></span>=&gt; <span class="id">bxz</span> /<span class="id">ball_sym</span> /(<span class="id">ball_split</span> <span class="id">bxz</span>). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">ball_close</span> (<span class="id">x</span> <span class="id">y</span> : <span class="id">M</span>) :<br/>
&nbsp;&nbsp;<span class="id">close</span> <span class="id">x</span> <span class="id">y</span> = <span class="kwd">forall</span> <span class="id">eps</span> : {<span class="id">posnum</span> <span class="id">R</span>}, <span class="id">ball</span> <span class="id">x</span> <span class="id">eps</span>%:<span class="id">num</span> <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof462')">Proof.</span></div>
<div class="proofscript" id="proof462">
<span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span> =&gt; [<span class="id">cxy</span> <span class="id">eps</span>|<span class="id">cxy</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> := !! <span class="id">cxy</span> <span class="id">_</span> (<span class="id">open_nbhs_ball</span> <span class="id">_</span> (<span class="id">eps</span>%:<span class="id">num</span>/2)%:<span class="id">pos</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">closureEonbhs</span>/= <span class="id">meetsC</span> <span class="id">meets_globallyr</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>/(<span class="id">_</span> <span class="id">_</span> (<span class="id">open_nbhs_ball</span> <span class="id">_</span> (<span class="id">eps</span>%:<span class="id">num</span>/2)%:<span class="id">pos</span>)) =&gt; [<span class="id">z</span> [<span class="id">zx</span> <span class="id">zy</span>]].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (@<span class="id">ball_splitl</span> <span class="id">z</span>); <span class="id">apply</span>: <span class="id">interior_subset</span>.<br/>
<span class="id">rewrite</span> <span class="id">closeEnbhs</span> =&gt; <span class="id">B</span> <span class="id">A</span> /<span class="id">nbhs_ballP</span>[<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e2</span> <span class="id">e2B</span>]]<br/>
&nbsp;&nbsp;/<span class="id">nbhs_ballP</span>[<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_singleton">e1</a></span> <span class="id">e1A</span>]].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">y</span>; <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_interior">split</a></span>; [<span class="id">apply</span>/<span class="id">e2B</span>|<span class="id">apply</span>/<span class="id">e1A</span>; <span class="id">exact</span>: <span class="id">ballxx</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">pseudoMetricType_numFieldType</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a href="mathcomp.analysis.topology.html#open_interior">ball_hausdorff</a></span>.<br/>
<span class="kwd">Variables</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#subsetI_eq0">R</a></span> : <span class="id">numDomainType</span>) (<span class="id">T</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">ball_hausdorff</span> : <span class="id">hausdorff_space</span> <span class="id">T</span> =<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">a</span> <span class="id">b</span> : <span class="id">T</span>), <span class="id">a</span> != <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">r</span> : {<span class="id">posnum</span> <span class="id">R</span>} * {<span class="id">posnum</span> <span class="id">R</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ball</span> <span class="id">a</span> <span class="id">r</span>.1%:<span class="id"><a href="mathcomp.analysis.topology.html#entourages.R">num</a></span> `&amp;` <span class="id">ball</span> <span class="id">b</span> <span class="id">r</span>.2%:<span class="id"><a href="mathcomp.analysis.topology.html#unif_continuous">num</a></span> == <span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof463')">Proof.</span></div>
<div class="proofscript" id="proof463">
<span class="id">rewrite</span> <span class="id">propeqE</span> <span class="id">open_hausdorff</span>; <span class="id">split</span> =&gt; <span class="id">T2T</span> <span class="id">a</span> <span class="id">b</span> /<span class="id">T2T</span>[[/=]].<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">B</span>; <span class="id">rewrite</span> 2!<span class="id">inE</span> =&gt; [[<span class="id">aA</span> <span class="id">bB</span>] [<span class="id">oA</span> <span class="id">oB</span> /<span class="id">eqP</span> <span class="id">ABeq0</span>]].<br/>
&nbsp;&nbsp;<span class="id">have</span> /<span class="id">nbhs_ballP</span>[<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">r</span>] <span class="id">rA</span>]: <span class="id">nbhs</span> <span class="id">a</span> <span class="id">A</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">open_nbhs_nbhs</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> /<span class="id">nbhs_ballP</span>[<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">s</span>] <span class="id">rB</span>]: <span class="id">nbhs</span> <span class="id">b</span> <span class="id">B</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">open_nbhs_nbhs</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">r</span>, <span class="id">s</span>) =&gt; /=; <span class="id">rewrite</span> (<span class="id">subsetI_eq0</span> <span class="id"><a name="countable_uniformity_metric">_</a></span> <span class="id">_</span> <span class="id">ABeq0</span>).<br/>
<span class="id">move</span>=&gt; <span class="id">r</span> <span class="id">s</span> /<span class="id">eqP</span> <span class="id">brs_eq0</span>; <span class="kwd">exists</span> ((<span class="id">ball</span> <span class="id">a</span> <span class="id">r</span>%:<span class="id">num</span>)^°, (<span class="id">ball</span> <span class="id">b</span> <span class="id">s</span>%:<span class="id">num</span>)^°) =&gt; /=.<br/>
&nbsp;&nbsp;<span class="id">split</span>; <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">inE</span>; <span class="id">apply</span>: <span class="id">nbhs_singleton</span>; <span class="id">apply</span>: <span class="id">nbhs_interior</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span>/<span class="id">nbhs_ballP</span>; <span class="id">apply</span>: <span class="id">in_filter_from</span> =&gt; /=.<br/>
<span class="id">split</span>; <span class="id">do</span> ?<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">open_interior</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">subsetI_eq0</span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#entourage_ballE">brs_eq0</a></span>)//; <span class="id">apply</span>: <span class="id">interior_subset</span>.<br/>
Qed.</div>
<span class="kwd">End</span> <span class="id">ball_hausdorff</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">entourages</span>.<br/>
<span class="kwd">Variable</span> <span class="id">R</span> : <span class="id">numDomainType</span>.<br/>
<span class="kwd">Lemma</span> <span class="id">unif_continuousP</span> (<span class="id">U</span> <span class="id">V</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id">unif_continuous</span> <span class="id">f</span> &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span>, <span class="id">e</span> &gt; 0 -&gt; <span class="kwd">exists2</span> <span class="id"><a href="mathcomp.analysis.reals.html#lt_succ_floor">d</a></span>, <span class="id">d</span> &gt; 0 &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">ball</span> <span class="id">x</span>.1 <span class="id">d</span> <span class="id">x</span>.2 -&gt; <span class="id">ball</span> (<span class="id">f</span> <span class="id">x</span>.1) <span class="id">e</span> (<span class="id">f</span> <span class="id">x</span>.2).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof464')">Proof.</span></div>
<div class="proofscript" id="proof464">
<span class="id">have</span> <span class="id">fappF</span> : <span class="id">Filter</span> ((<span class="kwd">fun</span> <span class="id">xy</span> =&gt; (<span class="id">f</span> <span class="id">xy</span>.1, <span class="id">f</span> <span class="id"><a name="matrix_PseudoMetric.m">xy</a></span>.2)) @ <span class="id">entourage_</span> <span class="id">ball</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a name="matrix_PseudoMetric.T">rewrite</a></span> <span class="id">entourage_ballE</span>; <span class="id">apply</span>: <span class="id">fmap_filter</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">unif_continuous</span> -!<span class="id">entourage_ballE</span> <span class="id">filter_fromP</span>.<br/>
Qed.</div>
<span class="kwd">End</span> <span class="id">entourages</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">countable_uniformity_metric</span> {<span class="id">R</span> : <span class="id">realType</span>} {<span class="id">T</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} :<br/>
&nbsp;&nbsp;<span class="id">countable_uniformity</span> <span class="id">T</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof465')">Proof.</span></div>
<div class="proofscript" id="proof465">
<span class="id">apply</span>/<span class="id">countable_uniformityP</span>.<br/>
<span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">n</span> =&gt; [<span class="id">set</span> <span class="id">xy</span> : <span class="id">T</span> * <span class="id">T</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">n</span>.+1%:<span class="id">R</span>^-1 <span class="id">xy</span>.2]); <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">n</span>; <span class="id">exact</span>: (<span class="id">entourage_ball</span> <span class="id">_</span> <span class="id">n</span>.+1%:<span class="id">R</span>^-1%:<span class="id">pos</span>).<br/>
<span class="id">move</span>=&gt; <span class="id">E</span>; <span class="id">rewrite</span> -<span class="id">entourage_ballE</span> =&gt; -[<span class="id">e</span> <span class="id">e0</span> <span class="id">subE</span>].<br/>
<span class="kwd">exists</span> `|<span class="id">floor</span> <span class="id">e</span>^-1|%<span class="id">N</span>; <span class="id">apply</span>: <span class="id">subset_trans</span> <span class="id">subE</span> =&gt; <span class="id">xy</span>; <span class="id">apply</span>: <span class="id">le_ball</span>.<br/>
<span class="id">rewrite</span> /= -[<span class="id">leRHS</span>]<span class="id">invrK</span> <span class="id">lef_pinv</span> ?<span class="id">posrE</span> ?<span class="id">invr_gt0</span>// -<span class="id">natr1</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">natr_absz</span> <span class="id">ger0_norm</span> ?<span class="id">floor_ge0</span> ?<span class="id">invr_ge0</span>// 1?<span class="id">ltW</span>// <span class="id">lt_succ_floor</span>.<br/>
Qed.</div>
<br/>
<h2> Specific pseudoMetric spaces </h2>
<br/>
<div class="doc">matrices </div>
<span class="kwd">Section</span> <span class="id">matrix_PseudoMetric</span>.<br/>
<span class="kwd">Variables</span> (<span class="id">m</span> <span class="id">n</span> : <span class="id">nat</span>) (<span class="id">R</span> : <span class="id">numDomainType</span>) (<span class="id">T</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>).<br/>
<span class="kwd">Implicit</span> <span class="id"><a href="mathcomp.analysis.topology.html#matrix_PseudoMetric.T">Types</a></span> <span class="id">x</span> <span class="id">y</span> : '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>).<br/>
<span class="kwd">Definition</span> <span class="id">mx_ball</span> <span class="id">x</span> (<span class="id">e</span> : <span class="id">R</span>) <span class="id">y</span> := <span class="kwd">forall</span> <span class="id">i</span> <span class="id">j</span>, <span class="id">ball</span> (<span class="id">x</span> <span class="id"><a name="j:2629">i</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#xget">j</a></span>) <span class="id">e</span> (<span class="id">y</span> <span class="id">i</span> <span class="id">j</span>).<br/>
<span class="kwd">Lemma</span> <span class="id">mx_ball_center</span> <span class="id">x</span> (<span class="id">e</span> : <span class="id">R</span>) : 0 &lt; <span class="id">e</span> -&gt; <span class="id">mx_ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof466')">Proof.</span></div>
<div class="proofscript" id="proof466">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ???; <span class="id">apply</span>: <span class="id">ballxx</span>. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">mx_ball_sym</span> <span class="id">x</span> <span class="id">y</span> (<span class="id">e</span> : <span class="id">R</span>) : <span class="id">mx_ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span> -&gt; <span class="id">mx_ball</span> <span class="id">y</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof467')">Proof.</span></div>
<div class="proofscript" id="proof467">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">xe_y</span> ??; <span class="id">apply</span>/<span class="id">ball_sym</span>/<span class="id">xe_y</span>. Qed.</div>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#le_ball">mx_ball_triangle</a></span> <span class="id">x</span> <span class="id">y</span> <span class="id">z</span> (<span class="id">e1</span> <span class="id">e2</span> : <span class="id">R</span>) :<br/>
&nbsp;&nbsp;<span class="id">mx_ball</span> <span class="id">x</span> <span class="id">e1</span> <span class="id">y</span> -&gt; <span class="id">mx_ball</span> <span class="id">y</span> <span class="id">e2</span> <span class="id">z</span> -&gt; <span class="id">mx_ball</span> <span class="id">x</span> (<span class="id">e1</span> + <span class="id">e2</span>) <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof468')">Proof.</span></div>
<div class="proofscript" id="proof468">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">xe1_y</span> <span class="id">ye2_z</span> ??; <span class="id">apply</span>: <span class="id">ball_triangle</span>; [<span class="id">apply</span>: <span class="id">xe1_y</span>| <span class="id">apply</span>: <span class="id">ye2_z</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">mx_entourage</span> : <span class="id">entourage</span> = <span class="id"><a href="mathcomp.analysis.topology.html#mx_entourage">entourage_</a></span> <span class="id">mx_ball</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof469')">Proof.</span></div>
<div class="proofscript" id="proof469">
<span class="id">rewrite</span> <span class="id">predeqE</span>=&gt; <span class="id">A</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; [<span class="id"><a href="mathcomp.analysis.topology.html#matrix_PseudoMetric.m">_</a></span>/<span class="id">posnumP</span>[<span class="id">e</span>] <span class="id">sbeA</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">_</span> <span class="id">_</span> =&gt; [<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span>%:<span class="id">num</span> <span class="id">xy</span>.2]).<br/>
<span class="id">move</span>=&gt; [<span class="id">P</span>]; <span class="id">rewrite</span> -<span class="id">entourage_ballE</span> =&gt; <span class="id">entP</span> <span class="id">sPA</span>.<br/>
<span class="id">set</span> <span class="id">diag</span> := <span class="kwd">fun</span> (<span class="id">e</span> : {<span class="id">posnum</span> <span class="id">R</span>}) =&gt; [<span class="id">set</span> <span class="id">xy</span> : <span class="id">T</span> * <span class="id">T</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span>%:<span class="id">num</span> <span class="id">xy</span>.2].<br/>
<span class="kwd">exists</span> (\<span class="id">big</span>[<span class="id">Num.min</span>/1%:<span class="id">pos</span>]<span class="id">_i</span> \<span class="id">big</span>[<span class="id">Num.min</span>/1%:<span class="id">pos</span>]<span class="id">_j</span> <span class="id">xget</span> 1%:<span class="id">pos</span><br/>
&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">e</span> : {<span class="id">posnum</span> <span class="id">R</span>} =&gt; <span class="id">diag</span> <span class="id">e</span> `&lt;=` <span class="id">P</span> <span class="id">i</span> <span class="id">j</span>))%:<span class="id">num</span> =&gt; //=.<br/>
<span class="id">move</span>=&gt; <span class="id">MN</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#snd">MN_min</a></span>; <span class="id">apply</span>: <span class="id">sPA</span> =&gt; <span class="id">i</span> <span class="id">j</span>.<br/>
<span class="id">have</span> /(<span class="id">xgetPex</span> 1%:<span class="id">pos</span>): <span class="kwd">exists</span> <span class="id">e</span> : {<span class="id">posnum</span> <span class="id">R</span>}, <span class="id">diag</span> <span class="id">e</span> `&lt;=` <span class="id">P</span> <span class="id">i</span> <span class="id">j</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>]] := <span class="id">entP</span> <span class="id">i</span> <span class="id"><a name="prod_ball_sym">j</a></span>; <span class="kwd">exists</span> <span class="id">e</span>.<br/>
<span class="id">apply</span>; <span class="id">apply</span>: <span class="id">le_ball</span> (<span class="id">MN_min</span> <span class="id">i</span> <span class="id">j</span>).<br/>
<span class="id">apply</span>: <span class="id">le_trans</span> (@<span class="id">bigmin_le</span> <span class="id">_</span> [<span class="id">orderType</span> <span class="id">of</span> {<span class="id">posnum</span> <span class="id">R</span>}] <span class="id">_</span> <span class="id">_</span> <span class="id">i</span> <span class="id">_</span>) <span class="id"><a href="mathcomp.analysis.topology.html#ball_sym">_</a></span>.<br/>
<span class="id">exact</span>: <span class="id">bigmin_le</span>.<br/>
Qed.</div>
<span class="kwd">Definition</span> <span class="id">matrix_pseudoMetricType_mixin</span> :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetric.Mixin</span> <span class="id">mx_ball_center</span> <span class="id">mx_ball_sym</span> <span class="id">mx_ball_triangle</span> <span class="id">mx_entourage</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">matrix_pseudoMetricType</span> :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetricType</span> '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) <span class="id">matrix_pseudoMetricType_mixin</span>.<br/>
<span class="kwd">End</span> <span class="id">matrix_PseudoMetric</span>.<br/>
<br/>
<div class="doc">product of two pseudoMetric spaces </div>
<span class="kwd">Section</span> <span class="id">prod_PseudoMetric</span>.<br/>
<span class="kwd">Context</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">U</span> <span class="id">V</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>}.<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> (<span class="id">x</span> <span class="id">y</span> : <span class="id">U</span> * <span class="id">V</span>).<br/>
<span class="kwd">Definition</span> <span class="id">prod_point</span> : <span class="id">U</span> * <span class="id">V</span> := (<span class="id">point</span>, <span class="id">point</span>).<br/>
<span class="kwd">Definition</span> <span class="id">prod_ball</span> <span class="id">x</span> (<span class="id">eps</span> : <span class="id">R</span>) <span class="id">y</span> :=<br/>
&nbsp;&nbsp;<span class="id">ball</span> (<span class="id">fst</span> <span class="id">x</span>) <span class="id">eps</span> (<span class="id">fst</span> <span class="id">y</span>) /\ <span class="id">ball</span> (<span class="id">snd</span> <span class="id">x</span>) <span class="id">eps</span> (<span class="id">snd</span> <span class="id">y</span>).<br/>
<span class="kwd">Lemma</span> <span class="id">prod_ball_center</span> <span class="id">x</span> (<span class="id">eps</span> : <span class="id">R</span>) : 0 &lt; <span class="id">eps</span> -&gt; <span class="id">prod_ball</span> <span class="id">x</span> <span class="id">eps</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof470')">Proof.</span></div>
<div class="proofscript" id="proof470">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">posnumP</span>[?]. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">prod_ball_sym</span> <span class="id">x</span> <span class="id">y</span> (<span class="id">eps</span> : <span class="id">R</span>) : <span class="id">prod_ball</span> <span class="id">x</span> <span class="id">eps</span> <span class="id">y</span> -&gt; <span class="id">prod_ball</span> <span class="id">y</span> <span class="id">eps</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof471')">Proof.</span></div>
<div class="proofscript" id="proof471">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">bxy1</span> <span class="id">bxy2</span>]; <span class="id">split</span>; <span class="id">apply</span>: <span class="id">ball_sym</span>. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">prod_ball_triangle</span> <span class="id">x</span> <span class="id">y</span> <span class="id">z</span> (<span class="id">e1</span> <span class="id">e2</span> : <span class="id">R</span>) :<br/>
&nbsp;&nbsp;<span class="id">prod_ball</span> <span class="id">x</span> <span class="id">e1</span> <span class="id">y</span> -&gt; <span class="id">prod_ball</span> <span class="id">y</span> <span class="id">e2</span> <span class="id">z</span> -&gt; <span class="id">prod_ball</span> <span class="id">x</span> (<span class="id">e1</span> + <span class="id">e2</span>) <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof472')">Proof.</span></div>
<div class="proofscript" id="proof472">
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">bxy1</span> <span class="id">bxy2</span>] [<span class="id">byz1</span> <span class="id">byz2</span>]; <span class="id">split</span>; <span class="id"><a href="mathcomp.analysis.topology.html#Mixin">apply</a></span>: <span class="id">ball_triangle</span>; <span class="id">eassumption</span>.<br/>
Qed.</div>
<span class="kwd">Lemma</span> <span class="id">prod_entourage</span> : <span class="id">entourage</span> = <span class="id">entourage_</span> <span class="id">prod_ball</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof473')">Proof.</span></div>
<div class="proofscript" id="proof473">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">P</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; [<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>] <span class="id">sbeP</span>].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> ([<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span>%:<span class="id">num</span> <span class="id">xy</span>.2],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span>%:<span class="id">num</span> <span class="id">xy</span>.2]) =&gt; //=.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; [[<span class="id">a</span> <span class="id"><a name="T:2664">b</a></span>] [<span class="id">c</span> <span class="id">d</span>]] [<span class="id"><a name="R:2665">bab</a></span> <span class="id">bcd</span>]; <span class="kwd">exists</span> ((<span class="id">a</span>, <span class="id"><a name="V:2667">c</a></span>), (<span class="id">b</span>, <span class="id">d</span>))=&gt; //=.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">sbeP</span>.<br/>
<span class="id">move</span>=&gt; [[<span class="id">A</span> <span class="id">B</span>]] /=; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">rewrite</a></span> -!<span class="id">entourage_ballE</span>.<br/>
<span class="id">move</span>=&gt; [[<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">eA</span>] <span class="id"><a href="mathcomp.analysis.topology.html#Filter">sbA</a></span>] [<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">eB</span>] <span class="id">sbB</span>] <span class="id">sABP</span>].<br/>
<span class="kwd">exists</span> (<span class="id">Num.min</span> <span class="id">eA</span> <span class="id">eB</span>)%:<span class="id">num</span> =&gt; //= -[[<span class="id">a</span> <span class="id">b</span>] [<span class="id">c</span> <span class="id">d</span>] [/= <span class="id">bac</span> <span class="id">bbd</span>]].<br/>
<span class="id">suff</span> /<span class="id">sABP</span> [] : (<span class="id">A</span> `*` <span class="id">B</span>) ((<span class="id">a</span>, <span class="id">c</span>), (<span class="id">b</span>, <span class="id">d</span>)) <span class="kwd">by</span> <span class="id">move</span>=&gt; [[??] [??]] ? [&lt;-&lt;-&lt;-&lt;-].<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#fcvg_ballP">split</a></span>; [<span class="id">apply</span>: <span class="id">sbA</span>|<span class="id">apply</span>: <span class="id">sbB</span>] =&gt; /=.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">le_ball</span> <span class="id">bac</span>; <span class="id">rewrite</span> -<span class="id">leEsub</span> <span class="id">le_minl</span> <span class="id">lexx</span>.<br/>
<span class="kwd">by</span> <span class="id"><a name="FG:2682">apply</a></span>: <span class="id">le_ball</span> <span class="id">bbd</span>; <span class="id">rewrite</span> -<span class="id"><a name="g:2684">leEsub</a></span> <span class="id">le_minl</span> <span class="id">lexx</span> <span class="id">orbT</span>.<br/>
Qed.</div>
<span class="kwd">Definition</span> <span class="id">prod_pseudoMetricType_mixin</span> :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetric.Mixin</span> <span class="id">prod_ball_center</span> <span class="id">prod_ball_sym</span> <span class="id">prod_ball_triangle</span> <span class="id">prod_entourage</span>.<br/>
<span class="kwd">End</span> <span class="id">prod_PseudoMetric</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">prod_pseudoMetricType</span> (<span class="id">R</span> : <span class="id">numDomainType</span>) (<span class="id">U</span> <span class="id">V</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>) :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetricType</span> (<span class="id">U</span> * <span class="id">V</span>) (@<span class="id">prod_pseudoMetricType_mixin</span> <span class="id">R</span> <span class="id">U</span> <span class="id">V</span>).<br/>
<br/>
<span class="kwd">Section</span> <span class="id">Nbhs_fct2</span>.<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="kwd">Type</span>} {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">U</span> <span class="id">V</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>}.<br/>
<span class="kwd">Lemma</span> <span class="id">fcvg_ball2P</span> {<span class="id"><a name="fct_PseudoMetric.U">F</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetricType">set</a></span> (<span class="id">set</span> <span class="id">U</span>)} {<span class="id">G</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">V</span>)}<br/>
&nbsp;&nbsp;{<span class="id">FF</span> : <span class="id">Filter</span> <span class="id"><a href="mathcomp.analysis.topology.html#fct_PseudoMetric.T">F</a></span>} {<span class="id">FG</span> : <span class="id"><a name="eps:2694">Filter</a></span> <span class="id">G</span>} (<span class="id">y</span> : <span class="id">U</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#fct_PseudoMetric.U">z</a></span> : <span class="id">V</span>):<br/>
&nbsp;&nbsp;(<span class="id">F</span>, <span class="id">G</span>) --&gt; (<span class="id"><a href="mathcomp.analysis.topology.html#ball">y</a></span>, <span class="id">z</span>) &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">eps</span> : <span class="id">R</span>, <span class="id"><a name="fct_ball_center">eps</a></span> &gt; 0 -&gt; \<span class="kwd">forall</span> <span class="id">y</span>' \<span class="id">near</span> <span class="id">F</span> &amp; <span class="id">z</span>' \<span class="id">near</span> <span class="id">G</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span> <span class="id">y</span>' /\ <span class="id">ball</span> <span class="id"><a href="mathcomp.analysis.signed.html#posnumP">z</a></span> <span class="id">eps</span> <span class="id">z</span>'.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof474')">Proof.</span></div>
<div class="proofscript" id="proof474">
 <span class="id">exact</span>: <span class="id">fcvg_ballP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#fct_PseudoMetric.T">cvg_ball2P</a></span> {<span class="id">I</span> <span class="id">J</span>} {<span class="id"><a href="mathcomp.analysis.topology.html#fct_ball">F</a></span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">I</span>)} {<span class="id"><a href="mathcomp.analysis.topology.html#fct_ball">G</a></span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">J</span>)}<br/>
&nbsp;&nbsp;{<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>} {<span class="id">FG</span> : <span class="id">Filter</span> <span class="id">G</span>} (<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id">U</span>) (<span class="id">g</span> : <span class="id">J</span> -&gt; <span class="id">V</span>) (<span class="id">y</span> : <span class="id">U</span>) (<span class="id">z</span> : <span class="id">V</span>):<br/>
&nbsp;&nbsp;(<span class="id">f</span> @ <span class="id">F</span>, <span class="id">g</span> @ <span class="id">G</span>) --&gt; (<span class="id">y</span>, <span class="id">z</span>) &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">eps</span> : <span class="id">R</span>, <span class="id">eps</span> &gt; 0 -&gt; \<span class="kwd">forall</span> <span class="id">i</span> \<span class="id">near</span> <span class="id">F</span> &amp; <span class="id">j</span> \<span class="id">near</span> <span class="id">G</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ball</span> <span class="id">y</span> <span class="id">eps</span> (<span class="id"><a href="mathcomp.analysis.topology.html#ball_triangle">f</a></span> <span class="id">i</span>) /\ <span class="id">ball</span> <span class="id">z</span> <span class="id">eps</span> (<span class="id">g</span> <span class="id">j</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof475')">Proof.</span></div>
<div class="proofscript" id="proof475">
<span class="id">rewrite</span> <span class="id">fcvg_ball2P</span>; <span class="id">split</span>=&gt; + <span class="id">e</span> <span class="id">e0</span> =&gt; /(<span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#fct_ball">e</a></span> <span class="id">e0</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">near_map2</span>; <span class="id">apply</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">fgyz</span>; <span class="id">rewrite</span> <span class="id">near_map2</span>; <span class="id"><a href="mathcomp.analysis.signed.html#posnumP">apply</a></span>: <span class="id">fgyz</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">Nbhs_fct2</span>.<br/>
<br/>
<div class="doc">Functional metric spaces </div>
<span class="kwd">Section</span> <span class="id">fct_PseudoMetric</span>.<br/>
<span class="kwd">Variable</span> (<span class="id"><a href="mathcomp.analysis.signed.html#posnumP">T</a></span> : <span class="id">choiceType</span>) (<span class="id">R</span> : <span class="id">numFieldType</span>) (<span class="id">U</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>).<br/>
<span class="kwd">Definition</span> <span class="id">fct_ball</span> (<span class="id">x</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">eps</span> : <span class="id">R</span>) (<span class="id">y</span> : <span class="id">T</span> -&gt; <span class="id"><a name="fct_pseudoMetricType_mixin">U</a></span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> : <span class="id">T</span>, <span class="id">ball</span> (<span class="id">x</span> <span class="id">t</span>) <span class="id">eps</span> (<span class="id">y</span> <span class="id">t</span>).<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#fct_ball_center">fct_ball_center</a></span> (<span class="id">x</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">e</span> : <span class="id">R</span>) : 0 &lt; <span class="id">e</span> -&gt; <span class="id">fct_ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof476')">Proof.</span></div>
<div class="proofscript" id="proof476">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">posnumP</span>[{}<span class="id">e</span>] ?. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">fct_ball_sym</span> (<span class="id">x</span> <span class="id">y</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">e</span> : <span class="id">R</span>) : <span class="id">fct_ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span> -&gt; <span class="id">fct_ball</span> <span class="id">y</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof477')">Proof.</span></div>
<div class="proofscript" id="proof477">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">t</span>; <span class="id">apply</span>: <span class="id">ball_sym</span>. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">fct_ball_triangle</span> (<span class="id">x</span> <span class="id">y</span> <span class="id">z</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">e1</span> <span class="id">e2</span> : <span class="id">R</span>) :<br/>
&nbsp;&nbsp;<span class="id">fct_ball</span> <span class="id">x</span> <span class="id">e1</span> <span class="id">y</span> -&gt; <span class="id">fct_ball</span> <span class="id">y</span> <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">e2</a></span> <span class="id">z</span> -&gt; <span class="id">fct_ball</span> <span class="id">x</span> (<span class="id">e1</span> + <span class="id">e2</span>) <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof478')">Proof.</span></div>
<div class="proofscript" id="proof478">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">xy</span> <span class="id">yz</span> <span class="id">t</span>; <span class="id">apply</span>: (@<span class="id">ball_triangle</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">y</span> <span class="id">t</span>)). Qed.</div>
<span class="kwd">Lemma</span> <span class="id">fct_entourage</span> : <span class="id">entourage</span> = <span class="id">entourage_</span> <span class="id">fct_ball</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof479')">Proof.</span></div>
<div class="proofscript" id="proof479">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">A</span>; <span class="id">split</span>; <span class="id"><a name="quotient_choice">last</a></span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>] <span class="id">sbeA</span>]; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span>%:<span class="id">num</span> <span class="id">xy</span>.2].<br/>
<span class="id">move</span>=&gt; [<span class="id">P</span>]; <span class="id">rewrite</span> -<span class="id">entourage_ballE</span> =&gt; -[<span class="id">_</span>/<span class="id"><a name="quotient_open">posnumP</a></span>[<span class="id">e</span>] <span class="id">sbeP</span>] <span class="id">sPA</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">e</span>%:<span class="id">num</span> =&gt; //= <span class="id">fg</span> <span class="id">fg_e</span>; <span class="id">apply</span>: <span class="id">sPA</span> =&gt; <span class="id">t</span>; <span class="id">apply</span>: <span class="id">sbeP</span>; <span class="id">apply</span>: <span class="id">fg_e</span>.<br/>
Qed.</div>
<span class="kwd">Definition</span> <span class="id">fct_pseudoMetricType_mixin</span> :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetricMixin</span> <span class="id">fct_ball_center</span> <span class="id">fct_ball_sym</span> <span class="id">fct_ball_triangle</span> <span class="id">fct_entourage</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">fct_pseudoMetricType</span> := <span class="id">PseudoMetricType</span> (<span class="id">T</span> -&gt; <span class="id">U</span>) <span class="id">fct_pseudoMetricType_mixin</span>.<br/>
<span class="kwd">End</span> <span class="id">fct_PseudoMetric</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">quotient_topology</span> (<span class="id">T</span> : <span class="id">topologicalType</span>) (<span class="id">Q</span> : <span class="id">quotType</span> <span class="id">T</span>) := <span class="id">Q</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">quotients</span>.<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">quotient_scope</span>.<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id">topologicalType</span>} {<span class="id">Q0</span> : <span class="id">quotType</span> <span class="id">T</span>}.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">Q</span> := <span class="id">quotient_topology</span> <span class="id">Q0</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">quotient_subtype</span> := [<span class="id">subType</span> <span class="id">Q</span> <span class="id">of</span> <span class="id">T</span> <span class="kwd">by</span> %/].<br/>
<span class="kwd">Canonical</span> <span class="id">quotient_eq</span> := <span class="id">EqType</span> <span class="id">Q</span> [<span class="id">eqMixin</span> <span class="id">of</span> <span class="id">Q</span> <span class="kwd">by</span> &lt;:].<br/>
<span class="kwd">Canonical</span> <span class="id">quotient_choice</span> := <span class="id">ChoiceType</span> <span class="id"><a href="mathcomp.analysis.topology.html#continuousP">Q</a></span>  [<span class="id">choiceMixin</span> <span class="id">of</span> <span class="id">Q</span> <span class="kwd">by</span> &lt;:].<br/>
<span class="kwd">Canonical</span> <span class="id">quotient_pointed</span> := <span class="id">PointedType</span> <span class="id">Q</span> (\<span class="id">pi_Q</span> <span class="id">point</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">quotient_open</span> <span class="id">U</span> := <span class="id">open</span> (\<span class="id">pi_Q</span> @^-1` <span class="id">U</span>).<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id">quotient_topologicalType_mixin</span> :=<br/>
&nbsp;&nbsp;@<span class="id">topologyOfOpenMixin</span> <span class="id">Q</span> <span class="id">quotient_open</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof480')">Next Obligation.</span></div>
<div class="proofscript" id="proof480">
 <span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">quotient_open</span> <span class="id">preimage_setT</span>; <span class="id">exact</span>: <span class="id">openT</span>. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof481')">Next Obligation.</span></div>
<div class="proofscript" id="proof481">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? ? ?; <span class="id">exact</span>: <span class="id">openI</span>. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof482')">Next Obligation.</span></div>
<div class="proofscript" id="proof482">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">I</span> <span class="id">f</span> <span class="id">ofi</span>; <span class="id">apply</span>: <span class="id">bigcup_open</span> =&gt; <span class="id">i</span> <span class="id">_</span>; <span class="id">exact</span>: <span class="id">ofi</span>. Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">quotient_filtered</span> := <span class="id">Filtered.Class</span> (<span class="id">Pointed.class</span> <span class="id">quotient_pointed</span>)<br/>
&nbsp;&nbsp;(<span class="id"><a href="mathcomp.analysis.topology.html#open">nbhs_of_open</a></span> <span class="id">quotient_open</span>).<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">quotient_topologicalType</span> := @<span class="id">Topological.Pack</span> <span class="id">Q</span><br/>
&nbsp;&nbsp;(@<span class="id">Topological.Class</span> <span class="id">_</span> <span class="id">quotient_filtered</span> <span class="id">quotient_topologicalType_mixin</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">Q</span>' := <span class="id">quotient_topologicalType</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">pi_continuous</span> : <span class="id">continuous</span> (\<span class="id">pi_Q</span> : <span class="id">T</span> -&gt; <span class="id">Q</span>').<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof483')">Proof.</span></div>
<div class="proofscript" id="proof483">
 <span class="id">exact</span>/<span class="id">continuousP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">quotient_continuous</span> {<span class="id">Z</span> : <span class="id">topologicalType</span>} (<span class="id">f</span> : <span class="id">Q</span>' -&gt; <span class="id">Z</span>) :<br/>
&nbsp;&nbsp;<span class="id">continuous</span> <span class="id">f</span> &lt;-&gt; <span class="id">continuous</span> (<span class="id">f</span> \<span class="id">o</span> \<span class="id">pi_Q</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof484')">Proof.</span></div>
<div class="proofscript" id="proof484">
<span class="id">split</span> =&gt; /<span class="id">continuousP</span> /= <span class="id">cts</span>; <span class="id">apply</span>/<span class="id">continuousP</span> =&gt; <span class="id">A</span> <span class="id">oA</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">cts</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">comp_preimage</span>; <span class="id">move</span>/<span class="id">continuousP</span>: <span class="id">pi_continuous</span>; <span class="id">apply</span>; <span class="id">exact</span>: <span class="id">cts</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">repr_comp_continuous</span> (<span class="id">Z</span> : <span class="id">topologicalType</span>) (<span class="id">g</span> : <span class="id">T</span> -&gt; <span class="id">Z</span>) :<br/>
&nbsp;&nbsp;<span class="id">continuous</span> <span class="id">g</span> -&gt; {<span class="id">homo</span> <span class="id">g</span> : <span class="id">a</span> <span class="id">b</span> / <span class="id">a</span> == <span class="id">b</span> %[<span class="id">mod</span> <span class="id">Q</span>] &gt;-&gt; <span class="id">a</span> == <span class="id">b</span>} -&gt;<br/>
&nbsp;&nbsp;<span class="id">continuous</span> (<span class="id">g</span> \<span class="id">o</span> <span class="id">repr</span> : <span class="id">Q</span>' -&gt; <span class="id">Z</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof485')">Proof.</span></div>
<div class="proofscript" id="proof485">
<span class="id">move</span>=&gt; /<span class="id">continuousP</span> <span class="id"><a href="mathcomp.classical.boolp.html#predeqE">ctsG</a></span> <span class="id">rgE</span>; <span class="id">apply</span>/<span class="id">continuousP</span> =&gt; <span class="id">A</span> <span class="id">oA</span>.<br/>
<span class="id">rewrite</span> /<span class="id">open</span>/= /<span class="id">quotient_open</span> (<span class="id">_</span> : <span class="id">_</span> @^-1` <span class="id">_</span> = <span class="id">g</span> @^-1` <span class="id">A</span>); <span class="id">first</span> <span class="id">exact</span>: <span class="id">ctsG</span>.<br/>
<span class="id">have</span> <span class="id">greprE</span> <span class="id">x</span> : <span class="id">g</span> (<span class="id">repr</span> (\<span class="id">pi_Q</span> <span class="id">x</span>)) = <span class="id">g</span> <span class="id">x</span> <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">eqP</span>; <span class="id">rewrite</span> <span class="id">rgE</span>// <span class="id">reprK</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id">x</span> /=; <span class="id">rewrite</span> <span class="id">greprE</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">quotients</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">discrete_pseudoMetric</span>.<br/>
<span class="kwd">Context</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">T</span> : <span class="id">topologicalType</span>} {<span class="id">dsc</span> : <span class="id">discrete_space</span> <span class="id">T</span>}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">discrete_ball</span> (<span class="id">x</span> : <span class="id">T</span>) (<span class="id">eps</span> : <span class="id">R</span>) <span class="id">y</span> : <span class="kwd">Prop</span> := <span class="id">x</span> = <span class="id">y</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">discrete_ball_center</span> <span class="id">x</span> (<span class="id">eps</span> : <span class="id">R</span>) : 0 &lt; <span class="id">eps</span> -&gt; <span class="id">discrete_ball</span> <span class="id">x</span> <span class="id">eps</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof486')">Proof.</span></div>
<div class="proofscript" id="proof486">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id">discrete_pseudoMetricType_mixin</span> :=<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#uniformType">PseudoMetric.Mixin</a></span> <span class="id">R</span> <span class="id">T</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">discrete_ent</a></span> <span class="id">discrete_ball</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof487')">Next Obligation.</span></div>
<div class="proofscript" id="proof487">
 <span class="kwd">by</span> <span class="id">done</span>. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof488')">Next Obligation.</span></div>
<div class="proofscript" id="proof488">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? ? -&gt;. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof489')">Next Obligation.</span></div>
<div class="proofscript" id="proof489">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? ? ? ? -&gt; -&gt;. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof490')">Next Obligation.</span></div>
<div class="proofscript" id="proof490">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">P</span>; <span class="id">split</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">e</span> <span class="id">_</span> + [<span class="id">a</span> <span class="id">b</span>] [<span class="id">i</span> <span class="id">_</span>] [-&gt; -&gt;]; <span class="id">apply</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">entP</span>; <span class="kwd">exists</span> 1 =&gt; //= <span class="id">z</span> <span class="id">z12</span>; <span class="id">apply</span>: <span class="id">entP</span>; <span class="kwd">exists</span> <span class="id">z</span>.1 =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> {2}<span class="id">z12</span> -<span class="id">surjective_pairing</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">discrete_pseudoMetricType</span> := <span class="id">PseudoMetricType</span><br/>
&nbsp;&nbsp;(@<span class="id">discrete_uniformType</span> <span class="id">_</span> <span class="id">dsc</span>) <span class="id">discrete_pseudoMetricType_mixin</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">discrete_pseudoMetric</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_bool</span> {<span class="id">R</span> : <span class="id">realType</span>} :=<br/>
&nbsp;&nbsp;@<span class="id">discrete_pseudoMetricType</span> <span class="id">R</span> [<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">bool</span>] <span class="id">discrete_bool</span>.<br/>
<br/>
<h2> Complete uniform spaces </h2>
<br/>
<span class="kwd">Definition</span> <span class="id">cauchy</span> {<span class="id">T</span> : <span class="id">uniformType</span>} (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) := (<span class="id">F</span>, <span class="id">F</span>) --&gt; <span class="id">entourage</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_cauchy</span> {<span class="id">T</span> : <span class="id">uniformType</span>} (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) : <span class="id">Filter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;[<span class="id">cvg</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">T</span>] -&gt; <span class="id">cauchy</span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof491')">Proof.</span></div>
<div class="proofscript" id="proof491">
<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Complete.type">FF</a></span> <span class="id">cvF</span> <span class="id">A</span> <span class="id">entA</span>; <span class="id">have</span> /<span class="id">entourage_split_ex</span> [<span class="id">B</span> <span class="id">entB</span> <span class="id">sB2A</span>] := <span class="id">entA</span>.<br/>
<span class="kwd">exists</span> (<span class="id">to_set</span> ((<span class="id">B</span>^-1)%<span class="id">classic</span>) (<span class="id">lim</span> <span class="id">F</span>), <span class="id">to_set</span> <span class="id">B</span> (<span class="id">lim</span> <span class="id">F</span>)).<br/>
&nbsp;&nbsp;<span class="id">split</span>=&gt; /=; <span class="id">apply</span>: <span class="id">cvF</span>; <span class="id">rewrite</span> /= -<span class="id">nbhs_entourageE</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">B</span>^-1)%<span class="id">classic</span> =&gt; //; <span class="id">apply</span>: <span class="id">entourage_inv</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">ab</span> [/= <span class="id">Balima</span> <span class="id">Blimb</span>]; <span class="id"><a href="mathcomp.analysis.topology.html#Uniform.class">apply</a></span>: <span class="id">sB2A</span>; <span class="kwd">exists</span> (<span class="id">lim</span> <span class="id">F</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Module</span> <span class="id">Complete</span>.<br/>
<span class="kwd">Definition</span> <span class="id">axiom</span> (<span class="id">T</span> : <span class="id">uniformType</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)), <span class="id">ProperFilter</span> <span class="id">F</span> -&gt; <span class="id">cauchy</span> <span class="id">F</span> -&gt; <span class="id">F</span> --&gt; <span class="id">lim</span> <span class="id">F</span>.<br/>
<span class="kwd">Section</span> <span class="id">ClassDef</span>.<br/>
<span class="kwd">Record</span> <span class="id">class_of</span> (<span class="id">T</span> : <span class="kwd">Type</span>) := <span class="kwd">Class</span> {<br/>
&nbsp;&nbsp;<span class="id">base</span> : <span class="id">Uniform.class_of</span> <span class="id">T</span> ;<br/>
&nbsp;&nbsp;<span class="id">mixin</span> : <span class="id">axiom</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Complete.ClassDef.cT">Uniform.Pack</a></span> <span class="id">base</span>)<br/>
}.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Uniform.class_of</span>.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">mixin</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Complete.axiom</span>.<br/>
<span class="kwd">Structure</span> <span class="id">type</span> := <span class="id"><a name="Complete.Exports">Pack</a></span> { <span class="id">sort</span>; <span class="id">_</span> : <span class="id">class_of</span> <span class="id">sort</span> }.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id"><a href="mathcomp.analysis.topology.html#Complete.mixin">type</a></span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Variables</span> (<span class="id">T</span> : <span class="kwd">Type</span>) (<span class="id">cT</span> : <span class="id">type</span>).<br/>
<span class="kwd">Definition</span> <span class="id">class</span> := <span class="kwd">let</span>: <span class="id">Pack</span> <span class="id">_</span> <span class="id">c</span> := <span class="id">cT</span> <span class="kwd">return</span> <span class="id">class_of</span> <span class="id">cT</span> <span class="kwd">in</span> <span class="id">c</span>.<br/>
<span class="kwd">Definition</span> <span class="id">clone</span> <span class="id">c</span> <span class="id">of</span> <span class="id">phant_id</span> <span class="id">class</span> <span class="id">c</span> := @<span class="id">Pack</span> <span class="id">T</span> <span class="id">c</span>.<br/>
<span class="kwd">Let</span> <span class="id">xT</span> := <span class="kwd">let</span>: <span class="id"><a href="mathcomp.analysis.topology.html#Complete.choiceType">Pack</a></span> <span class="id">T</span> <span class="id">_</span> := <span class="id"><a href="mathcomp.analysis.topology.html#Complete.pointedType">cT</a></span> <span class="kwd">in</span> <span class="id">T</span>.<br/>
<span class="kwd">Notation</span> <span class="id">xclass</span> := (<span class="id">class</span> : <span class="id">class_of</span> <span class="id">xT</span>).<br/>
<span class="kwd">Definition</span> <span class="id">pack</span> <span class="id">b0</span> (<span class="id">m0</span> : <span class="id">axiom</span> (@<span class="id">Uniform.Pack</span> <span class="id">T</span> <span class="id">b0</span>)) :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">bT</span> <span class="id">b</span> <span class="id">of</span> <span class="id">phant_id</span> (@<span class="id">Uniform.class</span> <span class="id">bT</span>) <span class="id">b</span> =&gt;<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">m</span> <span class="id">of</span> <span class="id">phant_id</span> <span class="id">m</span> <span class="id">m0</span> =&gt; @<span class="id">Pack</span> <span class="id">T</span> (@<span class="kwd">Class</span> <span class="id">T</span> <span class="id">b</span> <span class="id">m</span>).<br/>
<span class="kwd">Definition</span> <span class="id">eqType</span> := @<span class="id">Equality.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">choiceType</span> := @<span class="id">Choice.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">pointedType</span> := @<span class="id">Pointed.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">filteredType</span> := @<span class="id">Filtered.Pack</span> <span class="id">cT</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">topologicalType</span> := @<span class="id">Topological.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">uniformType</span> := @<span class="id">Uniform.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">End</span> <span class="id">ClassDef</span>.<br/>
<span class="kwd">Module</span> <span class="id">Exports</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Uniform.class_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id"><a name="Complete.Exports.CompleteType">mixin</a></span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">axiom</span>.<br/>
<span class="kwd">Coercion</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#idfun">sort</a></span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">eqType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Equality.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">eqType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">choiceType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Choice.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">choiceType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">pointedType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Pointed.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">filteredType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Filtered.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="FF:2758">filteredType</a></span>.<br/>
<span class="kwd">Coercion</span> <span class="id"><a href="mathcomp.analysis.topology.html#cauchy">topologicalType</a></span> : <span class="id">type</span> &gt;-&gt; <span class="id">Topological.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topologicalType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">uniformType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Uniform.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniformType</span>.<br/>
<span class="kwd">Notation</span> <span class="id">completeType</span> := <span class="id">type</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">completeType</span>' '<span class="id">of</span>' <span class="id">T</span> '<span class="kwd">for</span>' <span class="id">cT</span> ]" :=  (@<span class="id">clone</span> <span class="id">T</span> <span class="id">cT</span> <span class="id"><a name="mx_complete">_</a></span> <span class="id">idfun</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">completeType</span>'  '<span class="id">of</span>'  <span class="id">T</span>  '<span class="kwd">for</span>'  <span class="id">cT</span> ]") : <span class="id"><a href="mathcomp.analysis.topology.html#cvg">form_scope</a></span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">completeType</span>' '<span class="id">of</span>' <span class="id">T</span> ]" := (@<span class="id">clone</span> <span class="id">T</span> <span class="id">_</span> <span class="id">_</span> <span class="id">id</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">completeType</span>'  '<span class="id">of</span>'  <span class="id">T</span> ]") : <span class="id">form_scope</span>.<br/>
<span class="kwd">Notation</span> <span class="id">CompleteType</span> <span class="id">T</span> <span class="id">m</span> := (@<span class="id">pack</span> <span class="id">T</span> <span class="id">_</span> <span class="id">m</span> <span class="id"><a href="mathcomp.analysis.topology.html#near_map2">_</a></span> <span class="id">_</span> <span class="id">idfun</span> <span class="id">_</span> <span class="id">idfun</span>).<br/>
<span class="kwd">End</span> <span class="id">Exports</span>.<br/>
<span class="kwd">End</span> <span class="id">Complete</span>.<br/>
<span class="kwd">Export</span> <span class="id">Complete.Exports</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">completeType1</span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id">completeType</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cauchy_cvg</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>) :<br/>
&nbsp;&nbsp;<span class="id">cauchy</span> <span class="id">F</span> -&gt; <span class="id">cvg</span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof492')">Proof.</span></div>
<div class="proofscript" id="proof492">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id">T</span> <span class="id">F</span> <span class="id"><a href="mathcomp.analysis.topology.html#subset_split_ent">FF</a></span> =&gt; [? [?]]. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cauchy_cvgP</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">FF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>) : <span class="id">cauchy</span> <span class="id">F</span> &lt;-&gt; <span class="id">cvg</span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof493')">Proof.</span></div>
<div class="proofscript" id="proof493">
 <span class="kwd">by</span> <span class="id">split</span>=&gt; [/<span class="id">cauchy_cvg</span>|/<span class="id">cvg_cauchy</span>]. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">completeType1</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">cauchy_cvg</span> {<span class="id">T</span>} <span class="id">F</span> {<span class="id">FF</span>} <span class="id">_</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">cauchy_cvgP</span> {<span class="id">T</span>} <span class="id">F</span> {<span class="id">FF</span>}.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">matrix_Complete</span>.<br/>
<br/>
<span class="kwd">Variables</span> (<span class="id">T</span> : <span class="id">completeType</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#CompleteType">m</a></span> <span class="id">n</span> : <span class="id">nat</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">mx_complete</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>))) :<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">F</span> -&gt; <span class="id">cauchy</span> <span class="id">F</span> -&gt; <span class="id"><a name="T:2776">cvg</a></span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof494')">Proof.</span></div>
<div class="proofscript" id="proof494">
<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#completeType">FF</a></span> <span class="id">Fc</span>.<br/>
<span class="id">have</span> /(<span class="id">_</span> <span class="id">_</span> <span class="id">_</span>) /<span class="id"><a name="fun_complete">cauchy_cvg</a></span> /<span class="id">cvg_app_entourageP</span> <span class="id">cvF</span> :<br/>
&nbsp;&nbsp;<span class="id">cauchy</span> ((<span class="kwd">fun</span> <span class="id">M</span> : '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) =&gt; <span class="id">M</span> <span class="id">_</span> <span class="id">_</span>) @ <span class="id">F</span>).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">j</span> <span class="id">A</span> /= <span class="id">entA</span>; <span class="id">rewrite</span> <span class="id">near_simpl</span> -<span class="id">near2E</span> <span class="id">near_map2</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#cauchy">apply</a></span>: <span class="id">Fc</span>; <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">_</span> <span class="id">_</span> =&gt; <span class="id">A</span>).<br/>
<span class="id">apply</span>/<span class="id">cvg_ex</span>.<br/>
<span class="id">set</span> <span class="id">Mlim</span> := \<span class="id"><a href="mathcomp.analysis.topology.html#near2E">matrix_</a></span>(<span class="id">i</span>, <span class="id">j</span>) (<span class="id">lim</span> ((<span class="kwd">fun</span> <span class="id">M</span> : '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) =&gt; <span class="id">M</span> <span class="id">i</span> <span class="id">j</span>) @ <span class="id">F</span>) : <span class="id">T</span>).<br/>
<span class="kwd">exists</span> <span class="id"><a name="t:2780">Mlim</a></span>; <span class="id">apply</span>/<span class="id">cvg_mx_entourageP</span> =&gt; <span class="id">A</span> <span class="id">entA</span>; <span class="id">near</span>=&gt; <span class="id">M</span> =&gt; <span class="id">i</span> <span class="id">j</span>; <span class="id">near</span> <span class="id">F</span> =&gt; <span class="id">M</span>'.<br/>
<span class="id">apply</span>: <span class="id">subset_split_ent</span> =&gt; //; <span class="kwd">exists</span> (<span class="id">M</span>' <span class="id">i</span> <span class="id">j</span>) =&gt; /=.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">near</span>: <span class="id">M</span>'; <span class="id">rewrite</span> <span class="id">mxE</span>; <span class="id">apply</span>: <span class="id">cvF</span>.<br/>
<span class="id">move</span>: (<span class="id">i</span>) (<span class="id">j</span>); <span class="id">near</span>: <span class="id">M</span>'; <span class="id">near</span>: <span class="id">M</span>; <span class="id">apply</span>: <span class="id">nearP_dep</span>; <span class="id">apply</span>: <span class="id">Fc</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">_</span> <span class="id">_</span> =&gt; (<span class="id">split_ent</span> <span class="id">A</span>)^-1%<span class="id">classic</span>) =&gt; ?? //; <span class="id">apply</span>: <span class="id">entourage_inv</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id">matrix_completeType</span> := <span class="id">CompleteType</span> '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) <span class="id">mx_complete</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">matrix_Complete</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">fun_Complete</span>.<br/>
<br/>
<span class="kwd">Context</span> {<span class="id"><a name="U:2784">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#uniformType">choiceType</a></span>} {<span class="id">U</span> : <span class="id">completeType</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">fun_complete</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">T</span> -&gt; <span class="id">U</span>)))<br/>
&nbsp;&nbsp;{<span class="id">FF</span> :  <span class="id"><a name="g:2790">ProperFilter</a></span> <span class="id">F</span>} : <span class="id"><a href="mathcomp.analysis.topology.html#Cvg_switch.T1">cauchy</a></span> <span class="id">F</span> -&gt; <span class="id">cvg</span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof495')">Proof.</span></div>
<div class="proofscript" id="proof495">
<span class="id">move</span>=&gt; <span class="id">Fc</span>.<br/>
<span class="id">have</span> /(<span class="id">_</span> <span class="id">_</span>) /<span class="id">cauchy_cvg</span> /<span class="id">cvg_app_entourageP</span> <span class="id">cvF</span> : <span class="id">cauchy</span> (@^~<span class="id">_</span> @ <span class="id">F</span>).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">t</span> <span class="id">A</span> /= <span class="id">entA</span>; <span class="id">rewrite</span> <span class="id">near_simpl</span> -<span class="id">near2E</span> <span class="id">near_map2</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">Fc</span>; <span class="kwd">exists</span> <span class="id">A</span>.<br/>
<span class="id">apply</span>/<span class="id"><a href="mathcomp.analysis.topology.html#entourage_split">cvg_ex</a></span>; <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">t</span> =&gt; <span class="id">lim</span> (@^~<span class="id">t</span> @ <span class="id">F</span>)).<br/>
<span class="id">apply</span>/<span class="id">cvg_fct_entourageP</span> =&gt; <span class="id">A</span> <span class="id">entA</span>; <span class="id">near</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#entourage_split">f</a></span> =&gt; <span class="id">t</span>; <span class="id">near</span> <span class="id">F</span> =&gt; <span class="id">g</span>.<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id">g</span> <span class="id">t</span>)) =&gt; //; <span class="id">first</span> <span class="kwd">by</span> <span class="id">near</span>: <span class="id">g</span>; <span class="id">apply</span>: <span class="id">cvF</span>.<br/>
<span class="id">move</span>: (<span class="id">t</span>); <span class="id">near</span>: <span class="id">g</span>; <span class="id">near</span>: <span class="id">f</span>; <span class="id">apply</span>: <span class="id">nearP_dep</span>; <span class="id">apply</span>: <span class="id">Fc</span>.<br/>
<span class="kwd">exists</span> ((<span class="id">split_ent</span> <span class="id">A</span>)^-1)%<span class="id">classic</span>=&gt; //=.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id">fun_completeType</span> := <span class="id">CompleteType</span> (<span class="id">T</span> -&gt; <span class="id">U</span>) <span class="id">fun_complete</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">fun_Complete</span>.<br/>
<br/>
<h2> Limit switching </h2>
<span class="kwd">Section</span> <span class="id">Cvg_switch</span>.<br/>
<span class="kwd">Context</span> {<span class="id">T1</span> <span class="id">T2</span> : <span class="id">choiceType</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="x:2802">cvg_switch_1</a></span> {<span class="id">U</span> : <span class="id">uniformType</span>}<br/>
&nbsp;&nbsp;<span class="id">F1</span> {<span class="id">FF1</span> : <span class="id">ProperFilter</span> <span class="id">F1</span>} <span class="id">F2</span> {<span class="id">FF2</span> : <span class="id">Filter</span> <span class="id">F2</span>}<br/>
&nbsp;&nbsp;(<span class="id">f</span> : <span class="id">T1</span> -&gt; <span class="id">T2</span> -&gt; <span class="id">U</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#near_simpl">g</a></span> : <span class="id">T2</span> -&gt; <span class="id">U</span>) (<span class="id">h</span> : <span class="id">T1</span> -&gt; <span class="id">U</span>) (<span class="id">l</span> : <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id">F1</span> --&gt; <span class="id">g</span> -&gt; (<span class="kwd">forall</span> <span class="id">x1</span>, <span class="id">f</span> <span class="id">x1</span> @ <span class="id">F2</span> --&gt; <span class="id">h</span> <span class="id">x1</span>) -&gt; <span class="id">h</span> @ <span class="id">F1</span> --&gt; <span class="id">l</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">g</span> @ <span class="id">F2</span> --&gt; <span class="id">l</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof496')">Proof.</span></div>
<div class="proofscript" id="proof496">
<span class="id">move</span>=&gt; <span class="id">fg</span> <span class="id">fh</span> <span class="id">hl</span>; <span class="id">apply</span>/<span class="id">cvg_app_entourageP</span> =&gt; <span class="id">A</span> <span class="id">entA</span>.<br/>
<span class="id">near</span> <span class="id">F1</span> =&gt; <span class="id">x1</span>; <span class="id">near</span>=&gt; <span class="id">x2</span>; <span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id">h</span> <span class="id">x1</span>)) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">near</span>: <span class="id">x1</span>; <span class="id">apply</span>/(<span class="id">hl</span> (<span class="id">to_set</span> <span class="id">_</span> <span class="id">l</span>)) =&gt; /=.<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id"><a href="mathcomp.analysis.topology.html#entourage_split">f</a></span> <span class="id">x1</span> <span class="id">x2</span>)) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">near</span>: <span class="id">x2</span>; <span class="id">apply</span>/(<span class="id">fh</span> <span class="id">x1</span> (<span class="id">to_set</span> <span class="id">_</span> <span class="id">_</span>)) =&gt; /=.<br/>
<span class="id">move</span>: (<span class="id">x2</span>); <span class="id">near</span>: <span class="id">x1</span>; <span class="id">have</span> /<span class="id">cvg_fct_entourageP</span> /(<span class="id">_</span> (<span class="id">_</span>^-1%<span class="id">classic</span>)):= <span class="id">fg</span>; <span class="id">apply</span>.<br/>
<span class="id">exact</span>: <span class="id">entourage_inv</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_switch_2</span> {<span class="id">U</span> : <span class="id">completeType</span>}<br/>
&nbsp;&nbsp;<span class="id">F1</span> {<span class="id">FF1</span> : <span class="id">ProperFilter</span> <span class="id">F1</span>} <span class="id">F2</span> {<span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">FF2</a></span> : <span class="id">ProperFilter</span> <span class="id">F2</span>}<br/>
&nbsp;&nbsp;(<span class="id">f</span> : <span class="id">T1</span> -&gt; <span class="id">T2</span> -&gt; <span class="id">U</span>) (<span class="id">g</span> : <span class="id">T2</span> -&gt; <span class="id">U</span>) (<span class="id">h</span> : <span class="id">T1</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id">f</span> @ <span class="id"><a name="h:2810">F1</a></span> --&gt; <span class="id">g</span> -&gt; (<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">f</span> <span class="id">x</span> @ <span class="id">F2</span> --&gt; <span class="id">h</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;[<span class="id">cvg</span> <span class="id">h</span> @ <span class="id">F1</span> <span class="kwd">in</span> <span class="id">U</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof497')">Proof.</span></div>
<div class="proofscript" id="proof497">
<span class="id">move</span>=&gt; <span class="id">fg</span> <span class="id">fh</span>; <span class="id">apply</span>: <span class="id">cauchy_cvg</span> =&gt; <span class="id">A</span> <span class="id">entA</span>.<br/>
<span class="id">rewrite</span> !<span class="id">near_simpl</span> -<span class="id">near2_pair</span> <span class="id">near_map2</span>; <span class="id">near</span>=&gt; <span class="id">x1</span> <span class="id">y1</span> =&gt; /=; <span class="id">near</span> <span class="id">F2</span> =&gt; <span class="id">x2</span>.<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id">f</span> <span class="id">x1</span> <span class="id">x2</span>)) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">near</span>: <span class="id">x2</span>; <span class="id">apply</span>/(<span class="id">fh</span> <span class="id">_</span> (<span class="id">to_set</span> <span class="id">_</span> <span class="id">_</span>)) =&gt; /=.<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id">f</span> <span class="id">y1</span> <span class="id">x2</span>)) =&gt; //; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="id">near</span>: <span class="id">x2</span>; <span class="id">apply</span>/(<span class="id">fh</span> <span class="id">_</span> (<span class="id">to_set</span> ((<span class="id">_</span>^-1)%<span class="id">classic</span>) <span class="id">_</span>)).<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">nbhs_entourage</span> (<span class="id">entourage_inv</span> <span class="id">_</span>).<br/>
<span class="id"><a name="x:2817">apply</a></span>: (<span class="id">entourage_split</span> (<span class="id">g</span> <span class="id">x2</span>)) =&gt; //; <span class="id">move</span>: (<span class="id">x2</span>); [<span class="id">near</span>: <span class="id">x1</span>|<span class="id">near</span>: <span class="id">y1</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> /<span class="id">cvg_fct_entourageP</span> /(<span class="id">_</span> (<span class="id">_</span>^-1)%<span class="id">classic</span>) := <span class="id">fg</span>; <span class="id">apply</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id"><a name="y:2823">entourage_inv</a></span>.<br/>
<span class="kwd">by</span> <span class="id">have</span> /<span class="id">cvg_fct_entourageP</span> := <span class="id">fg</span>; <span class="id">apply</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_switch</span> {<span class="id">U</span> : <span class="id">completeType</span>}<br/>
&nbsp;&nbsp;<span class="id">F1</span> (<span class="id">FF1</span> : <span class="id">ProperFilter</span> <span class="id">F1</span>) <span class="id">F2</span> (<span class="id">FF2</span> : <span class="id">ProperFilter</span> <span class="id">F2</span>)<br/>
&nbsp;&nbsp;(<span class="id">f</span> : <span class="id">T1</span> -&gt; <span class="id">T2</span> -&gt; <span class="id">U</span>) (<span class="id">g</span> : <span class="id">T2</span> -&gt; <span class="id">U</span>) (<span class="id">h</span> : <span class="id">T1</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#entourage_ball">f</a></span> @ <span class="id">F1</span> --&gt; <span class="id">g</span> -&gt; (<span class="kwd">forall</span> <span class="id">x1</span>, <span class="id">f</span> <span class="id">x1</span> @ <span class="id"><a href="mathcomp.analysis.topology.html#entourage_ballE">F2</a></span> --&gt; <span class="id">h</span> <span class="id">x1</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">l</span> : <span class="id">U</span>, <span class="id">h</span> @ <span class="id">F1</span> --&gt; <span class="id">l</span> /\ <span class="id">g</span> @ <span class="id">F2</span> --&gt; <span class="id">l</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof498')">Proof.</span></div>
<div class="proofscript" id="proof498">
<span class="id">move</span>=&gt; <span class="id">Hfg</span> <span class="id">Hfh</span>; <span class="id">have</span> <span class="id">hcv</span> := !! <span class="id">cvg_switch_2</span> <span class="id">Hfg</span> <span class="id">Hfh</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> [<span class="id">lim</span> <span class="id">h</span> @ <span class="id">F1</span> <span class="kwd">in</span> <span class="id">U</span>]; <span class="id">split</span>=&gt; //; <span class="id">apply</span>: <span class="id">cvg_switch_1</span> <span class="id">Hfg</span> <span class="id">Hfh</span> <span class="id">hcv</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">Cvg_switch</span>.<br/>
<br/>
<h2> Complete pseudoMetric spaces </h2>
<br/>
<span class="kwd">Definition</span> <span class="id">cauchy_ex</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">T</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">eps</span> : <span class="id">R</span>, 0 &lt; <span class="id">eps</span> -&gt; <span class="kwd">exists</span> <span class="id">x</span>, <span class="id">F</span> (<span class="id">ball</span> <span class="id">x</span> <span class="id">eps</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">cauchy_ball</span> {<span class="id">R</span> : <span class="id">numDomainType</span>} {<span class="id">T</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span>, <span class="id">e</span> &gt; 0 -&gt; \<span class="kwd">forall</span> <span class="id">x</span> &amp; <span class="id">y</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cauchy_ballP</span> (<span class="id">R</span> : <span class="id">numDomainType</span>) (<span class="id">T</span>  : <span class="id">pseudoMetricType</span> <span class="id">R</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">FF</span> : <span class="id">Filter</span> <span class="id"><a name="PF:2835">F</a></span>) :<br/>
&nbsp;&nbsp;<span class="id">cauchy_ball</span> <span class="id">F</span> &lt;-&gt; <span class="id"><a href="mathcomp.analysis.topology.html#cauchy">cauchy</a></span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof499')">Proof.</span></div>
<div class="proofscript" id="proof499">
<span class="id">split</span>=&gt; <span class="id">cauchyF</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">eps</span>]; <span class="id">apply</span>/<span class="id">cauchyF</span>/<span class="id">entourage_ball</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">U</span>; <span class="id">rewrite</span> -<span class="id">entourage_ballE</span> =&gt; - [<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id"><a href="mathcomp.analysis.topology.html#entourage_ball">eps</a></span>] <span class="id">xyepsU</span>].<br/>
<span class="kwd">by</span> <span class="id">near</span> <span class="id">do</span> <span class="id">apply</span>: <span class="id">xyepsU</span>; <span class="id">apply</span>: <span class="id">cauchyF</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id">cauchy_ballP</span> {<span class="id">R</span> <span class="id">T</span>} <span class="id">F</span> {<span class="id">FF</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cauchy_exP</span> (<span class="id">R</span> : <span class="id">numFieldType</span>) (<span class="id">T</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">FF</span> : <span class="id">Filter</span> <span class="id">F</span>) :<br/>
&nbsp;&nbsp;<span class="id">cauchy_ex</span> <span class="id">F</span> -&gt; <span class="id">cauchy</span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof500')">Proof.</span></div>
<div class="proofscript" id="proof500">
<span class="id">move</span>=&gt; <span class="id">Fc</span> <span class="id">A</span>; <span class="id">rewrite</span> !<span class="id">nbhs_simpl</span> /= -<span class="id">entourage_ballE</span> =&gt; -[<span class="id">_</span>/<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">posnumP</a></span>[<span class="id">e</span>] <span class="id">sdeA</span>].<br/>
<span class="id">have</span> /<span class="id">Fc</span> [<span class="id">z</span> /= <span class="id">Fze</span>] := [<span class="id">gt0</span> <span class="id">of</span> <span class="id">e</span>%:<span class="id">num</span> / 2]; <span class="id">near</span>=&gt; <span class="id">x</span> <span class="id">y</span>; <span class="id">apply</span>: <span class="id">sdeA</span> =&gt; /=.<br/>
<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_simpl">apply</a></span>: (@<span class="id">ball_splitr</span> <span class="id">_</span> <span class="id">_</span> <span class="id">z</span>); [<span class="id">near</span>: <span class="id">x</span>|<span class="id">near</span>: <span class="id">y</span>].<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id">cauchy_exP</span> {<span class="id">R</span> <span class="id">T</span>} <span class="id">F</span> {<span class="id">FF</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cauchyP</span> (<span class="id">R</span> : <span class="id">numFieldType</span>) (<span class="id">T</span> : <span class="id">pseudoMetricType</span> <span class="id"><a href="mathcomp.analysis.topology.html#entourage_split">R</a></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">PF</span> : <span class="id">ProperFilter</span> <span class="id">F</span>) :<br/>
&nbsp;&nbsp;<span class="id">cauchy</span> <span class="id">F</span> &lt;-&gt; <span class="id">cauchy_ex</span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof501')">Proof.</span></div>
<div class="proofscript" id="proof501">
<span class="id">split</span>=&gt; [<span class="id">Fcauchy</span> <span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>] |/<span class="id">cauchy_exP</span>//].<br/>
<span class="id">near</span> <span class="id">F</span> =&gt; <span class="id">x</span>; <span class="kwd">exists</span> <span class="id">x</span>; <span class="id">near</span>: <span class="id">x</span>; <span class="id">apply</span>: (@<span class="id">nearP_dep</span> <span class="id">_</span> <span class="id">_</span> <span class="id">F</span> <span class="id">F</span>).<br/>
<span class="id">exact</span>/<span class="id">Fcauchy</span>/<span class="id"><a name="CompletePseudoMetric.base">entourage_ball</a></span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<span class="kwd">Arguments</span> <span class="id">cauchyP</span> {<span class="id">R</span> <span class="id">T</span>} <span class="id">F</span> {<span class="id">PF</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#CompletePseudoMetric.base">compact_cauchy_cvg</a></span> {<span class="id">T</span> : <span class="id">uniformType</span>} (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id"><a name="CompletePseudoMetric.base2">T</a></span>)) :<br/>
&nbsp;&nbsp;<span class="id"><a name="m:2845">ProperFilter</a></span> <span class="id">F</span> -&gt; <span class="id">cauchy</span> <span class="id">F</span> -&gt; <span class="id">F</span> <span class="id">U</span> -&gt; <span class="id">compact</span> <span class="id">U</span> -&gt; <span class="id">cvg</span> <span class="id">F</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof502')">Proof.</span></div>
<div class="proofscript" id="proof502">
<span class="id">move</span>=&gt; <span class="id">PF</span> <span class="id">cf</span> <span class="id">FU</span> /(<span class="id">_</span> <span class="id">F</span> <span class="id">PF</span> <span class="id">FU</span>) [<span class="id">x</span> [<span class="id">_</span> <span class="id">clFx</span>]]; <span class="id">apply</span>: (<span class="id"><a name="CompletePseudoMetric.sort">cvgP</a></span> <span class="id">x</span>).<br/>
<span class="id">apply</span>/<span class="id">cvg_entourageP</span> =&gt; <span class="id"><a href="mathcomp.analysis.topology.html#CompletePseudoMetric.sort">E</a></span> <span class="id">entE</span>.<br/>
<span class="id">have</span> : <span class="id">nbhs</span> <span class="id">entourage</span> (<span class="id">split_ent</span> <span class="id">E</span>) <span class="kwd">by</span> <span class="id"><a name="CompletePseudoMetric.ClassDef.T">rewrite</a></span> <span class="id">nbhs_filterE</span>.<br/>
<span class="id">move</span>=&gt; /(<span class="id">cf</span> (<span class="id">split_ent</span> <span class="id">E</span>))[] [<span class="id">D1</span> <span class="id">D2</span>]/= /[!<span class="id">nbhs_simpl</span>] -[<span class="id">FD1</span> <span class="id">FD2</span> <span class="id">D1D2E</span>].<br/>
<span class="id">have</span> : <span class="id">nbhs</span> <span class="id">x</span> <span class="id">to_set</span> (<span class="id">split_ent</span> <span class="id">E</span>) <span class="id">x</span> <span class="kwd">by</span> <span class="id">exact</span>: <span class="id">nbhs_entourage</span>.<br/>
<span class="id">move</span>=&gt; /(<span class="id">clFx</span> <span class="id">_</span> (<span class="id">to_set</span> (<span class="id">split_ent</span> <span class="id">E</span>) <span class="id">x</span>) <span class="id">FD1</span>)[<span class="id">z</span> [<span class="id">Dz</span> <span class="id">Exz</span>]].<br/>
<span class="kwd">by</span> <span class="id">near</span>=&gt; <span class="id">t</span>; <span class="id">apply</span>/(<span class="id">entourage_split</span> <span class="id">z</span> <span class="id">entE</span> <span class="id">Exz</span>)/<span class="id">D1D2E</span>; <span class="id">split</span> =&gt; //; <span class="id">near</span>: <span class="id">t</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Module</span> <span class="id">CompletePseudoMetric</span>.<br/>
<span class="kwd">Section</span> <span class="id">ClassDef</span>.<br/>
<span class="kwd">Variable</span> <span class="id">R</span> : <span class="id">numDomainType</span>.<br/>
<span class="kwd">Record</span> <span class="id">class_of</span> (<span class="id">T</span> : <span class="kwd">Type</span>) := <span class="kwd">Class</span> {<br/>
&nbsp;&nbsp;<span class="id">base</span> : <span class="id">PseudoMetric.class_of</span> <span class="id">R</span> <span class="id">T</span>;<br/>
&nbsp;&nbsp;<span class="id">mixin</span> : <span class="id">Complete.axiom</span> (<span class="id"><a href="mathcomp.analysis.topology.html#CompletePseudoMetric.xclass">Uniform.Pack</a></span> <span class="id">base</span>)<br/>
}.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">PseudoMetric.class_of</span>.<br/>
<span class="kwd">Definition</span> <span class="id">base2</span> <span class="id">T</span> <span class="id">m</span> := <span class="id"><a href="mathcomp.analysis.topology.html#CompletePseudoMetric.ClassDef.cT">Complete.Class</a></span> (@<span class="id">mixin</span> <span class="id">T</span> <span class="id">m</span>).<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">base2</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Complete.class_of</span>.<br/>
<br/>
<span class="kwd">Structure</span> <span class="id">type</span> := <span class="id">Pack</span> { <span class="id"><a href="mathcomp.analysis.topology.html#CompletePseudoMetric.ClassDef.cT">sort</a></span>; <span class="id">_</span> : <span class="id">class_of</span> <span class="id">sort</span> }.<br/>
<span class="id">Local</span> <span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Variables</span> (<span class="id">T</span> : <span class="kwd">Type</span>) (<span class="id">cT</span> : <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.Pack">type</a></span>).<br/>
<span class="kwd">Definition</span> <span class="id"><a href="mathcomp.analysis.topology.html#CompletePseudoMetric.ClassDef.R">class</a></span> := <span class="kwd">let</span>: <span class="id">Pack</span> <span class="id">_</span> <span class="id">c</span> := <span class="id">cT</span> <span class="kwd">return</span> <span class="id">class_of</span> <span class="id">cT</span> <span class="kwd">in</span> <span class="id">c</span>.<br/>
<span class="kwd">Definition</span> <span class="id">clone</span> <span class="id">c</span> <span class="id">of</span> <span class="id">phant_id</span> <span class="id"><a href="mathcomp.analysis.topology.html#CompletePseudoMetric.xclass">class</a></span> <span class="id">c</span> := @<span class="id"><a href="mathcomp.analysis.topology.html#CompletePseudoMetric.ClassDef">Pack</a></span> <span class="id">T</span> <span class="id">c</span>.<br/>
<span class="kwd">Let</span> <span class="id">xT</span> := <span class="kwd">let</span>: <span class="id">Pack</span> <span class="id">T</span> <span class="id">_</span> := <span class="id">cT</span> <span class="kwd">in</span> <span class="id">T</span>.<br/>
<span class="kwd">Notation</span> <span class="id">xclass</span> := (<span class="id">class</span> : <span class="id">class_of</span> <span class="id">xT</span>).<br/>
<span class="kwd">Definition</span> <span class="id">pack</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">bT</span> <span class="id">b</span> &amp; <span class="id">phant_id</span> (@<span class="id">PseudoMetric.class</span> <span class="id">R</span> <span class="id">bT</span>) (<span class="id">b</span> : <span class="id">PseudoMetric.class_of</span> <span class="id">R</span> <span class="id">T</span>) =&gt;<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">mT</span> <span class="id">m</span> &amp; <span class="id">phant_id</span> (<span class="id">Complete.class</span> <span class="id">mT</span>) (@<span class="id">Complete.Class</span> <span class="id">T</span> <span class="id">b</span> <span class="id">m</span>) =&gt;<br/>
&nbsp;&nbsp;<span class="id">Pack</span> (@<span class="kwd">Class</span> <span class="id">T</span> <span class="id">b</span> <span class="id">m</span>).<br/>
<span class="kwd">Definition</span> <span class="id">eqType</span> := @<span class="id">Equality.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">choiceType</span> := @<span class="id">Choice.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">pointedType</span> := @<span class="id">Pointed.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">filteredType</span> := @<span class="id">Filtered.Pack</span> <span class="id">cT</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">topologicalType</span> := @<span class="id">Topological.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">uniformType</span> := @<span class="id">Uniform.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">completeType</span> := @<span class="id">Complete.Pack</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetricType</span> := @<span class="id">PseudoMetric.Pack</span> <span class="id">R</span> <span class="id">cT</span> <span class="id">xclass</span>.<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_completeType</span> := @<span class="id">Complete.Pack</span> <span class="id">pseudoMetricType</span> <span class="id">xclass</span>.<br/>
<span class="kwd">End</span> <span class="id">ClassDef</span>.<br/>
<span class="kwd">Module</span> <span class="id">Exports</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">base</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">PseudoMetric.class_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">mixin</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Complete.axiom</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">base2</span> : <span class="id">class_of</span> &gt;-&gt; <span class="id">Complete.class_of</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">sort</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Sortclass</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">eqType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Equality.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">eqType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">choiceType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Choice.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">choiceType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">pointedType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Pointed.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">filteredType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Filtered.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filteredType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">topologicalType</span> : <span class="id"><a href="mathcomp.analysis.topology.html#CompletePseudoMetric.Exports">type</a></span> &gt;-&gt; <span class="id">Topological.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topologicalType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">uniformType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Uniform.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniformType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">completeType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">Complete.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">completeType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">pseudoMetricType</span> : <span class="id">type</span> &gt;-&gt; <span class="id">PseudoMetric.type</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetricType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_completeType</span>.<br/>
<span class="kwd">Notation</span> <span class="id">completePseudoMetricType</span> := <span class="id">type</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">completePseudoMetricType</span>' '<span class="id">of</span>' <span class="id">T</span> '<span class="kwd">for</span>' <span class="id">cT</span> ]" :=  (@<span class="id">clone</span> <span class="id">T</span> <span class="id">cT</span> <span class="id">_</span> <span class="id">idfun</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">completePseudoMetricType</span>'  '<span class="id">of</span>'  <span class="id">T</span>  '<span class="kwd">for</span>'  <span class="id">cT</span> ]") : <span class="id">form_scope</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">completePseudoMetricType</span>' '<span class="id">of</span>' <span class="id">T</span> ]" := (@<span class="id">clone</span> <span class="id">T</span> <span class="id">_</span> <span class="id">_</span> <span class="id">id</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">completePseudoMetricType</span>'  '<span class="id">of</span>'  <span class="id">T</span> ]") : <span class="id">form_scope</span>.<br/>
<span class="kwd">Notation</span> <span class="id">CompletePseudoMetricType</span> <span class="id">T</span> <span class="id">m</span> := (@<span class="id">pack</span> <span class="id">_</span> <span class="id">T</span> <span class="id">_</span> <span class="id">_</span> <span class="id">id</span> <span class="id">_</span> <span class="id">_</span> <span class="id">id</span>).<br/>
<span class="kwd">End</span> <span class="id">Exports</span>.<br/>
<span class="kwd">End</span> <span class="id">CompletePseudoMetric</span>.<br/>
<span class="kwd">Export</span> <span class="id">CompletePseudoMetric.Exports</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">matrix_completePseudoMetricType</span> (<span class="id">R</span> : <span class="id">numFieldType</span>)<br/>
&nbsp;&nbsp;(<span class="id">T</span> : <span class="id">completePseudoMetricType</span> <span class="id">R</span>) (<span class="id">m</span> <span class="id">n</span> : <span class="id">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id">CompletePseudoMetricType</span> '<span class="id">M</span>[<span class="id">T</span>]<span class="id">_</span>(<span class="id">m</span>, <span class="id">n</span>) <span class="id">mx_complete</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">fct_completePseudoMetricType</span> (<span class="id">T</span> : <span class="id">choiceType</span>) (<span class="id">R</span> : <span class="id">numFieldType</span>)<br/>
&nbsp;&nbsp;(<span class="id">U</span> : <span class="id">completePseudoMetricType</span> <span class="id">R</span>) :=<br/>
&nbsp;&nbsp;<span class="id">CompletePseudoMetricType</span> (<span class="id">T</span> -&gt; <span class="id">U</span>) <span class="id">fun_complete</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="ball_filter">pointed_of_zmodule</a></span> (<span class="id">R</span> : <span class="id">zmodType</span>) : <span class="id">pointedType</span> := <span class="id">PointedType</span> <span class="id">R</span> 0.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">ball_</span><br/>
&nbsp;&nbsp;(<span class="id">R</span> : <span class="id">numDomainType</span>) (<span class="id">V</span> : <span class="id">zmodType</span>) (<span class="id">norm</span> : <span class="id">V</span> -&gt; <span class="id">R</span>) (<span class="id">x</span> : <span class="id">V</span>) (<span class="id">e</span> : <span class="id">R</span>) :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">y</span> | <span class="id">norm</span> (<span class="id">x</span> - <span class="id">y</span>) &lt; <span class="id">e</span>].<br/>
<span class="kwd">Arguments</span> <span class="id">ball_</span> {<span class="id">R</span>} {<span class="id">V</span>} <span class="id">norm</span> <span class="id">x</span> <span class="id">e</span>%<span class="id">R</span> <span class="id">y</span> /.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">subset_ball_prop_in_itv</span> (<span class="id">R</span> : <span class="id">realDomainType</span>) (<span class="id">x</span> : <span class="id">R</span>) <span class="id">e</span> <span class="id">P</span> :<br/>
&nbsp;&nbsp;(<span class="id">ball_</span> <span class="id">Num.Def.normr</span> <span class="id">x</span> <span class="id">e</span> `&lt;=` <span class="id">P</span>)%<span class="id">classic</span> &lt;-&gt;<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> `](<span class="id">x</span> - <span class="id">e</span>), (<span class="id">x</span> + <span class="id">e</span>)[, <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">P</span> <span class="id">y</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof503')">Proof.</span></div>
<div class="proofscript" id="proof503">
<span class="kwd">by</span> <span class="id">split</span>=&gt; <span class="id">exP</span> <span class="id">y</span> /=; <span class="id">rewrite</span> ?<span class="id">in_itv</span> (<span class="id">ltr_distlC</span>, =^~<span class="id">ltr_distlC</span>); <span class="id">apply</span>: <span class="id">exP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">subset_ball_prop_in_itvcc</span> (<span class="id">R</span> : <span class="id">realDomainType</span>) (<span class="id">x</span> : <span class="id">R</span>) <span class="id">e</span> <span class="id">P</span> : 0 &lt; <span class="id">e</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">ball_</span> <span class="id">Num.Def.normr</span> <span class="id">x</span> (2 * <span class="id">e</span>) `&lt;=` <span class="id">P</span>)%<span class="id">classic</span> -&gt;<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> `[(<span class="id">x</span> - <span class="id">e</span>), (<span class="id">x</span> + <span class="id">e</span>)], <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">P</span> <span class="id">y</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof504')">Proof.</span></div>
<div class="proofscript" id="proof504">
<span class="id">move</span>=&gt; <span class="id">e_gt0</span> <span class="id">PP</span> <span class="id">y</span>; <span class="id">rewrite</span> <span class="id">in_itv</span>/= -<span class="id">ler_distlC</span> =&gt; <span class="id">ye</span>; <span class="id">apply</span>: <span class="id">PP</span> =&gt; /=.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">le_lt_trans</span> <span class="id">ye</span>)// <span class="id">ltr_pmull</span>// <span class="id">ltr1n</span>.<br/>
Qed.</div>
<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#pointed_of_zmodule">Global</a></span> <span class="kwd">Instance</span> <span class="id">ball_filter</span> (<span class="id">R</span> : <span class="id">realDomainType</span>) (<span class="id">t</span> : <span class="id">R</span>) : <span class="id">Filter</span><br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">P</span> | <span class="kwd">exists2</span> <span class="id">i</span> : <span class="id">R</span>, 0 &lt; <span class="id">i</span> &amp; <span class="id">ball_</span> <span class="id">Num.norm</span> <span class="id">t</span> <span class="id">i</span> `&lt;=` <span class="id">P</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof505')">Proof.</span></div>
<div class="proofscript" id="proof505">
<span class="id">apply</span>: <span class="id">Build_Filter</span>; [<span class="kwd">by</span> <span class="kwd">exists</span> 1 | <span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> | <span class="id">move</span>=&gt; <span class="id"><a name="e:2895">P</a></span> <span class="id">Q</span> <span class="id"><a href="mathcomp.analysis.topology.html#pseudoMetric_of_normedDomain.K">PQ</a></span>]; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#ball_">mkset</a></span>.<br/>
- <span class="id">move</span>=&gt; -[<span class="id">x</span> <span class="id">x0</span> <span class="id">xP</span>] [<span class="id">y</span> ? <span class="id">yQ</span>]; <span class="kwd">exists</span> (<span class="id">Num.min</span> <span class="id">x</span> <span class="id">y</span>); <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">lt_minr</span> <span class="id">x0</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">z</span> <span class="id"><a name="x:2896">tz</a></span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">xP</span>; <span class="id">rewrite</span> /= (<span class="id">lt_le_trans</span> <span class="id">tz</span>) // <span class="id">le_minl</span> <span class="id">lexx</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">yQ</span>; <span class="id">rewrite</span> /= (<span class="id">lt_le_trans</span> <span class="id">tz</span>) // <span class="id">le_minl</span> <span class="id"><a name="y:2900">lexx</a></span> <span class="id">orbT</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; -[<span class="id"><a href="mathcomp.analysis.topology.html#ball_">x</a></span> ? <span class="id">xP</span>]; <span class="kwd">exists</span> <span class="id">x</span> =&gt; //; <span class="id"><a href="mathcomp.analysis.topology.html#ball_">apply</a></span>: (<span class="id">subset_trans</span> <span class="id">xP</span>).<br/>
Qed.</div>
<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Extern</span> 0 (<span class="id">Filter</span> [<span class="id">set</span> <span class="id">P</span> | <span class="kwd">exists2</span> <span class="id">i</span>, <span class="id">_</span> &amp; <span class="id">ball_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">i</span> `&lt;=` <span class="id">P</span>]) =&gt;<br/>
&nbsp;&nbsp;(<span class="id">apply</span>: <span class="id">ball_filter</span>) : <span class="id">typeclass_instances</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">filtered_of_normedZmod</span> (<span class="id">K</span> : <span class="id">numDomainType</span>) (<span class="id">R</span> : <span class="id">normedZmodType</span> <span class="id">K</span>)<br/>
&nbsp;&nbsp;: <span class="id">filteredType</span> <span class="id">R</span> := <span class="id">Filtered.Pack</span> (<span class="id">Filtered.Class</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id">Pointed.class</span> (<span class="id">pointed_of_zmodule</span> <span class="id">R</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a href="mathcomp.analysis.topology.html#ball_norm_center">nbhs_ball_</a></span> (<span class="id">ball_</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; `|<span class="id">x</span>|)))).<br/>
<br/>
<span class="kwd">Section</span> <span class="id">pseudoMetric_of_normedDomain</span>.<br/>
<span class="kwd">Variables</span> (<span class="id">K</span> : <span class="id">numDomainType</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#ball_">R</a></span> : <span class="id">normedZmodType</span> <span class="id">K</span>).<br/>
<span class="kwd">Lemma</span> <span class="id">ball_norm_center</span> (<span class="id">x</span> : <span class="id">R</span>) (<span class="id">e</span> : <span class="id">K</span>) : 0 &lt; <span class="id">e</span> -&gt; <span class="id">ball_</span> <span class="id">Num.norm</span> <span class="id">x</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof506')">Proof.</span></div>
<div class="proofscript" id="proof506">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? /=; <span class="id">rewrite</span> <span class="id">subrr</span> <span class="id">normr0</span>. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">ball_norm_symmetric</span> (<span class="id">x</span> <span class="id">y</span> : <span class="id">R</span>) (<span class="id">e</span> : <span class="id">K</span>) :<br/>
&nbsp;&nbsp;<span class="id">ball_</span> <span class="id">Num.norm</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span> -&gt; <span class="id">ball_</span> <span class="id">Num.norm</span> <span class="id">y</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof507')">Proof.</span></div>
<div class="proofscript" id="proof507">
 <span class="kwd">by</span> <span class="id">rewrite</span> /= <span class="id">distrC</span>. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">ball_norm_triangle</span> (<span class="id">x</span> <span class="id">y</span> <span class="id">z</span> : <span class="id">R</span>) (<span class="id">e1</span> <span class="id">e2</span> : <span class="id"><a name="regular_topology">K</a></span>) :<br/>
&nbsp;&nbsp;<span class="id">ball_</span> <span class="id">Num.norm</span> <span class="id">x</span> <span class="id">e1</span> <span class="id"><a name="regular_topology.regular_topology">y</a></span> -&gt; <span class="id">ball_</span> <span class="id">Num.norm</span> <span class="id">y</span> <span class="id">e2</span> <span class="id">z</span> -&gt; <span class="id">ball_</span> <span class="id">Num.norm</span> <span class="id">x</span> (<span class="id">e1</span> + <span class="id">e2</span>) <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof508')">Proof.</span></div>
<div class="proofscript" id="proof508">
<span class="id">move</span>=&gt; /= ? ?; <span class="id">rewrite</span> -(<span class="id">subr0</span> <span class="id">x</span>) -(<span class="id">subrr</span> <span class="id">y</span>) <span class="id">opprD</span> <span class="id">opprK</span> (<span class="id">addrA</span> <span class="id">x</span> <span class="id">_</span> <span class="id">y</span>) -<span class="id">addrA</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">le_lt_trans</span> (<span class="id">ler_norm_add</span> <span class="id">_</span> <span class="id">_</span>)) // <span class="id">ltr_add</span>.<br/>
Qed.</div>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_of_normedDomain</span><br/>
&nbsp;&nbsp;: <span class="id">PseudoMetric.mixin_of</span> <span class="id">K</span> (@<span class="id">entourage_</span> <span class="id">K</span> <span class="id">R</span> <span class="id">R</span> (<span class="id">ball_</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; `|<span class="id">x</span>|)))<br/>
&nbsp;&nbsp;:= <span class="id">PseudoMetricMixin</span> <span class="id">ball_norm_center</span> <span class="id">ball_norm_symmetric</span> <span class="id">ball_norm_triangle</span> <span class="id">erefl</span>.<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_ball_normE</span> :<br/>
&nbsp;&nbsp;@<span class="id">nbhs_ball_</span> <span class="id">K</span> <span class="id">R</span> <span class="id">R</span> (<span class="id">ball_</span> <span class="id">Num.norm</span>) = <span class="id">nbhs_</span> (<span class="id">entourage_</span> (<span class="id">ball_</span> <span class="id">Num.norm</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof509')">Proof.</span></div>
<div class="proofscript" id="proof509">
<span class="id">rewrite</span> /<span class="id">nbhs_</span> <span class="id">entourage_E</span> <span class="id">predeq2E</span> =&gt; <span class="id">x</span> <span class="id">A</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; [<span class="id">e</span> <span class="id">egt0</span> <span class="id">sbeA</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball_</span> <span class="id">Num.norm</span> <span class="id">xy</span>.1 <span class="id">e</span> <span class="id">xy</span>.2] =&gt; //; <span class="kwd">exists</span> <span class="id">e</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">E</span> [<span class="id">e</span> <span class="id">egt0</span> <span class="id">sbeE</span>] <span class="id">sEA</span>]; <span class="kwd">exists</span> <span class="id">e</span> =&gt; // ??; <span class="id">apply</span>/<span class="id">sEA</span>/<span class="id">sbeE</span>.<br/>
Qed.</div>
<span class="kwd">End</span> <span class="id">pseudoMetric_of_normedDomain</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">regular_topology</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">regular_topology</span>.<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">pointedType</span> (<span class="id">R</span> : <span class="id">zmodType</span>) : <span class="id">pointedType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span> <span class="kwd">for</span> <span class="id">pointed_of_zmodule</span> <span class="id">R</span>].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">filteredType</span> (<span class="id">R</span> : <span class="id">numDomainType</span>) : <span class="id">filteredType</span> <span class="id">R</span> :=<br/>
&nbsp;&nbsp;[<span class="id">filteredType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span> <span class="kwd">for</span> <span class="id">filtered_of_normedZmod</span> <span class="id">R</span>].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">topologicalType</span> (<span class="id">R</span> : <span class="id">numFieldType</span>) : <span class="id">topologicalType</span> :=<br/>
&nbsp;&nbsp;<span class="id">TopologicalType</span> <span class="id">R</span>^<span class="id">o</span> (<span class="id">topologyOfEntourageMixin</span> (<span class="id">uniformityOfBallMixin</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id">nbhs_ball_normE</span> <span class="id">_</span> <span class="id">_</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.realType.R">pseudoMetric_of_normedDomain</a></span> <span class="id">_</span>))).<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">uniformType</span> (<span class="id">R</span> : <span class="id">numFieldType</span>) : <span class="id">uniformType</span> :=<br/>
&nbsp;&nbsp;<span class="id">UniformType</span> <span class="id">R</span>^<span class="id">o</span> (<span class="id">uniformityOfBallMixin</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id">nbhs_ball_normE</span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.realType.R">_</a></span>) (<span class="id">pseudoMetric_of_normedDomain</span> <span class="id">_</span>)).<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">pseudoMetricType</span> (<span class="id">R</span> : <span class="id">numFieldType</span>) :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetricType</span> <span class="id">R</span>^<span class="id">o</span> (@<span class="id">pseudoMetric_of_normedDomain</span> <span class="id">R</span> <span class="id">R</span>).<br/>
<span class="kwd">End</span> <span class="id">regular_topology</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">Exports</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointedType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filteredType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topologicalType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniformType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetricType</span>.<br/>
<span class="kwd">End</span> <span class="id">Exports</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">regular_topology</span>.<br/>
<span class="kwd">Export</span> <span class="id">regular_topology.Exports</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">numFieldTopology</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.rcfType.R">realType</a></span>.<br/>
<span class="kwd">Variable</span> (<span class="id">R</span> : <span class="id">realType</span>).<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">real_pointedType</span> := [<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">real_filteredType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">filteredType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.rcfType.R">filteredType</a></span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">real_topologicalType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.archiFieldType.R">real_uniformType</a></span> := [<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">real_pseudoMetricType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="kwd">End</span> <span class="id">realType</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">rcfType</span>.<br/>
<span class="kwd">Variable</span> (<span class="id">R</span> : <span class="id">rcfType</span>).<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">rcf_pointedType</span> := [<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">rcf_filteredType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">filteredType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">filteredType</span> <span class="id">R</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.archiFieldType.R">of</a></span> <span class="id">R</span>^<span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.archiFieldType.R">o</a></span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">rcf_topologicalType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">rcf_uniformType</span> := [<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">uniformType</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.realFieldType.R">of</a></span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">rcf_pseudoMetricType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="kwd">End</span> <span class="id">rcfType</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">archiFieldType</span>.<br/>
<span class="kwd">Variable</span> (<span class="id">R</span> : <span class="id">archiFieldType</span>).<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">archiField_pointedType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pointedType</span> <span class="id">of</span> <span class="id"><a name="numFieldTopology.realField_uniformType">R</a></span> <span class="kwd">for</span> [<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">archiField_filteredType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">filteredType</span> <span class="id"><a name="numFieldTopology.realField_pseudoMetricType">R</a></span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">filteredType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">archiField_topologicalType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">topologicalType</span> <span class="id"><a name="numFieldTopology.pointed_latticeType">of</a></span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">archiField_uniformType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.realField_pointedType">Local</a></span> <span class="kwd">Canonical</span> <span class="id">archiField_pseudoMetricType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="kwd">End</span> <span class="id">archiFieldType</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">realFieldType</span>.<br/>
<span class="kwd">Variable</span> (<span class="id">R</span> : <span class="id">realFieldType</span>).<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">realField_pointedType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pointedType</span> <span class="id">of</span> <span class="id"><a name="numFieldTopology.filtered_distrLatticeType">R</a></span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">realField_filteredType</span> :=<br/>
&nbsp;&nbsp;[<span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.realField_filteredType">filteredType</a></span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">filteredType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">realField_topologicalType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">realField_uniformType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">realField_pseudoMetricType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_latticeType</span> := [<span class="id">latticeType</span> <span class="id">of</span> <span class="id">realField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_distrLatticeType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">distrLatticeType</span> <span class="id">of</span> <span class="id">realField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_orderType</span> := [<span class="id"><a name="numFieldTopology.uniform_latticeType">orderType</a></span> <span class="id">of</span> <span class="id">realField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_realDomainType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">realDomainType</span> <span class="id">of</span> <span class="id">realField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_latticeType</span> := [<span class="id">latticeType</span> <span class="id">of</span> <span class="id">realField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_distrLatticeType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">distrLatticeType</span> <span class="id">of</span> <span class="id">realField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_orderType</span> := [<span class="id">orderType</span> <span class="id">of</span> <span class="id">realField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_realDomainType</span> :=<br/>
&nbsp;&nbsp;[<span class="id"><a name="numFieldTopology.pseudoMetric_distrLatticeType">realDomainType</a></span> <span class="id">of</span> <span class="id">realField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_latticeType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">latticeType</span> <span class="id"><a name="numFieldTopology.pseudoMetric_orderType">of</a></span> <span class="id">realField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_distrLatticeType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">distrLatticeType</span> <span class="id">of</span> <span class="id">realField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_orderType</span> := [<span class="id">orderType</span> <span class="id">of</span> <span class="id">realField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_realDomainType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">realDomainType</span> <span class="id">of</span> <span class="id">realField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_latticeType</span> := [<span class="id">latticeType</span> <span class="id">of</span> <span class="id">realField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_distrLatticeType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">distrLatticeType</span> <span class="id">of</span> <span class="id">realField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_orderType</span> := [<span class="id">orderType</span> <span class="id">of</span> <span class="id">realField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_realDomainType</span> := [<span class="id">realDomainType</span> <span class="id">of</span> <span class="id">realField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_latticeType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">latticeType</span> <span class="id">of</span> <span class="id">realField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_distrLatticeType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">distrLatticeType</span> <span class="id">of</span> <span class="id">realField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_orderType</span> := [<span class="id">orderType</span> <span class="id">of</span> <span class="id">realField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_realDomainType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">realDomainType</span> <span class="id">of</span> <span class="id">realField_pseudoMetricType</span>].<br/>
<span class="kwd">End</span> <span class="id">realFieldType</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">numClosedFieldType</span>.<br/>
<span class="kwd">Variable</span> (<span class="id"><a name="numFieldTopology.filtered_closedFieldType">R</a></span> : <span class="id">numClosedFieldType</span>).<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">numClosedField_pointedType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">numClosedField_filteredType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">filteredType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">filteredType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">numClosedField_topologicalType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">numClosedField_uniformType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">uniformType</span> <span class="id">of</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.numClosedField_uniformType">R</a></span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">numClosedField_pseudoMetricType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_decFieldType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">decFieldType</span> <span class="id">of</span> <span class="id">numClosedField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_closedFieldType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">closedFieldType</span> <span class="id">of</span> <span class="id">numClosedField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_decFieldType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">decFieldType</span> <span class="id">of</span> <span class="id">numClosedField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_closedFieldType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">closedFieldType</span> <span class="id">of</span> <span class="id">numClosedField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_decFieldType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">decFieldType</span> <span class="id">of</span> <span class="id">numClosedField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_closedFieldType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">closedFieldType</span> <span class="id">of</span> <span class="id">numClosedField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_decFieldType</span> := [<span class="id">decFieldType</span> <span class="id">of</span> <span class="id">numClosedField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_closedFieldType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">closedFieldType</span> <span class="id">of</span> <span class="id">numClosedField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_decFieldType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">decFieldType</span> <span class="id">of</span> <span class="id">numClosedField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_closedFieldType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">closedFieldType</span> <span class="id">of</span> <span class="id">numClosedField_pseudoMetricType</span>].<br/>
<span class="kwd">End</span> <span class="id">numClosedFieldType</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">numFieldType</span>.<br/>
<span class="kwd">Variable</span> (<span class="id">R</span> : <span class="id">numFieldType</span>).<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">numField_pointedType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pointedType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">numField_filteredType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">filteredType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">filteredType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id"><a name="numFieldTopology.pointed_numDomainType">numField_topologicalType</a></span> :=<br/>
&nbsp;&nbsp;[<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id">numField_uniformType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">uniformType</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="id">Local</span> <span class="kwd">Canonical</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.numField_filteredType">numField_pseudoMetricType</a></span> :=<br/>
&nbsp;&nbsp;[<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span> <span class="kwd">for</span> [<span class="id">pseudoMetricType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_ringType</span> := [<span class="id">ringType</span> <span class="id">of</span> <span class="id">numField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_comRingType</span> := [<span class="id">comRingType</span> <span class="id">of</span> <span class="id">numField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_unitRingType</span> := [<span class="id">unitRingType</span> <span class="id">of</span> <span class="id">numField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_comUnitRingType</span> := [<span class="id">comUnitRingType</span> <span class="id">of</span> <span class="id">numField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_idomainType</span> := [<span class="id">idomainType</span> <span class="id">of</span> <span class="id">numField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_fieldType</span> := [<span class="id">fieldType</span> <span class="id">of</span> <span class="id">numField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_porderType</span> := [<span class="id">porderType</span> <span class="id">of</span> <span class="id">numField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pointed_numDomainType</span> := [<span class="id">numDomainType</span> <span class="id">of</span> <span class="id">numField_pointedType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_ringType</span> := [<span class="id">ringType</span> <span class="id">of</span> <span class="id">numField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_comRingType</span> := [<span class="id">comRingType</span> <span class="id">of</span> <span class="id">numField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_unitRingType</span> := [<span class="id">unitRingType</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.numField_topologicalType">of</a></span> <span class="id">numField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id"><a name="numFieldTopology.topological_fieldType">filtered_comUnitRingType</a></span> :=<br/>
&nbsp;&nbsp;[<span class="id">comUnitRingType</span> <span class="id">of</span> <span class="id">numField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_idomainType</span> := [<span class="id">idomainType</span> <span class="id">of</span> <span class="id">numField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_fieldType</span> := [<span class="id">fieldType</span> <span class="id">of</span> <span class="id">numField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_porderType</span> := [<span class="id">porderType</span> <span class="id">of</span> <span class="id">numField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">filtered_numDomainType</span> := [<span class="id">numDomainType</span> <span class="id">of</span> <span class="id">numField_filteredType</span>].<br/>
<span class="kwd">Definition</span> <span class="id"><a name="numFieldTopology.uniform_unitRingType">topological_ringType</a></span> := [<span class="id">ringType</span> <span class="id">of</span> <span class="id">numField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id"><a name="numFieldTopology.uniform_comUnitRingType">topological_comRingType</a></span> := [<span class="id">comRingType</span> <span class="id">of</span> <span class="id">numField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id"><a name="numFieldTopology.uniform_idomainType">topological_unitRingType</a></span> :=<br/>
&nbsp;&nbsp;[<span class="id">unitRingType</span> <span class="id">of</span> <span class="id">numField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_comUnitRingType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">comUnitRingType</span> <span class="id">of</span> <span class="id">numField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_idomainType</span> := [<span class="id">idomainType</span> <span class="id">of</span> <span class="id">numField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_fieldType</span> := [<span class="id">fieldType</span> <span class="id">of</span> <span class="id">numField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">topological_porderType</span> := [<span class="id">porderType</span> <span class="id">of</span> <span class="id">numField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.numField_pseudoMetricType">topological_numDomainType</a></span> :=<br/>
&nbsp;&nbsp;[<span class="id">numDomainType</span> <span class="id">of</span> <span class="id">numField_topologicalType</span>].<br/>
<span class="kwd">Definition</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.numField_pseudoMetricType">uniform_ringType</a></span> := [<span class="id">ringType</span> <span class="id">of</span> <span class="id">numField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_comRingType</span> := [<span class="id">comRingType</span> <span class="id">of</span> <span class="id">numField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_unitRingType</span> := [<span class="id">unitRingType</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.numField_pseudoMetricType">of</a></span> <span class="id">numField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_comUnitRingType</span> := [<span class="id">comUnitRingType</span> <span class="id">of</span> <span class="id">numField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id"><a name="numFieldTopology.pseudoMetric_porderType">uniform_idomainType</a></span> := [<span class="id">idomainType</span> <span class="id">of</span> <span class="id">numField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_fieldType</span> := [<span class="id">fieldType</span> <span class="id">of</span> <span class="id">numField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_porderType</span> := [<span class="id">porderType</span> <span class="id">of</span> <span class="id">numField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">uniform_numDomainType</span> := [<span class="id">numDomainType</span> <span class="id">of</span> <span class="id">numField_uniformType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_ringType</span> := [<span class="id">ringType</span> <span class="id">of</span> <span class="id">numField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_comRingType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">comRingType</span> <span class="id">of</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.real_filteredType">numField_pseudoMetricType</a></span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_unitRingType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">unitRingType</span> <span class="id">of</span> <span class="id">numField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_comUnitRingType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">comUnitRingType</span> <span class="id">of</span> <span class="id">numField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_idomainType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">idomainType</span> <span class="id">of</span> <span class="id">numField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_fieldType</span> := [<span class="id">fieldType</span> <span class="id">of</span> <span class="id">numField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_porderType</span> := [<span class="id">porderType</span> <span class="id">of</span> <span class="id">numField_pseudoMetricType</span>].<br/>
<span class="kwd">Definition</span> <span class="id">pseudoMetric_numDomainType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">numDomainType</span> <span class="id">of</span> <span class="id">numField_pseudoMetricType</span>].<br/>
<span class="kwd">End</span> <span class="id">numFieldType</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">Exports</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">real_pointedType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">real_filteredType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">real_topologicalType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">real_uniformType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">real_pseudoMetricType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">real_pointedType</span> : <span class="id">realType</span> &gt;-&gt; <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">real_filteredType</span> : <span class="id">realType</span> &gt;-&gt; <span class="id">filteredType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">real_topologicalType</span> : <span class="id">realType</span> &gt;-&gt; <span class="id">topologicalType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">real_uniformType</span> : <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.archiField_filteredType">realType</a></span> &gt;-&gt; <span class="id">uniformType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">real_pseudoMetricType</span> : <span class="id">realType</span> &gt;-&gt; <span class="id">pseudoMetricType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">rcf_pointedType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">rcf_filteredType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">rcf_topologicalType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">rcf_uniformType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">rcf_pseudoMetricType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">rcf_pointedType</span> : <span class="id">rcfType</span> &gt;-&gt; <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">rcf_filteredType</span> : <span class="id">rcfType</span> &gt;-&gt; <span class="id">filteredType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">rcf_topologicalType</span> : <span class="id">rcfType</span> &gt;-&gt; <span class="id">topologicalType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">rcf_uniformType</span> : <span class="id">rcfType</span> &gt;-&gt; <span class="id">uniformType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">rcf_pseudoMetricType</span> : <span class="id">rcfType</span> &gt;-&gt; <span class="id">pseudoMetricType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">archiField_pointedType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">archiField_filteredType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">archiField_topologicalType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">archiField_uniformType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">archiField_pseudoMetricType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">archiField_pointedType</span> : <span class="id">archiFieldType</span> &gt;-&gt; <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">archiField_filteredType</span> : <span class="id">archiFieldType</span> &gt;-&gt; <span class="id">filteredType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">archiField_topologicalType</span> : <span class="id">archiFieldType</span> &gt;-&gt; <span class="id">topologicalType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">archiField_uniformType</span> : <span class="id">archiFieldType</span> &gt;-&gt; <span class="id">uniformType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">archiField_pseudoMetricType</span> : <span class="id">archiFieldType</span> &gt;-&gt; <span class="id">pseudoMetricType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">realField_pointedType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">realField_filteredType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">realField_topologicalType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">realField_uniformType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">realField_pseudoMetricType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_latticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_distrLatticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_orderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_realDomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_latticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_distrLatticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_orderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_realDomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_latticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_distrLatticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_orderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_realDomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_latticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_distrLatticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_orderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_realDomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_latticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_distrLatticeType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_orderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_realDomainType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">realField_pointedType</span> : <span class="id">realFieldType</span> &gt;-&gt; <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">realField_filteredType</span> : <span class="id">realFieldType</span> &gt;-&gt; <span class="id">filteredType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">realField_topologicalType</span> : <span class="id">realFieldType</span> &gt;-&gt; <span class="id">topologicalType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">realField_uniformType</span> : <span class="id">realFieldType</span> &gt;-&gt; <span class="id">uniformType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">realField_pseudoMetricType</span> : <span class="id">realFieldType</span> &gt;-&gt; <span class="id">pseudoMetricType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numClosedField_pointedType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numClosedField_filteredType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numClosedField_topologicalType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numClosedField_uniformType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numClosedField_pseudoMetricType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_decFieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_closedFieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_decFieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_closedFieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_decFieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_closedFieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_decFieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_closedFieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_decFieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_closedFieldType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numClosedField_pointedType</span> : <span class="id">numClosedFieldType</span> &gt;-&gt; <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numClosedField_filteredType</span> : <span class="id">numClosedFieldType</span> &gt;-&gt; <span class="id">filteredType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numClosedField_topologicalType</span> :<br/>
&nbsp;&nbsp;<span class="id">numClosedFieldType</span> &gt;-&gt; <span class="id">topologicalType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numClosedField_uniformType</span> : <span class="id">numClosedFieldType</span> &gt;-&gt; <span class="id">uniformType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numClosedField_pseudoMetricType</span> :<br/>
&nbsp;&nbsp;<span class="id">numClosedFieldType</span> &gt;-&gt; <span class="id">pseudoMetricType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numField_pointedType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numField_filteredType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numField_topologicalType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numField_uniformType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">numField_pseudoMetricType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_ringType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_comRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_unitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_comUnitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_idomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_fieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_porderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pointed_numDomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_ringType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_comRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_unitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_comUnitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_idomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_fieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_porderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">filtered_numDomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_ringType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_comRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_unitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_comUnitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_idomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_fieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_porderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">topological_numDomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_ringType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_comRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_unitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_comUnitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_idomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_fieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_porderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">uniform_numDomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_ringType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_comRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_unitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_comUnitRingType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_idomainType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_fieldType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_porderType</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">pseudoMetric_numDomainType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numField_pointedType</span> : <span class="id">numFieldType</span> &gt;-&gt; <span class="id">pointedType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numField_filteredType</span> : <span class="id">numFieldType</span> &gt;-&gt; <span class="id">filteredType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numField_topologicalType</span> : <span class="id">numFieldType</span> &gt;-&gt; <span class="id">topologicalType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numField_uniformType</span> : <span class="id">numFieldType</span> &gt;-&gt; <span class="id">uniformType</span>.<br/>
<span class="kwd">Coercion</span> <span class="id">numField_pseudoMetricType</span> : <span class="id">numFieldType</span> &gt;-&gt; <span class="id">pseudoMetricType</span>.<br/>
<span class="kwd">End</span> <span class="id">Exports</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">numFieldTopology</span>.<br/>
<span class="kwd">Import</span> <span class="id">numFieldTopology.Exports</span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id">Proper_dnbhs_regular_numFieldType</span> (<span class="id">R</span> : <span class="id">numFieldType</span>) (<span class="id">x</span> : <span class="id">R</span>^<span class="id">o</span>) :<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">x</span>^'.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof510')">Proof.</span></div>
<div class="proofscript" id="proof510">
<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#RestrictedUniformTopology.V">Build_ProperFilter</a></span> =&gt; <span class="id">A</span> /<span class="id">nbhs_ballP</span>[<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>] <span class="id">Ae</span>].<br/>
<span class="kwd">exists</span> (<span class="id">x</span> + <span class="id">e</span>%:<span class="id">num</span> / 2)%<span class="id">R</span>; <span class="id">apply</span>: <span class="id">Ae</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eq_sym</span> <span class="id">addrC</span> -<span class="id">subr_eq</span> <span class="id">subrr</span> <span class="id">eq_sym</span>.<br/>
<span class="id">rewrite</span> /<span class="id">ball</span> /= <span class="id"><a href="mathcomp.analysis.topology.html#RestrictedUniformTopology.V">opprD</a></span> <span class="id">addrA</span> <span class="id">subrr</span> <span class="id"><a href="mathcomp.analysis.topology.html#RestrictedUniformTopology.A">distrC</a></span> <span class="id">subr0</span> <span class="id">ger0_norm</span> //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> {2}(<span class="id">splitr</span> <span class="id">e</span>%:<span class="id">num</span>) <span class="id">ltr_spaddl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">Rhausdorff</span> (<span class="id">R</span> : <span class="id">realFieldType</span>) : <span class="id">hausdorff_space</span> <span class="id">R</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof511')">Proof.</span></div>
<div class="proofscript" id="proof511">
<span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">y</span> <span class="id">clxy</span>; <span class="id">apply</span>/<span class="id">eqP</span>; <span class="id">rewrite</span> <span class="id">eq_le</span>.<br/>
<span class="id">apply</span>/<span class="id">in_segment_addgt0Pr</span> =&gt; <span class="id">_</span> /<span class="id">posnumP</span>[<span class="id">e</span>].<br/>
<span class="id">rewrite</span> <span class="id">in_itv</span> /= -<span class="id">ler_distl</span>; <span class="id"><a href="mathcomp.analysis.topology.html#fct_RestrictedUniformTopology">set</a></span> <span class="id">he</span> := (<span class="id">e</span>%:<span class="id">num</span> / 2)%:<span class="id">pos</span>.<br/>
<span class="id">have</span> [<span class="id">z</span> [<span class="id">zx_he</span> <span class="id">yz_he</span>]] := <span class="id">clxy</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">nbhsx_ballx</span> <span class="id">x</span> <span class="id">he</span>) (<span class="id">nbhsx_ballx</span> <span class="id">y</span> <span class="id">he</span>).<br/>
<span class="id">have</span> := <span class="id">ball_triangle</span> <span class="id">yz_he</span> (<span class="id">ball_sym</span> <span class="id">zx_he</span>).<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">mulr2n</span> -<span class="id"><a name="f:2925">mulr_natr</a></span> <span class="id">divfK</span> // =&gt; /<span class="id">ltW</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">RestrictedUniformTopology</span>.<br/>
<span class="kwd">Context</span> {<span class="id">U</span> : <span class="id">choiceType</span>} (<span class="id">A</span> : <span class="id"><a name="y:2929">set</a></span> <span class="id">U</span>) {<span class="id">V</span> : <span class="id">uniformType</span>} .<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">fct_RestrictedUniform</span> := <span class="kwd">let</span> <span class="id">_</span> := <span class="id">A</span> <span class="kwd">in</span> <span class="id">U</span> -&gt; <span class="id">V</span>.<br/>
<span class="kwd">Definition</span> <span class="id">fct_RestrictedUniformTopology</span> :=<br/>
&nbsp;&nbsp;@<span class="id">weak_uniformType</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;([<span class="id">pointedType</span> <span class="id">of</span> @<span class="id">fct_RestrictedUniform</span>])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">fct_uniformType</span> [<span class="id">choiceType</span> <span class="id">of</span> { <span class="id">x</span> : <span class="id">U</span> | <span class="id">x</span> \<span class="kwd">in</span> <span class="id">A</span> }] <span class="id">V</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id">sigL</span> <span class="id">U</span> <span class="id">V</span> <span class="id">A</span>).<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">fct_RestrictUniformFilteredType</span>:=<br/>
&nbsp;&nbsp;[<span class="id">filteredType</span> <span class="id">fct_RestrictedUniform</span> <span class="id">of</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fct_RestrictedUniform</span> <span class="kwd">for</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#RestrictedUniformTopology.A">fct_RestrictedUniformTopology</a></span>].<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">fct_RestrictUniformTopologicalType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">fct_RestrictedUniform</span> <span class="kwd">for</span> <span class="id">fct_RestrictedUniformTopology</span>].<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">fct_restrictedUniformType</span> :=<br/>
&nbsp;&nbsp;[<span class="id">uniformType</span> <span class="id">of</span> <span class="id">fct_RestrictedUniform</span> <span class="kwd">for</span> <span class="id">fct_RestrictedUniformTopology</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_nbhs</span> (<span class="id">f</span> : <span class="id">fct_RestrictedUniformTopology</span>) <span class="id">P</span>:<br/>
&nbsp;&nbsp;<span class="id">nbhs</span> <span class="id">f</span> <span class="id">P</span> &lt;-&gt; (<span class="kwd">exists</span> <span class="id">E</span>, <span class="id"><a href="mathcomp.analysis.topology.html#entourage">entourage</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#fct_restrictedUniformType">E</a></span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">set</span> <span class="id">h</span> | <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">A</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_from">y</a></span> -&gt; <span class="id">E</span>(<span class="id">f</span> <span class="id">y</span>, <span class="id">h</span> <span class="id">y</span>)] `&lt;=` <span class="id">P</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof512')">Proof.</span></div>
<div class="proofscript" id="proof512">
<span class="id">split</span>=&gt; [[<span class="id">Q</span> [[/= <span class="id">W</span> <span class="id">oW</span> &lt;- /=] <span class="id">Wf</span> <span class="id"><a href="mathcomp.analysis.topology.html#RestrictedUniformTopology.U">subP</a></span>]]|[<span class="id">E</span> [<span class="id">entE</span> <span class="id">subP</span>]]].<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">openE</span> /= /<span class="id">interior</span> <span class="kwd">in</span> <span class="id">oW</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>: (<span class="id">oW</span> <span class="id">_</span> <span class="id">Wf</span>) =&gt; ? [ /= <span class="id">E</span> <span class="id">entE</span>] <span class="id">Esub</span> <span class="id">subW</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">E</span>; <span class="id">split</span>=&gt; // <span class="id">h</span> <span class="id">Eh</span>; <span class="id">apply</span>/<span class="id">subP</span>/<span class="id">subW</span>/<span class="id">Esub</span> =&gt; /= [[<span class="id">u</span> <span class="id">Au</span>]].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">Eh</span> =&gt; /=; <span class="id">rewrite</span> -<span class="id">inE</span>.<br/>
<span class="id">near</span>=&gt; <span class="id">g</span>; <span class="id">apply</span>: <span class="id">subP</span> =&gt; <span class="id">y</span> /<span class="id">mem_set</span> <span class="id">Ay</span>; <span class="id">rewrite</span> -!(<span class="id">sigLE</span> <span class="id">A</span>).<br/>
<span class="id">move</span>: (<span class="id">SigSub</span> <span class="id">_</span>); <span class="id">near</span>: <span class="id">g</span>.<br/>
<span class="id">have</span> := (@<span class="id">cvg_image</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">sigL</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#mem_set">A</a></span>) <span class="id">_</span> <span class="id">f</span> (<span class="id">nbhs_filter</span> <span class="id">f</span>)<br/>
&nbsp;&nbsp;(<span class="id">image_sigL</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#exist">point</a></span>)).1 <span class="id">cvg_id</span> [<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#in_mem">set</a></span> <span class="id">h</span> | <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">E</span> (<span class="id">sigL</span> <span class="id">A</span> <span class="id">f</span> <span class="id">y</span>, <span class="id">h</span> <span class="id">y</span>)].<br/>
<span class="id">case</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">fg</span> | <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">E</span> (<span class="id">fg</span>.1 <span class="id">y</span>, <span class="id">fg</span>.2 <span class="id">y</span>)]; [<span class="kwd">exists</span> <span class="id">E</span>|].<br/>
<span class="id">move</span>=&gt; <span class="id">B</span> <span class="id">nbhsB</span> <span class="id">rBrE</span>; <span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">_</span> <span class="id">nbhsB</span>) =&gt; <span class="id">g</span> <span class="id">Bg</span> [<span class="id">y</span> <span class="id">yA</span>].<br/>
<span class="kwd">by</span> <span class="id">move</span>: <span class="id">rBrE</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">case</span> =&gt; [+ <span class="id">_</span>]; <span class="id">apply</span>; <span class="kwd">exists</span> <span class="id">g</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_entourage</span> :<br/>
&nbsp;&nbsp;@<span class="id">entourage</span> <span class="id">fct_restrictedUniformType</span> =<br/>
&nbsp;&nbsp;<span class="id">filter_from</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id">entourage</span> <span class="id">V</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">P</span> =&gt; [<span class="id">set</span> <span class="id">fg</span> | <span class="kwd">forall</span> <span class="id">t</span> : <span class="id">U</span>, <span class="id">A</span> <span class="id">t</span> -&gt; <span class="id">P</span> (<span class="id">fg</span>.1 <span class="id"><a href="mathcomp.analysis.topology.html#cvg_to">t</a></span>, <span class="id">fg</span>.2 <span class="id">t</span>)]).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof513')">Proof.</span></div>
<div class="proofscript" id="proof513">
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id">P</span> /=.<br/>
&nbsp;&nbsp;<span class="id">case</span>=&gt; /= <span class="id">E</span> [<span class="id">F</span> <span class="id">entF</span> <span class="id">FsubE</span> <span class="id">EsubP</span>]; <span class="kwd">exists</span> <span class="id">F</span> =&gt; //; <span class="id">case</span>=&gt; <span class="id">f</span> <span class="id">g</span> <span class="id">Ffg</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">EsubP</span>/<span class="id">FsubE</span>=&gt; [[<span class="id">x</span> <span class="id">p</span>]] /=; <span class="id">apply</span>: <span class="id">Ffg</span>; <span class="id">move</span>/<span class="id">set_mem</span>: (<span class="id">p</span>).<br/>
<span class="id">case</span>=&gt; <span class="id">E</span> <span class="id">entE</span> <span class="id">EsubP</span>; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">fg</span> | <span class="kwd">forall</span> <span class="id">t</span>, <span class="id">E</span> (<span class="id">fg</span>.1 <span class="id">t</span>, <span class="id">fg</span>.2 <span class="id">t</span>)].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">E</span>.<br/>
<span class="id">case</span>=&gt; <span class="id">f</span> <span class="id">g</span> <span class="id">Efg</span>; <span class="id">apply</span>: <span class="id">EsubP</span> =&gt; <span class="id">t</span> /<span class="id">mem_set</span> <span class="id">At</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>: <span class="id">Efg</span> =&gt; /= /(<span class="id"><a name="A:2947">_</a></span> (@<span class="id">exist</span> <span class="id">_</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">in_mem</span> <span class="id">x</span> (<span class="id">mem</span> <span class="id">A</span>)) <span class="id">_</span> <span class="id">At</span>)).<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">RestrictedUniformTopology</span>.<br/>
<br/>
<span class="kwd">Notation</span> "{ '<span class="id">uniform</span>`' <span class="id">A</span> -&gt; <span class="id">V</span> }" := (@<span class="id">fct_RestrictedUniform</span> <span class="id">_</span> <span class="id">A</span> <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Notation</span> "{ '<span class="id">uniform</span>' <span class="id"><a name="V:2952">U</a></span> -&gt; <span class="id">V</span> }" := ({<span class="id">uniform</span>` [<span class="id">set</span>: <span class="id">U</span>] -&gt; <span class="id">V</span>}) :<br/>
&nbsp;&nbsp;<span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Notation</span> "{ '<span class="id">uniform</span>' <span class="id">A</span> , <span class="id">F</span> --&gt; <span class="id">f</span> }" :=<br/>
&nbsp;&nbsp;(<span class="id">cvg_to</span> [<span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">filter</a></span> <span class="id">of</span> <span class="id">F</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">filter_of</span> (<span class="id">Phantom</span> (<span class="id">fct_RestrictedUniform</span> <span class="id">A</span>) <span class="id"><a href="mathcomp.analysis.topology.html#fct_Pointwise">f</a></span>)))<br/>
&nbsp;&nbsp;&nbsp;: <span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Notation</span> "{ '<span class="id">uniform</span>' , <span class="id">F</span> --&gt; <span class="id">f</span> }" :=<br/>
&nbsp;&nbsp;(<span class="id">cvg_to</span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">filter_of</span> (<span class="id">Phantom</span> (<span class="id">fct_RestrictedUniform</span> <span class="id">setT</span>) <span class="id">f</span>)))<br/>
&nbsp;&nbsp;&nbsp;: <span class="id">classical_set_scope</span>.<br/>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">restricted_cvgE</span> {<span class="id">U</span> : <span class="id">choiceType</span>} {<span class="id">V</span> : <span class="id">uniformType</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>))) <span class="id">A</span> (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;{<span class="id">uniform</span> <span class="id">A</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} = (<span class="id">F</span> --&gt; (<span class="id">f</span> : {<span class="id">uniform</span>` <span class="id">A</span> -&gt; <span class="id">V</span>})).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof514')">Proof.</span></div>
<div class="proofscript" id="proof514">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">fct_Pointwise</span> <span class="id">U</span> (<span class="id">V</span>: <span class="id">topologicalType</span>) := <span class="id">U</span> -&gt; <span class="id">V</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">fct_PointwiseTopology</span> (<span class="id">U</span> : <span class="kwd">Type</span>) (<span class="id">V</span> : <span class="id">topologicalType</span>) :=<br/>
&nbsp;&nbsp;@<span class="id">product_topologicalType</span> <span class="id">U</span> (<span class="kwd">fun</span>=&gt; <span class="id">V</span>).<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">fct_PointwiseFilteredType</span> (<span class="id">U</span> : <span class="kwd">Type</span>) (<span class="id">V</span> : <span class="id">topologicalType</span>) :=<br/>
&nbsp;&nbsp;[<span class="id">filteredType</span> @<span class="id">fct_Pointwise</span> <span class="id">U</span> <span class="id">V</span> <span class="id">of</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@<span class="id">fct_Pointwise</span> <span class="id">U</span> <span class="id">V</span> <span class="kwd">for</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@<span class="id">fct_PointwiseTopology</span> <span class="id">U</span> <span class="id">V</span>].<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">fct_PointwiseTopologicalType</span> (<span class="id">U</span> : <span class="kwd">Type</span>) (<span class="id">V</span> : <span class="id">topologicalType</span>) :=<br/>
&nbsp;&nbsp;[<span class="id">topologicalType</span> <span class="id">of</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@<span class="id">fct_Pointwise</span> <span class="id">U</span> <span class="id">V</span> <span class="kwd">for</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@<span class="id">fct_PointwiseTopology</span> <span class="id">U</span> <span class="id"><a href="mathcomp.analysis.topology.html#filter_of">V</a></span>].<br/>
<br/>
<span class="kwd">Notation</span> "{ '<span class="id">ptws</span>' <span class="id">U</span> -&gt; <span class="id">V</span> }" := (@<span class="id">fct_Pointwise</span> <span class="id"><a href="mathcomp.analysis.topology.html#filterS">U</a></span> <span class="id">V</span>).<br/>
<br/>
<span class="kwd">Notation</span> "{ '<span class="id">ptws</span>' , <span class="id">F</span> --&gt; <span class="id">f</span> }" :=<br/>
&nbsp;&nbsp;(<span class="id">cvg_to</span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>] (<span class="id">filter_of</span> (<span class="id">Phantom</span> (@<span class="id">fct_Pointwise</span> <span class="id">_</span> <span class="id">_</span>) <span class="id">f</span>)))<br/>
&nbsp;&nbsp;: <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_cvgE</span> {<span class="id">U</span> : <span class="kwd">Type</span>} {<span class="id"><a href="mathcomp.classical.classical_sets.html#set">V</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.U">topologicalType</a></span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span>(<span class="id">U</span> -&gt; <span class="id">V</span>))) (<span class="id">A</span> : <span class="id">set</span> <span class="id">U</span>) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;{<span class="id">ptws</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} = (<span class="id">F</span> --&gt; (<span class="id">f</span> : {<span class="id">ptws</span> <span class="id">U</span> -&gt; <span class="id">V</span>})).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof515')">Proof.</span></div>
<div class="proofscript" id="proof515">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">UniformCvgLemmas</span>.<br/>
<span class="kwd">Context</span> {<span class="id">U</span> : <span class="id">choiceType</span>} {<span class="id">V</span> : <span class="id">uniformType</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_set1</span> <span class="id">F</span> (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) (<span class="id">x</span> : <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; {<span class="id">uniform</span> [<span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.U">set</a></span> <span class="id">x</span>], <span class="id">F</span> --&gt; <span class="id">f</span>} = ((<span class="id">g</span> <span class="id">x</span>) @[<span class="id"><a href="mathcomp.analysis.topology.html#Filter">g</a></span> --&gt; <span class="id">F</span>] --&gt; <span class="id">f</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof516')">Proof.</span></div>
<div class="proofscript" id="proof516">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; + <span class="id">W</span> =&gt; /(<span class="id">_</span> [<span class="id">set</span> <span class="id">t</span> | <span class="id">W</span> (<span class="id">t</span> <span class="id">x</span>)]) +; <span class="id">rewrite</span> /<span class="id">filter_of</span> -<span class="id">nbhs_entourageE</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">uniform_nbhs</span> =&gt; + [<span class="id">Q</span> <span class="id">entQ</span> <span class="id">subW</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>; <span class="kwd">exists</span> <span class="id">Q</span>; <span class="id">split</span> =&gt; // <span class="id">h</span> <span class="id">Qf</span>; <span class="id">exact</span>/<span class="id">subW</span>/<span class="id">Qf</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">Ff</span> <span class="id">W</span>; <span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.U">rewrite</a></span> /<span class="id">filter_of</span> <span class="id">uniform_nbhs</span> =&gt; [[<span class="id">E</span>] [<span class="id">entE</span> <span class="id">subW</span>]].<br/>
<span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">subW</span>); <span class="id">move</span>/(<span class="id">nbhs_entourage</span> (<span class="id">f</span> <span class="id">x</span>))/<span class="id">Ff</span>: <span class="id">entE</span> =&gt; //=; <span class="id">near_simpl</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filter_app</span>; <span class="id">apply</span>: <span class="id">nearW</span>=&gt; ? ? ? -&gt;.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_subset_nbhs</span> (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) (<span class="id">A</span> <span class="id">B</span> : <span class="id">set</span> <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id">B</span> `&lt;=` <span class="id">A</span> -&gt; <span class="id">nbhs</span> (<span class="id">f</span> : {<span class="id">uniform</span>` <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.classical.functions.html#cst">V</a></span>}) `=&gt;` <span class="id">nbhs</span> (<span class="id"><a href="mathcomp.analysis.topology.html#cvg_trans">f</a></span> : {<span class="id">uniform</span>` <span class="id">B</span> -&gt; <span class="id">V</span>}).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof517')">Proof.</span></div>
<div class="proofscript" id="proof517">
<span class="id">move</span> =&gt; <span class="id">BsubA</span> <span class="id">P</span> /<span class="id">uniform_nbhs</span> [<span class="id">E</span> [<span class="id">entE</span> <span class="id">EsubP</span>]].<br/>
<span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">EsubP</span>); <span class="id">apply</span>/<span class="id">uniform_nbhs</span>; <span class="kwd">exists</span> <span class="id">E</span>; <span class="id">split</span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">h</span> <span class="id"><a name="cvg_sigL">Eh</a></span> <span class="id">y</span> /<span class="id">BsubA</span> <span class="id">Ay</span>; <span class="id">exact</span>: <span class="id">Eh</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">uniform_subset_cvg</a></span> (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) (<span class="id">A</span> <span class="id">B</span> : <span class="id">set</span> <span class="id">U</span>) <span class="id">F</span> :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; <span class="id">B</span> `&lt;=` <span class="id">A</span> -&gt; {<span class="id"><a href="mathcomp.classical.functions.html#sigL">uniform</a></span> <span class="id">A</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} -&gt; {<span class="id">uniform</span> <span class="id">B</span>, <span class="id">F</span> --&gt; <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof518')">Proof.</span></div>
<div class="proofscript" id="proof518">
<span class="id">move</span> =&gt; <span class="id">FF</span> /<span class="id">uniform_subset_nbhs</span> =&gt; /(<span class="id">_</span> <span class="id">f</span>).<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">nbhsF</span> <span class="id">Acvg</span>; <span class="id"><a href="mathcomp.analysis.topology.html#filterS">apply</a></span>: <span class="id">cvg_trans</span>; [<span class="id">exact</span>: <span class="id">Acvg</span>|<span class="id">exact</span>: <span class="id">nbhsF</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_uniform_cvg</span>  (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>))) :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; {<span class="id">uniform</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} -&gt; {<span class="id">ptws</span>, <span class="id">F</span> --&gt; <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof519')">Proof.</span></div>
<div class="proofscript" id="proof519">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">rewrite</span> <span class="id">cvg_sup</span> =&gt; + <span class="id">i</span>; <span class="id">have</span> <span class="id">isubT</span> : [<span class="id">set</span> <span class="id">i</span>] `&lt;=` <span class="id">setT</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ?.<br/>
<span class="id">move</span>=&gt; /(<span class="id">uniform_subset_cvg</span> <span class="id">_</span> <span class="id">isubT</span>); <span class="id">rewrite</span> <span class="id">uniform_set1</span>.<br/>
<span class="id">rewrite</span> <span class="id">cvg_image</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>=&gt; <span class="id">v</span> // <span class="id">_</span>; <span class="kwd">exists</span> (<span class="id">cst</span> <span class="id">v</span>).<br/>
<span class="id">apply</span>: <span class="id">cvg_trans</span> =&gt; <span class="id">W</span> /=; <span class="id">rewrite</span> <span class="id">nbhs_simpl</span>; <span class="kwd">exists</span> (@^~ <span class="id">i</span> @^-1` <span class="id">W</span>) =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">image_preimage</span> // <span class="id">eqEsubset</span>; <span class="id">split</span>=&gt; // <span class="id">j</span> <span class="id">_</span>; <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">_</span> =&gt; <span class="id">j</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_sigL</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">U</span>) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id"><a name="f:2993">V</a></span>))) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;{<span class="id">uniform</span> <span class="id">A</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} &lt;-&gt;<br/>
&nbsp;&nbsp;{<span class="id">uniform</span>, <span class="id">sigL</span> <span class="id">A</span> @ <span class="id">F</span> --&gt; <span class="id">sigL</span> <span class="id">A</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof520')">Proof.</span></div>
<div class="proofscript" id="proof520">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">split</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">cvgF</span> <span class="id">P</span>' /= /<span class="id">uniform_nbhs</span> [ <span class="id">E</span> [/= <span class="id">entE</span> <span class="id">EsubP</span>]].<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">EsubP</span>); <span class="id">apply</span>: <span class="id">cvgF</span> =&gt; /=.<br/>
&nbsp;&nbsp;<span class="id"><a name="A:2995">apply</a></span>: (<span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.U">filterS</a></span> ( <span class="id">P</span>:= [<span class="id">set</span> <span class="id">h</span> | <span class="kwd">forall</span> <span class="id">y</span>, <span class="id"><a href="mathcomp.analysis.topology.html#hausdorff_space">A</a></span> <span class="id">y</span> -&gt; <span class="id">E</span>(<span class="id">f</span> <span class="id">y</span>, <span class="id">h</span> <span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.V">y</a></span>)])).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">h</span>/= <span class="id">Eh</span> [<span class="id">y</span> ?] <span class="id">_</span>; <span class="id">apply</span>: <span class="id">Eh</span>; <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.classical.boolp.html#propeqE">inE</a></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="kwd">by</span> (<span class="id">apply</span>/<span class="id">uniform_nbhs</span>; <span class="id">eexists</span>; <span class="id">split</span>; <span class="id">eauto</span>).<br/>
- <span class="id">move</span>=&gt; <span class="id">cvgF</span> <span class="id">P</span>' /= /<span class="id">uniform_nbhs</span> [ <span class="id">E</span> [/= <span class="id">entE</span> <span class="id">EsubP</span>]].<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">EsubP</span>).<br/>
&nbsp;&nbsp;<span class="id">move</span>: (<span class="id">cvgF</span>  [<span class="id">set</span> <span class="id">h</span> | (<span class="kwd">forall</span> <span class="id">y</span> , <span class="id">E</span> (<span class="id">sigL</span> <span class="id">A</span> <span class="id">f</span> <span class="id">y</span>, <span class="id">h</span> <span class="id">y</span>))]) =&gt; /=.<br/>
&nbsp;&nbsp;<span class="id">set</span> <span class="id">Q</span> := (<span class="id">x</span> <span class="kwd">in</span> (<span class="id">_</span> -&gt; <span class="id">x</span>) -&gt; <span class="id">_</span>); <span class="id">move</span>=&gt; <span class="id">W</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span>: <span class="id">Q</span> <span class="kwd">by</span> <span class="id">apply</span> <span class="id">W</span>, <span class="id">uniform_nbhs</span>; <span class="kwd">exists</span> <span class="id">E</span>; <span class="id">split</span> =&gt; // <span class="id">h</span> + ?; <span class="id">apply</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> {}/<span class="id">W</span> {}/<span class="id">Q</span>; <span class="id">near_simpl</span> =&gt; /= <span class="id">R</span>; <span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">_</span> <span class="id">R</span>) =&gt; <span class="id">h</span> /=.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">forall_sig</span> /<span class="id"><a name="f:3003">sigL</a></span> /=.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">eq_in_close</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">U</span>) (<span class="id">f</span> <span class="id">g</span> : {<span class="id">uniform</span>` <span class="id">A</span> -&gt; <span class="id">V</span>}) :<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> <span class="id">A</span>, <span class="id">f</span> =1 <span class="id">g</span>} -&gt; <span class="id">close</span> <span class="id">f</span> <span class="id">g</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof521')">Proof.</span></div>
<div class="proofscript" id="proof521">
<span class="id">rewrite</span> <span class="id">entourage_close</span> =&gt; /<span class="id">eq_sigLP</span> <span class="id">eqfg</span> ? [<span class="id">E</span> <span class="id">entE</span>]; <span class="id">apply</span>=&gt; /=.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">map_pair</span> <span class="id">eqfg</span>; <span class="id">exact</span>: <span class="id">entourage_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">hausdorrf_close_eq_in</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">U</span>) (<span class="id">f</span> <span class="id">g</span> : {<span class="id">uniform</span>` <span class="id">A</span> -&gt; <span class="id">V</span>}) :<br/>
&nbsp;&nbsp;<span class="id">hausdorff_space</span> <span class="id">V</span> -&gt; <span class="id">close</span> <span class="id">f</span> <span class="id">g</span> = {<span class="kwd">in</span> <span class="id">A</span>, <span class="id">f</span> =1 <span class="id">g</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof522')">Proof.</span></div>
<div class="proofscript" id="proof522">
<span class="id">move</span>=&gt; <span class="id">hV</span>.<br/>
<span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">eq_in_close</span>.<br/>
<span class="id">rewrite</span> <span class="id">entourage_close</span> =&gt; <span class="id">C</span> <span class="id">u</span>; <span class="id">rewrite</span> <span class="id">inE</span> =&gt; <span class="id">uA</span>; <span class="id">apply</span>: <span class="id">hV</span>.<br/>
<span class="id">rewrite</span> /<span class="id">cluster</span> -<span class="id">nbhs_entourageE</span> /= =&gt; <span class="id">X</span> <span class="id">Y</span> [<span class="id">X</span>' <span class="id">eX</span> <span class="id">X</span>'<span class="id">X</span>] [<span class="id">Y</span>' <span class="id">eY</span> <span class="id">Y</span>'<span class="id">Y</span>].<br/>
<span class="kwd">exists</span> (<span class="id">g</span> <span class="id">u</span>); <span class="id">split</span>; [<span class="id">apply</span>: <span class="id">X</span>'<span class="id">X</span>| <span class="id">apply</span>: <span class="id">Y</span>'<span class="id">Y</span>]; <span class="id">last</span> <span class="id">exact</span>: <span class="id">entourage_refl</span>.<br/>
<span class="id">apply</span>: (<span class="id">C</span> [<span class="id">set</span> <span class="id">fg</span> | <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">A</span> <span class="id">y</span> -&gt; <span class="id">X</span>' (<span class="id">fg</span>.1 <span class="id">y</span>, <span class="id">fg</span>.2 <span class="id">y</span>)]) =&gt; //=.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">uniform_entourage</span>; <span class="kwd">exists</span> <span class="id">X</span>'.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_restrict_cvg</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.U">U</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.V">V</a></span>))) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) <span class="id">A</span> : <span class="id">Filter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;{<span class="id">uniform</span> <span class="id">A</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} &lt;-&gt; {<span class="id">uniform</span>, <span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.V">restrict</a></span> <span class="id">A</span> @ <span class="id">F</span> --&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">restrict</a></span> <span class="id">A</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof523')">Proof.</span></div>
<div class="proofscript" id="proof523">
<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#uniform_nbhs">FF</a></span>; <span class="id">rewrite</span> <span class="id">cvg_sigL</span>; <span class="id">split</span>.<br/>
- <span class="id">rewrite</span> -<span class="id">sigLK</span>; <span class="id">move</span>/(<span class="id">cvg_app</span> <span class="id">valL</span>) =&gt; <span class="id">D</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">cvg_trans</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">D</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">P</span> /<span class="id">uniform_nbhs</span> [<span class="id">E</span> [/=<span class="id">entE</span> <span class="id">EsubP</span>]]; <span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">EsubP</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>/<span class="id">uniform_nbhs</span>; <span class="kwd">exists</span> <span class="id">E</span>; <span class="id">split</span>=&gt; //= <span class="id">h</span> /=.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">sigL</span> =&gt; <span class="id">R</span> <span class="id">u</span> <span class="id">_</span>; <span class="id">rewrite</span> <span class="id">oinv_set_val</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>: <span class="id">insubP</span>=&gt; /= *; [<span class="id">apply</span>: <span class="id">R</span>|<span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.V">apply</a></span>: <span class="id"><a name="B:3013">entourage_refl</a></span>].<br/>
- <span class="id">move</span>/(@<span class="id">cvg_app</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">sigL</span> <span class="id">A</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> -<span class="id">fmap_comp</span> <span class="id">sigL_restrict</span> =&gt; <span class="id">D</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">cvg_trans</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">D</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">P</span> /<span class="id">uniform_nbhs</span> [<span class="id">E</span> [/=<span class="id">entE</span> <span class="id">EsubP</span>]]; <span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">EsubP</span>).<br/>
&nbsp;&nbsp;<span class="id"><a name="h:3014">apply</a></span>/<span class="id">uniform_nbhs</span>; <span class="kwd">exists</span> <span class="id">E</span>; <span class="id">split</span>=&gt; //= <span class="id">h</span> /=.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">sigL</span> =&gt; <span class="id">R</span> [<span class="id">u</span> <span class="id">Au</span>] <span class="id">_</span> /=.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> := <span class="id">R</span> <span class="id">u</span> <span class="id">I</span>; <span class="id">rewrite</span> /<span class="id">patch</span> <span class="id">Au</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_nbhsT</span> (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;(<span class="id">nbhs</span> (<span class="id">f</span> : {<span class="id">uniform</span> <span class="id">U</span> -&gt; <span class="id">V</span>})) = <span class="id">nbhs</span> (<span class="id"><a href="mathcomp.analysis.topology.html#uniform_nbhs">f</a></span> : <span class="id">fct_topologicalType</span> <span class="id">U</span> <span class="id">V</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof524')">Proof.</span></div>
<div class="proofscript" id="proof524">
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>=&gt; <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>/<span class="id">uniform_nbhs</span> =&gt; <span class="id">E</span> [<span class="id">entE</span>] /<span class="id">filterS</span>; <span class="id">apply</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">fh</span> | <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">E</span> (<span class="id">fh</span>.1 <span class="id">y</span>, <span class="id">fh</span>.2 <span class="id">y</span>)]; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">E</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? /=.<br/>
<span class="id">case</span> =&gt; <span class="id">J</span> [<span class="id">E</span> <span class="id">entE</span> <span class="id">EJ</span>] /<span class="id">filterS</span>; <span class="id">apply</span>; <span class="id">apply</span>/<span class="id"><a name="F:3032">uniform_nbhs</a></span>; <span class="kwd">exists</span> <span class="id">E</span>.<br/>
<span class="kwd">by</span> <span class="id">split</span> =&gt; // <span class="id"><a href="mathcomp.analysis.topology.html#Filter">z</a></span> /= <span class="id">Efz</span>; <span class="id">apply</span>: <span class="id">EJ</span> =&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">t</a></span> /=; <span class="id">exact</span>: <span class="id">Efz</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_uniformU</span> (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>))) <span class="id">A</span> <span class="id">B</span> : <span class="id">Filter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;{<span class="id">uniform</span> <span class="id">A</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} -&gt; {<span class="id">uniform</span> <span class="id">B</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} -&gt;<br/>
&nbsp;&nbsp;{<span class="id">uniform</span> (<span class="id">A</span> `|` <span class="id">B</span>), <span class="id">F</span> --&gt; <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof525')">Proof.</span></div>
<div class="proofscript" id="proof525">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">AFf</span> <span class="id">BFf</span> <span class="id">Q</span> /=/<span class="id">uniform_nbhs</span> [<span class="id">E</span> [<span class="id">entE</span> <span class="id">EsubQ</span>]].<br/>
<span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">EsubQ</span>).<br/>
<span class="id">rewrite</span> (<span class="id"><a name="fam:3035">_</a></span>:  [<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#UniformCvgLemmas.U">h</a></span> | (<span class="kwd">forall</span> <span class="id">y</span> : <span class="id">U</span>, (<span class="id">A</span> `|` <span class="id">B</span>) <span class="id">y</span> -&gt; <span class="id">E</span> (<span class="id">f</span> <span class="id">y</span>, <span class="id">h</span> <span class="id">y</span>))] =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">set</span> <span class="id"><a name="k:3036">h</a></span> | <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">A</span> <span class="id">y</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#fct_restrictedUniformType">E</a></span> (<span class="id">f</span> <span class="id">y</span>, <span class="id">h</span> <span class="id">y</span>)] `&amp;`<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">set</span> <span class="id">h</span> | <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">B</span> <span class="id">y</span> -&gt; <span class="id">E</span> (<span class="id">f</span> <span class="id">y</span>, <span class="id">h</span> <span class="id">y</span>)]).<br/>
- <span class="id">apply</span>: <span class="id">filterI</span>; [<span class="id">apply</span>: <span class="id">AFf</span>| <span class="id">apply</span>: <span class="id">BFf</span>].<br/>
&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">uniform_nbhs</span>; <span class="kwd">exists</span> <span class="id">E</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">uniform_nbhs</span>; <span class="kwd">exists</span> <span class="id">E</span>; <span class="id">split</span>.<br/>
- <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>=&gt; <span class="id">h</span>.<br/>
&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">R</span>; <span class="id">split</span>=&gt; <span class="id">t</span> ?; <span class="id">apply</span>: <span class="id">R</span>;[<span class="id">left</span>| <span class="id"><a href="mathcomp.analysis.topology.html#fct_UniformFamily">right</a></span>].<br/>
&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">R1</span> <span class="id">R2</span>] <span class="id">y</span> [? | ?]; [<span class="id">apply</span>: <span class="id">R1</span>| <span class="id">apply</span>: <span class="id">R2</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cvg_uniform_set0</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>))) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) : <span class="id">Filter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;{<span class="id">uniform</span> <span class="id">set0</span>, <span class="id">F</span> --&gt; <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof526')">Proof.</span></div>
<div class="proofscript" id="proof526">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">P</span> /= /<span class="id">uniform_nbhs</span> [<span class="id">E</span> [? <span class="id">R</span>]].<br/>
<span class="id">suff</span> -&gt; : <span class="id">P</span> = <span class="id">setT</span> <span class="kwd">by</span> <span class="id">exact</span>: <span class="id">filterT</span>.<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; //=.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subset_trans</span> <span class="id">R</span> =&gt; <span class="id">g</span> <span class="id">_</span> ?.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="fam_cvgP">fct_UniformFamily</a></span> (<span class="id">fam</span> : (<span class="id">set</span> <span class="id">U</span>) -&gt; <span class="kwd">Prop</span>) := <span class="id">U</span> -&gt; <span class="id">V</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">family_cvg_uniformType</span> (<span class="id">fam</span>: <span class="id">set</span> <span class="id">U</span> -&gt; <span class="kwd">Prop</span>) :=<br/>
&nbsp;&nbsp;@<span class="id">sup_uniformType</span>  <span class="id">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">sigT</span> <span class="id">fam</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">k</span> =&gt; <span class="id">Uniform.class</span> (@<span class="id">fct_restrictedUniformType</span> <span class="id">U</span> (<span class="id">projT1</span> <span class="id">k</span>) <span class="id">V</span>)).<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">fct_UniformFamilyFilteredType</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvg_sup">fam</a></span> :=<br/>
&nbsp;&nbsp;[<span class="id">filteredType</span> <span class="id">fct_UniformFamily</span> <span class="id">fam</span> <span class="id">of</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fct_UniformFamily</span> <span class="id">fam</span> <span class="kwd">for</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">family_cvg_uniformType</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">fam</a></span>].<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">fct_UniformFamilyTopologicalType</span> <span class="id">fam</span> :=<br/>
&nbsp;&nbsp;[<span class="id">topologicalType</span> <span class="id">of</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fct_UniformFamily</span> <span class="id">fam</span> <span class="kwd">for</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">family_cvg_uniformType</span> <span class="id">fam</span>].<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">fct_UniformFamilyUniformType</span> <span class="id">fam</span> :=<br/>
&nbsp;&nbsp;[<span class="id">uniformType</span> <span class="id">of</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fct_UniformFamily</span> <span class="id">fam</span> <span class="kwd">for</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.classical_sets.html#set">family_cvg_uniformType</a></span> <span class="id">fam</span>].<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "{ '<span class="id">family</span>' <span class="id"><a href="mathcomp.analysis.topology.html#Filter">fam</a></span> , <span class="id">F</span> --&gt; <span class="id">f</span> }" :=<br/>
&nbsp;&nbsp;(<span class="id">cvg_to</span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">F</span>] (<span class="id">filter_of</span> (<span class="id">Phantom</span> (<span class="id">fct_UniformFamily</span> <span class="id">fam</span>) <span class="id">f</span>)))<br/>
&nbsp;&nbsp;: <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">fam_cvgP</span> (<span class="id">fam</span> : <span class="id">set</span> <span class="id">U</span> -&gt; <span class="kwd">Prop</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>))) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; {<span class="id">family</span> <span class="id">fam</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} &lt;-&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">A</span> : <span class="id">set</span> <span class="id">U</span>, <span class="id">fam</span> <span class="id">A</span> -&gt; {<span class="id">uniform</span> <span class="id">A</span>, <span class="id">F</span> --&gt; <span class="id">f</span> }).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof527')">Proof.</span></div>
<div class="proofscript" id="proof527">
<span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.analysis.topology.html#uniform_subset_cvg">cvg_sup</a></span> + <span class="id">A</span> <span class="id">FA</span>; <span class="id">move</span>/(<span class="id">_</span> (<span class="id">existT</span> <span class="id">_</span> <span class="id">_</span> <span class="id">FA</span>)).<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">famFf</span> /=; <span class="id">apply</span>/<span class="id">cvg_sup</span> =&gt; [[? ?] <span class="id">FA</span>]; <span class="id">apply</span>: <span class="id">famFf</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">family_cvg_subset</span> (<span class="id">famA</span> <span class="id">famB</span> : <span class="id">set</span> <span class="id">U</span> -&gt; <span class="kwd">Prop</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) : <span class="id">Filter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">famA</span> `&lt;=` <span class="id">famB</span> -&gt; {<span class="id">family</span> <span class="id">famB</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} -&gt; {<span class="id">family</span> <span class="id">famA</span>, <span class="id">F</span> --&gt; <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof528')">Proof.</span></div>
<div class="proofscript" id="proof528">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">S</span> /<span class="id">fam_cvgP</span> <span class="id">famBFf</span>; <span class="id">apply</span>/<span class="id">fam_cvgP</span> =&gt; <span class="id">A</span> ?; <span class="id">apply</span>/<span class="id">famBFf</span>/<span class="id">S</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">family_cvg_finite_covers</span> (<span class="id">famA</span> <span class="id">famB</span> : <span class="id">set</span> <span class="id">U</span> -&gt; <span class="kwd">Prop</span>)<br/>
&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>))) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) : <span class="id">Filter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">P</span>, <span class="id">famA</span> <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">I</span> : <span class="id">choiceType</span>) <span class="id"><a href="mathcomp.analysis.topology.html#uniformType">f</a></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">famB</span> (<span class="id">f</span> <span class="id">i</span>)) /\ <span class="id">finite_subset_cover</span> [<span class="id">set</span>: <span class="id">I</span>] <span class="id">f</span> <span class="id">P</span>) -&gt;<br/>
&nbsp;&nbsp;{<span class="id">family</span> <span class="id">famB</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} -&gt; {<span class="id">family</span> <span class="id">famA</span>, <span class="id">F</span> --&gt; <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof529')">Proof.</span></div>
<div class="proofscript" id="proof529">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">ex_finCover</span> /<span class="id">fam_cvgP</span> <span class="id">rFf</span>; <span class="id">apply</span>/<span class="id">fam_cvgP</span> =&gt; <span class="id">A</span> <span class="id">famAA</span>.<br/>
<span class="id">move</span>: <span class="id">ex_finCover</span> =&gt; /(<span class="id">_</span> <span class="id"><a name="A:3064">_</a></span> <span class="id">famAA</span>) [<span class="id">R</span> [<span class="id">g</span> [<span class="id"><a href="mathcomp.classical.classical_sets.html#set">g_famB</a></span> [<span class="id">D</span> <span class="id">_</span>]]]].<br/>
<span class="id">move</span>/<span class="id">uniform_subset_cvg</span>; <span class="id">apply</span>.<br/>
<span class="id">elim</span>/<span class="id">finSet_rect</span>: <span class="id">D</span> =&gt; <span class="id">X</span> <span class="id">IHX</span>.<br/>
<span class="id">have</span> [-&gt;|/<span class="id">set0P</span>[<span class="id">x</span> <span class="id">xX</span>]] := <span class="id">eqVneq</span> [<span class="id">set</span>` <span class="id">X</span>] <span class="id">set0</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">coverE</span> <span class="id"><a href="mathcomp.analysis.topology.html#fam_cvgP">bigcup_set0</a></span>; <span class="id">apply</span>: <span class="id">cvg_uniform_set0</span>.<br/>
<span class="id">rewrite</span> <span class="id">coverE</span> (<span class="id">bigcup_fsetD1</span> <span class="id">x</span>)//; <span class="id">apply</span>: <span class="id">cvg_uniformU</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>/<span class="id">rFf</span>/<span class="id">g_famB</span>.<br/>
<span class="id">exact</span>/<span class="id">IHX</span>/<span class="id">fproperD1</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a name="A:3070">UniformCvgLemmas</a></span>.<br/>
<br/>
<span class="kwd">Notation</span> "{ '<span class="id">family</span>' <span class="id">fam</span> , <span class="id">U</span> -&gt; <span class="id">V</span> }" :=  (@<span class="id">fct_UniformFamily</span> <span class="id">U</span> <span class="id">V</span> <span class="id"><a name="U:3072">fam</a></span>).<br/>
<span class="kwd">Notation</span> "{ '<span class="id">family</span>' <span class="id">fam</span> , <span class="id">F</span> --&gt; <span class="id">f</span> }" :=<br/>
&nbsp;&nbsp;(<span class="id">cvg_to</span> [<span class="id">filter</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">of</a></span> <span class="id">F</span>] (<span class="id">filter_of</span> (<span class="id">Phantom</span> (<span class="id">fct_UniformFamily</span> <span class="id">fam</span>) <span class="id">f</span>)))<br/>
&nbsp;&nbsp;: <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">fam_cvgE</span> {<span class="id">U</span> : <span class="id">choiceType</span>} {<span class="id">V</span> : <span class="id">uniformType</span>} (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) <span class="id">fam</span> :<br/>
&nbsp;&nbsp;{<span class="id">family</span> <span class="id">fam</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} = (<span class="id">F</span> --&gt; (<span class="id">f</span> : {<span class="id">family</span> <span class="id">fam</span>, <span class="id">U</span> -&gt; <span class="id">V</span>})).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof530')">Proof.</span></div>
<div class="proofscript" id="proof530">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">fam_nbhs</span> {<span class="id">U</span> : <span class="id">choiceType</span>} {<span class="id">V</span> : <span class="id">uniformType</span>} (<span class="id">fam</span> : <span class="id">set</span> <span class="id">U</span> -&gt; <span class="kwd">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">A</span> : <span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">U</a></span>) (<span class="id">E</span> : <span class="id">set</span> (<span class="id">V</span> * <span class="id">V</span>)) (<span class="id">f</span> : {<span class="id">family</span> <span class="id">fam</span>, <span class="id">U</span> -&gt; <span class="id">V</span>}) :<br/>
&nbsp;&nbsp;<span class="id">entourage</span> <span class="id">E</span> -&gt; <span class="id">fam</span> <span class="id">A</span> -&gt; <span class="id">nbhs</span> <span class="id">f</span> [<span class="id">set</span> <span class="id">g</span> | <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">A</span> <span class="id">y</span> -&gt; <span class="id">E</span> (<span class="id">f</span> <span class="id">y</span>, <span class="id">g</span> <span class="id">y</span>)].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof531')">Proof.</span></div>
<div class="proofscript" id="proof531">
<span class="id">move</span>=&gt; <span class="id">entE</span> <span class="id">famA</span>; <span class="id">have</span> /<span class="id">fam_cvgP</span> /(<span class="id">_</span> <span class="id">A</span>) : (<span class="id">nbhs</span> <span class="id">f</span> --&gt; <span class="id">f</span>) <span class="kwd">by</span> []; <span class="id">apply</span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">apply</span> <span class="id">uniform_nbhs</span>; <span class="kwd">exists</span> <span class="id">E</span>; <span class="id">split</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">compactly_in</span> {<span class="id">U</span> : <span class="id">topologicalType</span>} (<span class="id">A</span> : <span class="id">set</span> <span class="id">U</span>) :=<br/>
&nbsp;&nbsp;[<span class="id">set</span> <span class="id">B</span> | <span class="id">B</span> `&lt;=` <span class="id">A</span> /\ <span class="id">compact</span> <span class="id">B</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_cvg_within_compact</span> {<span class="id">U</span> : <span class="id">topologicalType</span>} {<span class="id">V</span> : <span class="id">uniformType</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">C</a></span> : <span class="id">set</span> <span class="id">U</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>))) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a name="O:3084">Filter</a></span> <span class="id">F</span> -&gt; <span class="id">compact</span> <span class="id">C</span> -&gt;<br/>
&nbsp;&nbsp;{<span class="id">uniform</span> <span class="id">C</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} &lt;-&gt; {<span class="id">family</span> <span class="id">compactly_in</span> <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhs">C</a></span>, <span class="id">F</span> --&gt; <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof532')">Proof.</span></div>
<div class="proofscript" id="proof532">
<span class="id">move</span>=&gt; <span class="id">FF</span> <span class="id">CC</span>.<br/>
<span class="id">apply</span>: (<span class="id">iff_trans</span> <span class="id">_</span> (<span class="id">iff_sym</span> (<span class="id">fam_cvgP</span> <span class="id">_</span> <span class="id">_</span> <span class="id">FF</span>))); <span class="id">split</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">CFf</span> <span class="id">D</span> [/<span class="id">uniform_subset_cvg</span> + <span class="id">_</span>]; <span class="id">apply</span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>; <span class="id">split</span>.<br/>
Qed.</div>
<br/>
<span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">Global</a></span> <span class="kwd">Instance</span> <span class="id">Proper_dnbhs_numFieldType</span> (<span class="id">R</span> : <span class="id">numFieldType</span>) (<span class="id">x</span> : <span class="id">R</span>) :<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">x</span>^'.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof533')">Proof.</span></div>
<div class="proofscript" id="proof533">
<span class="id">apply</span>: <span class="id">Build_ProperFilter</span> =&gt; <span class="id">A</span> /<span class="id">nbhs_ballP</span>[<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>] <span class="id">Ae</span>].<br/>
<span class="kwd">exists</span> (<span class="id">x</span> + <span class="id">e</span>%:<span class="id">num</span> / 2)%<span class="id">R</span>; <span class="id">apply</span>: <span class="id">Ae</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eq_sym</span> <span class="id">addrC</span> -<span class="id">subr_eq</span> <span class="id">subrr</span> <span class="id">eq_sym</span>.<br/>
<span class="id">rewrite</span> /<span class="id">ball</span> /= <span class="id">opprD</span> <span class="id">addrA</span> <span class="id">subrr</span> <span class="id">distrC</span> <span class="id">subr0</span> <span class="id">ger0_norm</span> //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> {2}(<span class="id">splitr</span> <span class="id">e</span>%:<span class="id">num</span>) <span class="id">ltr_spaddl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">dense</span> (<span class="id">T</span> : <span class="id">topologicalType</span>) (<span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">S</a></span> : <span class="id">set</span> <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">O</span> : <span class="id">set</span> <span class="id">T</span>), <span class="id">O</span> !=<span class="id">set0</span> -&gt; <span class="id">open</span> <span class="id">O</span> -&gt; <span class="id">O</span> `&amp;` <span class="id">S</span> !=<span class="id">set0</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">denseNE</span> (<span class="id"><a href="mathcomp.analysis.topology.html#weak_uniformType">T</a></span> : <span class="id">topologicalType</span>) (<span class="id">S</span> : <span class="id">set</span> <span class="id">T</span>) : ~ <span class="id">dense</span> <span class="id"><a name="x:3091">S</a></span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">O</span>, (<span class="kwd">exists</span> <span class="id">x</span>, <span class="id">open_nbhs</span> <span class="id">x</span> <span class="id"><a href="mathcomp.analysis.topology.html#weak_pseudoMetric.f">O</a></span>) /\ (<span class="id">O</span> `&amp;` <span class="id">S</span> = <span class="id">set0</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof534')">Proof.</span></div>
<div class="proofscript" id="proof534">
<span class="id">rewrite</span> /<span class="id">dense</span> /<span class="id">open_nbhs</span>.<br/>
<span class="id">move</span>=&gt; /<span class="id">existsNP</span>[<span class="id">X</span> /<span class="id">not_implyP</span>[[<span class="id">x</span> <span class="id">Xx</span>] /<span class="id">not_implyP</span>[ <span class="id">Ox</span> /<span class="id">forallNP</span> <span class="id">A</span>]]].<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">X</span>; <span class="id">split</span>; [<span class="kwd">exists</span> <span class="id">x</span> | <span class="id">rewrite</span> -<span class="id">subset0</span>; <span class="id">apply</span>/<span class="id">A</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">dense_rat</span> (<span class="id">R</span> : <span class="id">realType</span>) : <span class="id">dense</span> (@<span class="id">ratr</span> <span class="id">R</span> @` <span class="id">setT</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof535')">Proof.</span></div>
<div class="proofscript" id="proof535">
<span class="id">move</span>=&gt; <span class="id">A</span> [<span class="id">r</span> <span class="id">Ar</span>]; <span class="id">rewrite</span> <span class="id">openE</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">Ar</span>)/<span class="id">nbhs_ballP</span>[<span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>] <span class="id"><a href="mathcomp.analysis.topology.html#entourage">reA</a></span>].<br/>
<span class="id">have</span> /<span class="id">rat_in_itvoo</span>[<span class="id">q</span> /<span class="id">itvP</span> <span class="id">qre</span>] : <span class="id">r</span> &lt; <span class="id">r</span> + <span class="id">e</span>%:<span class="id">num</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">ltr_addl</span>.<br/>
<span class="kwd">exists</span> (<span class="id">ratr</span> <span class="id"><a href="mathcomp.analysis.topology.html#weak_pseudoMetric.f">q</a></span>) =&gt; //; <span class="id">split</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">q</span>.<br/>
<span class="id">apply</span>: <span class="id">reA</span>; <span class="id">rewrite</span> /<span class="id"><a name="e:3096">ball</a></span> /= <span class="id">distrC</span> <span class="id"><a href="mathcomp.analysis.topology.html#ball">ltr_distl</a></span> <span class="id">qre</span> <span class="id">andbT</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> (@<span class="id">le_lt_trans</span> <span class="id">_</span> <span class="id">_</span> <span class="id">r</span>)// ?<span class="id">qre</span>// <span class="id">ler_subl_addl</span> <span class="id">ler_addr</span> <span class="id">ltW</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">separated_open_countable</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">R</span> : <span class="id">realType</span>} (<span class="id">I</span> : <span class="kwd">Type</span>) (<span class="id">B</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">R</span>) (<span class="id">D</span> : <span class="id">set</span> <span class="id">I</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">open</span> (<span class="id">B</span> <span class="id">i</span>)) -&gt; (<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">B</span> <span class="id">i</span> !=<span class="id">set0</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">trivIset</span> <span class="id">D</span> <span class="id">B</span> -&gt; <span class="id">countable</span> <span class="id">D</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof536')">Proof.</span></div>
<div class="proofscript" id="proof536">
<span class="id">move</span>=&gt; <span class="id">oB</span> <span class="id">B0</span> <span class="id">tB</span>; <span class="id">have</span> [<span class="id">f</span> <span class="id">fB</span>] :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">f</span> : <span class="id">I</span> -&gt; <span class="id">rat</span> &amp; <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">D</span> <span class="id">i</span> -&gt; <span class="id">B</span> <span class="id">i</span> (<span class="id">ratr</span> (<span class="id">f</span> <span class="id">i</span>))}.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (@<span class="id">choice</span> <span class="id">_</span> <span class="id">_</span> (<span class="kwd">fun</span> <span class="id">x</span> <span class="id">y</span> =&gt; <span class="id">D</span> <span class="id">x</span> -&gt; <span class="id">B</span> <span class="id">x</span> (<span class="id">ratr</span> <span class="id">y</span>))) =&gt; <span class="id">i</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">r</span> [<span class="id">Bir</span> [<span class="id">q</span> <span class="id">_</span> <span class="id">qr</span>]]] := <span class="id">dense_rat</span> (<span class="id">B0</span> <span class="id">_</span>) (<span class="id">oB</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">q</span> =&gt; <span class="id">Di</span>; <span class="id">rewrite</span> <span class="id">qr</span>.<br/>
<span class="id">have</span> <span class="id">inj_f</span> : {<span class="kwd">in</span> <span class="id">D</span> &amp;, <span class="id">injective</span> <span class="id">f</span>}.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">j</span> /[!<span class="id">inE</span>] <span class="id">Di</span> <span class="id">Dj</span> /(<span class="id">congr1</span> <span class="id">ratr</span>) <span class="id">ratrij</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> ? : (<span class="id">B</span> <span class="id">i</span> `&amp;` <span class="id">B</span> <span class="id">j</span>) (<span class="id">ratr</span> (<span class="id">f</span> <span class="id">i</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span> =&gt; //; [<span class="id">exact</span>: <span class="id">fB</span>|<span class="id">rewrite</span> <span class="id">ratrij</span>; <span class="id">exact</span>: <span class="id">fB</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/(<span class="id">tB</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Di</span> <span class="id">Dj</span>); <span class="kwd">exists</span> (<span class="id">ratr</span> (<span class="id">f</span> <span class="id">i</span>)).<br/>
<span class="id">apply</span>/<span class="id">pcard_injP</span>; <span class="id">have</span> /<span class="id">card_bijP</span>/<span class="id">cid</span>[<span class="id">g</span> <span class="id">bijg</span>] := <span class="id">card_rat</span>.<br/>
<span class="id">pose</span> <span class="id">nat_of_rat</span> (<span class="id">q</span> : <span class="id">rat</span>) : <span class="id">nat</span> := <span class="id">set_val</span> (<span class="id">g</span> (<span class="id">to_setT</span> <span class="id">q</span>)).<br/>
<span class="id">have</span> <span class="id">inj_nat_of_rat</span> : <span class="id">injective</span> <span class="id">nat_of_rat</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">nat_of_rat</span>; <span class="id">apply</span>: <span class="id">inj_comp</span> =&gt; //; <span class="id">apply</span>: <span class="id">inj_comp</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">exact</span>/<span class="id">bij_inj</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">nat_of_rat</span> \<span class="id">o</span> <span class="id">f</span>) =&gt; <span class="id">i</span> <span class="id">j</span> <span class="id">Di</span> <span class="id">Dj</span> /<span class="id">inj_nat_of_rat</span>/<span class="id">inj_f</span>; <span class="id">exact</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="weak_ballE">weak_pseudoMetric</a></span>.<br/>
<span class="kwd">Context</span> {<span class="id">R</span> : <span class="id">realType</span>} (<span class="id">pS</span> : <span class="id">pointedType</span>) (<span class="id">U</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>) .<br/>
<span class="kwd">Variable</span> (<span class="id">f</span> : <span class="id">pS</span> -&gt; <span class="id">U</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">S</span> := <span class="id">weak_uniformType</span> <span class="id">f</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">weak_ball</span> (<span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">x</a></span> : <span class="id">S</span>) (<span class="id">r</span> : <span class="id">R</span>) (<span class="id">y</span> : <span class="id">S</span>) := <span class="id">ball</span> (<span class="id">f</span> <span class="id">x</span>) <span class="id">r</span> (<span class="id">f</span> <span class="id">y</span>).<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id">weak_pseudoMetricType_mixin</span> :=<br/>
&nbsp;&nbsp;@<span class="id">PseudoMetric.Mixin</span> <span class="id">R</span> <span class="id">S</span> <span class="id">entourage</span> <span class="id">weak_ball</span><br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.classical_sets.html#set">_</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof537')">Next Obligation.</span></div>
<div class="proofscript" id="proof537">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? <span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">e</span>]; <span class="id">exact</span>: <span class="id">ball_center</span>. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof538')">Next Obligation.</span></div>
<div class="proofscript" id="proof538">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? ?; <span class="id">exact</span>: <span class="id">ball_sym</span>. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof539')">Next Obligation.</span></div>
<div class="proofscript" id="proof539">
 <span class="id">move</span>=&gt; ? ? ? ? ?; <span class="id">exact</span>: <span class="id">ball_triangle</span>. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof540')">Next Obligation.</span></div>
<div class="proofscript" id="proof540">
<span class="id">rewrite</span> /<span class="id">entourage</span> /= /<span class="id">weak_ent</span> -<span class="id">entourage_ballE</span> /<span class="id">entourage_</span>.<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#nbhsx_ballx">have</a></span> -&gt; : (<span class="kwd">fun</span> <span class="id">e</span> =&gt; [<span class="id"><a name="n:3112">set</a></span> <span class="id">xy</span> | <span class="id">ball</span> (<span class="id">f</span> <span class="id"><a href="mathcomp.classical.boolp.html#exists2P">xy</a></span>.1) <span class="id">e</span> (<span class="id">f</span> <span class="id">xy</span>.2)]) =<br/>
&nbsp;&nbsp;&nbsp;(<span class="id">preimage</span> (<span class="id">map_pair</span> <span class="id">f</span>) \<span class="id">o</span> <span class="kwd">fun</span> <span class="id">e</span> =&gt; [<span class="id">set</span> <span class="id">xy</span> | <span class="id"><a name="n:3114">ball</a></span> <span class="id">xy</span>.1 <span class="id">e</span> <span class="id">xy</span>.2])%<span class="id">FUN</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> [].<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>; <span class="id">apply</span>/<span class="id">filter_fromP</span>.<br/>
- <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.cardinality.html#finite_set_countable">filter_from_filter</a></span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> 1 =&gt; /=.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">e1</span> <span class="id">e2</span> <span class="id">e1pos</span> <span class="id">e2pos</span>; <span class="id">wlog</span> <span class="id">e1lee2</span> : <span class="id">e1</span> <span class="id">e2</span> <span class="id">e1pos</span> <span class="id">e2pos</span> / <span class="id">e1</span> &lt;= <span class="id">e2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_ballP">have</a></span> [?|/<span class="id">ltW</span> ?] := <span class="id">lerP</span> <span class="id">e1</span> <span class="id">e2</span>; [<span class="id">exact</span> | <span class="id">rewrite</span> <span class="id">setIC</span>; <span class="id">exact</span>].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">e1</span> =&gt; //; <span class="id">rewrite</span> -<span class="id">preimage_setI</span>; <span class="id">apply</span>: <span class="id">preimage_subset</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: <span class="id">le_ball</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">e1lee2</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">E</span> [<span class="id">e</span> ?] <span class="id">heE</span>; <span class="kwd">exists</span> <span class="id">e</span> =&gt; //; <span class="id">apply</span>: <span class="id">preimage_subset</span>.<br/>
- <span class="id">apply</span>: <span class="id">filter_from_filter</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> [<span class="id"><a href="mathcomp.classical.classical_sets.html#subset_trans">set</a></span> <span class="id">xy</span> | (<span class="id">ball</span> <span class="id">xy</span>.1 1 <span class="id">xy</span>.2)]; <span class="kwd">exists</span> 1 =&gt; /=.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">E1</span> <span class="id">E2</span> [<span class="id">e1</span> <span class="id">e1pos</span> <span class="id">he1E1</span>] [<span class="id">e2</span> <span class="id">e2pos</span> <span class="id">he2E2</span>].<br/>
&nbsp;&nbsp;<span class="id">wlog</span> ? : <span class="id">E1</span> <span class="id">E2</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">e1pos</span> <span class="id">e2pos</span> <span class="id">he1E1</span> <span class="id">he2E2</span> / <span class="id">e1</span> &lt;= <span class="id">e2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span> [? /(<span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">e1</span> <span class="id">e2</span>)|/<span class="id">ltW</span> ? ] := <span class="id">lerP</span> <span class="id">e1</span> <span class="id">e2</span>; <span class="id">first</span> <span class="id"><a href="mathcomp.analysis.topology.html#interior_subset">exact</a></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">setIC</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">e2</span> <span class="id">e1</span>); <span class="id">exact</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">E1</span> `&amp;` <span class="id">E2</span>) =&gt; //; <span class="kwd">exists</span> <span class="id">e1</span> =&gt; // <span class="id">xy</span> /= <span class="id">B</span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">he1E1</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">he2E2</span>/<span class="id">le_ball</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">B</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">e</span> ?; <span class="kwd">exists</span> ([<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> <span class="id">xy</span>.1 <span class="id">e</span> <span class="id">xy</span>.2]) =&gt; //; <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">e</span> =&gt; /=.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">weak_pseudoMetricType</span> :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetricType</span> <span class="id">S</span> <span class="id">weak_pseudoMetricType_mixin</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_ballE</span> (<span class="id">e</span> : <span class="id">R</span>) (<span class="id">x</span> : <span class="id">weak_pseudoMetricType</span>) :<br/>
&nbsp;&nbsp;<span class="id">f</span>@^-1` (<span class="id">ball</span> (<span class="id">f</span> <span class="id">x</span>) <span class="id">e</span>) = <span class="id">ball</span> <span class="id">x</span> <span class="id">e</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof541')">Proof.</span></div>
<div class="proofscript" id="proof541">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">weak_pseudoMetric</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_second_countable</span> {<span class="id">R</span> : <span class="id">realType</span>} {<span class="id">T</span> : <span class="id"><a name="countable_uniform">pseudoMetricType</a></span> <span class="id">R</span>} :<br/>
&nbsp;&nbsp;<span class="id">compact</span> [<span class="id">set</span>: <span class="id">T</span>] -&gt; @<span class="id">second_countable</span> <span class="id">T</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof542')">Proof.</span></div>
<div class="proofscript" id="proof542">
<span class="id">have</span> <span class="id">npos</span> <span class="id">n</span> : (0:<span class="id">R</span>) &lt; <span class="id">n</span>.+1%:<span class="id">R</span>^-1 <span class="kwd">by</span> [].<br/>
<span class="id">pose</span> <span class="id">f</span> <span class="id">n</span> (<span class="id">z</span> : <span class="id">T</span>): <span class="id">set</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#iffLR">T</a></span> := (<span class="id"><a href="mathcomp.analysis.topology.html#countable_uniformityP">ball</a></span> <span class="id">z</span> (<span class="id">PosNum</span> (<span class="id">npos</span> <span class="id">n</span>))%:<span class="id">num</span>)^°.<br/>
<span class="id">move</span>=&gt; <span class="id">cmpt</span>; <span class="id">have</span> <span class="id">h</span> <span class="id">n</span> : <span class="id">finite_subset_cover</span> [<span class="id">set</span>: <span class="id">T</span>] (<span class="id">f</span> <span class="id">n</span>) [<span class="id"><a name="N:3121">set</a></span>: <span class="id">T</span>].<br/>
&nbsp;&nbsp;<span class="id">move</span>: <span class="id">cmpt</span>; <span class="id">rewrite</span> <span class="id">compact_cover</span>; <span class="id">apply</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">z</span> <span class="id">_</span>; <span class="id">rewrite</span> /<span class="id">f</span>; <span class="id">exact</span>: <span class="id">open_interior</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">z</span> <span class="id">_</span>; <span class="kwd">exists</span> <span class="id">z</span> =&gt; //; <span class="id">rewrite</span> /<span class="id">f</span> /<span class="id">interior</span>; <span class="id">exact</span>: <span class="id">nbhsx_ballx</span>.<br/>
<span class="id">pose</span> <span class="id">h</span>' <span class="id">n</span> := <span class="id">cid</span> (<span class="id">iffLR</span> (<span class="id">exists2P</span> <span class="id">_</span> <span class="id">_</span>) (<span class="id">h</span> <span class="id">n</span>)).<br/>
<span class="id">pose</span> <span class="id">h</span>'' <span class="id">n</span> := <span class="id">projT1</span> (<span class="id">h</span>' <span class="id">n</span>).<br/>
<span class="id">pose</span> <span class="id">B</span> := \<span class="id">bigcup_n</span> (<span class="id">f</span> <span class="id">n</span>) @` [<span class="id">set</span>` <span class="id">h</span>'' <span class="id">n</span>]; <span class="kwd">exists</span> <span class="id">B</span>;[|<span class="id">split</span>].<br/>
- <span class="id">apply</span>: <span class="id">bigcup_countable</span> =&gt; // <span class="id">n</span> <span class="id">_</span>; <span class="id">apply</span>: <span class="id">finite_set_countable</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>/<span class="id">finite_image</span>/ <span class="id">finite_fset</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span> =&gt; ? [? <span class="id">_</span> [? <span class="id">_</span> &lt;-]]; <span class="id">exact</span>: <span class="id">open_interior</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">V</span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#set">nbhs_ballP</a></span> [] <span class="id">_</span>/<span class="id">posnumP</span>[<span class="id">eps</span>] <span class="id">ballsubV</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [//|<span class="id">N</span>] := @<span class="id">ltr_add_invr</span> <span class="id">R</span> 0%<span class="id">R</span> (<span class="id">eps</span>%:<span class="id">num</span>/2) <span class="id">_</span>; <span class="id">rewrite</span> <span class="id">add0r</span> =&gt; <span class="id">deleps</span>.<br/>
&nbsp;&nbsp;<span class="id"><a name="countable_uniform.entG">have</a></span> [<span class="id"><a name="n:3127">w</a></span> <span class="id">wh</span> <span class="id">fx</span>] : <span class="kwd">exists2</span> <span class="id">w</span> : <span class="id">T</span>, <span class="id">w</span> \<span class="kwd">in</span> <span class="id">h</span>'' <span class="id">N</span> &amp; <span class="id">f</span> <span class="id">N</span> <span class="id">w</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> [<span class="id">_</span> /(<span class="id">_</span> <span class="id">x</span>) [// | <span class="id">w</span> ? ?]] := <span class="id">projT2</span> (<span class="id">h</span>' <span class="id">N</span>); <span class="kwd">exists</span> <span class="id">w</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filterI">f</a></span> <span class="id">N</span> <span class="id">w</span>); <span class="id">first</span> <span class="id">split</span> =&gt; //; <span class="id"><a name="symG">first</a></span> (<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">N</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id">subset_trans</span> <span class="id">_</span> <span class="id">ballsubV</span>) =&gt; <span class="id">z</span> <span class="id">bz</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> [<span class="id">_</span>%:<span class="id">num</span>]<span class="id">splitr</span>; <span class="id">apply</span>: (@<span class="id">ball_triangle</span> <span class="id">_</span> <span class="id">_</span> <span class="id">w</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">le_ball</span> (<span class="id">ltW</span> <span class="id">deleps</span>)); <span class="id">apply</span>/<span class="id">ball_sym</span>; <span class="id">apply</span>: <span class="id">interior_subset</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">le_ball</span> (<span class="id">ltW</span> <span class="id">deleps</span>)); <span class="id"><a href="mathcomp.classical.classical_sets.html#subset_trans">apply</a></span>: <span class="id">interior_subset</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopen_surj</span> {<span class="id">R</span> : <span class="id">realType</span>} {<span class="id">T</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} :<br/>
&nbsp;&nbsp;<span class="id">compact</span> [<span class="id">set</span>: <span class="id">T</span>] -&gt; $|{<span class="id">surjfun</span> [<span class="id">set</span>: <span class="id">nat</span>] &gt;-&gt; @<span class="id">clopen</span> <span class="id">T</span>}|.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof543')">Proof.</span></div>
<div class="proofscript" id="proof543">
<span class="id">move</span>=&gt; <span class="id">cmptT</span>.<br/>
<span class="id">suff</span> : @<span class="id"><a href="mathcomp.analysis.topology.html#g_">clopen</a></span> <span class="id">T</span> = <span class="id">set0</span> \/ $|{<span class="id">surjfun</span> [<span class="id">set</span>: <span class="id">nat</span>] &gt;-&gt; @<span class="id">clopen</span> <span class="id">T</span>}|.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span> =&gt; //; <span class="id">rewrite</span> <span class="id">eqEsubset</span> =&gt; -[/(<span class="id">_</span> <span class="id">_</span> <span class="id">clopenT</span>)].<br/>
<span class="id">exact</span>/<span class="id">pfcard_geP</span>/<span class="id">clopen_countable</span>/<span class="id">compact_second_countable</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">countable_uniform</span>.<br/>
<span class="kwd">Context</span> {<span class="id">R</span> : <span class="id">realType</span>} {<span class="id">T</span> : <span class="id">uniformType</span>}.<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">cnt_unif</span> : @<span class="id">countable_uniformity</span> <span class="id">T</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">f_</span> := <span class="id">projT1</span> (<span class="id">cid2</span> (<span class="id">iffLR</span> <span class="id"><a href="mathcomp.analysis.topology.html#entourage">countable_uniformityP</a></span> <span class="id"><a name="N:3135">cnt_unif</a></span>)).<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">countableBase</span> : <span class="kwd">forall</span> <span class="id">A</span>, <span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="kwd">exists</span> <span class="id">N</span>, <span class="id">f_</span> <span class="id">N</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof544')">Proof.</span></div>
<div class="proofscript" id="proof544">
 <span class="kwd">by</span> <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">cid2</span> (<span class="id">iffLR</span> <span class="id">countable_uniformityP</span> <span class="id">cnt_unif</span>)). Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">entF</span> : <span class="kwd">forall</span> <span class="id">n</span>, <span class="id">entourage</span> (<span class="id">f_</span> <span class="id">n</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof545')">Proof.</span></div>
<div class="proofscript" id="proof545">
 <span class="kwd">by</span> <span class="id">have</span> [] := <span class="id">projT2</span> (<span class="id">cid2</span> (<span class="id">iffLR</span> <span class="id">countable_uniformityP</span> <span class="id">cnt_unif</span>)). Qed.</div>
<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Fixpoint</span> <span class="id">g_</span> (<span class="id">n</span> : <span class="id">nat</span>) : <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">n</span> <span class="id">is</span> <span class="id">S</span> <span class="id">n</span> <span class="kwd">then</span> <span class="kwd">let</span> <span class="id">W</span> := <span class="id">split_ent</span> (<span class="id">split_ent</span> (<span class="id">g_</span> <span class="id">n</span>)) `&amp;` <span class="id">f_</span> <span class="id">n</span> <span class="kwd">in</span> <span class="id">W</span> `&amp;` <span class="id">W</span>^-1<br/>
&nbsp;&nbsp;<span class="kwd">else</span> [<span class="id">set</span>: <span class="id">T</span>*<span class="id">T</span>].<br/>
<br/>
<span class="kwd">Let</span> <span class="id">entG</span> (<span class="id">n</span> : <span class="id">nat</span>) : <span class="id">entourage</span> (<span class="id">g_</span> <span class="id">n</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof546')">Proof.</span></div>
<div class="proofscript" id="proof546">
<span class="id">elim</span>: <span class="id">n</span> =&gt; /=; <span class="id">first</span> <span class="id">exact</span>: <span class="id">entourageT</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">entg</span>; <span class="id">apply</span>/<span class="id">entourage_invI</span>; <span class="id">exact</span>: <span class="id">filterI</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">symG</span> (<span class="id">n</span> : <span class="id">nat</span>) : ((<span class="id">g_</span> <span class="id">n</span>)^-1)%<span class="id">classic</span> = <span class="id">g_</span> <span class="id">n</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof547')">Proof.</span></div>
<div class="proofscript" id="proof547">
<span class="kwd">by</span> <span class="id">case</span>: <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">n</a></span> =&gt; // <span class="id">n</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>; <span class="id">case</span>=&gt; ? ?; <span class="id">rewrite</span> /= <span class="id">andC</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">descendG1</span> <span class="id">n</span> : <span class="id">g_</span> <span class="id">n</span>.+1 `&lt;=` <span class="id">g_</span> <span class="id">n</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof548')">Proof.</span></div>
<div class="proofscript" id="proof548">
<span class="id">apply</span>: <span class="id">subIset</span>; <span class="id">left</span>; <span class="id">apply</span>: <span class="id">subIset</span>; <span class="id">left</span>; <span class="id">apply</span>: <span class="id">subset_trans</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">split_ent_subset</span>; <span class="id">exact</span>: <span class="id">entourage_split_ent</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subset_trans</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">split_ent_subset</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">descendG</span> (<span class="id">n</span> <span class="id">m</span>: <span class="id">nat</span>) : (<span class="id">m</span> &lt;= <span class="id">n</span>)%<span class="id">N</span> -&gt; <span class="id">g_</span> <span class="id">n</span> `&lt;=` <span class="id">g_</span> <span class="id">m</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof549')">Proof.</span></div>
<div class="proofscript" id="proof549">
<span class="id">elim</span>: <span class="id">n</span>; <span class="id">rewrite</span> ?<span class="id">leqn0</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt;/<span class="id">eqP</span> -&gt;.<br/>
<span class="id">move</span>=&gt; <span class="id"><a name="e:3142">n</a></span> <span class="id"><a name="z:3143">IH</a></span>; <span class="id">rewrite</span> <span class="id">leq_eqVlt</span> <span class="id">ltnS</span> =&gt; /<span class="id">orP</span> [/<span class="id"><a name="d2:3148">eqP</a></span> &lt;- //|] /<span class="id">IH</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subset_trans</span>; <span class="id">exact</span>: <span class="id">descendG1</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">splitG3</span> <span class="id">n</span> : <span class="id">g_</span> <span class="id">n</span>.+1 \; <span class="id">g_</span> <span class="id">n</span>.+1 \; <span class="id">g_</span> <span class="id">n</span>.+1 `&lt;=` <span class="id">g_</span> <span class="id">n</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof550')">Proof.</span></div>
<div class="proofscript" id="proof550">
<span class="id">suff</span> <span class="id">g2split</span> : <span class="id">g_</span> <span class="id">n</span>.+1 \; <span class="id">g_</span> <span class="id">n</span>.+1 `&lt;=` <span class="id">split_ent</span> (<span class="id"><a name="z:3151">g_</a></span> <span class="id">n</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#n_step_ball">subset_trans</a></span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">subset_split_ent</span> (<span class="id">entG</span> <span class="id">n</span>).<br/>
&nbsp;&nbsp;<span class="id"><a name="e:3155">apply</a></span>: <span class="id">set_compose_subset</span> (<span class="id">g2split</span>); <span class="id">rewrite</span> -[<span class="id">_</span> <span class="id">n</span>.+1]<span class="id">set_compose_diag</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">subset_trans</span> <span class="id">g2split</span>; <span class="id">apply</span>: <span class="id">set_compose_subset</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">_</span> <span class="id">_</span>] [<span class="id">z</span> <span class="id">_</span>] [&lt;- &lt;-]; <span class="id">exact</span>: <span class="id">entourage_refl</span>.<br/>
<span class="id">apply</span>: <span class="id">subset_trans</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">subset_split_ent</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">set_compose_subset</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#entourage">subIset</a></span>; <span class="id">left</span>; <span class="id"><a name="xy:3161">apply</a></span>: <span class="id">subIset</span>; <span class="id">left</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">gsubf</span> <span class="id">n</span> : <span class="id">g_</span> <span class="id">n</span>.+1 `&lt;=` <span class="id">f_</span> <span class="id">n</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof551')">Proof.</span></div>
<div class="proofscript" id="proof551">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subIset</span>; <span class="id">left</span>; <span class="id">apply</span>: <span class="id">subIset</span>; <span class="id">right</span>. Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">countableBaseG</span> <span class="id"><a name="x:3162">A</a></span> : <span class="id">entourage</span> <span class="id">A</span> -&gt; <span class="kwd">exists</span> <span class="id">N</span>, <span class="id">g_</span> <span class="id">N</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof552')">Proof.</span></div>
<div class="proofscript" id="proof552">
<span class="id">move</span>=&gt; /<span class="id">countableBase</span> [<span class="id">N</span>] <span class="id">fnA</span>; <span class="kwd">exists</span> <span class="id">N</span>.+1.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subset_trans</span> <span class="id">fnA</span>; <span class="id">exact</span>: <span class="id">gsubf</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">classical_set_scope</span>.<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">ring_scope</span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Definition</span> <span class="id">distN</span> (<span class="id"><a name="y:3174">e</a></span> : <span class="id"><a name="d1:3176">R</a></span>) : <span class="id">nat</span> := `|<span class="id">floor</span> <span class="id">e</span>^-1|%<span class="id">N</span>.<br/>
<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#step_ball">Local</a></span> <span class="kwd">Lemma</span> <span class="id">distN0</span> : <span class="id">distN</span> 0 = 0%<span class="id">N</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof553')">Proof.</span></div>
<div class="proofscript" id="proof553">
 <span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">distN</span> <span class="id">invr0</span> <span class="id">floor0</span>. Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">distN_nat</span> (<span class="id">n</span> : <span class="id">nat</span>): <span class="id">distN</span> (<span class="id">n</span>%:<span class="id">R</span>^-1) = <span class="id">n</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof554')">Proof.</span></div>
<div class="proofscript" id="proof554">
<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">distN</span> <span class="id">invrK</span> <span class="id"><a name="n:3178">floor_natz</a></span> -[<span class="id">RHS</span>]<span class="id">distn0</span>; <span class="id">congr</span> <span class="id">absz</span>; <span class="id">rewrite</span> <span class="id">subr0</span> <span class="id">intz</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">distN_le</span> <span class="id">e1</span> <span class="id">e2</span> : <span class="id">e1</span> &gt; 0 -&gt; <span class="id">e1</span> &lt;= <span class="id">e2</span> -&gt; (<span class="id">distN</span> <span class="id">e2</span> &lt;= <span class="id">distN</span> <span class="id">e1</span>)%<span class="id">N</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof555')">Proof.</span></div>
<div class="proofscript" id="proof555">
<span class="id">move</span>=&gt; <span class="id">e1pos</span> <span class="id">e1e2</span>; <span class="id">rewrite</span> /<span class="id">distN</span>; <span class="id">apply</span>: <span class="id">lez_abs2</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">floor_ge0</span> <span class="id">ltW</span>// <span class="id">invr_gt0</span> (<span class="id">lt_le_trans</span> <span class="id">_</span> <span class="id">e1e2</span>).<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">le_floor</span>// <span class="id">lef_pinv</span> ?<span class="id">invrK</span> ?<span class="id">invr_gt0</span>//; <span class="id">exact</span>: (<span class="id">lt_le_trans</span> <span class="id">_</span> <span class="id">e1e2</span>).<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Fixpoint</span> <span class="id">n_step_ball</span> <span class="id">n</span> <span class="id">x</span> <span class="id">e</span> <span class="id">z</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">n</span> <span class="id">is</span> <span class="id">n</span>.+1 <span class="kwd">then</span> <span class="kwd">exists</span> <span class="id">y</span> <span class="id">d1</span> <span class="id">d2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[/\ <span class="id">n_step_ball</span> <span class="id">n</span> <span class="id">x</span> <span class="id">d1</span> <span class="id">y</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 &lt; <span class="id">d1</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 &lt; <span class="id">d2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">g_</span> (<span class="id">distN</span> <span class="id">d2</span>) (<span class="id">y</span>, <span class="id">z</span>) &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">d1</span> + <span class="id">d2</span> = <span class="id">e</span>]<br/>
&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">e</span> &gt; 0 /\ <span class="id">g_</span> (<span class="id">distN</span> <span class="id">e</span>) (<span class="id">x</span>, <span class="id">z</span>).<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Definition</span> <span class="id">step_ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">z</span> := <span class="kwd">exists</span> <span class="id">i</span>, (<span class="id">n_step_ball</span> <span class="id">i</span> <span class="id">x</span> <span class="id">e</span> <span class="id">z</span>).<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">n_step_ball_pos</span> <span class="id">n</span> <span class="id">x</span> <span class="id">e</span> <span class="id">z</span> : <span class="id">n_step_ball</span> <span class="id">n</span> <span class="id">x</span> <span class="id">e</span> <span class="id">z</span> -&gt; 0 &lt; <span class="id">e</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof556')">Proof.</span></div>
<div class="proofscript" id="proof556">
<span class="kwd">by</span> <span class="id">case</span>: <span class="id">n</span> =&gt; [[]|] // <span class="id">n</span>; <span class="id">case</span>=&gt; [?] [?] [?] [] ? ? ? ? &lt;-; <span class="id">apply</span>: <span class="id">addr_gt0</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">step_ball_pos</span> <span class="id">x</span> <span class="id">e</span> <span class="id">z</span> : <span class="id">step_ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">z</span> -&gt; 0 &lt; <span class="id">e</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof557')">Proof.</span></div>
<div class="proofscript" id="proof557">
 <span class="kwd">by</span> <span class="id">case</span> =&gt; ?; <span class="id">exact</span>: <span class="id">n_step_ball_pos</span>. Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">entourage_nball</span> <span class="id">e</span> :<br/>
&nbsp;&nbsp;0 &lt; <span class="id">e</span> -&gt; <span class="id">entourage</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id">step_ball</span> <span class="id">xy</span>.1 <span class="id">e</span> <span class="id">xy</span>.2].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof558')">Proof.</span></div>
<div class="proofscript" id="proof558">
<span class="id">move</span>=&gt; <span class="id">epos</span>; <span class="id">apply</span>: (@<span class="id">filterS</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">g_</span> (<span class="id">distN</span> <span class="id">e</span>))) =&gt; // [[<span class="id">x</span> <span class="id">y</span>]] ?.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> 0%<span class="id">N</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">n_step_ball_center</span> <span class="id">x</span> <span class="id">e</span> : 0 &lt; <span class="id">e</span> -&gt; <span class="id">n_step_ball</span> 0 <span class="id">x</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof559')">Proof.</span></div>
<div class="proofscript" id="proof559">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">epos</span>; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: <span class="id">entourage_refl</span>. Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">step_ball_center</span> <span class="id">x</span> <span class="id">e</span> : 0 &lt; <span class="id">e</span> -&gt; <span class="id">step_ball</span> <span class="id">x</span> <span class="id"><a href="mathcomp.analysis.topology.html#distN_le">e</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof560')">Proof.</span></div>
<div class="proofscript" id="proof560">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">epos</span>; <span class="kwd">exists</span> 0%<span class="id">N</span>; <span class="id">apply</span>: <span class="id">n_step_ball_center</span>. Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">n_step_ball_triangle</span> <span class="id">n</span> <span class="id">m</span> <span class="id">x</span> <span class="id">y</span> <span class="id">z</span> <span class="id">d1</span> <span class="id">d2</span> :<br/>
&nbsp;&nbsp;<span class="id">n_step_ball</span> <span class="id">n</span> <span class="id">x</span> <span class="id">d1</span> <span class="id">y</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">n_step_ball</span> <span class="id">m</span> <span class="id">y</span> <span class="id">d2</span> <span class="id">z</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">n_step_ball</span> (<span class="id">n</span> + <span class="id">m</span>).+1 <span class="id">x</span> (<span class="id">d1</span> + <span class="id">d2</span>) <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof561')">Proof.</span></div>
<div class="proofscript" id="proof561">
<span class="id">move</span>: <span class="id">n</span> <span class="id">z</span> <span class="id">d2</span>; <span class="id">elim</span>: <span class="id">m</span> =&gt; [<span class="id">n</span> <span class="id">z</span> <span class="id">d2</span> <span class="id">Nxy</span> [? ?]|<span class="id">n</span> <span class="id">IH</span> <span class="id">m</span> <span class="id">z</span> <span class="id">d2</span> <span class="id">Oxy</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">y</span>, <span class="id">d1</span>, <span class="id">d2</span>; <span class="id">split</span>; <span class="id">rewrite</span> ?<span class="id">addn0</span> // (<span class="id">n_step_ball_pos</span> <span class="id">Nxy</span>).<br/>
<span class="id">move</span>=&gt; [<span class="id">w</span>] [<span class="id">e1</span>] [<span class="id">e2</span>] [<span class="id">Oyw</span> ? ? ? &lt;-].<br/>
<span class="kwd">exists</span> <span class="id">w</span>, (<span class="id">d1</span> + <span class="id">e1</span>), <span class="id">e2</span>; <span class="id">rewrite</span> <span class="id">addnS</span> <span class="id">addrA</span>.<br/>
<span class="id">split</span> =&gt; //; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">addr_gt0</span>//; <span class="id">exact</span>: <span class="id">n_step_ball_pos</span> <span class="id">Oxy</span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>: (<span class="id">IH</span> <span class="id">m</span> <span class="id">w</span> <span class="id">e1</span> <span class="id">Oxy</span> <span class="id"><a href="mathcomp.analysis.topology.html#n_step_ball_le">Oyw</a></span>) =&gt; <span class="id">t</span> [<span class="id">e3</span>] [<span class="id">e4</span>] [] <span class="id">Oxt</span> ? ? ? &lt;-; <span class="kwd">exists</span> <span class="id">t</span>, <span class="id">e3</span>, <span class="id">e4</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">step_ball_triangle</span> <span class="id">x</span> <span class="id">y</span> <span class="id">z</span> <span class="id">d1</span> <span class="id">d2</span> :<br/>
&nbsp;&nbsp;<span class="id">step_ball</span> <span class="id">x</span> <span class="id">d1</span> <span class="id">y</span> -&gt; <span class="id">step_ball</span> <span class="id">y</span> <span class="id">d2</span> <span class="id">z</span> -&gt; <span class="id">step_ball</span> <span class="id">x</span> (<span class="id">d1</span> + <span class="id">d2</span>) <span class="id">z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof562')">Proof.</span></div>
<div class="proofscript" id="proof562">
<span class="id">move</span>=&gt; [<span class="id">n</span> <span class="id">Oxy</span>] [<span class="id">m</span> <span class="id">Oyz</span>]; <span class="kwd">exists</span> (<span class="id">n</span> + <span class="id">m</span>).+1.<br/>
<span class="id">exact</span>: <span class="id">n_step_ball_triangle</span> <span class="id">Oxy</span> <span class="id">Oyz</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">n_step_ball_sym</span> <span class="id">n</span> <span class="id">x</span> <span class="id">y</span> <span class="id">e</span> :<br/>
&nbsp;&nbsp;<span class="id">n_step_ball</span> <span class="id">n</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span> -&gt; <span class="id">n_step_ball</span> <span class="id">n</span> <span class="id">y</span> <span class="id"><a href="mathcomp.analysis.topology.html#n_step_ball">e</a></span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof563')">Proof.</span></div>
<div class="proofscript" id="proof563">
<span class="id">move</span>: <span class="id">x</span> <span class="id">y</span> <span class="id">e</span>; <span class="id">elim</span>: <span class="id">n</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ? ?; <span class="id">rewrite</span> /= -{1}<span class="id">symG</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">IH</span> <span class="id">x</span> <span class="id">y</span> <span class="id">e</span> [<span class="id">t</span>] [<span class="id">d1</span>] [<span class="id">d2</span>] [] /<span class="id">IH</span> <span class="id">Oty</span> ? ?.<br/>
<span class="id">rewrite</span> <span class="id">addrC</span> -<span class="id">symG</span> -[<span class="id">n</span>]<span class="id">add0n</span> =&gt; <span class="id">gty</span> &lt;-; <span class="id">apply</span>: (<span class="id">n_step_ball_triangle</span> <span class="id">_</span> <span class="id">Oty</span>).<br/>
<span class="kwd">by</span> <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">gty</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">step_ball_sym</span> <span class="id">x</span> <span class="id">y</span> <span class="id">e</span> : <span class="id">step_ball</span> <span class="id">x</span> <span class="id">e</span> <span class="id">y</span> -&gt; <span class="id">step_ball</span> <span class="id">y</span> <span class="id">e</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof564')">Proof.</span></div>
<div class="proofscript" id="proof564">
 <span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">n</span> /<span class="id">n_step_ball_sym</span> ?; <span class="kwd">exists</span> <span class="id">n</span>. Qed.</div>
<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">n_step_ball_le</span> <span class="id">n</span> <span class="id">x</span> <span class="id">e1</span> <span class="id">e2</span> :<br/>
&nbsp;&nbsp;<span class="id">e1</span> &lt;= <span class="id">e2</span> -&gt; <span class="id">n_step_ball</span> <span class="id">n</span> <span class="id">x</span> <span class="id">e1</span> `&lt;=` <span class="id">n_step_ball</span> <span class="id">n</span> <span class="id">x</span> <span class="id">e2</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof565')">Proof.</span></div>
<div class="proofscript" id="proof565">
<span class="id">move</span>: <span class="id">x</span> <span class="id">e1</span> <span class="id">e2</span>; <span class="id">elim</span>: <span class="id">n</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">e1e2</span> <span class="id">y</span> [?] <span class="id">gxy</span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>: (<span class="id">lt_le_trans</span> <span class="id">_</span> <span class="id">e1e2</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">descendG</span>; <span class="id">last</span> (<span class="id">exact</span>: <span class="id">gxy</span>); <span class="id">exact</span>: <span class="id">distN_le</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">IH</span> <span class="id">x</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">e1e2</span> <span class="id">z</span> [<span class="id">y</span>] [<span class="id">d1</span>] [<span class="id">d2</span>] [] /<span class="id">IH</span> <span class="id">P</span> <span class="id">d1pos</span> <span class="id">d2pos</span> <span class="id">gyz</span> <span class="id">d1d2e1</span>.<br/>
<span class="id">have</span> <span class="id">d1e1d2</span> : <span class="id">d1</span> = <span class="id">e1</span> - <span class="id">d2</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">d1d2e1</span> -<span class="id">addrA</span> <span class="id">subrr</span> <span class="id">addr0</span>.<br/>
<span class="id">have</span> <span class="id">e2d2le</span> : <span class="id">e1</span> - <span class="id">d2</span> &lt;= <span class="id">e2</span> - <span class="id">d2</span> <span class="kwd">by</span> <span class="id">exact</span>: <span class="id">ler_sub</span>.<br/>
<span class="kwd">exists</span> <span class="id">y</span>, (<span class="id">e2</span> - <span class="id">d2</span>), <span class="id">d2</span>; <span class="id">split</span> =&gt; //.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">P</span>; <span class="id">apply</span>: <span class="id">le_trans</span> <span class="id">e2d2le</span>; <span class="id">rewrite</span> <span class="id">d1e1d2</span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">lt_le_trans</span> <span class="id">e2d2le</span>; <span class="id">rewrite</span> -<span class="id">d1e1d2</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">addrA</span> [-<span class="id">_</span> + <span class="id">_</span>]<span class="id">addrC</span> <span class="id">subrr</span> <span class="id">addr0</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">step_ball_le</span> <span class="id">x</span> <span class="id">e1</span> <span class="id">e2</span> :<br/>
&nbsp;&nbsp;<span class="id">e1</span> &lt;= <span class="id">e2</span> -&gt; <span class="id">step_ball</span> <span class="id">x</span> <span class="id">e1</span> `&lt;=` <span class="id">step_ball</span> <span class="id">x</span> <span class="id">e2</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof566')">Proof.</span></div>
<div class="proofscript" id="proof566">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">e1e2</span> ? [<span class="id">n</span> <span class="id">P</span>]; <span class="kwd">exists</span> <span class="id">n</span>; <span class="id">exact</span>: (<span class="id">n_step_ball_le</span> <span class="id">e1e2</span>). Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">distN_half</span> (<span class="id">n</span> : <span class="id">nat</span>) : <span class="id">n</span>.+1%:<span class="id">R</span>^-1 / (2:<span class="id">R</span>) &lt;= <span class="id">n</span>.+2%:<span class="id">R</span>^-1.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof567')">Proof.</span></div>
<div class="proofscript" id="proof567">
<span class="id">rewrite</span> -<span class="id">invrM</span> //; [|<span class="id">exact</span>: <span class="id">unitf_gt0</span> |<span class="id">exact</span>: <span class="id">unitf_gt0</span>].<br/>
<span class="id">rewrite</span> <span class="id">lef_pinv</span> ?<span class="id">posrE</span> // -?<span class="id">natrM</span> ?<span class="id">ler_nat</span> -<span class="id">addn1</span> -<span class="id"><a name="n_step_ball_le_g">addn1</a></span> -<span class="id">addnA</span> <span class="id">mulnDr</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">muln1</span> <span class="id">leq_add2r</span> <span class="id">leq_pmull</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">split_n_step_ball</span> <span class="id">n</span> <span class="id">x</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">z</span> :<br/>
&nbsp;&nbsp;0 &lt; <span class="id">e1</span> -&gt; 0 &lt; <span class="id">e2</span> -&gt; <span class="id">n_step_ball</span> <span class="id">n</span>.+1 <span class="id">x</span> (<span class="id">e1</span> + <span class="id">e2</span>) <span class="id">z</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">t1</span> <span class="id">t2</span> <span class="id">a</span> <span class="id">b</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[/\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n_step_ball</span> <span class="id">a</span> <span class="id">x</span> <span class="id">e1</span> <span class="id">t1</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n_step_ball</span> 0 <span class="id">t1</span> (<span class="id">e1</span> + <span class="id">e2</span>) <span class="id">t2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n_step_ball</span> <span class="id">b</span> <span class="id">t2</span> <span class="id">e2</span> <span class="id">z</span> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">a</span> + <span class="id">b</span> = <span class="id">n</span>)%<span class="id">N</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof568')">Proof.</span></div>
<div class="proofscript" id="proof568">
<span class="id">move</span>: <span class="id">e1</span> <span class="id">e2</span> <span class="id">x</span> <span class="id">z</span>; <span class="id">elim</span>: <span class="id">n</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">e1</span> <span class="id">e2</span> <span class="id">x</span> <span class="id">z</span> <span class="id">e1pos</span> <span class="id">e2pos</span> [<span class="id">y</span>] [<span class="id">d1</span>] [<span class="id">d2</span>] [] <span class="id">Oxy</span> ? ? <span class="id">gd2yz</span> <span class="id">deE</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>: (<span class="id">pselect</span> (<span class="id">e1</span> &lt;= <span class="id">d1</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">e1d1</span>; <span class="kwd">exists</span> <span class="id">x</span>, <span class="id">y</span>, 0%<span class="id">N</span>, 0%<span class="id">N</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">exact</span>: <span class="id">n_step_ball_center</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">apply</span>: <span class="id">n_step_ball_le</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">Oxy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">deE</span> <span class="id">ler_addl</span>; <span class="id">apply</span>: <span class="id">ltW</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">apply</span>: (@<span class="id">n_step_ball_le</span> <span class="id">_</span> <span class="id">_</span> <span class="id">d2</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> -[<span class="id">e2</span>]<span class="id">addr0</span> -(<span class="id">subrr</span> <span class="id">e1</span>) <span class="id">addrA</span> -<span class="id">ler_subl_addr</span> <span class="id">opprK</span> <span class="id">addrC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> [<span class="id">e2</span> + <span class="id">_</span>]<span class="id">addrC</span> -<span class="id">deE</span>; <span class="id">exact</span>: <span class="id">ler_add</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">addn0</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /<span class="id">negP</span>; <span class="id">rewrite</span> -<span class="id">real_ltNge</span> ?<span class="id">num_real</span> //.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">e1d1</span>; <span class="kwd">exists</span> <span class="id">y</span>, <span class="id">z</span>, 0%<span class="id">N</span>, 0%<span class="id">N</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">n_step_ball_le</span>; <span class="id">last</span> (<span class="id">exact</span>: <span class="id">Oxy</span>); <span class="id">exact</span>: <span class="id">ltW</span>.<br/>
&nbsp;&nbsp;- <span class="id">rewrite</span> -<span class="id">deE</span>; <span class="id">apply</span>: (@<span class="id">n_step_ball_le</span> <span class="id">_</span> <span class="id">_</span> <span class="id">d2</span>) =&gt; //.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">ler_addr</span>; <span class="id">apply</span>: <span class="id">ltW</span>.<br/>
&nbsp;&nbsp;- <span class="id">exact</span>: <span class="id">n_step_ball_center</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">addn0</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">IH</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">x</span> <span class="id">z</span> <span class="id">e1pos</span> <span class="id">e2pos</span> [<span class="id">y</span>] [<span class="id">d1</span>] [<span class="id">d2</span>] [] <span class="id">Od1xy</span> <span class="id">d1pos</span> <span class="id">d2pos</span> <span class="id">gd2yz</span> <span class="id">deE</span>.<br/>
<span class="id">case</span>: (<span class="id">pselect</span> (<span class="id">e2</span> &lt;= <span class="id">d2</span>)).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">e2d2</span>; <span class="kwd">exists</span> <span class="id">y</span>, <span class="id">z</span>, <span class="id">n</span>.+1, 0%<span class="id">N</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;- <span class="id">apply</span>: (@<span class="id">n_step_ball_le</span> <span class="id">_</span> <span class="id">_</span> <span class="id">d1</span>); <span class="id">rewrite</span> // -[<span class="id">e1</span>]<span class="id">addr0</span> -(<span class="id">subrr</span> <span class="id">e2</span>) <span class="id">addrA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">deE</span> -<span class="id">ler_subl_addr</span> <span class="id">opprK</span> <span class="id">ler_add</span>.<br/>
&nbsp;&nbsp;- <span class="id">apply</span>: (@<span class="id">n_step_ball_le</span> <span class="id">_</span> <span class="id">_</span> <span class="id">d2</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">deE</span> <span class="id">ler_addr</span>; <span class="id">exact</span>: <span class="id">ltW</span>.<br/>
&nbsp;&nbsp;- <span class="id">exact</span>: <span class="id">n_step_ball_center</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#subset_step_ball">rewrite</a></span> <span class="id">addn0</span>.<br/>
<span class="id">have</span> <span class="id">d1E</span>' : <span class="id">d1</span> = <span class="id">e1</span> + (<span class="id">e2</span> - <span class="id">d2</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>: <span class="id">deE</span>; <span class="id">rewrite</span> <span class="id">addrA</span> [<span class="id">e1</span> + <span class="id">_</span>]<span class="id">addrC</span> =&gt; &lt;-; <span class="id">rewrite</span> -<span class="id"><a name="countable_uniform_pseudoMetricType_mixin">addrA</a></span> <span class="id">subrr</span> <span class="id">addr0</span>.<br/>
<span class="id">move</span>=&gt; /<span class="id">negP</span>; <span class="id">rewrite</span> -?<span class="id">real_ltNge</span> // ?<span class="id">num_real</span> // =&gt; <span class="id">d2lee2</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>: (<span class="id">IH</span> <span class="id">e1</span> (<span class="id">e2</span> - <span class="id">d2</span>) <span class="id">x</span> <span class="id">y</span>); <span class="id">rewrite</span> ?<span class="id">subr_gt0</span> // -<span class="id">d1E</span>' //.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">t1</span> [<span class="id">t2</span>] [<span class="id">c1</span>] [<span class="id">c2</span>] [] <span class="id">Oxy1</span> <span class="id">gt1t2</span> <span class="id">t2y</span> &lt;-.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">t1</span>, <span class="id">t2</span>, <span class="id">c1</span>, <span class="id">c2</span>.+1; <span class="id">split</span> =&gt; //.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">apply</span>: (@<span class="id">n_step_ball_le</span> <span class="id">_</span> <span class="id">_</span> <span class="id">d1</span>); <span class="id">rewrite</span> -?<span class="id">deE</span> // ?<span class="id">ler_addl</span>; <span class="id">exact</span>: <span class="id">ltW</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">exists</span> <span class="id">y</span>, (<span class="id">e2</span> - <span class="id">d2</span>), <span class="id">d2</span>; <span class="id">split</span>; <span class="id"><a href="mathcomp.analysis.topology.html#distN">rewrite</a></span> // ?<span class="id">subr_gt0</span>//.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">addrA</span> [-<span class="id">_</span> + <span class="id">_</span>]<span class="id">addrC</span> <span class="id">subrr</span> <span class="id">addr0</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">addnS</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">n_step_ball_le_g</span> <span class="id">x</span> <span class="id">n</span> :<br/>
&nbsp;&nbsp;<span class="id">n_step_ball</span> 0 <span class="id">x</span> <span class="id">n</span>%:<span class="id">R</span>^-1 `&lt;=` [<span class="id">set</span> <span class="id">y</span> | <span class="id">g_</span> <span class="id">n</span> (<span class="id">x</span>,<span class="id">y</span>)].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof569')">Proof.</span></div>
<div class="proofscript" id="proof569">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">y</span> [] ?; <span class="id">rewrite</span> <span class="id">distN_nat</span>. Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">subset_n_step_ball</span> <span class="id">n</span> <span class="id">x</span> <span class="id">N</span> :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.pointedType">n_step_ball</a></span> <span class="id">n</span> <span class="id"><a name="sup_pseudometric.Ii">x</a></span> <span class="id">N</span>.+1%:<span class="id">R</span>^-1 `&lt;=` [<span class="id">set</span> <span class="id">y</span> | (<span class="id">g_</span> <span class="id">N</span>) (<span class="id">x</span>, <span class="id">y</span>)].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof570')">Proof.</span></div>
<div class="proofscript" id="proof570">
<span class="id">move</span>: <span class="id">N</span> <span class="id">x</span>; <span class="id">elim</span>: <span class="id">n</span> {-2}<span class="id"><a name="sup_pseudometric.Icnt">n</a></span> (<span class="id">leqnn</span> <span class="id">n</span>) =&gt; <span class="id">n</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">leqn0</span> =&gt; /<span class="id">eqP</span> -&gt; <span class="id">N</span> <span class="id">x</span>; <span class="id">apply</span>: <span class="id">subset_trans</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>: <span class="id"><a name="sup_pseudometric.TS">n_step_ball_le_g</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">y</span> ?; <span class="id">exact</span>: <span class="id">descendG</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">IH1</span> + + <span class="id">N</span> <span class="id">x1</span> <span class="id">x4</span>; <span class="id">case</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? [?] <span class="id">P</span>; <span class="id">apply</span>: <span class="id">descendG</span> <span class="id">_</span> <span class="id">P</span>; <span class="id">rewrite</span> <span class="id">distN_nat</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">l</span> <span class="id">ln1</span> <span class="id">Ox1x4</span>.<br/>
<span class="id">case</span>: (@<span class="id">split_n_step_ball</span> <span class="id">l</span> <span class="id">x1</span> (<span class="id">N</span>.+1%:<span class="id"><a href="mathcomp.analysis.topology.html#countable_uniform_pseudoMetricType_mixin">R</a></span>^-1/2) (<span class="id">N</span>.+1%:<span class="id">R</span>^-1/2) <span class="id">x4</span>) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">splitr</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">x2</span> [<span class="id">x3</span>] [<span class="id">l1</span>] [<span class="id">l2</span>] [] <span class="id">P1</span> [? +] <span class="id">P3</span> <span class="id">l1l2</span>; <span class="id">rewrite</span> -<span class="id">splitr</span> <span class="id">distN_nat</span> =&gt; ?.<br/>
<span class="id">have</span> <span class="id">l1n</span> : (<span class="id">l1</span> &lt;= <span class="id">n</span>)%<span class="id">N</span> <span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">leq_trans</span> (<span class="id">leq_addr</span> <span class="id">l2</span> <span class="id">l1</span>))// <span class="id">l1l2</span> -<span class="id">ltnS</span>.<br/>
<span class="id">have</span> <span class="id">l2n</span> : (<span class="id">l2</span> &lt;= <span class="id">n</span>)%<span class="id">N</span> <span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">leq_trans</span> (<span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">leq_addl</a></span> <span class="id">l1</span> <span class="id">l2</span>))// <span class="id">l1l2</span> -<span class="id">ltnS</span>.<br/>
<span class="id">apply</span>: <span class="id">splitG3</span>; <span class="kwd">exists</span> <span class="id">x3</span>; [<span class="kwd">exists</span> <span class="id">x2</span> =&gt; //|].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>/(<span class="id">n_step_ball_le</span> (<span class="id">distN_half</span> <span class="id">N</span>))/(<span class="id">IH1</span> <span class="id">_</span> <span class="id">l1n</span>) : <span class="id">P1</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>/(<span class="id">n_step_ball_le</span> (<span class="id">distN_half</span> <span class="id">N</span>))/(<span class="id">IH1</span> <span class="id">_</span> <span class="id">l2n</span>) : <span class="id">P3</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">subset_step_ball</span> <span class="id">x</span> <span class="id">N</span> :<br/>
&nbsp;&nbsp;<span class="id">step_ball</span> <span class="id">x</span> <span class="id">N</span>.+1%:<span class="id">R</span>^-1 `&lt;=` [<span class="id">set</span> <span class="id">y</span> | (<span class="id">g_</span> <span class="id">N</span>) (<span class="id">x</span>, <span class="id">y</span>)].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof571')">Proof.</span></div>
<div class="proofscript" id="proof571">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">y</span> [] <span class="id">n</span>; <span class="id">exact</span>: <span class="id">subset_n_step_ball</span>. Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">step_ball_entourage</span> : <span class="id">entourage</span> = <span class="id">entourage_</span> <span class="id">step_ball</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof572')">Proof.</span></div>
<div class="proofscript" id="proof572">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">E</span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">e</span> /= <span class="id">epos</span> <span class="id">esubE</span>; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">filterS</a></span> <span class="id">esubE</span>); <span class="id">exact</span>: <span class="id">entourage_nball</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">entE</span>; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">case</a></span>: (<span class="id">countableBase</span> <span class="id">entE</span>) =&gt; <span class="id">N</span> <span class="id">fN</span>.<br/>
<span class="kwd">exists</span> <span class="id">N</span>.+2%:<span class="id">R</span>^-1; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> /= <span class="id">invr_gt0</span>.<br/>
<span class="id">apply</span>: (<span class="id">subset_trans</span> <span class="id">_</span> <span class="id">fN</span>); <span class="id"><a name="x:3236">apply</a></span>: <span class="id">subset_trans</span>; <span class="id">last</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#set">gsubf</a></span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">x</span> <span class="id">y</span> /= <span class="id">N1ball</span>; <span class="id">apply</span>: (@<span class="id">subset_step_ball</span> <span class="id">x</span> <span class="id">N</span>.+1).<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">countable_uniform_pseudoMetricType_mixin</span> := <span class="id">PseudoMetric.Mixin</span><br/>
&nbsp;&nbsp;<span class="id">step_ball_center</span> <span class="id">step_ball_sym</span> <span class="id">step_ball_triangle</span> <span class="id">step_ball_entourage</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">countable_uniform_bounded</span> (<span class="id">x</span> <span class="id">y</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">U</span> := <span class="id">PseudoMetricType</span> <span class="id">_</span> <span class="id">countable_uniform_pseudoMetricType_mixin</span><br/>
&nbsp;&nbsp;<span class="kwd">in</span> @<span class="id">ball</span> <span class="id">_</span> <span class="id">U</span> <span class="id">x</span> 2 <span class="id">y</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof573')">Proof.</span></div>
<div class="proofscript" id="proof573">
<span class="id">rewrite</span> /<span class="id">ball</span>; <span class="kwd">exists</span> <span class="id">O</span>%<span class="id">N</span>; <span class="id">rewrite</span> /<span class="id">n_step_ball</span>; <span class="id">split</span>; <span class="id">rewrite</span> // /<span class="id">distN</span>. <br/>
<span class="id">suff</span> -&gt; : @<span class="id">floor</span> <span class="id">R</span> 2^-1 = 0 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">absz0</span> /=.<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#Subspace.A">apply</a></span>/<span class="id">eqP</span>; <span class="id">rewrite</span> -[<span class="id">_</span> == <span class="id">_</span>]<span class="id">negbK</span>; <span class="id">rewrite</span> <span class="id">floor_neq0</span> <span class="id">negb_or</span> -?<span class="id">ltNge</span> -?<span class="id">leNgt</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">andP</span>; <span class="id">split</span> =&gt; //; <span class="id">rewrite</span> <span class="id">invf_lt1</span> //= <span class="id">ltr_addl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">countable_uniform</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">sup_pseudometric</span>.<br/>
<span class="kwd">Variable</span> (<span class="id">R</span> : <span class="id">realType</span>) (<span class="id">T</span> : <span class="id">pointedType</span>) (<span class="id">Ii</span> : <span class="kwd">Type</span>).<br/>
<span class="kwd">Variable</span> (<span class="id">Tc</span> : <span class="id">Ii</span> -&gt; <span class="id">PseudoMetric.class_of</span> <span class="id">R</span> <span class="id">T</span>).<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">Icnt</span> : <span class="id">countable</span> [<span class="id">set</span>: <span class="id">Ii</span>].<br/>
<br/>
<span class="kwd">Let</span> <span class="id">I</span> : <span class="id">choiceType</span> := <span class="id">classicType_choiceType</span> <span class="id">Ii</span>.<br/>
<span class="kwd">Let</span> <span class="id">TS</span> := <span class="kwd">fun</span> <span class="id"><a name="subspace_pointedType">i</a></span> =&gt; <span class="id">PseudoMetric.Pack</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.PointedType">Tc</a></span> <span class="id">i</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">countable_uniformityT</span> := @<span class="id">countable_sup_ent</span> <span class="id">T</span> <span class="id">Ii</span> <span class="id">Tc</span> <span class="id">Icnt</span><br/>
&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">i</span> =&gt; @<span class="id">countable_uniformity_metric</span> <span class="id">_</span> (<span class="id">TS</span> <span class="id">i</span>)).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">sup_pseudoMetric_mixin</span> := @<span class="id">countable_uniform_pseudoMetricType_mixin</span> <span class="id">R</span><br/>
&nbsp;&nbsp;(<span class="id">sup_uniformType</span> <span class="id">Tc</span>) <span class="id">countable_uniformityT</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_subspace_filter">sup_pseudoMetricType</a></span> :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetricType</span> (<span class="id">sup_uniformType</span> <span class="id">Tc</span>) <span class="id">sup_pseudoMetric_mixin</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">sup_pseudometric</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">product_pseudometric</span>.<br/>
<span class="kwd">Variable</span> (<span class="id">R</span> : <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_subspaceP">realType</a></span>) (<span class="id">Ii</span> : <span class="id">countType</span>) (<span class="id">Tc</span> : <span class="id">Ii</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_interior">pseudoMetricType</a></span> <span class="id">R</span>).<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">Icnt</span> : <span class="id">countable</span> [<span class="id">set</span>: <span class="id">Ii</span>].<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">product_pseudoMetricType</span> :=<br/>
&nbsp;&nbsp;<span class="id">sup_pseudoMetricType</span> (<span class="kwd">fun</span> <span class="id">i</span> =&gt; <span class="id">PseudoMetric.class</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">weak_pseudoMetricType</span> (<span class="kwd">fun</span> <span class="id">f</span> : <span class="id">dep_arrow_pointedType</span> <span class="id">Tc</span> =&gt; <span class="id">f</span> <span class="id">i</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Icnt</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">product_pseudometric</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">subspace</span> {<span class="id">T</span> : <span class="kwd">Type</span>} (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) := <span class="id">T</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">subspace</span> {<span class="id">T</span>} <span class="id">_</span> : <span class="id">simpl</span> <span class="id">never</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">incl_subspace</span> {<span class="id">T</span> <span class="id">A</span>} (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">A</span>) : <span class="id">T</span> := <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">Subspace</span>.<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id">topologicalType</span>} (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">nbhs_subspace</span> (<span class="id">x</span> : <span class="id"><a name="x:3248">subspace</a></span> <span class="id">A</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#within">set</a></span> (<span class="id">set</span> (<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">subspace</a></span> <span class="id">A</span>)) :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">x</span> \<span class="kwd">in</span> <span class="id">A</span> <span class="kwd">then</span> <span class="id">within</span> <span class="id">A</span> (<span class="id">nbhs</span> <span class="id">x</span>) <span class="kwd">else</span> <span class="id">globally</span> [<span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_simpl">x</a></span>].<br/>
<br/>
<span class="kwd">Variant</span> <span class="id">nbhs_subspace_spec</span> <span class="id">x</span> : <span class="kwd">Prop</span> -&gt; <span class="kwd">Prop</span> -&gt; <span class="id">bool</span> -&gt; <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>) -&gt; <span class="kwd">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id">WithinSubspace</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">nbhs_subspace_spec</span> <span class="id">x</span> <span class="id">True</span> <span class="id">False</span> <span class="id">true</span> (<span class="id">within</span> <span class="id">A</span> (<span class="id">nbhs</span> <span class="id">x</span>))<br/>
&nbsp;&nbsp;| <span class="id">WithoutSubspace</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;~ <span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">nbhs_subspace_spec</span> <span class="id">x</span> <span class="id">False</span> <span class="id">True</span> <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">false</a></span> (<span class="id">globally</span> [<span class="id">set</span> <span class="id">x</span>]).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#Subspace.A">nbhs_subspaceP</a></span> <span class="id">x</span> :<br/>
&nbsp;&nbsp;<span class="id">nbhs_subspace_spec</span> <span class="id">x</span> (<span class="id">A</span> <span class="id">x</span>) (~ <span class="id">A</span> <span class="id">x</span>) (<span class="id">x</span> \<span class="kwd">in</span> <span class="id">A</span>) (<span class="id">nbhs_subspace</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof574')">Proof.</span></div>
<div class="proofscript" id="proof574">
<span class="id">rewrite</span> /<span class="id">nbhs_subspace</span>; <span class="id">case</span>:(<span class="id">boolP</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#inE">x</a></span> \<span class="kwd">in</span> <span class="id">A</span>)); <span class="id">rewrite</span> ?(<span class="id">inE</span>, <span class="id">notin_set</span>) =&gt; <span class="id">xA</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> (@<span class="id">propext</span> (<span class="id">A</span> <span class="id">x</span>) <span class="id">True</span>)// <span class="id">not_True</span>; <span class="id">constructor</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> (@<span class="id">propext</span> (<span class="id">A</span> <span class="id">x</span>) <span class="id">False</span>)// <span class="id"><a name="f:3254">not_False</a></span>; <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_subspace_in</span> (<span class="id">x</span> : <span class="id">T</span>) : <span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">within</span> <span class="id"><a href="mathcomp.classical.boolp.html#propeqE">A</a></span> (<span class="id">nbhs</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#in_setP">x</a></span>) = <span class="id">nbhs_subspace</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof575')">Proof.</span></div>
<div class="proofscript" id="proof575">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id">nbhs_subspaceP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_subspace_out</span> (<span class="id">x</span> : <span class="id">T</span>) : ~ <span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">globally</span> [<span class="id">set</span> <span class="id">x</span>] = <span class="id">nbhs_subspace</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof576')">Proof.</span></div>
<div class="proofscript" id="proof576">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id">nbhs_subspaceP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_subspace_filter</span> (<span class="id"><a name="nbhs_subspace_interior">x</a></span> : <span class="id">subspace</span> <span class="id">A</span>) : <span class="id">ProperFilter</span> (<span class="id">nbhs_subspace</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof577')">Proof.</span></div>
<div class="proofscript" id="proof577">
<span class="id">case</span>: <span class="id">nbhs_subspaceP</span> =&gt; ?; <span class="id">last</span> <span class="id">exact</span>: <span class="id">globally_properfilter</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">within_nbhs_proper</span>; <span class="id">apply</span>: <span class="id">subset_closure</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">subspace_pointedType</span> := <span class="id">PointedType</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Subspace.T">subspace</a></span> <span class="id">A</span>) <span class="id">point</span>.<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">subspace_filteredType</span> :=<br/>
&nbsp;&nbsp;<span class="id">FilteredType</span> (<span class="id">subspace</span> <span class="id">A</span>) (<span class="id">subspace</span> <span class="id">A</span>) <span class="id">nbhs_subspace</span>.<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id">subspace_topologicalMixin</span> :<br/>
&nbsp;&nbsp;<span class="id">Topological.mixin_of</span> (<span class="id">nbhs_subspace</span>) := @<span class="id">topologyOfFilterMixin</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">subspace</span> <span class="id">A</span>) <span class="id">nbhs_subspace</span> <span class="id">nbhs_subspace_filter</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof578')">Next Obligation.</span></div>
<div class="proofscript" id="proof578">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">p</span> <span class="id">A0</span>; <span class="id">case</span>: <span class="id"><a name="open_subspace1out">nbhs_subspaceP</a></span> =&gt; ? =&gt; [/<span class="id">nbhs_singleton</span>|]; <span class="id">apply</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof579')">Next Obligation.</span></div>
<div class="proofscript" id="proof579">
<span class="id">move</span>=&gt; <span class="id">p</span> <span class="id">A0</span>; <span class="id">case</span>: <span class="id">nbhs_subspaceP</span> =&gt; [|] <span class="id">Ap</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">nbhs_interior</a></span>; <span class="id">apply</span>: <span class="id">filterS</span> =&gt; <span class="id">y</span> <span class="id">A0y</span> <span class="id">Ay</span>; <span class="id">case</span>: <span class="id">nbhs_subspaceP</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">E</span> <span class="id">x</span> -&gt;; <span class="id">case</span>: <span class="id">nbhs_subspaceP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id">subspace_topologicalType</span> :=<br/>
&nbsp;&nbsp;<span class="id">TopologicalType</span> (<span class="id">subspace</span> <span class="id">A</span>) <span class="id">subspace_topologicalMixin</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">subspace_cvgP</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">x</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; <span class="id">A</span> <span class="id">x</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">F</span> --&gt; (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">A</span>)) &lt;-&gt; (<span class="id">F</span> --&gt; <span class="id">within</span> <span class="id">A</span> (<span class="id">nbhs</span> <span class="id">x</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof580')">Proof.</span></div>
<div class="proofscript" id="proof580">
 <span class="kwd">by</span> <span class="id">case</span>: (<span class="id">y</span> <span class="kwd">in</span> <span class="id">F</span> --&gt; <span class="id">y</span>) / <span class="id">nbhs_subspaceP</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">subspace_continuousP</span> {<span class="id">S</span> : <span class="id">topologicalType</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">S</span>) :<br/>
&nbsp;&nbsp;<span class="id">continuous</span> (<span class="id">f</span> : <span class="id">subspace</span> <span class="id">A</span> -&gt; <span class="id">S</span>) &lt;-&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">f</span> @ <span class="id">within</span> <span class="id">A</span> (<span class="id">nbhs</span> <span class="id">x</span>) --&gt; <span class="id">f</span> <span class="id">x</span>) .<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof581')">Proof.</span></div>
<div class="proofscript" id="proof581">
<span class="id">split</span> =&gt; [<span class="id"><a name="U:3265">ctsf</a></span> <span class="id">x</span> <span class="id">Ax</span> <span class="id">W</span> /=|<span class="id">wA</span> <span class="id"><a href="mathcomp.analysis.topology.html#Subspace.A">x</a></span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">nbhs_simpl</span> //= <span class="id">nbhs_subspace_in</span> //=; <span class="id">apply</span>: <span class="id">ctsf</span>.<br/>
<span class="id">case</span>: (<span class="id">y</span> <span class="kwd">in</span> <span class="id">_</span> @[<span class="id">_</span> --&gt; <span class="id">y</span>]) / (<span class="id">nbhs_subspaceP</span> <span class="id">x</span>) =&gt; <span class="id">Ax</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: (<span class="id">cvg_trans</span> <span class="id">_</span> (<span class="id">wA</span> <span class="id">_</span> <span class="id">Ax</span>)).<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; ? /<span class="id">nbhs_singleton</span> //= ?; <span class="id">rewrite</span> <span class="id">nbhs_simpl</span> =&gt; ? -&gt;.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">subspace_eq_continuous</span> {<span class="id">S</span> : <span class="id">topologicalType</span>} (<span class="id">f</span> <span class="id">g</span> : <span class="id">subspace</span> <span class="id">A</span> -&gt; <span class="id">S</span>) :<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> <span class="id">A</span>, <span class="id">f</span> =1 <span class="id">g</span>} -&gt; <span class="id">continuous</span> <span class="id">f</span> -&gt; <span class="id">continuous</span> <span class="id">g</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof582')">Proof.</span></div>
<div class="proofscript" id="proof582">
<span class="id">rewrite</span> ?<span class="id">subspace_continuousP</span>=&gt; <span class="id">feq</span> <span class="id">L</span> <span class="id">x</span> <span class="id">Ax</span>; <span class="id">rewrite</span> -(<span class="id">feq</span> <span class="id">x</span>) ?<span class="id">inE</span> //.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">cvg_trans</span> <span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.topology.html#closed">L</a></span> <span class="id">x</span> <span class="id">Ax</span>); <span class="id">apply</span>: <span class="id">fmap_within_eq</span>=&gt; ? ?; <span class="id">rewrite</span> <span class="id">feq</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_subspace_in</span> {<span class="id">U</span> : <span class="id"><a href="mathcomp.analysis.topology.html#open_subspaceIT">topologicalType</a></span>} (<span class="id">f</span> : <span class="id">subspace</span> <span class="id"><a href="mathcomp.analysis.topology.html#open0">A</a></span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id">continuous</span> <span class="id">f</span> = {<span class="kwd">in</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof583')">Proof.</span></div>
<div class="proofscript" id="proof583">
<span class="id">rewrite</span> <span class="id">propeqE</span> <span class="id">in_setP</span> <span class="id">subspace_continuousP</span>/<span class="id">filter_of</span>/<span class="id">nbhs</span> //=; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Q</span> <span class="id">x</span> <span class="id">Ax</span>; <span class="id">case</span>: (<span class="id">nbhs_subspaceP</span> <span class="id">x</span>) =&gt; //=; <span class="id">exact</span>: <span class="id">Q</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; + <span class="id">x</span> <span class="id">Ax</span> =&gt; /(<span class="id">_</span> <span class="id">x</span> <span class="id">Ax</span>); <span class="id">case</span>: (<span class="id">nbhs_subspaceP</span> <span class="id">x</span>) =&gt; //=; <span class="id">exact</span>: <span class="id">Q</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_subspace_interior</span> (<span class="id">x</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">A</span>^° <span class="id">x</span> -&gt; <span class="id">nbhs</span> <span class="id">x</span> = (<span class="id">nbhs</span> (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">A</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof584')">Proof.</span></div>
<div class="proofscript" id="proof584">
<span class="id">move</span>=&gt; /[<span class="id">dup</span>] /[<span class="id">dup</span>] /<span class="id">interior_subset</span> ? /<span class="id">within_interior</span> &lt;- ?.<br/>
<span class="kwd">by</span> <span class="id"><a name="V:3270">case</a></span>: <span class="id">RHS</span> / <span class="id">nbhs_subspaceP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_subspace_ex</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) (<span class="id">x</span> : <span class="id">T</span>) : <span class="id">A</span> <span class="id">x</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">nbhs</span> (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">A</span>) <span class="id">U</span> &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists2</span> <span class="id">V</span>, <span class="id"><a href="mathcomp.analysis.topology.html#withinE">nbhs</a></span> (<span class="id">x</span> : <span class="id">T</span>) <span class="id">V</span> &amp; <span class="id">U</span> `&amp;` <span class="id">A</span> = <span class="id">V</span> `&amp;` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof585')">Proof.</span></div>
<div class="proofscript" id="proof585">
 <span class="kwd">by</span> <span class="id">case</span>: (<span class="id">nbhs</span> <span class="id">_</span>) / <span class="id">nbhs_subspaceP</span>; <span class="id"><a href="mathcomp.analysis.topology.html#open_nbhsE">rewrite</a></span> // ?<span class="id">withinE</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">incl_subspace_continuous</span> : <span class="id">continuous</span> <span class="id">incl_subspace</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof586')">Proof.</span></div>
<div class="proofscript" id="proof586">
 <span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#interior_subset">apply</a></span>/<span class="id">subspace_continuousP</span> =&gt; <span class="id">x</span> <span class="id">Ax</span>; <span class="id">apply</span>: <span class="id">cvg_within</span>. Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">SubspaceOpen</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_subspace1out</span> (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">A</span>) : ~ <span class="id">A</span> <span class="id">x</span> -&gt; <span class="id">open</span> [<span class="id">set</span> <span class="id">x</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof587')">Proof.</span></div>
<div class="proofscript" id="proof587">
<span class="id">move</span>=&gt; /<span class="id">nbhs_subspace_out</span> <span class="id">E</span>; <span class="id">have</span> : <span class="id">nbhs</span> <span class="id">x</span> [<span class="id">set</span> <span class="id">x</span>] <span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">nbhs</span> //= -<span class="id">E</span>.<br/>
<span class="id">rewrite</span> <span class="id">nbhsE</span> =&gt; [[<span class="id">U</span> []]] <span class="id">oU</span> <span class="id">Ux</span> <span class="id">Usub</span>; <span class="id">suff</span> : <span class="id">U</span> = [<span class="id">set</span> <span class="id">x</span>] <span class="kwd">by</span> <span class="id">move</span>=&gt; &lt;-.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; // <span class="id">t</span> -&gt;.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_subspace_out</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) : <span class="id">U</span> `&lt;=` ~` <span class="id">A</span> -&gt; <span class="id">open</span> <span class="id">U</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof588')">Proof.</span></div>
<div class="proofscript" id="proof588">
<span class="id">move</span>=&gt; <span class="id">Usub</span>; <span class="id">rewrite</span> (<span class="id">_</span> : <span class="id">U</span> = \<span class="id">bigcup_</span>(<span class="id">i</span> <span class="kwd">in</span> <span class="id">U</span>) [<span class="id">set</span> <span class="id">i</span>]).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">bigcup_open</span> =&gt; ? ?; <span class="id">apply</span>: <span class="id">open_subspace1out</span>; <span class="id"><a name="U:3275">exact</a></span>: <span class="id">Usub</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id">x</span>; [<span class="id">move</span>=&gt; ?; <span class="kwd">exists</span> <span class="id">x</span>|<span class="id">case</span>=&gt; <span class="id">i</span> ? -&gt;].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_subspaceT</span> : <span class="id">open</span> (<span class="id"><a href="mathcomp.analysis.topology.html#openC">A</a></span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof589')">Proof.</span></div>
<div class="proofscript" id="proof589">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id"><a href="mathcomp.classical.boolp.html#eq_exists">case</a></span>: <span class="id">nbhs_subspaceP</span> =&gt; //= ? ?; <span class="id">apply</span>: <span class="id">withinT</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_subspaceIT</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) : <span class="id">open</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#congr1">U</a></span> `&amp;` <span class="id">A</span>) = <span class="id">open</span> <span class="id">U</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof590')">Proof.</span></div>
<div class="proofscript" id="proof590">
<span class="id">apply</span>/<span class="id">propext</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">oU</span>; <span class="id"><a name="open_subspaceW">apply</a></span>: <span class="id">openI</span> =&gt; //; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">apply</a></span>: <span class="id">open_subspaceT</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">oUA</span>; <span class="id">rewrite</span> (<span class="id">_</span> : <span class="id">U</span> = (<span class="id">U</span> `&amp;` <span class="id">A</span>) `|` (<span class="id">U</span> `&amp;` ~`<span class="id">A</span>)).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">openU</span> =&gt; //; <span class="id">apply</span>: <span class="id">open_subspace_out</span> =&gt; ? [].<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.analysis.topology.html#Subspace.T">setIUr</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#closed">setUCr</a></span> <span class="id">setIT</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_subspaceTI</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) :<br/>
&nbsp;&nbsp;<span class="id">open</span> (<span class="id">A</span> `&amp;` <span class="id">U</span> : <span class="id"><a href="mathcomp.analysis.topology.html#open_subspaceW">set</a></span> (<span class="id">subspace</span> <span class="id">A</span>)) = <span class="id">open</span> <span class="id">U</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof591')">Proof.</span></div>
<div class="proofscript" id="proof591">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">setIC</span> <span class="id">open_subspaceIT</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_subspaceT</span> : <span class="id">closed</span> (<span class="id">A</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof592')">Proof.</span></div>
<div class="proofscript" id="proof592">
<span class="id">rewrite</span> -(<span class="id">setCK</span> <span class="id">A</span>);<br/>
<span class="kwd">by</span> <span class="id"><a href="mathcomp.classical.boolp.html#propext">apply</a></span>: <span class="id">open_closedC</span>; <span class="id">rewrite</span> -<span class="id">open_subspaceIT</span> <span class="id">setICl</span>; <span class="id">exact</span>: <span class="id">open0</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_subspaceP</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">open</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">V</span>, <span class="id">open</span> (<span class="id">V</span> : <span class="id"><a href="mathcomp.analysis.topology.html#subspace">set</a></span> <span class="id">T</span>) /\ <span class="id">V</span> `&amp;` <span class="id">A</span> = <span class="id"><a href="mathcomp.analysis.topology.html#Subspace.A">U</a></span> `&amp;` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof593')">Proof.</span></div>
<div class="proofscript" id="proof593">
<span class="id">split</span>=&gt; [|[<span class="id">V</span> [<span class="id">oV</span> <span class="id">UV</span>]]]; <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> -<span class="id">open_subspaceIT</span> -<span class="id">UV</span> =&gt; <span class="id">x</span> //= []; <span class="id">case</span>: <span class="id">nbhs_subspaceP</span> =&gt; //=.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#Subspace.A">withinE</a></span> /= =&gt; <span class="id">Ax</span> <span class="id">Vx</span> <span class="id">_</span>; <span class="kwd">exists</span> <span class="id">V</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">setIA</span> <span class="id">setIid</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>: <span class="id">oV</span>; <span class="id">rewrite</span> <span class="id">openE</span>; <span class="id">exact</span>.<br/>
<span class="id">rewrite</span> -<span class="id">open_subspaceIT</span> =&gt; <span class="id">oUA</span>.<br/>
<span class="id">have</span> <span class="id"><a href="mathcomp.analysis.topology.html#closedI">oxF</a></span> <span class="id">x</span> : (<span class="id">U</span> `&amp;` <span class="id">A</span>) <span class="id">x</span> -&gt; <span class="kwd">exists2</span> <span class="id">V</span>, <span class="id">open_nbhs</span> <span class="id">x</span> <span class="id">V</span> &amp; <span class="id">V</span> `&amp;` <span class="id">A</span> `&lt;=` <span class="id">U</span> `&amp;` <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /[<span class="id">dup</span>] <span class="id">UAx</span> [<span class="id">Ux</span> <span class="id">Ax</span>]; <span class="id">move</span>: (<span class="id">oUA</span> <span class="id">_</span> <span class="id">UAx</span>); <span class="id">case</span>: <span class="id">nbhs_subspaceP</span> =&gt; // <span class="id">_</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">withinE</span> /= =&gt; -[<span class="id">V</span> <span class="id">nbhsV</span>]; <span class="id">rewrite</span> -<span class="id">setIA</span> <span class="id">setIid</span> =&gt; <span class="id">UV</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">V</span>^°; <span class="id">rewrite</span> ?<span class="id"><a name="U:3284">open_nbhsE</a></span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">split</span>; [<span class="id"><a href="mathcomp.analysis.topology.html#closure">exact</a></span>: <span class="id">open_interior</span>|<span class="id">exact</span>: <span class="id">nbhs_interior</span>].<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">UV</span> =&gt; <span class="id">t</span> [/<span class="id">interior_subset</span>].<br/>
<span class="id">pose</span> <span class="id">f</span> <span class="id">x</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">pselect</span> ((<span class="id">U</span> `&amp;` <span class="id">A</span>) <span class="id">x</span>) <span class="id">is</span> <span class="id">left</span> <span class="id">e</span> <span class="kwd">then</span> <span class="id">projT1</span> (<span class="id">cid2</span> (<span class="id">oxF</span> <span class="id">x</span> <span class="id">e</span>)) <span class="kwd">else</span> <span class="id">set0</span>.<br/>
<span class="kwd">exists</span> (\<span class="id">bigcup_</span>(<span class="id">x</span> <span class="kwd">in</span> <span class="id">U</span> `&amp;` <span class="id">A</span>) <span class="id">f</span> <span class="id">x</span>); <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">bigcup_open</span> =&gt; <span class="id">i</span> <span class="id">UAi</span>; <span class="id">rewrite</span> /<span class="id">f</span>; <span class="id">case</span>: <span class="id">pselect</span> =&gt; // ?.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>: (<span class="id">cid2</span> <span class="id">_</span>) =&gt; //= <span class="id">W</span>; <span class="id">rewrite</span> <span class="id">open_nbhsE</span> =&gt; -[].<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span> /<span class="id">f</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#subset_closure">t</a></span> [[<span class="id">u</span> <span class="id">UAu</span>]] /=; <span class="id">case</span>: <span class="id">pselect</span> =&gt; //= ?.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>: (<span class="id">cid2</span> <span class="id">_</span>) =&gt; /= <span class="id">W</span> <span class="id">_</span> + ? ?; <span class="id">exact</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">t</span> <span class="id">UAt</span>; <span class="id"><a href="mathcomp.classical.classical_sets.html#setSI">split</a></span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#closureE">case</a></span>: <span class="id">UAt</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#smallest_sub">t</a></span> =&gt; //; <span class="id">case</span>: <span class="id">pselect</span> =&gt; //= -[<span class="id">Ut</span> <span class="id">At</span>]; <span class="id">case</span>: (<span class="id">cid2</span> <span class="id">_</span>) =&gt; //= <span class="id">W</span> [].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_subspaceP</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">closed</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">V</span>, <span class="id"><a name="subspace_hausdorff">closed</a></span> (<span class="id">V</span> : <span class="id">set</span> <span class="id">T</span>) /\ <span class="id">V</span> `&amp;` <span class="id">A</span> = <span class="id">U</span> `&amp;` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof594')">Proof.</span></div>
<div class="proofscript" id="proof594">
<span class="id">rewrite</span> -<span class="id">openC</span> <span class="id">open_subspaceP</span>.<br/>
<span class="id">under</span> [<span class="id">X</span> <span class="kwd">in</span> <span class="id">_</span> &lt;-&gt; <span class="id">X</span>] <span class="id">eq_exists</span> =&gt; <span class="id">V</span> <span class="id">do</span> <span class="id">rewrite</span> -<span class="id">openC</span>.<br/>
<span class="kwd">by</span> <span class="id">split</span> =&gt; -[<span class="id">V</span> [? <span class="id">VU</span>]]; <span class="kwd">exists</span> (~` <span class="id">V</span>); <span class="id">split</span>; <span class="id">rewrite</span> ?<span class="id">setCK</span> //;<br/>
&nbsp;&nbsp;<span class="id">move</span>/(<span class="id">congr1</span> <span class="id">setC</span>): <span class="id">VU</span>; <span class="id">rewrite</span> ?<span class="id">eqEsubset</span> ?<span class="id">setCI</span> ?<span class="id">setCK</span>; <span class="id">firstorder</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_subspaceW</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">open</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) -&gt; <span class="id">open</span> (<span class="id"><a href="mathcomp.analysis.topology.html#subspace">U</a></span> : <span class="id">set</span> (<span class="id"><a href="mathcomp.analysis.topology.html#Subspace.A">subspace</a></span> <span class="id">A</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof595')">Proof.</span></div>
<div class="proofscript" id="proof595">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Subspace.T">oU</a></span>; <span class="id">apply</span>/<span class="id">open_subspaceP</span>; <span class="kwd">exists</span> <span class="id">U</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_subspaceW</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">closed</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) -&gt; <span class="id">closed</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof596')">Proof.</span></div>
<div class="proofscript" id="proof596">
  <span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">closed_openC</span>/<span class="id"><a href="mathcomp.analysis.topology.html#cvg_trans">open_subspaceW</a></span>/<span class="id">open_closedC</span>; <span class="id">rewrite</span> <span class="id">setCK</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_setIS</span> (<span class="id">U</span> : <span class="id"><a href="mathcomp.analysis.topology.html#subspace_cvgP">set</a></span> (<span class="id">subspace</span> <span class="id">A</span>)) : <span class="id">open</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">open</span> (<span class="id">U</span> `&amp;` <span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) = <span class="id">open</span> <span class="id">U</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof597')">Proof.</span></div>
<div class="proofscript" id="proof597">
<span class="id">move</span>=&gt; <span class="id">oA</span>; <span class="id">apply</span>/<span class="id">propext</span>; <span class="id">rewrite</span> <span class="id">open_subspaceP</span>.<br/>
<span class="id">split</span>=&gt; [|[<span class="id">V</span> [<span class="id">oV</span> &lt;-]]]; <span class="id">last</span> <span class="id">exact</span>: <span class="id">openI</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">oUA</span>; <span class="kwd">exists</span> (<span class="id">U</span> `&amp;` <span class="id">A</span>); <span class="id">rewrite</span> -<span class="id">setIA</span> <span class="id">setIid</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_setSI</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) : <span class="id">open</span> <span class="id">A</span> -&gt; <span class="id">open</span> (<span class="id">A</span> `&amp;` <span class="id">U</span>) = <span class="id">open</span> <span class="id">U</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof598')">Proof.</span></div>
<div class="proofscript" id="proof598">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">oA</span>; <span class="id">rewrite</span> -<span class="id">setIC</span> <span class="id"><a href="mathcomp.analysis.topology.html#Subspace.A">open_setIS</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_setIS</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) : <span class="id">closed</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">closed</span> (<span class="id">U</span> `&amp;` <span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) = <span class="id">closed</span> <span class="id">U</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof599')">Proof.</span></div>
<div class="proofscript" id="proof599">
<span class="id">move</span>=&gt; <span class="id">oA</span>; <span class="id">apply</span>/<span class="id">propext</span>; <span class="id">rewrite</span> <span class="id">closed_subspaceP</span>.<br/>
<span class="id">split</span>=&gt; [|[<span class="id">V</span> [<span class="id">oV</span> &lt;-]]]; <span class="id">last</span> <span class="id">exact</span>: <span class="id">closedI</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">oUA</span>; <span class="kwd">exists</span> (<span class="id">U</span> `&amp;` <span class="id">A</span>); <span class="id">rewrite</span> -<span class="id">setIA</span> <span class="id">setIid</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closed_setSI</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) :<br/>
&nbsp;&nbsp;<span class="id">closed</span> <span class="id">A</span> -&gt; <span class="id">closed</span> (<span class="id">A</span> `&amp;` <span class="id">U</span>) = <span class="id"><a href="mathcomp.analysis.topology.html#open_subspaceP">closed</a></span> <span class="id">U</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof600')">Proof.</span></div>
<div class="proofscript" id="proof600">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">oA</span>; <span class="id">rewrite</span> -<span class="id">setIC</span> <span class="id">closed_setIS</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">closure_subspaceW</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.classical_sets.html#setIC">U</a></span> `&lt;=` <span class="id">A</span> -&gt; <span class="id">closure</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) = <span class="id">closure</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) `&amp;` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof601')">Proof.</span></div>
<div class="proofscript" id="proof601">
<span class="id">have</span> /<span class="id">closed_subspaceP</span> := (@<span class="id">closed_closure</span> <span class="id">_</span> (<span class="id">U</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>))).<br/>
<span class="id">move</span>=&gt; [<span class="id"><a href="mathcomp.analysis.topology.html#subspace">V</a></span>] [<span class="id">clV</span> <span class="id">VAclUA</span>] /[<span class="id">dup</span>] /(@<span class="id">closure_subset</span> <span class="id">subspace_topologicalType</span>).<br/>
<span class="id">have</span>/<span class="id">closure_id</span> &lt;- := (<span class="id">closed_subspaceT</span>) =&gt; /<span class="id">setIidr</span> &lt;-; <span class="id">rewrite</span> <span class="id">setIC</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">UsubA</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">setSI</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_subspace_filter">closureE</a></span>; <span class="id">apply</span>: <span class="id">smallest_sub</span> (@<span class="id">subset_closure</span> <span class="id">_</span> <span class="id">U</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">closed_subspaceW</span>; <span class="id">exact</span>: <span class="id">closed_closure</span>.<br/>
<span class="id">rewrite</span> -<span class="id">VAclUA</span>; <span class="id">apply</span>: <span class="id">setSI</span>; <span class="id">rewrite</span> <span class="id">closureE</span> //=; <span class="id">apply</span>: <span class="id">smallest_sub</span> =&gt; //.<br/>
<span class="id">apply</span>: <span class="id">subset_trans</span> (@<span class="id">subIsetl</span> <span class="id">_</span> <span class="id">V</span> <span class="id">A</span>); <span class="id">rewrite</span> <span class="id">VAclUA</span> <span class="id">subsetI</span>; <span class="id">split</span> =&gt; //.<br/>
<span class="id">exact</span>: (@<span class="id">subset_closure</span> <span class="id">_</span> (<span class="id">U</span> : <span class="id"><a name="SubspaceRelative">set</a></span> (<span class="id">subspace</span> <span class="id">A</span>))).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">subspace_hausdorff</span> :<br/>
&nbsp;&nbsp;<span class="id">hausdorff_space</span> <span class="id">T</span> -&gt; <span class="id">hausdorff_space</span> [<span class="id"><a href="mathcomp.classical.classical_sets.html#set">topologicalType</a></span> <span class="id">of</span> <span class="id">subspace</span> <span class="id">A</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof602')">Proof.</span></div>
<div class="proofscript" id="proof602">
<span class="id">rewrite</span> ?<span class="id">open_hausdorff</span> =&gt; + <span class="id">x</span> <span class="id">y</span> <span class="id">xNy</span> =&gt; /(<span class="id">_</span> <span class="id">x</span> <span class="id">y</span> <span class="id">xNy</span>).<br/>
<span class="id">move</span>=&gt; [[<span class="id">P</span> <span class="id">Q</span>]] /= [<span class="id">Px</span> <span class="id">Qx</span>] /= [/<span class="id">open_subspaceW</span> <span class="id">oP</span> /<span class="id">open_subspaceW</span> <span class="id">oQ</span>].<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="kwd">exists</span> (<span class="id">P</span>, <span class="id">Q</span>).<br/>
Qed.</div>
<span class="kwd">End</span> <span class="id">SubspaceOpen</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">compact_subspaceIP</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">compact</span> (<span class="id">U</span> `&amp;` <span class="id">A</span> : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)) &lt;-&gt; <span class="id">compact</span> (<span class="id">U</span> `&amp;` <span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof603')">Proof.</span></div>
<div class="proofscript" id="proof603">
<span class="id">rewrite</span> ?<span class="id">compact_ultra</span> /=.<br/>
<span class="id">split</span>=&gt; + <span class="id">F</span> <span class="id">UF</span> <span class="id">FUA</span> =&gt; /(<span class="id">_</span> <span class="id">F</span> <span class="id">UF</span> <span class="id"><a name="U:3298">FUA</a></span>) [<span class="id">x</span>] [[<span class="id">Ux</span> <span class="id">Ax</span>] <span class="id">Fp</span>].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">x</span>; <span class="id">split</span>=&gt; //; <span class="id">move</span>/<span class="id">subspace_cvgP</span>: <span class="id">Fp</span> =&gt; /(<span class="id">_</span> <span class="id">Ax</span>) <span class="id">Fx</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">cvg_trans</span>; [<span class="id">exact</span>: <span class="id">Fx</span> | <span class="id">exact</span>: <span class="id">cvg_within</span>].<br/>
<span class="kwd">exists</span> <span class="id">x</span>; <span class="id">split</span>=&gt; //; <span class="id">apply</span>/<span class="id">subspace_cvgP</span> =&gt; //.<br/>
<span class="id"><a name="nbhs_subspaceT">rewrite</a></span> <span class="id">withinE</span> =&gt; <span class="id">W</span>/= -[<span class="id"><a href="mathcomp.analysis.topology.html#nbhs">V</a></span> <span class="id">nbhsV</span> <span class="id">WV</span>]; <span class="id">apply</span>: <span class="id">filterS</span> (<span class="id">V</span> `&amp;` (<span class="id">U</span> `&amp;` <span class="id">A</span>)) <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">setIC</span> -<span class="id">setIA</span> [<span class="id">A</span> `&amp;` <span class="id">_</span>]<span class="id">setIC</span> -<span class="id">WV</span>=&gt;?[]?[].<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filterI</span>; <span class="id">rewrite</span> <span class="id">nbhs_simpl</span> //; <span class="id">exact</span>: <span class="id">Fp</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">clopen_connectedP</span> : <span class="id">connected</span> <span class="id">A</span> &lt;-&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">U</span>, @<span class="id">clopen</span> (<span class="id">subspace_topologicalType</span>) <span class="id">U</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">U</span> `&lt;=` <span class="id">A</span>  -&gt; <span class="id">U</span> !=<span class="id">set0</span> -&gt; <span class="id">U</span> = <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof604')">Proof.</span></div>
<div class="proofscript" id="proof604">
<span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; + <span class="id">U</span> [/<span class="id">open_subspaceP</span> <span class="id">oU</span> /<span class="id">closed_subspaceP</span> <span class="id">cU</span>] <span class="id">UA</span> <span class="id">U0</span>; <span class="id">apply</span> =&gt; //.<br/>
&nbsp;&nbsp;- <span class="id">case</span>: <span class="id">oU</span> =&gt; <span class="id">V</span> [<span class="id">oV</span> <span class="id">VAUA</span>]; <span class="kwd">exists</span> <span class="id">V</span>; <span class="id">rewrite</span> // <span class="id">setIC</span> <span class="id">VAUA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>/<span class="id">esym</span>/<span class="id">setIidPl</span>.<br/>
&nbsp;&nbsp;- <span class="id">case</span>: <span class="id">cU</span> =&gt; <span class="id">V</span> [<span class="id">cV</span> <span class="id">VAUA</span>]; <span class="kwd">exists</span> <span class="id">V</span> =&gt; //; <span class="id">rewrite</span> <span class="id">setIC</span> <span class="id">VAUA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>/<span class="id">esym</span>/<span class="id">setIidPl</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">clpnA</span> <span class="id">U</span> <span class="id">Un0</span> [<span class="id">V</span> <span class="id">oV</span> <span class="id">UVA</span>] [<span class="id">W</span> <span class="id">cW</span> <span class="id"><a href="mathcomp.analysis.topology.html#SubspaceRelative.T">UWA</a></span>]; <span class="id">apply</span>: <span class="id">clpnA</span> =&gt; //; <span class="id">first</span> <span class="id">split</span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">open_subspaceP</span>; <span class="kwd">exists</span> <span class="id">V</span>; <span class="id">rewrite</span> <span class="id">setIC</span> <span class="id">UVA</span> <span class="id">setIAC</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#in_setP">setIid</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">closed_subspaceP</span>; <span class="kwd">exists</span> <span class="id">W</span>; <span class="id">rewrite</span> <span class="id">setIC</span> <span class="id">UWA</span> <span class="id">setIAC</span> <span class="id">setIid</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">UWA</span>; <span class="id">exact</span>: <span class="id">subIsetl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">Subspace</span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id">subspace_filter</span> {<span class="id">T</span> : <span class="id">topologicalType</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">A</span> : <span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#continuous_subspace_in">T</a></span>) (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">A</span>) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id">Filter</span> (<span class="id">nbhs_subspace</span> <span class="id">x</span>) := <span class="id">nbhs_subspace_filter</span> <span class="id">x</span>.<br/>
<br/>
<span class="id">Global</span> <span class="kwd">Instance</span> <span class="id">subspace_proper_filter</span> {<span class="id">T</span> : <span class="id">topologicalType</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">A</span>) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id">ProperFilter</span> (<span class="id">nbhs_subspace</span> <span class="id">x</span>) := <span class="id">nbhs_subspace_filter</span> <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Notation</span> "{ '<span class="id">within</span>' <span class="id">A</span> , '<span class="id">continuous</span>' <span class="id">f</span> }" := (<span class="kwd">forall</span> <span class="id">x</span>,<br/>
&nbsp;&nbsp;<span class="id">cvg_to</span> [<span class="id">filter</span> <span class="id">of</span> <span class="id">fmap</span> <span class="id">f</span> (<span class="id"><a href="mathcomp.analysis.topology.html#open">filter_of</a></span> (<span class="id">Phantom</span> (<span class="id">subspace</span> <span class="id">A</span>) <span class="id">x</span>))]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id"><a href="mathcomp.analysis.topology.html#open">filter</a></span> <span class="id">of</span> <span class="id"><a href="mathcomp.analysis.topology.html#open">f</a></span> <span class="id">x</span>]) : <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">SubspaceRelative</span>.<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id">topologicalType</span>}.<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> (<span class="id">U</span> : <span class="id">topologicalType</span>) (<span class="id">A</span> <span class="id">B</span> : <span class="id">set</span> <span class="id">T</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_subspace_subset</span> <span class="id">A</span> <span class="id">B</span> (<span class="id">x</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">A</span> `&lt;=` <span class="id">B</span> -&gt; <span class="id">nbhs</span> (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">B</span>) `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#closed">nbhs</a></span> (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof605')">Proof.</span></div>
<div class="proofscript" id="proof605">
<span class="id">rewrite</span> /<span class="id">nbhs</span> //= =&gt; <span class="id">AB</span>; <span class="id">case</span>: (<span class="id">nbhs_subspaceP</span> <span class="id">A</span>); <span class="id">case</span>: (<span class="id">nbhs_subspaceP</span> <span class="id">B</span>).<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id">apply</span>: <span class="id">within_subset</span> =&gt; //=; <span class="id">exact</span>: (<span class="id">nbhs_filter</span> <span class="id">x</span>).<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ? /<span class="id">AB</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Bx</span> ? <span class="id">W</span> /<span class="id">nbhs_singleton</span> /(<span class="id">_</span> <span class="id">Bx</span>) ? ? -&gt;.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_subspaceW</span> {<span class="id">U</span>} <span class="id">A</span> <span class="id">B</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#closed_subspaceP">U</a></span>) :<br/>
&nbsp;&nbsp;<span class="id">A</span> `&lt;=` <span class="id">B</span> -&gt;<br/>
&nbsp;&nbsp;{<span class="id">within</span> <span class="id">B</span>, <span class="id">continuous</span> <span class="id">f</span>} -&gt; {<span class="id">within</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof606')">Proof.</span></div>
<div class="proofscript" id="proof606">
<span class="kwd">by</span> <span class="id">move</span>=&gt; ? <span class="id">ctsF</span> ? ? ?; <span class="id">apply</span>: (@<span class="id">nbhs_subspace_subset</span> <span class="id">A</span> <span class="id">B</span>) =&gt; //; <span class="id">exact</span>: <span class="id">ctsF</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nbhs_subspaceT</span> (<span class="id">x</span> : <span class="id">T</span>) : <span class="id">nbhs</span> (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">setT</span>) = <span class="id">nbhs</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof607')">Proof.</span></div>
<div class="proofscript" id="proof607">
<span class="id">rewrite</span> {1}/<span class="id">nbhs</span> //=; <span class="id">have</span> [<span class="id">_</span>|] := <span class="id">nbhs_subspaceP</span> [<span class="id">set</span>: <span class="id">T</span>]; <span class="id">last</span> <span class="kwd">by</span> <span class="id">cbn</span>.<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span> <span class="id"><a name="A:3325">withinE</a></span>; <span class="id">split</span> =&gt; [<span class="id">W</span> [<span class="id">V</span> <span class="id">nbhsV</span>]|<span class="id">W</span> ?]; <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">W</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> 2!<span class="id">setIT</span> =&gt; -&gt;.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_subspaceT_for</span> {<span class="id">U</span>} <span class="id">A</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) (<span class="id">x</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">A</span> <span class="id">x</span> -&gt; {<span class="kwd">for</span> <span class="id">x</span>, <span class="id">continuous</span> <span class="id">f</span>} -&gt; {<span class="kwd">for</span> <span class="id">x</span>, <span class="id">continuous</span> (<span class="id">f</span> : <span class="id"><a href="mathcomp.analysis.topology.html#open_subspaceIT">subspace</a></span> <span class="id">A</span> -&gt; <span class="id">U</span>)}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof608')">Proof.</span></div>
<div class="proofscript" id="proof608">
<span class="id">rewrite</span> /<span class="id">filter_of</span>/<span class="id">nbhs</span>/=/<span class="id">prop_for</span> =&gt; <span class="id">inA</span> <span class="id">ctsf</span>.<br/>
<span class="id">have</span> [<span class="id">_</span>|//] := <span class="id">nbhs_subspaceP</span> <span class="id">A</span> <span class="id">x</span>.<br/>
<span class="id">apply</span>: (<span class="id">cvg_trans</span> <span class="id">_</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setIid">ctsf</a></span>); <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">apply</a></span>: <span class="id">cvg_fmap2</span>; <span class="id">apply</span>: <span class="id">cvg_within</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">subspace</span>; <span class="id">exact</span>: <span class="id">nbhs_filter</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_in_subspaceT</span> {<span class="id">U</span>} <span class="id">A</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>} -&gt; {<span class="id">within</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof609')">Proof.</span></div>
<div class="proofscript" id="proof609">
<span class="id">rewrite</span> <span class="id">continuous_subspace_in</span> ?<span class="id"><a name="f:3329">in_setP</a></span> =&gt; <span class="id">ctsf</span> <span class="id">t</span> <span class="id">At</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">continuous_subspaceT_for</span> =&gt; //=; <span class="id">apply</span>: <span class="id">ctsf</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_subspaceT</span> {<span class="id">U</span>} <span class="id">A</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id">continuous</span> <span class="id">f</span> -&gt; {<span class="id">within</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof610')">Proof.</span></div>
<div class="proofscript" id="proof610">
<span class="id">move</span>=&gt; <span class="id">ctsf</span>; <span class="id">rewrite</span> <span class="id"><a name="U:3330">continuous_subspace_in</a></span> =&gt; ? ?.<br/>
<span class="id">exact</span>: <span class="id">continuous_in_subspaceT</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_open_subspace</span> {<span class="id">U</span>} <span class="id">A</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id">open</span> <span class="id">A</span> -&gt; {<span class="id">within</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>} = {<span class="kwd">in</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof611')">Proof.</span></div>
<div class="proofscript" id="proof611">
<span class="id">rewrite</span> <span class="id">openE</span> <span class="id">continuous_subspace_in</span> /= =&gt; <span class="id">oA</span>; <span class="id">rewrite</span> <span class="id">propeqE</span> ?<span class="id">in_setP</span>.<br/>
<span class="kwd">by</span> <span class="id">split</span> =&gt; + <span class="id">x</span> /[<span class="id">dup</span>] <span class="id">Ax</span> /<span class="id">oA</span> <span class="id">Aox</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">Ax</span>);<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">filter_of</span> -(<span class="id">nbhs_subspace_interior</span> <span class="id">Aox</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_inP</span> {<span class="id"><a href="mathcomp.analysis.topology.html#uniformType">U</a></span>} <span class="id">A</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) : <span class="id">open</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;{<span class="kwd">in</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>} &lt;-&gt; <span class="kwd">forall</span> <span class="id">X</span>, <span class="id">open</span> <span class="id">X</span> -&gt; <span class="id">open</span> (<span class="id">A</span> `&amp;` <span class="id">f</span> @^-1` <span class="id">X</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof612')">Proof.</span></div>
<div class="proofscript" id="proof612">
<span class="id">move</span>=&gt; <span class="id">oA</span>; <span class="id">rewrite</span> -<span class="id">continuous_open_subspace</span>// <span class="id">continuousP</span>.<br/>
<span class="kwd">by</span> <span class="id">under</span> <span class="id">eq_forall</span> <span class="id">do</span> <span class="id">rewrite</span> -<span class="id">open_setSI</span>//.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">withinU_continuous</span> {<span class="id">U</span>} <span class="id">A</span> <span class="id">B</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) : <span class="id">closed</span> <span class="id">A</span> -&gt; <span class="id">closed</span> <span class="id">B</span> -&gt;<br/>
&nbsp;&nbsp;{<span class="id">within</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>} -&gt; {<span class="id">within</span> <span class="id">B</span>, <span class="id">continuous</span> <span class="id">f</span>} -&gt;<br/>
&nbsp;&nbsp;{<span class="id">within</span> <span class="id">A</span> `|` <span class="id">B</span>, <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof613')">Proof.</span></div>
<div class="proofscript" id="proof613">
<span class="id">move</span>=&gt; ? ? <span class="id">ctsA</span> <span class="id">ctsB</span>; <span class="id">apply</span>/<span class="id">continuous_closedP</span> =&gt; <span class="id">W</span> <span class="id">oW</span>.<br/>
<span class="id">case</span>/<span class="id">continuous_closedP</span>/(<span class="id">_</span> <span class="id">_</span> <span class="id">oW</span>)/<span class="id">closed_subspaceP</span>: <span class="id">ctsA</span> =&gt; <span class="id">V1</span> [? <span class="id">V1W</span>].<br/>
<span class="id">case</span>/<span class="id">continuous_closedP</span>/(<span class="id">_</span> <span class="id">_</span> <span class="id">oW</span>)/<span class="id">closed_subspaceP</span>: <span class="id">ctsB</span> =&gt; <span class="id">V2</span> [? <span class="id">V2W</span>].<br/>
<span class="id">apply</span>/<span class="id">closed_subspaceP</span>; <span class="kwd">exists</span> ((<span class="id">V1</span> `&amp;` <span class="id">A</span>) `|` (<span class="id">V2</span> `&amp;` <span class="id">B</span>)); <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">closedU</span>; <span class="id">exact</span>: <span class="id">closedI</span>.<br/>
<span class="id">rewrite</span> [<span class="id">RHS</span>]<span class="id">setIUr</span> -<span class="id">V2W</span> -<span class="id">V1W</span> <span class="id">eqEsubset</span>; <span class="id">split</span>=&gt; ?.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>=&gt; [[][]] ? ? [] ?; [<span class="id">left</span> | <span class="id">left</span> | <span class="id">right</span> | <span class="id">right</span>]; <span class="id">split</span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>=&gt; [][] ? ?; <span class="id">split</span>=&gt; []; [<span class="id">left</span>; <span class="id">split</span> | <span class="id">left</span> | <span class="id">right</span>; <span class="id">split</span> | <span class="id">right</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">subspaceT_continuous</span> {<span class="id">U</span>} <span class="id">A</span> (<span class="id">B</span> : <span class="id">set</span> <span class="id">U</span>) (<span class="id">f</span> : {<span class="kwd">fun</span> <span class="id">A</span> &gt;-&gt; <span class="id">B</span>}) :<br/>
&nbsp;&nbsp;{<span class="id">within</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>} -&gt; <span class="id">continuous</span> (<span class="id">f</span> : <span class="id">subspace</span> <span class="id">A</span> -&gt; <span class="id">subspace</span> <span class="id">B</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof614')">Proof.</span></div>
<div class="proofscript" id="proof614">
<span class="id">move</span>=&gt; /<span class="id">continuousP</span> <span class="id">ctsf</span>; <span class="id">apply</span>/<span class="id">continuousP</span> =&gt; <span class="id">O</span> /<span class="id">open_subspaceP</span> [<span class="id">V</span> [<span class="id">oV</span> <span class="id">VBOB</span>]].<br/>
<span class="id">rewrite</span> -<span class="id">open_subspaceIT</span>; <span class="id">apply</span>/<span class="id">open_subspaceP</span>.<br/>
<span class="id">case</span>/<span class="id">open_subspaceP</span>: (<span class="id">ctsf</span> <span class="id">_</span> <span class="id">oV</span>) =&gt; <span class="id">W</span> [<span class="id">oW</span> <span class="id">fVA</span>]; <span class="kwd">exists</span> <span class="id">W</span>; <span class="id">split</span> =&gt; //.<br/>
<span class="id">rewrite</span> <span class="id">fVA</span> -<span class="id">setIA</span> <span class="id">setIid</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; <span class="id">x</span> [<span class="id">fVx</span> <span class="id">Ax</span>]; <span class="id">split</span> =&gt; //.<br/>
- <span class="kwd">by</span> <span class="id">have</span> /[!<span class="id">VBOB</span>]-[] : (<span class="id">V</span> `&amp;` <span class="id">B</span>) (<span class="id">f</span> <span class="id">x</span>) <span class="kwd">by</span> <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">funS</span>.<br/>
- <span class="kwd">by</span> <span class="id">have</span> /[!<span class="id">esym</span> <span class="id">VBOB</span>]-[] : (<span class="id">O</span> `&amp;` <span class="id">B</span>) (<span class="id">f</span> <span class="id">x</span>) <span class="kwd">by</span> <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">funS</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_subspace0</span> {<span class="id">U</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) : {<span class="id">within</span> <span class="id">set0</span>, <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof615')">Proof.</span></div>
<div class="proofscript" id="proof615">
<span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">Q</span>; <span class="id">rewrite</span> <span class="id">nbhs_simpl</span> /= {2}/<span class="id">nbhs</span> /=.<br/>
<span class="kwd">by</span> <span class="id">case</span>: (<span class="id">nbhs_subspaceP</span> (@<span class="id">set0</span> <span class="id">T</span>) <span class="id">x</span>) =&gt; // <span class="id">_</span> /<span class="id">nbhs_singleton</span> /= ? ? -&gt;.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_subspace1</span> {<span class="id">U</span>} (<span class="id"><a href="mathcomp.analysis.topology.html#SubspaceUniform.A">a</a></span> : <span class="id">T</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;{<span class="id">within</span> [<span class="id">set</span> <span class="id">a</span>], <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof616')">Proof.</span></div>
<div class="proofscript" id="proof616">
<span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">Q</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsP">nbhs_simpl</a></span> /= {2}/<span class="id">nbhs</span> /=.<br/>
<span class="id">case</span>: (<span class="id">nbhs_subspaceP</span> [<span class="id">set</span> <span class="id">a</span>] <span class="id">x</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#SubspaceUniform.A">move</a></span>=&gt; <span class="id">_</span> /<span class="id">nbhs_singleton</span> /= ? ? -&gt;.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; -&gt; /<span class="id">nbhs_singleton</span> ?; <span class="id">apply</span>: <span class="id">nearW</span> =&gt; ? -&gt;.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">SubspaceRelative</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a href="mathcomp.analysis.topology.html#SubspaceUniform.A">SubspaceUniform</a></span>.<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "<span class="id">A</span> ^-1" := ([<span class="id">set</span> <span class="id">xy</span> | <span class="id">A</span> (<span class="id">xy</span>.2, <span class="id">xy</span>.1)]) : <span class="id">classical_set_scope</span>.<br/>
<span class="kwd">Context</span> {<span class="id">X</span> : <span class="id">uniformType</span>} (<span class="id">A</span> : <span class="id">set</span> <span class="id">X</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">subspace_ent</span> :=<br/>
&nbsp;&nbsp;<span class="id">filter_from</span> (@<span class="id">entourage</span> <span class="id">X</span>)<br/>
&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">E</span> =&gt; [<span class="id">set</span> <span class="id">xy</span> | (<span class="id">xy</span>.1 = <span class="id">xy</span>.2) \/ (<span class="id">A</span> <span class="id">xy</span>.1 /\ <span class="id">A</span> <span class="id">xy</span>.2 /\ <span class="id">E</span> <span class="id">xy</span>)]).<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id">subspace_uniformMixin</span> :=<br/>
&nbsp;&nbsp;@<span class="id">Uniform.Mixin</span> (<span class="id">subspace</span> <span class="id">A</span>) (@<span class="id">nbhs_subspace</span> <span class="id">_</span> <span class="id">_</span>) <span class="id">subspace_ent</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof617')">Next Obligation.</span></div>
<div class="proofscript" id="proof617">
<span class="id">apply</span>: <span class="id">filter_from_filter</span>; <span class="id">first</span> <span class="kwd">by</span> (<span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">exact</span>: <span class="id">filterT</span>).<br/>
<span class="id">move</span>=&gt; <span class="id">P</span> <span class="id">Q</span> <span class="id">entP</span> <span class="id">entQ</span>; <span class="kwd">exists</span> (<span class="id">P</span> `&amp;` <span class="id">Q</span>); <span class="id">first</span> <span class="id">exact</span>: <span class="id">filterI</span>.<br/>
<span class="id">move</span>=&gt; [<span class="id">x</span> <span class="id">y</span>] /=; <span class="id">case</span>; <span class="id">first</span> (<span class="kwd">by</span> <span class="id">move</span>=&gt; -&gt;; <span class="id">split</span>=&gt; /=; <span class="id"><a name="subspace_uniformType">left</a></span>).<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">Ax</span> [<span class="id">Ay</span> [<span class="id"><a href="mathcomp.analysis.topology.html#UniformType">Pxy</a></span> <span class="id">Qxy</span>]]]; <span class="id">split</span>=&gt; /=; <span class="id">right</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof618')">Next Obligation.</span></div>
<div class="proofscript" id="proof618">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; ? + [<span class="id">x</span> <span class="id">y</span>]/= -&gt;; <span class="id">case</span>=&gt; <span class="id">V</span> <span class="id">entV</span>; <span class="id">apply</span>; <span class="id">left</span>. Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof619')">Next Obligation.</span></div>
<div class="proofscript" id="proof619">
<span class="id"><a name="X:3344">move</a></span>=&gt; ?; <span class="id">case</span>=&gt; <span class="id">V</span> ? <span class="id">Vsub</span>; <span class="kwd">exists</span> (<span class="id">V</span>^-1)%<span class="id">classic</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">entourage_inv</span>.<br/>
<span class="id">move</span>=&gt; [<span class="id">x</span> <span class="id">y</span>] /= <span class="id">G</span>; <span class="id">apply</span>: <span class="id">Vsub</span>; <span class="id">case</span>: <span class="id">G</span>; <span class="id">first</span> <span class="kwd">by</span> (<span class="id">move</span>=&gt; &lt;-; <span class="id">left</span>).<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; [? [? <span class="id">Vxy</span>]]; <span class="id">right</span>; <span class="id">repeat</span> <span class="id">split</span> =&gt; //.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof620')">Next Obligation.</span></div>
<div class="proofscript" id="proof620">
<span class="id">move</span>=&gt; ?; <span class="id">case</span>=&gt; <span class="id">E</span> <span class="id">entE</span> <span class="id">Esub</span>.<br/>
<span class="kwd">exists</span>  [<span class="id">set</span> <span class="id">xy</span> | <span class="id">xy</span>.1 = <span class="id">xy</span>.2 \/ <span class="id">A</span> <span class="id">xy</span>.1 /\ <span class="id">A</span> <span class="id">xy</span>.2 /\ <span class="id">split_ent</span> <span class="id">E</span> <span class="id">xy</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">split_ent</span> <span class="id">E</span>).<br/>
<span class="id">move</span>=&gt; [<span class="id">x</span> <span class="id">y</span>] [<span class="id">z</span> /= <span class="id">Ez</span> <span class="id">zE</span>] /=; <span class="id">case</span>: <span class="id">Ez</span>; <span class="id"><a href="mathcomp.analysis.topology.html#ballxx">case</a></span>: <span class="id">zE</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">move</span>=&gt; -&gt; -&gt;; <span class="id">apply</span>: <span class="id">Esub</span>; <span class="id">left</span>.<br/>
&nbsp;&nbsp;- <span class="id">move</span>=&gt; [ ? []] ? <span class="id">G</span> <span class="id">xy</span>; <span class="id">subst</span>; <span class="id">apply</span>: <span class="id">Esub</span>; <span class="id">right</span>; <span class="id">repeat</span> <span class="id">split</span> =&gt; //=.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">entourage_split</span> =&gt; //=; <span class="id">first</span> <span class="id">exact</span>: <span class="id">G</span>; <span class="id">exact</span>: <span class="id">entourage_refl</span>.<br/>
&nbsp;&nbsp;- <span class="id">move</span>=&gt; -&gt; [ ? []] ? <span class="id">G</span>; <span class="id">apply</span>: <span class="id">Esub</span>; <span class="id">right</span>; <span class="id">repeat</span> <span class="id">split</span> =&gt; //=.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">entourage_split</span> =&gt; //=; <span class="id">first</span> <span class="id">exact</span>: <span class="id">G</span>; <span class="id">exact</span>: <span class="id">entourage_refl</span>.<br/>
&nbsp;&nbsp;- <span class="id">move</span>=&gt; []? []? ?[]?[]??; <span class="id">apply</span>: <span class="id">Esub</span>; <span class="id">right</span>; <span class="id">repeat</span> <span class="id">split</span> =&gt; //=.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subset_split_ent</span> =&gt; //; <span class="kwd">exists</span> <span class="id">z</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof621')">Next Obligation.</span></div>
<div class="proofscript" id="proof621">
<span class="id">pose</span>  <span class="id">EA</span> := [<span class="id"><a href="mathcomp.analysis.topology.html#subspace_ball">set</a></span> <span class="id">xy</span> | <span class="id">xy</span>.1 = <span class="id">xy</span>.2 \/ <span class="id">A</span> <span class="id">xy</span>.1 /\ <span class="id">A</span> <span class="id">xy</span>.2].<br/>
<span class="id">have</span> <span class="id">entEA</span> : <span class="id">subspace_ent</span> <span class="id">EA</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">setT</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">filterT</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [??] /= [ -&gt;|[?] [?]];[<span class="id">left</span>|<span class="id">right</span>].<br/>
<span class="id">rewrite</span> <span class="id">funeq2E</span>=&gt; <span class="id">x</span> <span class="id">U</span>.<br/>
<span class="id">case</span>: (@<span class="id">nbhs_subspaceP</span> <span class="id">X</span> <span class="id">A</span> <span class="id">x</span>); <span class="id">rewrite</span> <span class="id">propeqE</span>; <span class="id">split</span> =&gt; //=.<br/>
- <span class="id">rewrite</span> <span class="id">withinE</span>; <span class="id">case</span>=&gt; <span class="id">V</span> /[<span class="id">dup</span>] <span class="id">nbhsV</span> =&gt; [/<span class="id">nbhsP</span> [<span class="id">E</span> <span class="id">entE</span> <span class="id"><a name="xy:3348">Esub</a></span>] <span class="id">UV</span>].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id">xy</span>.1 = <span class="id">xy</span>.2 \/ <span class="id">A</span> <span class="id">xy</span>.1 /\ <span class="id">A</span> <span class="id">xy</span>.2 /\ <span class="id">E</span> <span class="id">xy</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">E</span> =&gt; //= [[??]] /= [-&gt;| [?[]]//]; <span class="id">exact</span>: <span class="id">entourage_refl</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">y</span> /= [&lt;-|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">suff</span> : (<span class="id">U</span> `&amp;` <span class="id">A</span>) <span class="id">x</span> <span class="kwd">by</span> <span class="id">case</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">UV</span>; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: (@<span class="id">nbhs_singleton</span> <span class="id">X</span>).<br/>
&nbsp;&nbsp;<span class="id">case</span>=&gt; <span class="id">_</span> [<span class="id">Ay</span> <span class="id">Ey</span>]; <span class="id">suff</span> : (<span class="id">U</span> `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#subspace_pseudoMetricType_mixin">A</a></span>) <span class="id">y</span> <span class="kwd">by</span> <span class="id">case</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">UV</span>; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: <span class="id">Esub</span>.<br/>
- <span class="id">move</span>=&gt; [] <span class="id"><a name="SubspaceWeak">W</a></span> [<span class="id">E</span> <span class="id">eentE</span> <span class="id">subW</span>] <span class="id">subU</span> //=.<br/>
&nbsp;&nbsp;<span class="id">near</span>=&gt; <span class="id">w</span>; <span class="id">apply</span>: <span class="id">subU</span>; <span class="id">apply</span>: <span class="id">subW</span>; <span class="id">right</span>; <span class="id">repeat</span> <span class="id">split</span> =&gt; //=.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">exact</span>: (<span class="id">near</span> (<span class="id">withinT</span> <span class="id">_</span> (@<span class="id">nbhs_filter</span> <span class="id">X</span> <span class="id">_</span>))).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">near</span>: <span class="id">w</span>; <span class="id">apply</span>/<span class="id">nbhsP</span>; <span class="kwd">exists</span> <span class="id">E</span> =&gt; // <span class="id">y</span> /= <span class="id">Ey</span>.<br/>
- <span class="id">move</span>=&gt; //= <span class="id">Ux</span>; <span class="kwd">exists</span> <span class="id">EA</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">y</span> /= [|[]] //= &lt;-; <span class="id">apply</span>: <span class="id">Ux</span>.<br/>
- <span class="id">rewrite</span> //= =&gt; [[<span class="id">W</span> [<span class="id">W</span>' <span class="id">entW</span>' <span class="id">subW</span>] <span class="id">subU</span>]] ? -&gt;.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subU</span>; <span class="id">apply</span>: <span class="id">subW</span>; <span class="id">left</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id">subspace_uniformType</span> :=<br/>
&nbsp;&nbsp;<span class="id">UniformType</span> (<span class="id">subspace</span> <span class="id">A</span>) <span class="id">subspace_uniformMixin</span>.<br/>
<span class="kwd">End</span> <span class="id">SubspaceUniform</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">SubspacePseudoMetric</span>.<br/>
<span class="kwd">Context</span> {<span class="id"><a name="i:3357">R</a></span> : <span class="id">numDomainType</span>} {<span class="id">X</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>} (<span class="id">A</span> : <span class="id">set</span> <span class="id">X</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">subspace_ball</span> (<span class="id">x</span> : <span class="id">subspace</span> <span class="id">A</span>) (<span class="id">r</span> : <span class="id">R</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">x</span> \<span class="kwd">in</span> <span class="id">A</span> <span class="kwd">then</span> <span class="id">A</span> `&amp;` <span class="id">ball</span> (<span class="id">x</span> : <span class="id">X</span>) <span class="id">r</span> <span class="kwd">else</span> [<span class="id">set</span> <span class="id">x</span>].<br/>
<br/>
<span class="id">Program</span> <span class="kwd">Definition</span> <span class="id">subspace_pseudoMetricType_mixin</span> :=<br/>
&nbsp;&nbsp;@<span class="id">PseudoMetric.Mixin</span> <span class="id">R</span> (<span class="id">subspace</span> <span class="id">A</span>) (<span class="id">subspace_ent</span> <span class="id">A</span>) (<span class="id">subspace_ball</span>)<br/>
&nbsp;&nbsp;<span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof622')">Next Obligation.</span></div>
<div class="proofscript" id="proof622">
<span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">e</span>; <span class="id">rewrite</span> /<span class="id">subspace_ball</span>; <span class="id">case</span>: <span class="id">ifP</span> =&gt; //= /<span class="id">asboolP</span> ? ?.<br/>
<span class="kwd">by</span> <span class="id">split</span>=&gt; //; <span class="id">exact</span>: <span class="id">ballxx</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof623')">Next Obligation.</span></div>
<div class="proofscript" id="proof623">
<span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">y</span> <span class="id">e</span>; <span class="id">rewrite</span> /<span class="id">subspace_ball</span>; <span class="id">case</span>: <span class="id">ifP</span> =&gt; //= /<span class="id">asboolP</span> ?.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [] <span class="id">Ay</span> /<span class="id">ball_sym</span> <span class="id">yBx</span>; <span class="id">case</span>: <span class="id">ifP</span> =&gt; /<span class="id">asboolP</span>.<br/>
<span class="kwd">by</span> <span class="id"><a name="T:3363">move</a></span>=&gt; -&gt;; <span class="id">case</span>: <span class="id">ifP</span> =&gt; /<span class="id">asboolP</span>.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof624')">Next Obligation.</span></div>
<div class="proofscript" id="proof624">
<span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">y</span> <span class="id">z</span> <span class="id">e1</span> <span class="id"><a name="i:3365">e2</a></span>; <span class="id">rewrite</span> /<span class="id">subspace_ball</span>; (<span class="id">repeat</span> <span class="id">case</span>: <span class="id">ifP</span> =&gt; /<span class="id">asboolP</span>).<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt;?? [??] [??]; <span class="id">split</span> =&gt; //=; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#product_embeddings.f_">ball_triangle</a></span>; <span class="id">eauto</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ?? [??] -&gt;.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; + /[<span class="id">swap</span>] =&gt; /[<span class="id">swap</span>] =&gt; -&gt;.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">_</span> <span class="id">_</span> -&gt; -&gt;.<br/>
Qed.</div>
<div><span class="toggleproof" onclick="toggleDisplay('proof625')">Next Obligation.</span></div>
<div class="proofscript" id="proof625">
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>; <span class="id">rewrite</span> /<span class="id">subspace_ball</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">U</span> [<span class="id">W</span> + <span class="id">subU</span>]; <span class="id">rewrite</span> -<span class="id">entourage_ballE</span> =&gt; [[<span class="id"><a href="mathcomp.analysis.topology.html#weak_topologicalType">eps</a></span>] <span class="id">nneg</span> <span class="id">subW</span>].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">eps</span> =&gt; //; <span class="id">apply</span>: (<span class="id">subset_trans</span> <span class="id">_</span> <span class="id">subU</span>).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; [<span class="id"><a href="mathcomp.analysis.topology.html#open">x</a></span> <span class="id">y</span>] /=; <span class="id">case</span>: <span class="id">ifP</span> =&gt; /<span class="id">asboolP</span> ?.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">Ay</span> <span class="id"><a href="mathcomp.analysis.topology.html#product_embeddings.T">xBy</a></span>]; <span class="id">right</span>; <span class="id">repeat</span> <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">subW</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#product_embeddings.weakT">move</a></span>=&gt; -&gt;; <span class="id">left</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">E</span> [<span class="id">eps</span> <span class="id">nneg</span> <span class="id">subE</span>]; <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">xy</span> | <span class="id">ball</span> (<span class="id">xy</span>.1 : <span class="id">X</span>) <span class="id">eps</span> <span class="id">xy</span>.2].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">entourage_ballE</span>; <span class="kwd">exists</span> <span class="id">eps</span>.<br/>
<span class="id">move</span>=&gt; [<span class="id">x</span> <span class="id">y</span>] /= [-&gt;|[]<span class="id"><a href="mathcomp.analysis.topology.html#filterS">Ax</a></span> []<span class="id">Ay</span> <span class="id">xBy</span>]; <span class="id">apply</span>: <span class="id">subE</span> =&gt; //=.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhsE">case</a></span>: <span class="id">ifP</span> =&gt; /<span class="id">asboolP</span>; <span class="id">split</span> =&gt; //; <span class="id">exact</span>: <span class="id">ballxx</span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>: <span class="id">ifP</span> =&gt; /<span class="id">asboolP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id">subspace_pseudoMetricType</span> :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetricType</span> (<span class="id">subspace</span> <span class="id">A</span>) <span class="id">subspace_pseudoMetricType_mixin</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">SubspacePseudoMetric</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">SubspaceWeak</span>.<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id">topologicalType</span>} {<span class="id">U</span> : <span class="id">pointedType</span>}.<br/>
<span class="kwd">Variables</span> (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">T</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">U</span>' := <span class="id">weak_topologicalType</span> <span class="id">f</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_subspace_open</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">U</span>') :<br/>
&nbsp;&nbsp;<span class="id">open</span> <span class="id">A</span> -&gt; <span class="id">open</span> (<span class="id">f</span> @` <span class="id">A</span> : <span class="id"><a href="mathcomp.analysis.topology.html#closed_closure">set</a></span> (<span class="id">subspace</span> (<span class="id">range</span> <span class="id">f</span>))).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof626')">Proof.</span></div>
<div class="proofscript" id="proof626">
<span class="id">case</span>=&gt; <span class="id">B</span> <span class="id">oB</span> &lt;-; <span class="id">apply</span>/<span class="id">open_subspaceP</span>; <span class="kwd">exists</span> <span class="id">B</span>; <span class="id">split</span> =&gt; //; <span class="id">rewrite</span> <span class="id">eqEsubset</span>.<br/>
<span class="id">split</span> =&gt; <span class="id">z</span> [] /[<span class="id">swap</span>]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">w</span> <span class="id">_</span> &lt;- ?; <span class="id">split</span>; <span class="kwd">exists</span> <span class="id">w</span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">w</span> <span class="id">_</span> &lt;- [<span class="id">v</span>] ? &lt;-.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">SubspaceWeak</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">separate_points_from_closed</span> {<span class="id">I</span> : <span class="kwd">Type</span>} {<span class="id">T</span> : <span class="id">topologicalType</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">U_</span> : <span class="id">I</span> -&gt; <span class="id">topologicalType</span>} (<span class="id">f_</span> : <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">T</span> -&gt; <span class="id">U_</span> <span class="id">i</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) <span class="id">x</span>,<br/>
&nbsp;&nbsp;<span class="id">closed</span> <span class="id">U</span> -&gt; ~ <span class="id">U</span> <span class="id">x</span> -&gt; <span class="kwd">exists</span> <span class="id">i</span>, ~ (<span class="id">closure</span> (<span class="id"><a href="mathcomp.analysis.topology.html#open">f_</a></span> <span class="id">i</span> @` <span class="id">U</span>)) (<span class="id">f_</span> <span class="id">i</span> <span class="id">x</span>).<br/>
<br/>
<span class="kwd">Section</span> <span class="id">product_embeddings</span>.<br/>
<span class="kwd">Context</span> {<span class="id">I</span> : <span class="id">choiceType</span>} {<span class="id">T</span> : <span class="id">topologicalType</span>} {<span class="id">U_</span> : <span class="id">I</span> -&gt; <span class="id">topologicalType</span>}.<br/>
<span class="kwd">Variable</span> (<span class="id"><a href="mathcomp.classical.mathcomp_extra.html#proj">f_</a></span> : <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">T</span> -&gt; <span class="id">U_</span> <span class="id">i</span>).<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">sepf</span> : <span class="id">separate_points_from_closed</span> <span class="id">f_</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">ctsf</span> : <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">continuous</span> (<span class="id">f_</span> <span class="id">i</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">weakT</span> := @<span class="id">sup_topologicalType</span> <span class="id">T</span> <span class="id">I</span><br/>
&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">i</span> =&gt; <span class="id">Topological.class</span> (<span class="id">weak_topologicalType</span> (<span class="id">f_</span> <span class="id">i</span>))).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">PU</span> := <span class="id">product_topologicalType</span> <span class="id">U_</span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> <span class="id">sup_open</span> := (@<span class="id">open</span> <span class="id">weakT</span>).<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "'<span class="id"><a href="mathcomp.analysis.topology.html#product_embeddings.T">weak_open</a></span>' <span class="id">i</span>" :=<br/>
&nbsp;&nbsp;(@<span class="id">open</span> (<span class="id">weak_topologicalType</span> (<span class="id">f_</span> <span class="id">i</span>))) (<span class="kwd">at</span> <span class="id">level</span> 0).<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> <span class="id">natural_open</span> := (@<span class="id">open</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">T</a></span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_sep_cvg</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>)) (<span class="id">x</span> : <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; (<span class="id">F</span> --&gt; (<span class="id">x</span> : <span class="id">T</span>)) &lt;-&gt; (<span class="id">F</span> --&gt; (<span class="id">x</span> : <span class="id">weakT</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof627')">Proof.</span></div>
<div class="proofscript" id="proof627">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">FTx</span>; <span class="id">apply</span>/<span class="id">cvg_sup</span> =&gt; <span class="id">i</span> <span class="id">U</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> /= -&gt; := @<span class="id">nbhsE</span> (<span class="id">weak_topologicalType</span> (<span class="id">f_</span> <span class="id">i</span>)) <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>=&gt; <span class="id">B</span> [[<span class="id">C</span> <span class="id">oC</span> &lt;- ?]] /<span class="id">filterS</span>; <span class="id">apply</span>; <span class="id">apply</span>: <span class="id">FTx</span>; <span class="id">rewrite</span> /= <span class="id">nbhsE</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">f_</span> <span class="id">i</span> @^-1` <span class="id">C</span>) =&gt; //; <span class="id">split</span> =&gt; //; <span class="id"><a href="mathcomp.analysis.topology.html#product_embeddings.f_">exact</a></span>: <span class="id">open_comp</span>.<br/>
<span class="id">move</span>/<span class="id">cvg_sup</span> =&gt; <span class="id">wiFx</span> <span class="id">U</span>; <span class="id">rewrite</span> /= <span class="id">nbhs_simpl</span> <span class="id">nbhsE</span> =&gt; [[<span class="id">B</span> [<span class="id">oB</span> ?]]].<br/>
<span class="id">move</span>/<span class="id">filterS</span>; <span class="id">apply</span>; <span class="id">have</span> [//|<span class="id">i</span> <span class="id">nclfix</span>] := @<span class="id">sepf</span> <span class="id"><a href="mathcomp.analysis.topology.html#openI">_</a></span> <span class="id">x</span> (<span class="id">open_closedC</span> <span class="id">oB</span>).<br/>
<span class="id">apply</span>: (<span class="id">wiFx</span> <span class="id">i</span>); <span class="id">have</span> /= -&gt; := @<span class="id">nbhsE</span> (<span class="id">weak_topologicalType</span> (<span class="id">f_</span> <span class="id">i</span>)) <span class="id">x</span>.<br/>
<span class="kwd">exists</span> (<span class="id">f_</span> <span class="id">i</span> @^-1` (~` <span class="id">closure</span> [<span class="id">set</span> <span class="id">f_</span> <span class="id">i</span> <span class="id">x</span> | <span class="id"><a href="mathcomp.analysis.topology.html#proj_continuous">x</a></span> <span class="kwd">in</span> ~` <span class="id">B</span>])); [<span class="id">split</span>=&gt;//|].<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">open_comp</span>; <span class="id"><a href="mathcomp.analysis.topology.html#accessible_space">last</a></span> <span class="kwd">by</span> <span class="id">rewrite</span> ?<span class="id"><a href="mathcomp.analysis.topology.html#product_embeddings.T">openC</a></span>; <span class="id">last</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#product_embeddings.T">closed_closure</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; + <span class="id">_</span>; <span class="id">exact</span>: <span class="id">weak_continuous</span>.<br/>
<span class="id">rewrite</span> <span class="id">closureC</span> <span class="id">preimage_bigcup</span> =&gt; <span class="id">z</span> [<span class="id">V</span> [<span class="id">oV</span>]] <span class="id">VnB</span> =&gt; /<span class="id">VnB</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>/<span class="id">forall2NP</span> =&gt; /(<span class="id">_</span> <span class="id">z</span>) [] // /<span class="id">contrapT</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_sep_nbhsE</span> <span class="id">x</span> : @<span class="id">nbhs</span> <span class="id">T</span> <span class="id">T</span> <span class="id">x</span> = @<span class="id">nbhs</span> <span class="id">T</span> <span class="id">weakT</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof628')">Proof.</span></div>
<div class="proofscript" id="proof628">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">U</span>; <span class="id">split</span>; <span class="id">move</span>: <span class="id">U</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">have</span> <span class="id">P</span> := <span class="id">weak_sep_cvg</span> <span class="id">x</span> (<span class="id">nbhs_filter</span> (<span class="id">x</span> : <span class="id">weakT</span>)); <span class="id">exact</span>/<span class="id">P</span>.<br/>
<span class="kwd">by</span> <span class="id">have</span> <span class="id">P</span> := <span class="id">weak_sep_cvg</span> <span class="id">x</span> (<span class="id">nbhs_filter</span> (<span class="id">x</span> : <span class="id">T</span>)); <span class="id">exact</span>/<span class="id">P</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_sep_openE</span> : @<span class="id">open</span> <span class="id">T</span> = @<span class="id">open</span> <span class="id">weakT</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof629')">Proof.</span></div>
<div class="proofscript" id="proof629">
<span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">A</span>; <span class="id">rewrite</span> ?<span class="id">openE</span> /<span class="id">interior</span>.<br/>
<span class="kwd">by</span> <span class="id">split</span> =&gt; + <span class="id">z</span> =&gt; /(<span class="id">_</span> <span class="id">z</span>); <span class="id">rewrite</span> <span class="id">weak_sep_nbhsE</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">join_product</span> (<span class="id">x</span> : <span class="id">T</span>) : <span class="id">PU</span> := <span class="id">f_</span> ^~ <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">join_product_continuous</span> : <span class="id">continuous</span> <span class="id">join_product</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof630')">Proof.</span></div>
<div class="proofscript" id="proof630">
<span class="id">suff</span> : <span class="id">continuous</span> (<span class="id">join_product</span> : <span class="id">weakT</span> -&gt; <span class="id">PU</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">cts</span> <span class="id">x</span> <span class="id">U</span> =&gt; /<span class="id">cts</span>; <span class="id">rewrite</span> <span class="id">nbhs_simpl</span> /= -<span class="id">weak_sep_nbhsE</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">x</span>; <span class="id">apply</span>/<span class="id">cvg_sup</span>; <span class="id">first</span> <span class="id">exact</span>/<span class="id">fmap_filter</span>/(<span class="id">nbhs_filter</span> (<span class="id">x</span> : <span class="id">weakT</span>)).<br/>
<span class="id">move</span>=&gt; <span class="id">i</span>; <span class="id">move</span>: <span class="id">x</span>; <span class="id">apply</span>/(@<span class="id">continuousP</span> <span class="id"><a href="mathcomp.analysis.topology.html#product_embeddings">_</a></span> (<span class="id">weak_topologicalType</span> <span class="id">_</span>)) =&gt; <span class="id">A</span> [<span class="id">B</span> ? <span class="id">E</span>].<br/>
<span class="id">rewrite</span> -<span class="id">E</span> (<span class="id">_</span> : @^~ <span class="id">i</span> =  <span class="id">proj</span> <span class="id">i</span>) //.<br/>
<span class="id">have</span> -&gt; : <span class="id">join_product</span> @^-1` (<span class="id">proj</span> <span class="id">i</span> @^-1` <span class="id">B</span>) = <span class="id">f_</span> <span class="id"><a href="mathcomp.analysis.topology.html#compact">i</a></span> @^-1` <span class="id">B</span> <span class="kwd">by</span> [].<br/>
<span class="id">apply</span>: <span class="id">open_comp</span> =&gt; // + <span class="id">_</span>; <span class="id">rewrite</span> /<span class="id">cvg_to</span> =&gt; <span class="id">x</span> <span class="id">U</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a name="C:3382">nbhs_simpl</a></span> /= -<span class="id">weak_sep_nbhsE</span>; <span class="id">move</span>: <span class="id">x</span> <span class="id">U</span>; <span class="id">exact</span>: <span class="id">ctsf</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> <span class="id">prod_open</span> :=<br/>
&nbsp;&nbsp;(@<span class="id">open</span> (<span class="id">subspace_topologicalType</span> (<span class="id">range</span> <span class="id">join_product</span>))).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">join_product_open</span> (<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">open</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">open</span> ((<span class="id">join_product</span> @` <span class="id">A</span>) : <span class="id">set</span> (<span class="id">subspace</span> (<span class="id"><a href="mathcomp.analysis.topology.html#filter_ex">range</a></span> <span class="id">join_product</span>))).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof631')">Proof.</span></div>
<div class="proofscript" id="proof631">
<span class="id">move</span>=&gt; <span class="id">oA</span>; <span class="id">rewrite</span> <span class="id">openE</span> =&gt; <span class="id">y</span> /= [<span class="id">x</span> <span class="id">Ax</span>] <span class="id"><a href="mathcomp.analysis.topology.html#compact_subspaceIP">jxy</a></span>.<br/>
<span class="id">have</span> [// | <span class="id">i</span> <span class="id">nAfiy</span>] := @<span class="id">sepf</span> (~` <span class="id">A</span>) <span class="id">x</span> (<span class="id">open_closedC</span> <span class="id">oA</span>).<br/>
<span class="id">pose</span> <span class="id">B</span> : <span class="id">set</span> <span class="id">PU</span> := <span class="id">proj</span> <span class="id">i</span> @^-1` (~` <span class="id">closure</span> (<span class="id">f_</span> <span class="id">i</span> @` ~` <span class="id">A</span>)).<br/>
<span class="id">apply</span>: (@<span class="id">filterS</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#imageP">_</a></span> <span class="id">_</span> <span class="id">_</span> (<span class="id">range</span> <span class="id">join_product</span> `&amp;` <span class="id">B</span>)).<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">z</span> [[<span class="id">w</span> ?]] <span class="id">wzE</span> <span class="id">Bz</span>; <span class="kwd">exists</span> <span class="id">w</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">move</span>: <span class="id">Bz</span>; <span class="id">rewrite</span> /<span class="id">B</span> -<span class="id">wzE</span> <span class="id">closureC</span>; <span class="id">case</span>=&gt; <span class="id">K</span> [<span class="id">oK</span> <span class="id">KsubA</span>] /<span class="id">KsubA</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> -&gt; : <span class="id">proj</span> <span class="id">i</span> (<span class="id">join_product</span> <span class="id">w</span>) = <span class="id">f_</span> <span class="id">i</span> <span class="id">w</span> <span class="kwd">by</span> [].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">exists2P</span>/<span class="id">forallNP</span>/(<span class="id">_</span> <span class="id">w</span>)/<span class="id">not_andP</span> [] // /<span class="id">contrapT</span>.<br/>
<span class="id">apply</span>: <span class="id">open_nbhs_nbhs</span>; <span class="id">split</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">jxy</span>.<br/>
<span class="id">apply</span>: <span class="id">openI</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">open_subspaceT</span>.<br/>
<span class="id">apply</span>: <span class="id">open_subspaceW</span>; <span class="id">apply</span>: <span class="id">open_comp</span>; <span class="id">last</span> <span class="id">exact</span>/<span class="id">closed_openC</span>/<span class="id">closed_closure</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; + <span class="id">_</span>; <span class="id">exact</span>: <span class="id">proj_continuous</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">join_product_inj</span> : <span class="id">accessible_space</span> <span class="id">T</span> -&gt; <span class="id">set_inj</span> [<span class="id">set</span>: <span class="id">T</span>] <span class="id">join_product</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof632')">Proof.</span></div>
<div class="proofscript" id="proof632">
<span class="id">move</span>=&gt; /<span class="id">accessible_closed_set1</span> <span class="id">cl1</span> <span class="id">x</span> <span class="id">y</span>; <span class="id">case</span>: (<span class="id">eqVneq</span> <span class="id">x</span> <span class="id">y</span>) =&gt; // <span class="id">xny</span> <span class="id">_</span> <span class="id">_</span> <span class="id">jxjy</span>.<br/>
<span class="id">have</span> [] := (@<span class="id">sepf</span> [<span class="id">set</span> <span class="id">y</span>] <span class="id">x</span> (<span class="id">cl1</span> <span class="id">y</span>)); <span class="id">first</span> <span class="kwd">by</span> <span class="id">exact</span>/<span class="id"><a href="mathcomp.classical.classical_sets.html#preimage">eqP</a></span>.<br/>
<span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">P</span>; <span class="id">suff</span> : <span class="id">join_product</span> <span class="id">x</span> <span class="id">i</span> != <span class="id">join_product</span> <span class="id">y</span> <span class="id">i</span> <span class="kwd">by</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#esym">rewrite</a></span> <span class="id">jxjy</span> =&gt; /<span class="id">eqP</span>.<br/>
<span class="id">apply</span>/<span class="id">negP</span>; <span class="id">move</span>: <span class="id">P</span>; <span class="id">apply</span>: <span class="id">contra_not</span> =&gt; /<span class="id">eqP</span>; <span class="id">rewrite</span> /<span class="id">join_product</span> =&gt; -&gt;.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subset_closure</span>; <span class="kwd">exists</span> <span class="id">y</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">join_product_weak</span> : <span class="id">set_inj</span> [<span class="id">set</span>: <span class="id">T</span>] <span class="id">join_product</span> -&gt;<br/>
&nbsp;&nbsp;@<span class="id">open</span> <span class="id">T</span> = @<span class="id">open</span> (<span class="id">weak_topologicalType</span> <span class="id">join_product</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof633')">Proof.</span></div>
<div class="proofscript" id="proof633">
<span class="id">move</span>=&gt; <span class="id">inj</span>; <span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; <span class="id">U</span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [<span class="id">V</span> ? &lt;-]; <span class="id">apply</span>: <span class="id">open_comp</span> =&gt; // + <span class="id">_</span>; <span class="id">exact</span>: <span class="id">join_product_continuous</span>.<br/>
<span class="id">move</span>=&gt; /<span class="id">join_product_open</span>/<span class="id">open_subspaceP</span> [<span class="id">V</span> [<span class="id">oU</span> <span class="id">VU</span>]].<br/>
<span class="kwd">exists</span> <span class="id">V</span> =&gt; //; <span class="id">have</span> := @<span class="id">f_equal</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">preimage</span> <span class="id">join_product</span>) <span class="id">_</span> <span class="id">_</span> <span class="id">VU</span>.<br/>
<span class="id">rewrite</span> !<span class="id">preimage_setI</span> // !<span class="id">preimage_range</span> !<span class="id">setIT</span> =&gt; -&gt;.<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">preimage_image</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">z</span> [<span class="id">w</span> <span class="id">Uw</span>] /<span class="id">inj</span> &lt;- //; <span class="id">rewrite</span> <span class="id">inE</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">product_embeddings</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_compact</span> {<span class="id">T</span> <span class="id">U</span> : <span class="id">topologicalType</span>} (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) <span class="id">A</span> :<br/>
&nbsp;&nbsp;{<span class="id">within</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>} -&gt; <span class="id">compact</span> <span class="id">A</span> -&gt; <span class="id">compact</span> (<span class="id">f</span> @` <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof634')">Proof.</span></div>
<div class="proofscript" id="proof634">
<span class="id">move</span>=&gt; <span class="id">fcont</span> <span class="id">Aco</span> <span class="id">F</span> <span class="id">FF</span> <span class="id">FfA</span>; <span class="id">set</span> <span class="id">G</span> := <span class="id">filter_from</span> <span class="id">F</span> (<span class="kwd">fun</span> <span class="id">C</span> =&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#preimage">A</a></span> `&amp;` <span class="id">f</span> @^-1` <span class="id">C</span>).<br/>
<span class="id">have</span> <span class="id">GF</span> : <span class="id"><a href="mathcomp.analysis.topology.html#closure">ProperFilter</a></span> <span class="id">G</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id">filter_from_proper</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#image_subset">filter_from_filter</a></span> <span class="id">_</span> <span class="id">_</span>)).<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">f</span> @` <span class="id">A</span>).<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">C1</span> <span class="id">C2</span> <span class="id">F1</span> <span class="id">F2</span>; <span class="kwd">exists</span> (<span class="id">C1</span> `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#closed">C2</a></span>); [<span class="id">exact</span>: <span class="id">filterI</span>|<span class="id">move</span>=&gt; ? [? []]].<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">C</span> /(<span class="id">filterI</span> <span class="id">FfA</span>) /<span class="id">filter_ex</span> [<span class="id">_</span> [[<span class="id">p</span> ? &lt;-]]]; <span class="kwd">exists</span> <span class="id">p</span>.<br/>
<span class="id">move</span>: <span class="id">Aco</span>; <span class="id">rewrite</span> -[<span class="id">A</span>]<span class="id">setIid</span> =&gt; /<span class="id">compact_subspaceIP</span>; <span class="id">rewrite</span> <span class="id">setIid</span>.<br/>
<span class="id">case</span> /(<span class="id">_</span> <span class="id">G</span>); <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">f</span> @` <span class="id">A</span>) =&gt; // ? [].<br/>
<span class="id">move</span>=&gt; <span class="id">p</span> [<span class="id">Ap</span> <span class="id">clsGp</span>]; <span class="kwd">exists</span> (<span class="id">f</span> <span class="id">p</span>); <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>/<span class="id">imageP</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">B</span> <span class="id">C</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#image_preimage_subset">FB</a></span> /<span class="id">fcont</span> <span class="id">p_Cf</span>.<br/>
<span class="id">have</span> : <span class="id">G</span> (<span class="id">A</span> `&amp;` <span class="id">f</span> @^-1` <span class="id">B</span>) <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">B</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; /<span class="id">clsGp</span> /(<span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#closure">p_Cf</a></span>) [<span class="id">q</span> [[]]]; <span class="kwd">exists</span> (<span class="id">f</span> <span class="id">q</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">connected_continuous_connected</span> (<span class="id">T</span> <span class="id">U</span> : <span class="id">topologicalType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">U</span>) :<br/>
&nbsp;&nbsp;<span class="id">connected</span> <span class="id">A</span> -&gt; {<span class="id">within</span> <span class="id">A</span>, <span class="id">continuous</span> <span class="id">f</span>} -&gt; <span class="id">connected</span> (<span class="id">f</span> @` <span class="id">A</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof635')">Proof.</span></div>
<div class="proofscript" id="proof635">
<span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">cA</a></span> <span class="id">cf</span>; <span class="id">apply</span>: <span class="id">contrapT</span> =&gt; /<span class="id">connectedPn</span>[<span class="id">E</span> [<span class="id">E0</span> <span class="id">fAE</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">sE</a></span>]].<br/>
<span class="id">set</span> <span class="id">AfE</span> := <span class="kwd">fun</span> <span class="id">b</span> =&gt;(<span class="id">A</span> `&amp;` <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">f</a></span> @^-1` <span class="id">E</span> <span class="id">b</span>) : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>).<br/>
<span class="id">suff</span> <span class="id"><a href="mathcomp.analysis.topology.html#continuous">sAfE</a></span> : <span class="id">separated</span> (<span class="id">AfE</span> <span class="id">false</span>) (<span class="id">AfE</span> <span class="id">true</span>).<br/>
&nbsp;&nbsp;<span class="id">move</span>: <span class="id">cA</span>; <span class="id">apply</span>/<span class="id">connectedPn</span>; <span class="kwd">exists</span> <span class="id">AfE</span>; <span class="id">split</span>; <span class="id">last</span> (<span class="id">rewrite</span> /<span class="id">AfE</span>; <span class="id">split</span>).<br/>
&nbsp;&nbsp;- <span class="id">move</span>=&gt; <span class="id">b</span>; <span class="id">case</span>: (<span class="id">E0</span> <span class="id">b</span>) =&gt; /= <span class="id">u</span> <span class="id">Ebu</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span> [<span class="id">t</span> <span class="id">Et</span> <span class="id">ftu</span>] : (<span class="id">f</span> @` <span class="id">A</span>) <span class="id">u</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">fAE</span>; <span class="id">case</span>: <span class="id"><a href="mathcomp.analysis.topology.html#uniform_nbhs">b</a></span> <span class="id">Ebu</span>; [<span class="id">right</span>|<span class="id">left</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">t</span>; <span class="id">split</span> =&gt; //=; <span class="id">rewrite</span> /<span class="id">preimage</span> <span class="id">ftu</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">setIUr</span> -<span class="id">preimage_setU</span> -<span class="id">fAE</span>; <span class="id">exact</span>/<span class="id">esym</span>/<span class="id">setIidPl</span>/<span class="id">preimage_image</span>.<br/>
&nbsp;&nbsp;+ <span class="id">rewrite</span> -{2}(<span class="id">setIid</span> <span class="id">A</span>) ?<span class="id">setIA</span> -(@<span class="id"><a href="mathcomp.analysis.topology.html#uniform_nbhs">closure_subspaceW</a></span> <span class="id">_</span> <span class="id">A</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ?[].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -/(<span class="id">AfE</span> <span class="id">false</span>) -<span class="id">setIA</span> -/(<span class="id">AfE</span> <span class="id">true</span>); <span class="id">case</span>: <span class="id">sAfE</span>.<br/>
&nbsp;&nbsp;+ <span class="id">rewrite</span> -{1}(<span class="id">setIid</span> <span class="id">A</span>) <span class="id">setIC</span> ?<span class="id">setIA</span> -(@<span class="id">closure_subspaceW</span> <span class="id">_</span> <span class="id">A</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -/(<span class="id">AfE</span> <span class="id">true</span>) -<span class="id">setIA</span> -/(<span class="id">AfE</span> <span class="id">false</span>) <span class="id">setIC</span>; <span class="id">case</span>: <span class="id">sAfE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ?[].<br/>
<span class="id">suff</span> <span class="id">cI0</span> <span class="id">b</span> : <span class="id">closure</span> (<span class="id">AfE</span> <span class="id">b</span>) `&amp;` <span class="id">AfE</span> (~~ <span class="id">b</span>) = <span class="id">set0</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">separated</span> <span class="id">cI0</span> <span class="id">setIC</span> <span class="id">cI0</span>.<br/>
<span class="id">have</span> [<span class="id">fAfE</span> <span class="id">cEIE</span>] :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span> @` <span class="id">AfE</span> (~~ <span class="id">b</span>) = <span class="id">E</span> (~~ <span class="id">b</span>) /\ <span class="id">closure</span> (<span class="id">E</span> <span class="id">b</span>) `&amp;` <span class="id">E</span> (~~ <span class="id">b</span>) = <span class="id">set0</span>.<br/>
&nbsp;&nbsp;<span class="id">split</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">case</span>: <span class="id">sE</span> =&gt; ? ?; <span class="id">case</span>: <span class="id">b</span> =&gt; //; <span class="id">rewrite</span> <span class="id">setIC</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; [|<span class="id">u</span> <span class="id">Ebu</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id">subset_trans</span> <span class="id">sub_image_setI</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subIset</span>; <span class="id">right</span>; <span class="id">exact</span>: <span class="id">image_preimage_subset</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">t</span> [<span class="id">At</span> <span class="id">ftu</span>]] : <span class="kwd">exists</span> <span class="id">t</span>, <span class="id">A</span> <span class="id">t</span> /\ <span class="id">f</span> <span class="id">t</span> = <span class="id">u</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">suff</span> [<span class="id">t</span> <span class="id">At</span> <span class="id">ftu</span>] : (<span class="id">f</span> @` <span class="id"><a href="mathcomp.classical.functions.html#restrict">A</a></span>) <span class="id">u</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">t</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">fAE</span>; <span class="id">case</span>: <span class="id">b</span> <span class="id">Ebu</span>; [<span class="id">left</span>|<span class="id">right</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">t</span> =&gt; //; <span class="id">split</span> =&gt; //=; <span class="id">rewrite</span> /<span class="id"><a name="Y:3406">preimage</a></span> <span class="id">ftu</span>.<br/>
<span class="id">have</span> ? : <span class="id">f</span> @` <span class="id">closure</span> (<span class="id">AfE</span> <span class="id">b</span>) `&lt;=` <span class="id">closure</span> (<span class="id">E</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span> /(@<span class="id">image_subset</span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#powerset_filter_from">_</a></span> <span class="id">f</span>) : <span class="id">closure</span> (<span class="id">AfE</span> <span class="id">b</span>) `&lt;=` <span class="id">f</span> @^-1` <span class="id">closure</span> (<span class="id">E</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span> /<span class="id">closure_id</span> -&gt; : <span class="id">closed</span> (<span class="id">f</span> @^-1` <span class="id">closure</span> (<span class="id">E</span> <span class="id">b</span>) : <span class="id">set</span> (<span class="id">subspace</span> <span class="id">A</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">closed_comp</span> =&gt; //; <span class="id">exact</span>: <span class="id">closed_closure</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">closure_subset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span> /(@<span class="id">preimage_subset</span> <span class="id">_</span> <span class="id">_</span> <span class="id">f</span>) <span class="id">A0cA0</span> := @<span class="id">subset_closure</span> <span class="id">_</span> (<span class="id">E</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subset_trans</span> <span class="id">A0cA0</span>; <span class="id">apply</span>: <span class="id">subIset</span>; <span class="id">right</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>/<span class="id">subset_trans</span>; <span class="id">apply</span>; <span class="id">exact</span>: <span class="id">image_preimage_subset</span>.<br/>
<span class="id">apply</span>/<span class="id">eqP</span>/<span class="id">negPn</span>/<span class="id">negP</span>/<span class="id">set0P</span> =&gt; -[<span class="id">t</span> [? ?]].<br/>
<span class="id">have</span> : <span class="id">f</span> @` <span class="id">closure</span> (<span class="id">AfE</span> <span class="id">b</span>) `&amp;` <span class="id">f</span> @` <span class="id">AfE</span> (~~ <span class="id">b</span>) = <span class="id">set0</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">fAfE</span>; <span class="id">exact</span>: <span class="id">subsetI_eq0</span> <span class="id">cEIE</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">predeqE</span> =&gt; /(<span class="id">_</span> (<span class="id">f</span> <span class="id">t</span>)) [<span class="id">fcAfEb</span>] <span class="id">_</span>; <span class="id">apply</span>: <span class="id">fcAfEb</span>; <span class="id"><a name="T:3411">split</a></span>; <span class="kwd">exists</span> <span class="id">t</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_limit_continuous</span> {<span class="id">U</span> : <span class="id">topologicalType</span>} {<span class="id">V</span> : <span class="id">uniformType</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>))) (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">F</span> -&gt; (\<span class="kwd">forall</span> <span class="id">g</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">continuous</span> (<span class="id">g</span> : <span class="id">U</span> -&gt; <span class="id">V</span>)) -&gt;<br/>
&nbsp;&nbsp;{<span class="id">uniform</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} -&gt; <span class="id">continuous</span> <span class="id">f</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof636')">Proof.</span></div>
<div class="proofscript" id="proof636">
<span class="id">move</span>=&gt; <span class="id">PF</span> <span class="id">ctsF</span> <span class="id">Ff</span> <span class="id">x</span>; <span class="id">apply</span>/<span class="id">cvg_app_entourageP</span> =&gt; <span class="id">A</span> <span class="id">entA</span>; <span class="id">near</span> <span class="id">F</span> =&gt; <span class="id">g</span>; <span class="id">near</span>=&gt; <span class="id">y</span>.<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id">g</span> <span class="id">x</span>)) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">near</span>: <span class="id">g</span>; <span class="id">apply</span>/<span class="id">Ff</span>/<span class="id">uniform_nbhs</span>; <span class="kwd">exists</span> (<span class="id">split_ent</span> <span class="id">A</span>); <span class="id">split</span> =&gt; // ?; <span class="id">exact</span>.<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id">g</span> <span class="id"><a href="mathcomp.classical.mathcomp_extra.html#proj">y</a></span>)) =&gt; //; <span class="id">near</span>: <span class="id">y</span>; <span class="id">near</span>: <span class="id">g</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">_</span> <span class="id">ctsF</span>) =&gt; <span class="id">g</span> /(<span class="id">_</span> <span class="id">x</span>) /<span class="id">cvg_app_entourageP</span>; <span class="id">exact</span>.<br/>
<span class="id">apply</span>/<span class="id">Ff</span>/<span class="id">uniform_nbhs</span>; <span class="kwd">exists</span> (<span class="id">split_ent</span> (<span class="id">split_ent</span> <span class="id">A</span>))^-1%<span class="id">classic</span>.<br/>
<span class="kwd">by</span> <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">entourage_inv</span> | <span class="id">move</span>=&gt; <span class="id">g</span> <span class="id"><a name="U:3417">fg</a></span>; <span class="id"><a href="mathcomp.analysis.topology.html#topologicalType">near_simpl</a></span>; <span class="id">near</span>=&gt; <span class="id">z</span>; <span class="id"><a href="mathcomp.analysis.topology.html#uniformType">exact</a></span>: <span class="id">fg</span>].<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_limit_continuous_subspace</span> {<span class="id">U</span> : <span class="id">topologicalType</span>} {<span class="id">V</span> : <span class="id">uniformType</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">K</span> : <span class="id">set</span> <span class="id">U</span>) (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> (<span class="id">U</span> -&gt; <span class="id">V</span>))) (<span class="id">f</span> : <span class="id">subspace</span> <span class="id">K</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">F</span> -&gt; (\<span class="kwd">forall</span> <span class="id">g</span> \<span class="id">near</span> <span class="id">F</span>, <span class="id">continuous</span> (<span class="id">g</span> : <span class="id">subspace</span> <span class="id">K</span> -&gt; <span class="id">V</span>)) -&gt;<br/>
&nbsp;&nbsp;{<span class="id">uniform</span> <span class="id">K</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} -&gt; {<span class="id">within</span> <span class="id">K</span>, <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof637')">Proof.</span></div>
<div class="proofscript" id="proof637">
<span class="id"><a href="mathcomp.analysis.topology.html#cvg_image">move</a></span>=&gt; <span class="id">PF</span> <span class="id">ctsF</span> <span class="id">Ff</span>; <span class="id">apply</span>: (@<span class="id">subspace_eq_continuous</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">restrict</span> <span class="id">K</span> <span class="id">f</span>)).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#cvg_trans">rewrite</a></span> /<span class="id">restrict</span> =&gt; ? -&gt;.<br/>
<span class="id">apply</span>: (@<span class="id">uniform_limit_continuous</span><br/>
&nbsp;&nbsp;(<span class="id">subspace_topologicalType</span> <span class="id">K</span>) <span class="id">_</span> (<span class="id">restrict</span> <span class="id">K</span> @ <span class="id">F</span>) <span class="id">_</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">_</span> <span class="id">ctsF</span>) =&gt; <span class="id">g</span>; <span class="id">apply</span>: <span class="id">subspace_eq_continuous</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#uniform_set1">rewrite</a></span> /<span class="id">restrict</span> =&gt; ? -&gt;.<br/>
<span class="kwd">by</span> <span class="id">apply</span> (@<span class="id">uniform_restrict_cvg</span> <span class="id">_</span> <span class="id">_</span> <span class="id">F</span> ) =&gt; //; <span class="id">exact</span>: <span class="id">PF</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">continuous_localP</span> {<span class="id">X</span> <span class="id">Y</span> : <span class="id">topologicalType</span>} (<span class="id">f</span> : <span class="id">X</span> -&gt; <span class="id">Y</span>) :<br/>
&nbsp;&nbsp;<span class="id">continuous</span> <span class="id">f</span> &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">x</span> : <span class="id">X</span>), \<span class="kwd">forall</span> <span class="id">U</span> \<span class="id">near</span> <span class="id">powerset_filter_from</span> (<span class="id">nbhs</span> <span class="id">x</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">within</span> <span class="id">U</span>, <span class="id">continuous</span> <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof638')">Proof.</span></div>
<div class="proofscript" id="proof638">
<span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id">near</span>=&gt; <span class="id">U</span>; <span class="id">apply</span>: <span class="id">continuous_subspaceT</span>=&gt; ?; <span class="id">exact</span>.<br/>
<span class="id">move</span>=&gt; + <span class="id">x</span> =&gt; /(<span class="id">_</span> <span class="id">x</span>)/<span class="id">near_powerset_filter_fromP</span>.<br/>
<span class="id">case</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id"><a href="mathcomp.analysis.topology.html#family_cvg_subset">exact</a></span>: <span class="id">continuous_subspaceW</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">U</span> <span class="id">nbhsU</span> <span class="id">wctsf</span>; <span class="id">wlog</span> <span class="id">oU</span> : <span class="id">U</span> <span class="id">wctsf</span> <span class="id">nbhsU</span> / <span class="id">open</span> <span class="id">U</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>: <span class="id">nbhsU</span>; <span class="id"><a href="mathcomp.analysis.topology.html#UniformPointwise.V">rewrite</a></span> <span class="id">nbhsE</span> =&gt; -[] <span class="id">W</span> [<span class="id">oW</span> <span class="id">Wx</span> <span class="id">WU</span>] /(<span class="id">_</span> <span class="id">W</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>/(<span class="id">_</span> (<span class="id">continuous_subspaceW</span> <span class="id">WU</span> <span class="id">wctsf</span>)); <span class="id">apply</span> =&gt; //; <span class="kwd">exists</span> <span class="id">W</span>.<br/>
<span class="id">move</span>/<span class="id">nbhs_singleton</span>: <span class="id">nbhsU</span>; <span class="id">move</span>: <span class="id">x</span>; <span class="id">apply</span>/<span class="id">in_setP</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">continuous_open_subspace</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">totally_disconnected_prod</span> (<span class="id">I</span> : <span class="id">choiceType</span>)<br/>
&nbsp;&nbsp;(<span class="id">T</span> : <span class="id">I</span> -&gt; <span class="id">topologicalType</span>) (<span class="id">A</span> : <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">set</span> (<span class="id">T</span> <span class="id">i</span>)) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">totally_disconnected</span> (<span class="id"><a name="gauges.split_sym">A</a></span> <span class="id">i</span>)) -&gt;<br/>
&nbsp;&nbsp;@<span class="id">totally_disconnected</span> (<span class="id">product_topologicalType</span> <span class="id">T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id"><a href="mathcomp.analysis.topology.html#split_ent">f</a></span> =&gt; <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">A</span> <span class="id">i</span> (<span class="id">f</span> <span class="id">i</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof639')">Proof.</span></div>
<div class="proofscript" id="proof639">
<span class="id">move</span>=&gt; <span class="id">dsctAi</span> <span class="id">x</span> /= <span class="id">Aix</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>; <span class="id">last</span> <span class="id">first</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? -&gt;; <span class="id">exact</span>: <span class="id"><a name="gauge">connected_component_refl</a></span>.<br/>
<span class="id">move</span>=&gt; <span class="id">f</span> /= [<span class="id"><a name="n:3434">C</a></span> /= [<span class="id">Cx</span> <span class="id">CA</span> <span class="id"><a href="mathcomp.analysis.topology.html#gauges.split_sym">ctC</a></span> <span class="id">Cf</span>]]; <span class="id">apply</span>/<span class="id">functional_extensionality_dep</span> =&gt; <span class="id">i</span>.<br/>
<span class="id">suff</span> : <span class="id">proj</span> <span class="id">i</span> @` <span class="id"><a href="mathcomp.analysis.topology.html#gauges.split_sym">C</a></span> `&lt;=` [<span class="id">set</span> <span class="id">x</span> <span class="id">i</span>] <span class="kwd">by</span> <span class="id">apply</span>; <span class="kwd">exists</span> <span class="id">f</span>.<br/>
<span class="id">rewrite</span> -(<span class="id">dsctAi</span> <span class="id">i</span>) // =&gt; <span class="id">Ti</span> ?; <span class="kwd">exists</span> (<span class="id">proj</span> <span class="id">i</span> @` <span class="id">C</span>) =&gt; //.<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#gauge">split</a></span>; [<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">x</span> | <span class="kwd">by</span> <span class="id">move</span>=&gt; ? [<span class="id">r</span> <span class="id">Cr</span> &lt;-]; <span class="id">exact</span>: <span class="id">CA</span> |].<br/>
<span class="id">apply</span>/(<span class="id">connected_continuous_connected</span> <span class="id">ctC</span>)/<span class="id">continuous_subspaceT</span>.<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#filterS">exact</a></span>: <span class="id">proj_continuous</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">UniformPointwise</span>.<br/>
<span class="kwd">Context</span> {<span class="id">U</span> : <span class="id">topologicalType</span>} {<span class="id"><a href="mathcomp.analysis.topology.html#Filter">V</a></span> : <span class="id">uniformType</span>}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">singletons</span> {<span class="id">T</span> : <span class="kwd">Type</span>} := [<span class="id">set</span> [<span class="id">set</span> <span class="id">x</span>] | <span class="id">x</span> <span class="kwd">in</span> [<span class="id">set</span>: <span class="id">T</span>]].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_cvg_family_singleton</span> <span class="id">F</span> (<span class="id">f</span>: <span class="id">U</span> -&gt; <span class="id">V</span>):<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; {<span class="id">ptws</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} = {<span class="id">family</span> @<span class="id">singletons</span> <span class="id">U</span>, <span class="id">F</span> --&gt; <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof640')">Proof.</span></div>
<div class="proofscript" id="proof640">
<span class="id">move</span>=&gt; <span class="id">FF</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#subsetI">propeqE</a></span> <span class="id">fam_cvgP</span> <span class="id">cvg_sup</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; + <span class="id">A</span> [<span class="id">x</span> <span class="id">_</span> &lt;-] =&gt; /(<span class="id">_</span> <span class="id">x</span>); <span class="id">rewrite</span> <span class="id">uniform_set1</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">cvg_image</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>=&gt; <span class="id">v</span> // <span class="id">_</span>; <span class="kwd">exists</span> (<span class="id">cst</span> <span class="id">v</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">cvg_trans</span> =&gt; <span class="id">W</span> /=; <span class="id">rewrite</span> ?<span class="id">nbhs_simpl</span> /<span class="id">fmap</span> /= =&gt; [[<span class="id">W</span>' + &lt;-]].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">filterS</span> =&gt; <span class="id">g</span> <span class="id">W</span>'<span class="id">g</span> /=; <span class="kwd">exists</span> <span class="id">g</span>.<br/>
<span class="id">move</span>=&gt; + <span class="id">i</span>; <span class="id">have</span> /[<span class="id">swap</span>] /[<span class="id">apply</span>] : <span class="id">singletons</span> [<span class="id">set</span> <span class="id">i</span>] <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">i</span>.<br/>
<span class="id">rewrite</span> <span class="id">uniform_set1</span>.<br/>
<span class="id">rewrite</span> <span class="id">cvg_image</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>=&gt; <span class="id">v</span> // <span class="id">_</span>; <span class="kwd">exists</span> (<span class="id">cst</span> <span class="id">v</span>).<br/>
<span class="id">move</span>=&gt; + <span class="id">W</span> //=; <span class="id">rewrite</span> ?<span class="id">nbhs_simpl</span> =&gt; <span class="id">Q</span> =&gt; /<span class="id">Q</span> <span class="id">Q</span>'; <span class="kwd">exists</span> (@^~ <span class="id">i</span> @^-1` <span class="id"><a href="mathcomp.analysis.topology.html#gauges.entourage_gauge.E">W</a></span>) =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; [<span class="id">j</span> [? + &lt;-//]|<span class="id">j</span> <span class="id">Wj</span>]; <span class="kwd">exists</span> (<span class="kwd">fun</span> <span class="id">_</span> =&gt; <span class="id">j</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_cvg_compact_family</span> <span class="id">F</span> (<span class="id">f</span> : <span class="id">U</span> -&gt; <span class="id">V</span>) :<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; {<span class="id">family</span> <span class="id">compact</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} -&gt; {<span class="id">ptws</span>, <span class="id">F</span> --&gt; <span class="id">f</span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof641')">Proof.</span></div>
<div class="proofscript" id="proof641">
<span class="id">move</span>=&gt; <span class="id">PF</span>; <span class="id">rewrite</span> <span class="id">pointwise_cvg_family_singleton</span>; <span class="id">apply</span>: <span class="id">family_cvg_subset</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">A</span> [<span class="id">x</span> <span class="id">_</span> &lt;-]; <span class="id">exact</span>: <span class="id">compact_set1</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_cvgP</span> <span class="id"><a href="mathcomp.analysis.topology.html#subset_split_ent">F</a></span> (<span class="id">f</span>: <span class="id">U</span> -&gt; <span class="id">V</span>):<br/>
&nbsp;&nbsp;<span class="id">Filter</span> <span class="id">F</span> -&gt; {<span class="id">ptws</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} &lt;-&gt; <span class="kwd">forall</span> (<span class="id">t</span> : <span class="id">U</span>), (<span class="kwd">fun</span> <span class="id">g</span> =&gt; <span class="id">g</span> <span class="id">t</span>) @ <span class="id">F</span> --&gt; <span class="id">f</span> <span class="id">t</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof642')">Proof.</span></div>
<div class="proofscript" id="proof642">
<span class="id">move</span>=&gt; <span class="id">Ff</span>; <span class="id">rewrite</span> <span class="id">pointwise_cvg_family_singleton</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>/<span class="id">fam_cvgP</span> =&gt; + <span class="id">t</span> <span class="id">A</span> <span class="id">At</span> =&gt; /(<span class="id">_</span> [<span class="id">set</span> <span class="id">t</span>]); <span class="id">rewrite</span> <span class="id">uniform_set1</span>; <span class="id">apply</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">t</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">pf</span>; <span class="id">apply</span>/<span class="id">fam_cvgP</span> =&gt; ? [<span class="id">t</span> <span class="id">_</span> &lt;-]; <span class="id">rewrite</span> <span class="id">uniform_set1</span>; <span class="id"><a href="mathcomp.analysis.topology.html#FilteredType">exact</a></span>: <span class="id">pf</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">UniformPointwise</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">gauges</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">split_sym</span> {<span class="id">T</span> : <span class="id">uniformType</span>} (<span class="id">W</span> : <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>)) :=<br/>
&nbsp;&nbsp;(<span class="id">split_ent</span> <span class="id">W</span>) `&amp;` (<span class="id">split_ent</span> <span class="id">W</span>)^-1.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">entourage_gauge</span>.<br/>
<span class="kwd">Context</span> {<span class="id">T</span> : <span class="id">uniformType</span>} (<span class="id">E</span> : <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>)) (<span class="id">entE</span> : <span class="id">entourage</span> <span class="id">E</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">gauge</span> :=<br/>
&nbsp;&nbsp;<span class="id">filter_from</span> [<span class="id">set</span>: <span class="id">nat</span>] (<span class="kwd">fun</span> <span class="id">n</span> =&gt; <span class="id">iter</span> <span class="id">n</span> <span class="id">split_sym</span> (<span class="id">E</span> `&amp;` <span class="id">E</span>^-1)).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.analysis.topology.html#gauges.entourage_gauge.E">iter_split_ent</a></span> <span class="id">j</span> : <span class="id">entourage</span> (<span class="id">iter</span> <span class="id">j</span> <span class="id">split_sym</span> (<span class="id">E</span> `&amp;` <span class="id">E</span>^-1)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof643')">Proof.</span></div>
<div class="proofscript" id="proof643">
 <span class="kwd">by</span> <span class="id">elim</span>: <span class="id">j</span> =&gt; [|<span class="id">i</span> <span class="id">IH</span>]; <span class="id">exact</span>: <span class="id">filterI</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">gauge_ent</span> <span class="id">A</span> : <span class="id">gauge</span> <span class="id">A</span> -&gt; <span class="id">entourage</span> <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof644')">Proof.</span></div>
<div class="proofscript" id="proof644">
<span class="id">case</span>=&gt; <span class="id">n</span>; <span class="id"><a name="gauge_pseudoMetric_mixin">elim</a></span>: <span class="id">n</span> <span class="id">A</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ? <span class="id">_</span> /<span class="id">filterS</span>; <span class="id">apply</span>; <span class="id">apply</span>: <span class="id">filterI</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">n</span> ? <span class="id">A</span> <span class="id">_</span> /<span class="id">filterS</span>; <span class="id">apply</span>; <span class="id">apply</span>: <span class="id">filterI</span>; <span class="id">have</span> ? := <span class="id">iter_split_ent</span> <span class="id">n</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="R:3446">gauge_filter</a></span> : <span class="id">Filter</span> <span class="id">gauge</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof645')">Proof.</span></div>
<div class="proofscript" id="proof645">
<span class="id"><a href="mathcomp.analysis.topology.html#gauge_uniformType">apply</a></span>: <span class="id">filter_from_filter</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> 0%<span class="id">N</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">j</span> <span class="id">_</span> <span class="id">_</span>; <span class="id">wlog</span> <span class="id">ilej</span> : <span class="id">i</span> <span class="id"><a name="uniform_pseudometric_sup">j</a></span> / (<span class="id">i</span> &lt;= <span class="id">j</span>)%<span class="id">N</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">WH</span>; <span class="id">have</span> [|/<span class="id">ltnW</span>] := <span class="id">leqP</span> <span class="id">i</span> <span class="id">j</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[|<span class="id"><a href="mathcomp.analysis.topology.html#entourage">rewrite</a></span> (<span class="id">setIC</span> (<span class="id">iter</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>))]; <span class="id">exact</span>: <span class="id">WH</span>.<br/>
<span class="kwd">exists</span> <span class="id">j</span> =&gt; //; <span class="id">rewrite</span> <span class="id">subsetI</span>; <span class="id">split</span> =&gt; //; <span class="id"><a href="mathcomp.analysis.topology.html#gauge_pseudoMetricType">elim</a></span>: <span class="id">j</span> <span class="id">i</span> <span class="id">ilej</span> =&gt; [<span class="id">i</span>|<span class="id">j</span> <span class="id">IH</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">i</a></span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">leqn0</span> =&gt; /<span class="id">eqP</span> -&gt;.<br/>
<span class="id">rewrite</span> <span class="id">leq_eqVlt</span> =&gt; /<span class="id">predU1P</span>[&lt;-//|/<span class="id">ltnSE</span>/<span class="id">IH</span>]; <span class="id">apply</span>: <span class="id">subset_trans</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">x</span>/= [<span class="id">jx</span> <span class="id">_</span>]; <span class="id">apply</span>: <span class="id">split_ent_subset</span> =&gt; //; <span class="id">exact</span>: <span class="id">iter_split_ent</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">gauge_refl</span> <span class="id">A</span> : <span class="id">gauge</span> <span class="id">A</span> -&gt; [<span class="id">set</span> <span class="id">fg</span> | <span class="id">fg</span>.1 = <span class="id">fg</span>.2] `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof646')">Proof.</span></div>
<div class="proofscript" id="proof646">
<span class="id">case</span>=&gt; <span class="id">n</span> <span class="id">_</span>; <span class="id">apply</span>: <span class="id">subset_trans</span> =&gt; -[<span class="id">_</span> <span class="id">a</span>]/= -&gt;.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">entourage_refl</span>; <span class="id">exact</span>: <span class="id">iter_split_ent</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set_fset1">gauge_inv</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#bigcap_set1">A</a></span> : <span class="id">gauge</span> <span class="id">A</span> -&gt; <span class="id">gauge</span> (<span class="id">A</span>^-1)%<span class="id">classic</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof647')">Proof.</span></div>
<div class="proofscript" id="proof647">
<span class="id">case</span>=&gt; <span class="id">n</span> <span class="id">_</span> <span class="id">EA</span>; <span class="id">apply</span>: (@<span class="id">filterS</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">iter</span> <span class="id">n</span> <span class="id">split_sym</span> (<span class="id">E</span> `&amp;` <span class="id">E</span>^-1))).<br/>
- <span class="id">exact</span>: <span class="id">gauge_filter</span>.<br/>
- <span class="kwd">by</span> <span class="id">case</span>: <span class="id">n</span> <span class="id">EA</span>; <span class="id">last</span> <span class="id"><a href="mathcomp.analysis.topology.html#iter_split_ent">move</a></span>=&gt; <span class="id">n</span>; <span class="id">move</span>=&gt; <span class="id">EA</span> [? ?] [/=] ? ?; <span class="id">exact</span>: <span class="id">EA</span>.<br/>
- <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">n</span> .<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">gauge_split</span> <span class="id">A</span> : <span class="id">gauge</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">A</a></span> -&gt; <span class="kwd">exists2</span> <span class="id">B</span>, <span class="id">gauge</span> <span class="id">B</span> &amp; <span class="id">B</span> \; <span class="id">B</span> `&lt;=` <span class="id">A</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof648')">Proof.</span></div>
<div class="proofscript" id="proof648">
<span class="id">case</span> =&gt; <span class="id">n</span> <span class="id">_</span> <span class="id">EA</span>; <span class="kwd">exists</span> (<span class="id">iter</span> <span class="id">n</span>.+1 <span class="id">split_sym</span> (<span class="id">E</span> `&amp;` <span class="id">E</span>^-1)); <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">n</span>.+1.<br/>
<span class="id">apply</span>: <span class="id">subset_trans</span> <span class="id">EA</span>; <span class="id">apply</span>: <span class="id">subset_trans</span>; <span class="id">first</span> <span class="id">last</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id"><a name="ArzelaAscoli">apply</a></span>: <span class="id">subset_split_ent</span>; <span class="id">exact</span>: <span class="id">iter_split_ent</span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#uniformType">a</a></span> <span class="id">c</span> [<span class="id">b</span>] [] ? ? [] ? ?; <span class="kwd">exists</span> <span class="id"><a href="mathcomp.analysis.topology.html#hausdorff_space">b</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">gauge_uniformType_mixin</span> :=<br/>
&nbsp;<span class="id">UniformMixin</span> <span class="id">gauge_filter</span> <span class="id">gauge_refl</span> <span class="id">gauge_inv</span> <span class="id">gauge_split</span> <span class="id">erefl</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">gauge_topologicalTypeMixin</span> :=<br/>
&nbsp;&nbsp;<span class="id">topologyOfEntourageMixin</span> <span class="id">gauge_uniformType_mixin</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">gauge_filtered</span> := <span class="id">FilteredType</span> <span class="id">T</span> <span class="id">T</span> (<span class="id">nbhs_</span> <span class="id">gauge</span>).<br/>
<span class="kwd">Definition</span> <span class="id"><a href="mathcomp.analysis.topology.html#ArzelaAscoli.Y">gauge_topologicalType</a></span> :=<br/>
&nbsp;&nbsp;<span class="id">TopologicalType</span> <span class="id">gauge_filtered</span> <span class="id">gauge_topologicalTypeMixin</span>.<br/>
<span class="kwd">Definition</span> <span class="id">gauge_uniformType</span> := <span class="id">UniformType</span><br/>
&nbsp;&nbsp;<span class="id">gauge_topologicalType</span> <span class="id">gauge_uniformType_mixin</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">gauge_countable_uniformity</span> : <span class="id">countable_uniformity</span> <span class="id">gauge_uniformType</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof649')">Proof.</span></div>
<div class="proofscript" id="proof649">
<span class="kwd">exists</span> [<span class="id">set</span> <span class="id">iter</span> <span class="id">n</span> <span class="id">split_sym</span> (<span class="id">E</span> `&amp;` <span class="id">E</span>^-1) | <span class="id">n</span> <span class="kwd">in</span> [<span class="id">set</span>: <span class="id">nat</span>]].<br/>
<span class="id">split</span>; [<span class="id">exact</span>: <span class="id">card_image_le</span> | <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">W</span> [<span class="id">n</span>] <span class="id">_</span> &lt;-; <span class="kwd">exists</span> <span class="id">n</span>|].<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">D</span> [<span class="id">n</span> <span class="id"><a name="equicontinuous_subset_id">_</a></span> ?]; <span class="kwd">exists</span> (<span class="id">iter</span> <span class="id">n</span> <span class="id">split_sym</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">E</a></span> `&amp;` <span class="id">E</span>^-1)).<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">gauge_pseudoMetric_mixin</span> {<span class="id">R</span> : <span class="id">realType</span>} :=<br/>
&nbsp;&nbsp;@<span class="id">countable_uniform_pseudoMetricType_mixin</span> <span class="id">R</span> <span class="id">_</span> <span class="id">gauge_countable_uniformity</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">gauge_pseudoMetricType</span> {<span class="id">R</span> : <span class="id">realType</span>} :=<br/>
&nbsp;&nbsp;<span class="id">PseudoMetricType</span> <span class="id">gauge_uniformType</span> (@<span class="id">gauge_pseudoMetric_mixin</span> <span class="id">R</span>).<br/>
<br/>
<span class="kwd">End</span> <span class="id">entourage_gauge</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_pseudometric_sup</span> {<span class="id">R</span> : <span class="id">realType</span>} {<span class="id">T</span> : <span class="id">uniformType</span>} :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@<span class="id">entourage</span> <span class="id">T</span> = @<span class="id">sup_ent</span> <span class="id">T</span> {<span class="id">E</span> : <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>) | @<span class="id">entourage</span> <span class="id">T</span> <span class="id">E</span>}<br/>
&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">E</span> =&gt; <span class="id">Uniform.class</span> (@<span class="id">gauge_pseudoMetricType</span> <span class="id">T</span> (<span class="id">projT1</span> <span class="id">E</span>) (<span class="id">projT2</span> <span class="id">E</span>) <span class="id"><a name="W:3480">R</a></span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof650')">Proof.</span></div>
<div class="proofscript" id="proof650">
<span class="id"><a name="fW:3481">rewrite</a></span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; [<span class="id">E</span> <span class="id">entE</span>|<span class="id">E</span>].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">E</span> =&gt; //=.<br/>
&nbsp;&nbsp;<span class="id">pose</span> <span class="id">pe</span> : {<span class="id">classic</span> {<span class="id">E0</span> : <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>) | <span class="id">_</span>}} * <span class="id">_</span> := (<span class="id">exist</span> <span class="id">_</span> <span class="id">E</span> <span class="id">entE</span>, <span class="id">E</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span> <span class="id">entPE</span> : `[&lt; @<span class="id">entourage</span> (<span class="id">gauge_uniformType</span> <span class="id">entE</span>) <span class="id">E</span> &gt;].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">asboolP</span>; <span class="kwd">exists</span> 0%<span class="id">N</span> =&gt; // ? [].<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">fset1</span> (<span class="id">exist</span> <span class="id">_</span> <span class="id">pe</span> <span class="id">entPE</span>)) =&gt; //=; <span class="id">first</span> <span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">rewrite</span> <span class="id">in_setE</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">set_fset1</span> <span class="id">bigcap_set1</span>.<br/>
<span class="id">case</span>=&gt; <span class="id">W</span> /= [/= <span class="id">J</span>] <span class="id"><a href="mathcomp.analysis.topology.html#ArzelaAscoli.X">_</a></span> &lt;- /<span class="id">filterS</span>; <span class="id">apply</span>; <span class="id">apply</span>: <span class="id">filter_bigI</span> =&gt; -[] [] [] /= <span class="id">D</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">entD</span> <span class="id">G</span> /[<span class="id">dup</span>] /<span class="id">asboolP</span> [<span class="id">n</span> <span class="id">_</span> + <span class="id">_</span> <span class="id">_</span>] =&gt; /<span class="id">filterS</span>; <span class="id">apply</span>.<br/>
<span class="id">exact</span>: <span class="id">iter_split_ent</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">gauges</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">normal_space</span> (<span class="id">T</span> : <span class="id"><a href="mathcomp.analysis.topology.html#pointwise_precompact">topologicalType</a></span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>, <span class="id">closed</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">set_nbhs</span> <span class="id">A</span> `&lt;=` <span class="id">filter_from</span> (<span class="id">set_nbhs</span> <span class="id">A</span>) <span class="id">closure</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">regular_space</span> (<span class="id">T</span> : <span class="id">topologicalType</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> : <span class="id">T</span>, <span class="id">nbhs</span> <span class="id">a</span> `&lt;=` <span class="id">filter_from</span> (<span class="id">nbhs</span> <span class="id">a</span>) <span class="id">closure</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">ArzelaAscoli</span>.<br/>
<span class="kwd">Context</span> {<span class="id">X</span> : <span class="id">topologicalType</span>}.<br/>
<span class="kwd">Context</span> {<span class="id">Y</span> : <span class="id"><a href="mathcomp.analysis.topology.html#ArzelaAscoli.X">uniformType</a></span>}.<br/>
<span class="kwd">Context</span> {<span class="id">hsdf</span> : <span class="id">hausdorff_space</span> <span class="id">Y</span>}.<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">I</a></span> : <span class="kwd">Type</span>).<br/>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">equicontinuous</span> {<span class="id">I</span>} (<span class="id">W</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">d</span> : <span class="id"><a href="mathcomp.analysis.topology.html#tychonoff">I</a></span> -&gt; (<span class="id">X</span> -&gt; <span class="id">Y</span>)) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> (<span class="id">E</span> : <span class="id">set</span> (<span class="id">Y</span> * <span class="id">Y</span>)), <span class="id">entourage</span> <span class="id">E</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;\<span class="kwd">forall</span> <span class="id">y</span> \<span class="id">near</span> <span class="id">x</span>, <span class="kwd">forall</span> <span class="id">i</span>, <span class="id">W</span> <span class="id">i</span> -&gt; <span class="id">E</span>(<span class="id">d</span> <span class="id">i</span> <span class="id">x</span>, <span class="id">d</span> <span class="id">i</span> <span class="id">y</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">equicontinuous_subset</span> {<span class="id">I</span> <span class="id">J</span>} (<span class="id">W</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">V</span> : <span class="id">set</span> <span class="id">J</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id"><a href="mathcomp.analysis.topology.html#closure_limit_point">fW</a></span> : <span class="id">I</span> -&gt; <span class="id">X</span> -&gt; <span class="id">Y</span>} {<span class="id">fV</span> : <span class="id">J</span> -&gt; <span class="id">X</span> -&gt; <span class="id">Y</span>} :<br/>
&nbsp;&nbsp;<span class="id">fW</span> @`<span class="id">W</span> `&lt;=` <span class="id">fV</span> @` <span class="id">V</span> -&gt; <span class="id">equicontinuous</span> <span class="id">V</span> <span class="id">fV</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#smallest_sub">equicontinuous</a></span> <span class="id">W</span> <span class="id">fW</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof651')">Proof.</span></div>
<div class="proofscript" id="proof651">
<span class="id">move</span>=&gt; <span class="id">WsubV</span> + <span class="id">x</span> <span class="id">E</span> <span class="id">entE</span> =&gt; /(<span class="id">_</span> <span class="id">x</span> <span class="id">E</span> <span class="id">entE</span>); <span class="id">apply</span>: <span class="id">filterS</span> =&gt; <span class="id">y</span> <span class="id">VE</span> <span class="id">i</span> <span class="id">Wi</span>.<br/>
<span class="kwd">by</span> <span class="id">case</span>: (<span class="id">WsubV</span> (<span class="id">fW</span> <span class="id">i</span>)); [<span class="kwd">exists</span> <span class="id">i</span> | <span class="id">move</span>=&gt; <span class="id">j</span> <span class="id">Vj</span> &lt;-; <span class="id">exact</span>: <span class="id">VE</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">equicontinuous_subset_id</span> (<span class="id">W</span> <span class="id">V</span> : <span class="id">set</span> (<span class="id">X</span> -&gt; <span class="id">Y</span>)) :<br/>
&nbsp;&nbsp;<span class="id">W</span> `&lt;=` <span class="id">V</span> -&gt; <span class="id">equicontinuous</span> <span class="id">V</span> <span class="id">id</span> -&gt; <span class="id">equicontinuous</span> <span class="id"><a href="mathcomp.analysis.topology.html#compact_ultra">W</a></span> <span class="id">id</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof652')">Proof.</span></div>
<div class="proofscript" id="proof652">
<span class="id">move</span>=&gt; <span class="id">WsubV</span>; <span class="id">apply</span>: <span class="id">equicontinuous_subset</span> =&gt; ? [<span class="id">y</span> ? &lt;- /=]; <span class="kwd">exists</span> <span class="id">y</span> =&gt; //.<br/>
<span class="id">exact</span>: <span class="id">WsubV</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">equicontinuous_continuous_for</span> {<span class="id">I</span>} (<span class="id">W</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">fW</span> : <span class="id">I</span> -&gt; <span class="id">X</span> -&gt; <span class="id">Y</span>) <span class="id">i</span> <span class="id">x</span> :<br/>
&nbsp;&nbsp;{<span class="kwd">for</span> <span class="id">x</span>, <span class="id">equicontinuous</span> <span class="id">W</span> <span class="id"><a href="mathcomp.analysis.topology.html#ArzelaAscoli.X">fW</a></span>} -&gt; <span class="id">W</span> <span class="id">i</span> -&gt; {<span class="kwd">for</span> <span class="id">x</span>, <span class="id">continuous</span> (<span class="id">fW</span> <span class="id">i</span>)}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof653')">Proof.</span></div>
<div class="proofscript" id="proof653">
<span class="id">move</span>=&gt; <span class="id">ectsW</span> <span class="id">Wf</span>; <span class="id">apply</span>/<span class="id">cvg_entourageP</span> =&gt; <span class="id">E</span> <span class="id">entE</span>; <span class="id">near_simpl</span>.<br/>
<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#compact">near</a></span>=&gt; <span class="id">y</span>; <span class="id">apply</span>: (<span class="id">near</span> (<span class="id">ectsW</span> <span class="id">_</span> <span class="id">entE</span>) <span class="id">y</span>).<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#continuous_compact">Unshelve</a></span>. <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">equicontinuous_continuous</span> {<span class="id">I</span>} (<span class="id">W</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">fW</span> : <span class="id">I</span> -&gt; (<span class="id">X</span> -&gt; <span class="id">Y</span>)) (<span class="id">i</span> : <span class="id">I</span>) :<br/>
&nbsp;&nbsp;<span class="id">equicontinuous</span> <span class="id">W</span> <span class="id">fW</span> -&gt; <span class="id">W</span> <span class="id"><a href="mathcomp.analysis.topology.html#pointwise_cvg_compact_family">i</a></span> -&gt; <span class="id">continuous</span> (<span class="id">fW</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof654')">Proof.</span></div>
<div class="proofscript" id="proof654">
<span class="id">move</span>=&gt; <span class="id">ectsW</span> <span class="id">Wf</span> <span class="id">x</span>; <span class="id">apply</span>: <span class="id">equicontinuous_continuous_for</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">Wf</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; ?; <span class="id">exact</span>: <span class="id">ectsW</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">pointwise_precompact</span> {<span class="id">I</span>} (<span class="id">W</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">d</span> : <span class="id"><a name="g:3512">I</a></span> -&gt; <span class="id">X</span> -&gt; <span class="id">Y</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">precompact</span> [<span class="id">set</span> (<span class="id">d</span> <span class="id">i</span> <span class="id">x</span>) | <span class="id">i</span> <span class="kwd">in</span> <span class="id">W</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_precompact_subset</span> {<span class="id">I</span> <span class="id">J</span>} (<span class="id">W</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">V</span> : <span class="id">set</span> <span class="id"><a href="mathcomp.analysis.topology.html#fam_cvgP">J</a></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">fW</span> : <span class="id">I</span> -&gt; <span class="id">X</span> -&gt; <span class="id">Y</span>} {<span class="id">fV</span> : <span class="id">J</span> -&gt; <span class="id">X</span> -&gt; <span class="id">Y</span>} :<br/>
&nbsp;&nbsp;<span class="id">fW</span> @` <span class="id">W</span> `&lt;=` <span class="id">fV</span> @` <span class="id">V</span> -&gt; <span class="id">pointwise_precompact</span> <span class="id">V</span> <span class="id">fV</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">pointwise_precompact</span> <span class="id">W</span> <span class="id">fW</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof655')">Proof.</span></div>
<div class="proofscript" id="proof655">
<span class="id">move</span>=&gt; <span class="id">WsubV</span> + <span class="id">x</span> =&gt; /(<span class="id">_</span> <span class="id">x</span>) <span class="id">pcptV</span>; <span class="id">apply</span>: <span class="id">precompact_subset</span> <span class="id">pcptV</span> =&gt; <span class="id">y</span> [<span class="id">i</span> <span class="id">Wi</span> &lt;-].<br/>
<span class="kwd">by</span> <span class="id">case</span>: (<span class="id">WsubV</span> (<span class="id">fW</span> <span class="id"><a href="mathcomp.analysis.topology.html#closure">i</a></span>)); [<span class="kwd">exists</span> <span class="id">i</span> | <span class="id">move</span>=&gt; <span class="id">j</span> <span class="id">Vj</span> &lt;-; <span class="kwd">exists</span> <span class="id">j</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_precompact_precompact</span> {<span class="id">I</span>} (<span class="id">W</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id"><a href="mathcomp.analysis.topology.html#ArzelaAscoli.Y">fW</a></span> : <span class="id">I</span> -&gt; (<span class="id">X</span> -&gt; <span class="id">Y</span>)) :<br/>
&nbsp;&nbsp;<span class="id">pointwise_precompact</span> <span class="id">W</span> <span class="id">fW</span> -&gt; <span class="id">precompact</span> ((<span class="id">fW</span> @` <span class="id">W</span>) : <span class="id">set</span> {<span class="id">ptws</span> <span class="id">X</span> -&gt; <span class="id">Y</span>}).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof656')">Proof.</span></div>
<div class="proofscript" id="proof656">
<span class="id">rewrite</span> <span class="id">precompactE</span> =&gt; <span class="id">ptwsPreW</span>.<br/>
<span class="id">pose</span> <span class="id">K</span> := <span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">closure</span> [<span class="id">set</span> <span class="id">fW</span> <span class="id">i</span> <span class="id">x</span> | <span class="id">i</span> <span class="kwd">in</span> <span class="id">W</span>].<br/>
<span class="id">set</span> <span class="id">R</span> := [<span class="id">set</span> <span class="id">f</span> : {<span class="id">ptws</span> <span class="id">X</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#near">Y</a></span>} | <span class="kwd">forall</span> <span class="id">x</span> : <span class="id">X</span>, <span class="id">K</span> <span class="id">x</span> (<span class="id">f</span> <span class="id">x</span>)].<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#entourage_sym">have</a></span> <span class="id">C</span> : <span class="id">compact</span> <span class="id">R</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">tychonoff</span> =&gt; <span class="id">x</span>; <span class="id">rewrite</span> -<span class="id">precompactE</span>; <span class="id">move</span>: <span class="id">ptwsPreW</span>; <span class="id">exact</span>.<br/>
<span class="id">apply</span>: (<span class="id">subclosed_compact</span> <span class="id">_</span> <span class="id">C</span>); <span class="id"><a href="mathcomp.analysis.topology.html#small_set_sub">first</a></span> <span class="id">exact</span>: <span class="id">closed_closure</span>.<br/>
<span class="id">have</span> <span class="id">WsubR</span> : (<span class="id">fW</span> @` <span class="id">W</span>) `&lt;=` <span class="id">R</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">f</span> <span class="id">Wf</span> <span class="id">x</span>; <span class="id">rewrite</span> /<span class="id">R</span> /<span class="id">K</span> <span class="id">closure_limit_point</span>; <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>: <span class="id">Wf</span> =&gt; <span class="id">i</span> ? &lt;-; <span class="kwd">exists</span> <span class="id">i</span>.<br/>
<span class="id">rewrite</span> <span class="id">closureE</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#equicontinuous">smallest_sub</a></span> (<span class="id">compact_closed</span> <span class="id">_</span> <span class="id">C</span>) <span class="id">WsubR</span>.<br/>
<span class="id">exact</span>: <span class="id">hausdorff_product</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">uniform_pointwise_compact</span> (<span class="id">W</span> : <span class="id">set</span> (<span class="id">X</span> -&gt; <span class="id">Y</span>)) :<br/>
&nbsp;&nbsp;<span class="id">compact</span> (<span class="id">W</span> : <span class="id">set</span> (@<span class="id">fct_UniformFamily</span> <span class="id">X</span> <span class="id">Y</span> <span class="id">compact</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">compact</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">ptws</span> <span class="id">X</span> -&gt; <span class="id">Y</span>}).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof657')">Proof.</span></div>
<div class="proofscript" id="proof657">
<span class="id">rewrite</span> [<span class="id">x</span> <span class="kwd">in</span> <span class="id">x</span> <span class="id">_</span> -&gt; <span class="id">_</span>]<span class="id">compact_ultra</span> [<span class="id">x</span> <span class="kwd">in</span> <span class="id">_</span> -&gt; <span class="id">x</span> <span class="id">_</span>]<span class="id">compact_ultra</span>.<br/>
<span class="id">move</span>=&gt; + <span class="id">F</span> <span class="id">UF</span> <span class="id">FW</span> =&gt; /(<span class="id">_</span> <span class="id">F</span> <span class="id">UF</span> <span class="id">FW</span>) [<span class="id">h</span> [<span class="id">Wh</span> <span class="id">Fh</span>]]; <span class="kwd">exists</span> <span class="id">h</span>; <span class="id">split</span> =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#subset_closure">Q</a></span> <span class="id">Fq</span>; <span class="id">apply</span>: (<span class="id">pointwise_cvg_compact_family</span> <span class="id">_</span> <span class="id">Fh</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">precompact_pointwise_precompact</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">family</span> <span class="id">compact</span>, <span class="id">X</span> -&gt; <span class="id">Y</span>}) :<br/>
&nbsp;&nbsp;<span class="id">precompact</span> <span class="id">W</span> -&gt; <span class="id">pointwise_precompact</span> <span class="id"><a href="mathcomp.analysis.topology.html#fam_cvgP">W</a></span> <span class="id">id</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof658')">Proof.</span></div>
<div class="proofscript" id="proof658">
<span class="id">move</span>=&gt; + <span class="id">x</span>; <span class="id">rewrite</span> ?<span class="id">precompactE</span> =&gt; <span class="id">pcptW</span>.<br/>
<span class="id">have</span> : <span class="id">compact</span> (<span class="id">proj</span> <span class="id">x</span> @` (<span class="id">closure</span> <span class="id">W</span>)).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">continuous_compact</span> =&gt; //; <span class="id">apply</span>: <span class="id">continuous_subspaceT</span>=&gt; <span class="id">g</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">E</span> <span class="id">nbhsE</span>; <span class="id">have</span> := (@<span class="id">proj_continuous</span> <span class="id">_</span> <span class="id">_</span> <span class="id">x</span> <span class="id">g</span> <span class="id">E</span> <span class="id">nbhsE</span>).<br/>
&nbsp;&nbsp;<span class="id">exact</span>: (@<span class="id">pointwise_cvg_compact_family</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">nbhs</span> <span class="id">g</span>)).<br/>
<span class="id">move</span>=&gt; /[<span class="id">dup</span>]/(<span class="id">compact_closed</span> <span class="id">hsdf</span>)/<span class="id">closure_id</span> -&gt; /<span class="id">subclosed_compact</span>.<br/>
<span class="id">apply</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">closed_closure</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">closure_subset</span>/<span class="id">image_subset</span>; <span class="id">exact</span>: (@<span class="id">subset_closure</span> <span class="id">_</span> <span class="id">W</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_cvg_entourage</span> (<span class="id">x</span> : <span class="id">X</span>) (<span class="id">f</span> : {<span class="id">ptws</span> <span class="id">X</span> -&gt; <span class="id">Y</span>}) <span class="id">E</span> :<br/>
&nbsp;&nbsp;<span class="id">entourage</span> <span class="id">E</span> -&gt; \<span class="kwd">forall</span> <span class="id"><a href="mathcomp.analysis.topology.html#entourage_sym">g</a></span> \<span class="id">near</span> <span class="id">f</span>, <span class="id">E</span> (<span class="id">f</span> <span class="id">x</span>, <span class="id">g</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof659')">Proof.</span></div>
<div class="proofscript" id="proof659">
<span class="id">move</span>=&gt; <span class="id">entE</span>; <span class="id">have</span> : ({<span class="id">ptws</span>, <span class="id">nbhs</span> <span class="id">f</span> --&gt; <span class="id">f</span>}) <span class="kwd">by</span> [].<br/>
<span class="id">rewrite</span> <span class="id">pointwise_cvg_family_singleton</span> =&gt; /<span class="id">fam_cvgP</span> /(<span class="id">_</span> [<span class="id">set</span> <span class="id">x</span>]).<br/>
<span class="id">rewrite</span> <span class="id">uniform_set1</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> (<span class="id">to_set</span> <span class="id">E</span> (<span class="id">f</span> <span class="id">x</span>))); <span class="id">apply</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">x</span>.<br/>
<span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.topology.html#nbhs">move</a></span>: <span class="id">E</span> <span class="id">entE</span>; <span class="id">exact</span>/<span class="id">cvg_entourageP</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">equicontinuous_closure</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">ptws</span> <span class="id">X</span> -&gt; <span class="id">Y</span>}) :<br/>
&nbsp;&nbsp;<span class="id">equicontinuous</span> <span class="id">W</span> <span class="id">id</span> -&gt; <span class="id">equicontinuous</span> (<span class="id">closure</span> <span class="id">W</span>) <span class="id">id</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof660')">Proof.</span></div>
<div class="proofscript" id="proof660">
<span class="id">move</span>=&gt; <span class="id">ectsW</span> =&gt; <span class="id">x</span> <span class="id">E</span> <span class="id">entE</span>; <span class="id">near</span>=&gt; <span class="id">y</span> =&gt; <span class="id">f</span> <span class="id">clWf</span>.<br/>
<span class="id"><a name="pointwise_compact_closure">near</a></span> (<span class="id">within</span> <span class="id">W</span> (<span class="id">nbhs</span> (<span class="id">f</span> : {<span class="id"><a name="W:3521">ptws</a></span> <span class="id">X</span> -&gt; <span class="id">Y</span>}))) =&gt; <span class="id">g</span>.<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#equicontinuous">near</a></span>: <span class="id">g</span>; <span class="id">rewrite</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">near_withinE</a></span>; <span class="id">near_simpl</span>; <span class="id">near</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#compact">g</a></span> =&gt; <span class="id">Wg</span>.<br/>
<span class="id"><a href="mathcomp.analysis.topology.html#ArzelaAscoli.X">apply</a></span>: (@<span class="id">entourage_split</span> <span class="id">_</span> (<span class="id">g</span> <span class="id">x</span>)) =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: (<span class="id">near</span> (<span class="id">pointwise_cvg_entourage</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>)).<br/>
<span class="id">apply</span>: (@<span class="id">entourage_split</span> <span class="id">_</span> (<span class="id">g</span> <span class="id">y</span>)) =&gt; //; <span class="id">first</span> <span class="id">exact</span>: (<span class="id">near</span> (@<span class="id">ectsW</span> <span class="id">x</span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#pointwise_compact_cvg">_</a></span>)).<br/>
<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">entourage_sym</span>; <span class="id">exact</span>: (<span class="id">near</span> (<span class="id">pointwise_cvg_entourage</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>)).<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="kwd">by</span> <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">small_ent_sub</span> := @<span class="id"><a href="mathcomp.analysis.topology.html#pointwise_compact_cvg">small_set_sub</a></span> <span class="id">_</span> <span class="id">_</span> (@<span class="id">entourage</span> <span class="id">Y</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_compact_cvg</span> (<span class="id">F</span> : <span class="id">set</span> (<span class="id">set</span> {<span class="id">ptws</span> <span class="id">X</span> -&gt; <span class="id">Y</span>})) (<span class="id">f</span> : {<span class="id">ptws</span> <span class="id">X</span> -&gt; <span class="id">Y</span>}) :<br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;(\<span class="kwd">forall</span> <span class="id">W</span> \<span class="id">near</span> <span class="id">powerset_filter_from</span> <span class="id">F</span>, <span class="id">equicontinuous</span> <span class="id">W</span> <span class="id">id</span>) -&gt;<br/>
&nbsp;&nbsp;{<span class="id">ptws</span>, <span class="id">F</span> --&gt; <span class="id">f</span>} &lt;-&gt; {<span class="id">family</span> <span class="id">compact</span>, <span class="id">F</span> --&gt; <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#id">f</a></span>}.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof661')">Proof.</span></div>
<div class="proofscript" id="proof661">
<span class="id">move</span>=&gt; <span class="id">PF</span> /<span class="id">near_powerset_filter_fromP</span>; <span class="id"><a href="mathcomp.analysis.topology.html#ArzelaAscoli.Y">case</a></span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">equicontinuous_subset_id</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">W</span>; <span class="id">wlog</span> <span class="id">Wf</span> : <span class="id">f</span> <span class="id">W</span> / <span class="id">W</span> <span class="id">f</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; + <span class="id"><a href="mathcomp.analysis.topology.html#compact_ultra">FW</a></span> /<span class="id">equicontinuous_closure</span> =&gt; /(<span class="id">_</span> <span class="id">f</span> (<span class="id">closure</span> <span class="id">W</span>)) <span class="id">Q</span>.<br/>
&nbsp;&nbsp;<span class="id">split</span> =&gt; <span class="id">Ff</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">pointwise_cvg_compact_family</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span> <span class="id">Q</span> =&gt; //; <span class="id">last</span> <span class="kwd">by</span> (<span class="id">apply</span>: (<span class="id">filterS</span> <span class="id">_</span> <span class="id">FW</span>); <span class="id">exact</span>: <span class="id">subset_closure</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">closureEcvg</span>; <span class="kwd">exists</span> <span class="id">F</span>; [|<span class="id">split</span>] =&gt; // ? /<span class="id">filterS</span>; <span class="id">apply</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">FW</span> <span class="id">ectsW</span>; <span class="id">split</span>=&gt; [<span class="id">ptwsF</span>|]; <span class="id">last</span> <span class="id">exact</span>: <span class="id">pointwise_cvg_compact_family</span>.<br/>
<span class="id">apply</span>/<span class="id">fam_cvgP</span> =&gt; <span class="id">K</span> ? <span class="id">U</span> /=; <span class="id">rewrite</span> <span class="id">uniform_nbhs</span> =&gt; [[<span class="id">E</span> [<span class="id">eE</span> <span class="id">EsubU</span>]]].<br/>
<span class="id">suff</span> : \<span class="kwd">forall</span> <span class="id">g</span> \<span class="id">near</span> <span class="id">within</span> <span class="id">W</span> (<span class="id">nbhs</span> <span class="id">f</span>), <span class="kwd">forall</span> <span class="id">y</span>, <span class="id">K</span> <span class="id">y</span> -&gt; <span class="id">E</span> (<span class="id">f</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">y</a></span>, <span class="id">g</span> <span class="id">y</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">near_withinE</span>; <span class="id">near_simpl</span> =&gt; <span class="id">N</span>; <span class="id">apply</span>: (<span class="id">filter_app</span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#compact">_</a></span> <span class="id">FW</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">ptwsF</span>; <span class="id">near</span>=&gt; <span class="id">g</span> =&gt; ?; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#equicontinuous">EsubU</a></span>; <span class="id">apply</span>: (<span class="id">near</span> <span class="id">N</span> <span class="id">g</span>).<br/>
<span class="id">near</span> (<span class="id">powerset_filter_from</span> (@<span class="id">entourage</span> <span class="id">Y</span>)) =&gt; <span class="id">E</span>'.<br/>
<span class="id">have</span> <span class="id">entE</span>' : <span class="id">entourage</span> <span class="id">E</span>' <span class="kwd">by</span> <span class="id">exact</span>: (<span class="id">near</span> (<span class="id">near_small_set</span> <span class="id">_</span>)).<br/>
<span class="id">pose</span> <span class="id">Q</span> := <span class="kwd">fun</span> (<span class="id">h</span> : <span class="id">X</span> -&gt; <span class="id">Y</span>) <span class="id">x</span> =&gt; <span class="id">E</span>' (<span class="id">f</span> <span class="id">x</span>, <span class="id">h</span> <span class="id">x</span>).<br/>
<span class="id">apply</span>: (<span class="id">iffLR</span> (<span class="id">compact_near_coveringP</span> <span class="id">K</span>)) =&gt; // <span class="id">x</span> <span class="id">Kx</span>.<br/>
<span class="id">near</span>=&gt; <span class="id">y</span> <span class="id">g</span> =&gt; /=.<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id">f</span> <span class="id">x</span>) <span class="id">eE</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span> <span class="id">entourage_sym</span>; <span class="id">apply</span>: (<span class="id">near</span> (<span class="id">small_ent_sub</span> <span class="id">_</span>) <span class="id">E</span>') =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: (<span class="id">near</span> (<span class="id">ectsW</span> <span class="id">x</span> <span class="id">E</span>' <span class="id">entE</span>') <span class="id">y</span>).<br/>
<span class="id">apply</span>: (@<span class="id">entourage_split</span> <span class="id"><a href="mathcomp.analysis.topology.html#entourage_sym">_</a></span> (<span class="id">g</span> <span class="id">x</span>)) =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id">near</span> (<span class="id">small_ent_sub</span> <span class="id">_</span>) <span class="id">E</span>') =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">near</span>: <span class="id">g</span>; <span class="id">near_simpl</span>; <span class="id">apply</span>: (@<span class="id"><a href="mathcomp.analysis.topology.html#compact_set1">cvg_within</a></span> <span class="id">_</span> (<span class="id">nbhs</span> <span class="id">f</span>)).<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">pointwise_cvg_entourage</span>.<br/>
<span class="id">apply</span>: (<span class="id">near</span> (<span class="id">small_ent_sub</span> <span class="id">_</span>) <span class="id">E</span>') =&gt; //.<br/>
<span class="id">apply</span>: (<span class="id">near</span> (<span class="id">ectsW</span> <span class="id">x</span> <span class="id">E</span>' <span class="id">entE</span>')) =&gt; //.<br/>
<span class="id">exact</span>: (<span class="id">near</span> (<span class="id">withinT</span> <span class="id">_</span> (<span class="id">nbhs_filter</span> <span class="id">f</span>))).<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_compact_closure</span> (<span class="id">W</span> : <span class="id">set</span> (<span class="id">X</span> -&gt; <span class="id">Y</span>)) :<br/>
&nbsp;&nbsp;<span class="id">equicontinuous</span> <span class="id">W</span> <span class="id">id</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">closure</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">family</span> <span class="id">compact</span>, <span class="id">X</span> -&gt; <span class="id">Y</span>}) =<br/>
&nbsp;&nbsp;<span class="id">closure</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">ptws</span> <span class="id">X</span> -&gt; <span class="id">Y</span>}).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof662')">Proof.</span></div>
<div class="proofscript" id="proof662">
<span class="id">rewrite</span> ?<span class="id">closureEcvg</span> // <span class="id">predeqE</span> =&gt; ? ?.<br/>
<span class="id">split</span>; <span class="id">move</span>=&gt; [<span class="id">F</span> <span class="id">PF</span> [<span class="id">Fx</span> <span class="id">WF</span>]]; (<span class="kwd">exists</span> <span class="id">F</span>; <span class="id">last</span> <span class="id">split</span>) =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">apply</span>/@<span class="id"><a href="mathcomp.analysis.topology.html#ArzelaAscoli.X">pointwise_compact_cvg</a></span> =&gt; //; <span class="id">apply</span>/<span class="id">near_powerset_filter_fromP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">equicontinuous_subset_id</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">W</span> =&gt; //; <span class="id">exact</span>: <span class="id">WF</span>.<br/>
<span class="id">apply</span>/@<span class="id">pointwise_compact_cvg</span> =&gt; //; <span class="id">apply</span>/<span class="id">near_powerset_filter_fromP</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">equicontinuous_subset_id</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">W</span> =&gt; //; <span class="id">exact</span>: <span class="id">WF</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_precompact_equicontinuous</span> (<span class="id"><a href="mathcomp.analysis.topology.html#continuous">W</a></span> : <span class="id">set</span> (<span class="id">X</span> -&gt; <span class="id">Y</span>)) :<br/>
&nbsp;&nbsp;<span class="id">pointwise_precompact</span> <span class="id">W</span> <span class="id">id</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">equicontinuous</span> <span class="id">W</span> <span class="id">id</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">precompact</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">family</span> <span class="id"><a href="mathcomp.analysis.topology.html#near_powerset_filter_fromP">compact</a></span>, <span class="id">X</span> -&gt; <span class="id">Y</span> }).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof663')">Proof.</span></div>
<div class="proofscript" id="proof663">
<span class="id">move</span>=&gt; /<span class="id">pointwise_precompact_precompact</span> + <span class="id">ectsW</span>.<br/>
<span class="id">rewrite</span> ?<span class="id">precompactE</span> <span class="id">compact_ultra</span> <span class="id">compact_ultra</span> <span class="id">pointwise_compact_closure</span> //.<br/>
<span class="id">move</span>=&gt; /= + <span class="id">F</span> <span class="id">UF</span> <span class="id">FcW</span> =&gt; /(<span class="id">_</span> <span class="id">F</span> <span class="id">UF</span>); <span class="id">rewrite</span> <span class="id">image_id</span>; <span class="id">case</span> =&gt; // <span class="id">p</span> [<span class="id">cWp</span> <span class="id"><a href="mathcomp.analysis.topology.html#continuous_subspaceT">Fp</a></span>].<br/>
<span class="kwd">exists</span> <span class="id">p</span>; <span class="id">split</span> =&gt; //; <span class="id">apply</span>/(<span class="id">pointwise_compact_cvg</span>) =&gt; //.<br/>
<span class="id">apply</span>/<span class="id">near_powerset_filter_fromP</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">equicontinuous_subset_id</span>.<br/>
<span class="kwd">exists</span> (<span class="id">closure</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">ptws</span> <span class="id">X</span> -&gt; <span class="id">Y</span> })) =&gt; //; <span class="id">exact</span>: <span class="id">equicontinuous_closure</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">precompact_equicontinuous</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">lcptX</span> : <span class="id">locally_compact</span> [<span class="id"><a href="mathcomp.analysis.topology.html#continuous">set</a></span>: <span class="id">X</span>].<br/>
<br/>
<span class="kwd">Let</span> <span class="id">compact_equicontinuous</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">family</span> <span class="id">compact</span>, <span class="id"><a href="mathcomp.analysis.topology.html#ArzelaAscoli.Y">X</a></span> -&gt; <span class="id">Y</span>}) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">f</span>, <span class="id">W</span> <span class="id">f</span> -&gt; <span class="id">continuous</span> <span class="id">f</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">compact</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">family</span> <span class="id">compact</span>, <span class="id">X</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#equicontinuous_continuous">Y</a></span>}) -&gt;<br/>
&nbsp;&nbsp;<span class="id">equicontinuous</span> <span class="id">W</span> <span class="id">id</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof664')">Proof.</span></div>
<div class="proofscript" id="proof664">
<span class="id">move</span>=&gt; <span class="id">ctsW</span> <span class="id">cptW</span> <span class="id">x</span> <span class="id">E</span> <span class="id">entE</span>.<br/>
<span class="id">have</span> [//|<span class="id">U</span> <span class="id">UWx</span> [<span class="id">cptU</span> <span class="id">clU</span>]] := @<span class="id">lcptX</span> <span class="id">x</span>; <span class="id">rewrite</span> <span class="id">withinET</span> <span class="kwd">in</span> <span class="id">UWx</span>.<br/>
<span class="id">near</span> (<span class="id">powerset_filter_from</span> (@<span class="id">entourage</span> <span class="id">Y</span>)) =&gt; <span class="id">E</span>'.<br/>
<span class="id">have</span> <span class="id">entE</span>' : <span class="id">entourage</span> <span class="id">E</span>' <span class="kwd">by</span> <span class="id">exact</span>: (<span class="id">near</span> (<span class="id">near_small_set</span> <span class="id">_</span>)).<br/>
<span class="id">pose</span> <span class="id">Q</span> := <span class="kwd">fun</span> (<span class="id">y</span> : <span class="id">X</span>) (<span class="id">f</span> : {<span class="id">family</span> <span class="id">compact</span>, <span class="id">X</span> -&gt; <span class="id">Y</span>}) =&gt; <span class="id">E</span>' (<span class="id">f</span> <span class="id">x</span>, <span class="id">f</span> <span class="id">y</span>).<br/>
<span class="id">apply</span>: (<span class="id">iffLR</span> (<span class="id">compact_near_coveringP</span> <span class="id">W</span>)) =&gt; // <span class="id">f</span> <span class="id">Wf</span>; <span class="id">near</span>=&gt; <span class="id">g</span> <span class="id">y</span> =&gt; /=.<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id">f</span> <span class="id">x</span>) <span class="id">entE</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span>/<span class="id">entourage_sym</span>; <span class="id">apply</span>: (<span class="id">near</span> (<span class="id">small_ent_sub</span> <span class="id">_</span>) <span class="id">E</span>') =&gt; //.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: (<span class="id">near</span> (<span class="id">fam_nbhs</span> <span class="id">_</span> <span class="id">entE</span>' (@<span class="id">compact_set1</span> <span class="id">_</span> <span class="id">x</span>)) <span class="id">g</span>).<br/>
<span class="id">apply</span>: (<span class="id">entourage_split</span> (<span class="id">f</span> <span class="id">y</span>) (<span class="id">entourage_split_ent</span> <span class="id">entE</span>)).<br/>
&nbsp;&nbsp;<span class="id">apply</span>: (<span class="id">near</span> (<span class="id">small_ent_sub</span> <span class="id">_</span>) <span class="id">E</span>') =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">near</span>: <span class="id">y</span>; <span class="id">apply</span>: ((@<span class="id">ctsW</span> <span class="id">f</span> <span class="id">Wf</span> <span class="id">x</span>) (<span class="id">to_set</span> <span class="id">_</span> <span class="id">_</span>)); <span class="id">exact</span>: <span class="id">nbhs_entourage</span>.<br/>
<span class="id">apply</span>: (<span class="id">near</span> (<span class="id">small_ent_sub</span> <span class="id">_</span>) <span class="id">E</span>') =&gt; //.<br/>
<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">near</span> (<span class="id">fam_nbhs</span> <span class="id">_</span> <span class="id">entE</span>' <span class="id">cptU</span>) <span class="id">g</span>) =&gt; //; <span class="id">exact</span>: (<span class="id">near</span> <span class="id">UWx</span> <span class="id">y</span>).<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">precompact_equicontinuous</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">family</span> <span class="id">compact</span>, <span class="id">X</span> -&gt; <span class="id">Y</span>}) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">f</span>, <span class="id">W</span> <span class="id">f</span> -&gt; <span class="id">continuous</span> <span class="id">f</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">precompact</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">family</span> <span class="id">compact</span>, <span class="id">X</span> -&gt; <span class="id">Y</span>}) -&gt;<br/>
&nbsp;&nbsp;<span class="id">equicontinuous</span> <span class="id">W</span> <span class="id">id</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof665')">Proof.</span></div>
<div class="proofscript" id="proof665">
<span class="id">move</span>=&gt; <span class="id">pcptW</span> <span class="id">ctsW</span>; <span class="id">apply</span>: (<span class="id">equicontinuous_subset_id</span> (@<span class="id">subset_closure</span> <span class="id">_</span> <span class="id">W</span>)).<br/>
<span class="id">apply</span>: <span class="id">compact_equicontinuous</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">precompactE</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">f</span>; <span class="id">rewrite</span> <span class="id">closureEcvg</span> =&gt; [[<span class="id">G</span> <span class="id">PG</span> [<span class="id">Gf</span> <span class="id">GW</span>]]] <span class="id">x</span> <span class="id">B</span> /=.<br/>
<span class="id">rewrite</span> -<span class="id">nbhs_entourageE</span> =&gt; -[<span class="id">E</span> <span class="id">entE</span>] /<span class="id">filterS</span>; <span class="id">apply</span>; <span class="id">near_simpl</span>.<br/>
<span class="id">suff</span> <span class="id">ctsf</span> : <span class="id">continuous</span> <span class="id">f</span> <span class="kwd">by</span> <span class="id">move</span>: <span class="id">E</span> <span class="id">entE</span>; <span class="id">apply</span>/<span class="id">cvg_app_entourageP</span>; <span class="id">exact</span>: <span class="id">ctsf</span>.<br/>
<span class="id">apply</span>/<span class="id">continuous_localP</span> =&gt; <span class="id">x</span>'; <span class="id">apply</span>/<span class="id">near_powerset_filter_fromP</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id">exact</span>: <span class="id">continuous_subspaceW</span>.<br/>
<span class="id">case</span>: (@<span class="id">lcptX</span> <span class="id">x</span>') =&gt; // <span class="id">U</span>; <span class="id">rewrite</span> <span class="id">withinET</span> =&gt; <span class="id">nbhsU</span> [<span class="id">cptU</span> <span class="id">_</span>].<br/>
<span class="kwd">exists</span> <span class="id">U</span> =&gt; //; <span class="id">apply</span>: (<span class="id">uniform_limit_continuous_subspace</span> <span class="id">PG</span> <span class="id">_</span> <span class="id">_</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">near</span>=&gt; <span class="id">g</span>; <span class="id">apply</span>: <span class="id">continuous_subspaceT</span>; <span class="id">near</span>: <span class="id">g</span>; <span class="id">exact</span>: <span class="id">GW</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>/<span class="id">fam_cvgP</span>/(<span class="id">_</span> <span class="id">_</span> <span class="id">cptU</span>) : <span class="id">Gf</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">precompact_equicontinuous</span>.<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">Ascoli</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">family</span> <span class="id">compact</span>, <span class="id">X</span> -&gt; <span class="id">Y</span>}) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">locally_compact</span> [<span class="id">set</span>: <span class="id">X</span>] -&gt;<br/>
&nbsp;&nbsp;<span class="id">pointwise_precompact</span> <span class="id">W</span> <span class="id">id</span> /\ <span class="id">equicontinuous</span> <span class="id">W</span> <span class="id">id</span> &lt;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">f</span>, <span class="id">W</span> <span class="id">f</span> -&gt; <span class="id">continuous</span> <span class="id">f</span>) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">precompact</span> (<span class="id">W</span> : <span class="id">set</span> {<span class="id">family</span> <span class="id">compact</span>, <span class="id">X</span> -&gt; <span class="id">Y</span>}).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof666')">Proof.</span></div>
<div class="proofscript" id="proof666">
<span class="id">move</span>=&gt; <span class="id">lcpt</span>; <span class="id">split</span> =&gt; [[<span class="id">Wid</span> <span class="id">ectsW</span>]|[<span class="id">fWf</span>]<span class="id">pcptW</span>].<br/>
&nbsp;&nbsp;<span class="id">split</span>=&gt; [?|]; <span class="id">first</span> <span class="id">exact</span>: <span class="id">equicontinuous_continuous</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">pointwise_precompact_equicontinuous</span>.<br/>
<span class="id">split</span>; <span class="id">last</span> <span class="id">exact</span>: <span class="id">precompact_equicontinuous</span>.<br/>
<span class="id">exact</span>: <span class="id">precompact_pointwise_precompact</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">ArzelaAscoli</span>.<br/>

</div>
<div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/tree/yoshihiro503%40generate_index">a fork of coq2html</a></div>
</body>
</html>
