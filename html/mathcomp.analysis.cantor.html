
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.analysis.cantor</title>
<meta name="description" content="Documentation of Coq module mathcomp.analysis.cantor" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>

<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init('proofscript')">
<h1 class="title">Module mathcomp.analysis.cantor</h1>
<div class="coq">
<span class="kwd">From</span> <span class="id">mathcomp</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">all_ssreflect</span> <span class="id">ssralg</span> <span class="id">ssrint</span> <span class="id">ssrnum</span>.<br/>
<span class="kwd">From</span> <span class="id">mathcomp</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">interval</span> <span class="id">rat</span> <span class="id">fintype</span> <span class="id">finmap</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">mathcomp_extra</span> <span class="id">boolp</span> <span class="id">classical_sets</span> <span class="id">signed</span> <span class="id">functions</span> <span class="id">cardinality</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">reals</span> <span class="id">topology</span>.<br/>
<span class="kwd">From</span> <span class="id">HB</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">structures</span>.<br/>
<br/>
<pre class="ssrdoc">
                     The Cantor Space and Applications                     
                                                                           
This file develops the theory of the Cantor space, that is bool^nat with   
the product topology. The two main theorems proved here are                
homeomorphism_cantor_like, and cantor_surj, a.k.a. Alexandroff-Hausdorff.  
                                                                           
         cantor_space == the Cantor space, with its canonical metric       
        cantor_like T == perfect + compact + hausdroff + zero dimensional  
   pointed_discrete T == equips T with the discrete topology               
            tree_of T == builds a topological tree with levels (T n)       
                                                                           
</pre>
<br/>
<span class="kwd">Set</span> <span class="kwd">Implicit</span> <span class="kwd">Arguments</span>.<br/>
<span class="id">Unset</span> <span class="id">Strict</span> <span class="kwd">Implicit</span>.<br/>
<span class="id">Unset</span> <span class="id">Printing</span> <span class="kwd">Implicit</span> <span class="id">Defensive</span>.<br/>
<br/>
<span class="kwd">Import</span> <span class="id">Order.TTheory</span> <span class="id">GRing.Theory</span> <span class="id">Num.Def</span> <span class="id">Num.Theory</span>.<br/>
<span class="kwd">Import</span> <span class="id">numFieldTopology.Exports</span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">cantor_space</span> :=<br/>
&nbsp;&nbsp;<span class="id">product_uniformType</span> (<span class="kwd">fun</span> <span class="id">_</span> : <span class="id">nat</span> =&gt; @<span class="id">discrete_uniformType</span> <span class="id">_</span> <span class="id">discrete_bool</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">cantor_like</span> (<span class="id">T</span> : <span class="id">topologicalType</span>) :=<br/>
&nbsp;&nbsp;[/\ <span class="id">perfect_set</span> [<span class="id">set</span>: <span class="id">T</span>],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">compact</span> [<span class="id">set</span>: <span class="id">T</span>],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hausdorff_space</span> <span class="id">T</span> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">zero_dimensional</span> <span class="id">T</span>].<br/>
<br/>
<span class="kwd">Canonical</span> <span class="id">cantor_pseudoMetric</span> {<span class="id">R</span>} :=<br/>
&nbsp;&nbsp;@<span class="id">product_pseudoMetricType</span> <span class="id">R</span> <span class="id">_</span> (<span class="kwd">fun</span> <span class="id">_</span> : <span class="id">nat</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@<span class="id">discrete_pseudoMetricType</span> <span class="id">R</span> <span class="id">_</span> <span class="id">discrete_bool</span>) (<span class="id">countableP</span> <span class="id">_</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cantor_space_compact</span> : <span class="id">compact</span> [<span class="id">set</span>: <span class="id">cantor_space</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof1')">Proof.</span></div>
<div class="proofscript" id="proof1">
<span class="id">have</span> := @<span class="id">tychonoff</span> <span class="id">_</span> (<span class="kwd">fun</span> <span class="id">_</span> : <span class="id">nat</span> =&gt; <span class="id">_</span>) <span class="id">_</span> (<span class="kwd">fun</span>=&gt; <span class="id">bool_compact</span>).<br/>
<span class="kwd">by</span> <span class="id">congr</span> (<span class="id">compact</span> <span class="id">_</span>); <span class="id">rewrite</span> <span class="id">eqEsubset</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cantor_space_hausdorff</span> : <span class="id">hausdorff_space</span> <span class="id">cantor_space</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof2')">Proof.</span></div>
<div class="proofscript" id="proof2">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">hausdorff_product</span> =&gt; ?; <span class="id">exact</span>: <span class="id">discrete_hausdorff</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cantor_zero_dimensional</span> : <span class="id">zero_dimensional</span> <span class="id">cantor_space</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof3')">Proof.</span></div>
<div class="proofscript" id="proof3">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">zero_dimension_prod</span> =&gt; <span class="id">_</span>; <span class="id">exact</span>: <span class="id">discrete_zero_dimension</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cantor_perfect</span> : <span class="id">perfect_set</span> [<span class="id">set</span>: <span class="id">cantor_space</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof4')">Proof.</span></div>
<div class="proofscript" id="proof4">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">perfect_diagonal</span> =&gt; <span class="id">_</span>; <span class="kwd">exists</span> (<span class="id">true</span>, <span class="id">false</span>). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cantor_like_cantor_space</span> : <span class="id">cantor_like</span> <span class="id">cantor_space</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof5')">Proof.</span></div>
<div class="proofscript" id="proof5">
<span class="id">split</span>.<br/>
- <span class="id">exact</span>: <span class="id">cantor_perfect</span>.<br/>
- <span class="id">exact</span>: <span class="id">cantor_space_compact</span>.<br/>
- <span class="id">exact</span>: <span class="id">cantor_space_hausdorff</span>.<br/>
- <span class="id">exact</span>: <span class="id">cantor_zero_dimensional</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">topological_trees</span>.<br/>
<span class="kwd">Context</span> {<span class="id">K</span> : <span class="id">nat</span> -&gt; <span class="id">topologicalType</span>} {<span class="id">X</span> : <span class="id">topologicalType</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">refine_apx</span> : <span class="kwd">forall</span> <span class="id">n</span>, <span class="id">set</span> <span class="id">X</span> -&gt; <span class="id">K</span> <span class="id">n</span> -&gt; <span class="id">set</span> <span class="id">X</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">tree_invariant</span> : <span class="id">set</span> <span class="id">X</span> -&gt; <span class="kwd">Prop</span>).<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">cmptX</span> : <span class="id">compact</span> [<span class="id">set</span>: <span class="id">X</span>].<br/>
<span class="kwd">Hypothesis</span> <span class="id">hsdfX</span> : <span class="id">hausdorff_space</span> <span class="id">X</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">discreteK</span> : <span class="kwd">forall</span> <span class="id">n</span>, <span class="id">discrete_space</span> (<span class="id">K</span> <span class="id">n</span>).<br/>
<span class="kwd">Hypothesis</span> <span class="id">refine_cover</span> : <span class="kwd">forall</span> <span class="id">n</span> <span class="id">U</span>, <span class="id">U</span> = \<span class="id">bigcup_e</span> @<span class="id">refine_apx</span> <span class="id">n</span> <span class="id">U</span> <span class="id">e</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">refine_invar</span> : <span class="kwd">forall</span> <span class="id">n</span> <span class="id">U</span> <span class="id">e</span>,<br/>
&nbsp;&nbsp;<span class="id">tree_invariant</span> <span class="id">U</span> -&gt; <span class="id">tree_invariant</span> (@<span class="id">refine_apx</span> <span class="id">n</span> <span class="id">U</span> <span class="id">e</span>).<br/>
<span class="kwd">Hypothesis</span> <span class="id">invar_n0</span> : <span class="kwd">forall</span> <span class="id">U</span>, <span class="id">tree_invariant</span> <span class="id">U</span> -&gt; <span class="id">U</span> !=<span class="id">set0</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">invarT</span> : <span class="id">tree_invariant</span> [<span class="id">set</span>: <span class="id">X</span>].<br/>
<span class="kwd">Hypothesis</span> <span class="id">invar_cl</span> : <span class="id">tree_invariant</span> `&lt;=` <span class="id">closed</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">refine_separates</span>: <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> : <span class="id">X</span>, <span class="id">x</span> != <span class="id">y</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">n</span>, <span class="kwd">forall</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">X</span>) <span class="id">e</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@<span class="id">refine_apx</span> <span class="id">n</span> <span class="id">U</span> <span class="id">e</span> <span class="id">x</span> -&gt; ~@<span class="id">refine_apx</span> <span class="id">n</span> <span class="id">U</span> <span class="id">e</span> <span class="id">y</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">refine_subset</span> <span class="id">n</span> <span class="id">U</span> <span class="id">e</span> : @<span class="id">refine_apx</span> <span class="id">n</span> <span class="id">U</span> <span class="id">e</span> `&lt;=` <span class="id">U</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof6')">Proof.</span></div>
<div class="proofscript" id="proof6">
 <span class="kwd">by</span> <span class="id">rewrite</span> [<span class="id">X</span> <span class="kwd">in</span> <span class="id">_</span> `&lt;=` <span class="id">X</span>](<span class="id">refine_cover</span> <span class="id">n</span>); <span class="id">exact</span>: <span class="id">bigcup_sup</span>. Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">T</span> := <span class="id">product_topologicalType</span> <span class="id">K</span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Fixpoint</span> <span class="id">branch_apx</span> (<span class="id">b</span> : <span class="id">T</span>) <span class="id">n</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">n</span> <span class="id">is</span> <span class="id">m</span>.+1 <span class="kwd">then</span> <span class="id">refine_apx</span> (<span class="id">branch_apx</span> <span class="id">b</span> <span class="id">m</span>) (<span class="id">b</span> <span class="id">m</span>) <span class="kwd">else</span> [<span class="id">set</span>: <span class="id">X</span>].<br/>
<br/>
<span class="kwd">Let</span> <span class="id">tree_mapF</span> <span class="id">b</span> := <span class="id">filter_from</span> [<span class="id">set</span>: <span class="id">nat</span>] (<span class="id">branch_apx</span> <span class="id">b</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">tree_map_invar</span> <span class="id">b</span> <span class="id">n</span> : <span class="id">tree_invariant</span> (<span class="id">branch_apx</span> <span class="id">b</span> <span class="id">n</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof7')">Proof.</span></div>
<div class="proofscript" id="proof7">
 <span class="kwd">by</span> <span class="id">elim</span>: <span class="id">n</span> =&gt; // <span class="id">n</span> ?; <span class="id">exact</span>: <span class="id">refine_invar</span>. Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">tree_map_sub</span> <span class="id">b</span> <span class="id">i</span> <span class="id">j</span> : (<span class="id">i</span> &lt;= <span class="id">j</span>)%<span class="id">N</span> -&gt; <span class="id">branch_apx</span> <span class="id">b</span> <span class="id">j</span> `&lt;=` <span class="id">branch_apx</span> <span class="id">b</span> <span class="id">i</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof8')">Proof.</span></div>
<div class="proofscript" id="proof8">
<span class="id">elim</span>: <span class="id">j</span> <span class="id">i</span> =&gt; [?|<span class="id">j</span> <span class="id">IH</span> <span class="id">i</span>]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">leqn0</span> =&gt; /<span class="id">eqP</span> -&gt;.<br/>
<span class="id">rewrite</span> <span class="id">leq_eqVlt</span> =&gt; /<span class="id">predU1P</span>[-&gt;//|/<span class="id">IH</span>].<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subset_trans</span>; <span class="id">exact</span>: <span class="id">refine_subset</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Instance</span> <span class="id">tree_map_filter</span> <span class="id">b</span> : <span class="id">ProperFilter</span> (<span class="id">tree_mapF</span> <span class="id">b</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof9')">Proof.</span></div>
<div class="proofscript" id="proof9">
<span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">case</span> =&gt; <span class="id">n</span> <span class="id">_</span> <span class="id">P</span>; <span class="id">case</span>: (<span class="id">invar_n0</span> (<span class="id">tree_map_invar</span> <span class="id">b</span> <span class="id">n</span>)) =&gt; <span class="id">x</span> /<span class="id">P</span>.<br/>
<span class="id">apply</span>: <span class="id">filter_from_filter</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> 0%<span class="id">N</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">j</span> <span class="id">_</span> <span class="id">_</span>; <span class="kwd">exists</span> (<span class="id">maxn</span> <span class="id">i</span> <span class="id">j</span>)  =&gt; //; <span class="id">rewrite</span> <span class="id">subsetI</span>.<br/>
<span class="kwd">by</span> <span class="id">split</span>; <span class="id">apply</span>: <span class="id">tree_map_sub</span>; [<span class="id">exact</span>: <span class="id">leq_maxl</span> | <span class="id">exact</span>: <span class="id">leq_maxr</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">tree_map</span> <span class="id">b</span> := <span class="id">lim</span> (<span class="id">tree_mapF</span> <span class="id">b</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">cvg_tree_map</span> <span class="id">b</span> : <span class="id">cvg</span> (<span class="id">tree_mapF</span> <span class="id">b</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof10')">Proof.</span></div>
<div class="proofscript" id="proof10">
<span class="id">have</span> [|<span class="id">x</span> [<span class="id">_</span> <span class="id">clx</span>]] := <span class="id">cmptX</span> (<span class="id">tree_map_filter</span> <span class="id">b</span>); <span class="id">first</span> <span class="id">exact</span>: <span class="id">filterT</span>.<br/>
<span class="id">apply</span>/<span class="id">cvg_ex</span>; <span class="kwd">exists</span> <span class="id">x</span> =&gt; /=; <span class="id">apply</span>: (<span class="id">compact_cluster_set1</span> <span class="id">_</span> <span class="id">cmptX</span>) =&gt; //.<br/>
- <span class="id">exact</span>: <span class="id">filterT</span>.<br/>
- <span class="id">exact</span>: <span class="id">filterT</span>.<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>=&gt; [<span class="id">y</span> <span class="id">cly</span>|? -&gt; //].<br/>
<span class="id">have</span> [-&gt;//|/<span class="id">refine_separates</span>[<span class="id">n</span> <span class="id">sep</span>]] := <span class="id">eqVneq</span> <span class="id">x</span> <span class="id">y</span>.<br/>
<span class="id">have</span> <span class="id">bry</span> : <span class="id">branch_apx</span> <span class="id">b</span> <span class="id">n</span>.+1 <span class="id">y</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> /<span class="id">closure_id</span> -&gt; := <span class="id">invar_cl</span> (<span class="id">tree_map_invar</span> <span class="id">b</span> <span class="id">n</span>.+1).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>: <span class="id">cly</span>; <span class="id">rewrite</span> <span class="id">clusterE</span>; <span class="id">apply</span>; <span class="kwd">exists</span> <span class="id">n</span>.+1.<br/>
<span class="id">suff</span> /<span class="id">sep</span> : <span class="id">branch_apx</span> <span class="id">b</span> <span class="id">n</span>.+1 <span class="id">x</span> <span class="kwd">by</span> [].<br/>
<span class="id">have</span> /<span class="id">closure_id</span> -&gt; := <span class="id">invar_cl</span> (<span class="id">tree_map_invar</span> <span class="id">b</span> <span class="id">n</span>.+1).<br/>
<span class="kwd">by</span> <span class="id">move</span>: <span class="id">clx</span>; <span class="id">rewrite</span> <span class="id">clusterE</span>; <span class="id">apply</span>; <span class="kwd">exists</span> <span class="id">n</span>.+1.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">tree_map_surj</span> : <span class="id">set_surj</span> [<span class="id">set</span>: <span class="id">T</span>] [<span class="id">set</span>: <span class="id">X</span>] <span class="id">tree_map</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof11')">Proof.</span></div>
<div class="proofscript" id="proof11">
<span class="id">move</span>=&gt; <span class="id">z</span> <span class="id">_</span>; <span class="id">suff</span> : <span class="kwd">exists</span> <span class="id">g</span>, <span class="kwd">forall</span> <span class="id">n</span>, <span class="id">branch_apx</span> <span class="id">g</span> <span class="id">n</span> <span class="id">z</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>=&gt; <span class="id">g</span> <span class="id">gnz</span>; <span class="kwd">exists</span> <span class="id">g</span> =&gt; //; <span class="id">apply</span>: <span class="id">close_eq</span> =&gt; // <span class="id">U</span> [<span class="id">oU</span> <span class="id">Uz</span>] <span class="id">V</span> <span class="id">ngV</span>; <span class="kwd">exists</span> <span class="id">z</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span> =&gt; //; <span class="id">have</span> [<span class="id">n</span> <span class="id">_</span>] := @<span class="id">cvg_tree_map</span> <span class="id">g</span> <span class="id">_</span> <span class="id">ngV</span>; <span class="id">exact</span>.<br/>
<span class="id">have</span> <span class="id">zcov</span>' : <span class="kwd">forall</span> <span class="id">n</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">X</span>), <span class="kwd">exists</span> <span class="id">e</span>, <span class="id">U</span> <span class="id">z</span> -&gt; @<span class="id">refine_apx</span> <span class="id">n</span> <span class="id">U</span> <span class="id">e</span> <span class="id">z</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">U</span>; <span class="id">have</span> [|?] := <span class="id">pselect</span> (<span class="id">U</span> <span class="id">z</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">point</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> [<span class="id">X</span> <span class="kwd">in</span> <span class="id">X</span> <span class="id">z</span> -&gt; <span class="id">_</span>](@<span class="id">refine_cover</span> <span class="id">n</span> <span class="id">U</span>); <span class="id">case</span> =&gt; <span class="id">e</span> <span class="id">_</span> ?; <span class="kwd">exists</span> <span class="id">e</span>.<br/>
<span class="id">pose</span> <span class="id">zcov</span> <span class="id">n</span> <span class="id">U</span> := <span class="id">projT1</span> (<span class="id">cid</span> (<span class="id">zcov</span>' <span class="id">n</span> <span class="id">U</span>)).<br/>
<span class="id">pose</span> <span class="kwd">fix</span> <span class="id">g</span> <span class="id">n</span> : <span class="id">K</span> <span class="id">n</span> * <span class="id">set</span> <span class="id">X</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">n</span> <span class="id">is</span> <span class="id">m</span>.+1<br/>
&nbsp;&nbsp;<span class="kwd">then</span> (<span class="id">zcov</span> <span class="id">m</span>.+1 (<span class="id">g</span> <span class="id">m</span>).2, @<span class="id">refine_apx</span> <span class="id">m</span>.+1 (<span class="id">g</span> <span class="id">m</span>).2 (<span class="id">zcov</span> <span class="id">m</span>.+1 (<span class="id">g</span> <span class="id">m</span>).2))<br/>
&nbsp;&nbsp;<span class="kwd">else</span> (<span class="id">zcov</span> <span class="id">O</span> [<span class="id">set</span>: <span class="id">X</span>], @<span class="id">refine_apx</span> <span class="id">O</span> [<span class="id">set</span>: <span class="id">X</span>] (<span class="id">zcov</span> <span class="id">O</span> [<span class="id">set</span>: <span class="id">X</span>])).<br/>
<span class="id">pose</span> <span class="id">g</span>' <span class="id">n</span> := (<span class="id">g</span> <span class="id">n</span>).1; <span class="id">have</span> <span class="id">apxg</span> <span class="id">n</span> : <span class="id">branch_apx</span> <span class="id">g</span>' <span class="id">n</span>.+1 = (<span class="id">g</span> <span class="id">n</span>).2.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">elim</span>: <span class="id">n</span> =&gt; //= <span class="id">n</span> -&gt;.<br/>
<span class="kwd">exists</span> <span class="id">g</span>'; <span class="id">elim</span> =&gt; // <span class="id">n</span> /= <span class="id">IH</span>.<br/>
<span class="id">have</span> /(<span class="id">_</span> <span class="id">IH</span>) := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">zcov</span>' <span class="id">n</span> (<span class="id">branch_apx</span> <span class="id">g</span>' <span class="id">n</span>))).<br/>
<span class="kwd">by</span> <span class="id">case</span>: <span class="id">n</span> {<span class="id">IH</span>} =&gt; // <span class="id">n</span>; <span class="id">rewrite</span> <span class="id">apxg</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">tree_prefix</span> (<span class="id">b</span> : <span class="id">T</span>) (<span class="id">n</span> : <span class="id">nat</span>) :<br/>
&nbsp;&nbsp;\<span class="kwd">forall</span> <span class="id">c</span> \<span class="id">near</span> <span class="id">b</span>, <span class="kwd">forall</span> <span class="id">i</span>,  (<span class="id">i</span> &lt; <span class="id">n</span>)%<span class="id">N</span> -&gt; <span class="id">b</span> <span class="id">i</span> = <span class="id">c</span> <span class="id">i</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof12')">Proof.</span></div>
<div class="proofscript" id="proof12">
<span class="id">elim</span>: <span class="id">n</span> =&gt; [|<span class="id">n</span> <span class="id">IH</span>]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">near</span>=&gt; <span class="id">z</span> =&gt; ?; <span class="id">rewrite</span> <span class="id">ltn0</span>.<br/>
<span class="id">near</span>=&gt; <span class="id">z</span> =&gt; <span class="id">i</span>; <span class="id">rewrite</span> <span class="id">leq_eqVlt</span> =&gt; /<span class="id">predU1P</span>[|<span class="id">iSn</span>]; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">near</span> <span class="id">IH</span> <span class="id">z</span>).<br/>
<span class="id">move</span>=&gt; [-&gt;]; <span class="id">near</span>: <span class="id">z</span>; <span class="kwd">exists</span> (<span class="id">proj</span> <span class="id">n</span> @^-1` [<span class="id">set</span> <span class="id">b</span> <span class="id">n</span>]).<br/>
<span class="id">split</span> =&gt; //; <span class="id">suff</span> : @<span class="id">open</span> <span class="id">T</span> (<span class="id">proj</span> <span class="id">n</span> @^-1` [<span class="id">set</span> <span class="id">b</span> <span class="id">n</span>]) <span class="kwd">by</span> [].<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">open_comp</span>; [<span class="id">move</span>=&gt; + <span class="id">_</span>; <span class="id">exact</span>: <span class="id">proj_continuous</span>| <span class="id">exact</span>: <span class="id">discrete_open</span>].<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">apx_prefix</span> <span class="id">b</span> <span class="id">c</span> <span class="id">n</span> :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, (<span class="id">i</span> &lt; <span class="id">n</span>)%<span class="id">N</span> -&gt; <span class="id">b</span> <span class="id">i</span> = <span class="id">c</span> <span class="id">i</span>) -&gt; <span class="id">branch_apx</span> <span class="id">b</span> <span class="id">n</span> = <span class="id">branch_apx</span> <span class="id">c</span> <span class="id">n</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof13')">Proof.</span></div>
<div class="proofscript" id="proof13">
<span class="id">elim</span>: <span class="id">n</span> =&gt; //= <span class="id">n</span> <span class="id">IH</span> <span class="id">inS</span>; <span class="id">rewrite</span> <span class="id">IH</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">inS</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id">exact</span>/<span class="id">inS</span>/<span class="id">ltnW</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">tree_map_apx</span> <span class="id">b</span> <span class="id">n</span> : <span class="id">branch_apx</span> <span class="id">b</span> <span class="id">n</span> (<span class="id">tree_map</span> <span class="id">b</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof14')">Proof.</span></div>
<div class="proofscript" id="proof14">
<span class="id">apply</span>: (@<span class="id">closed_cvg</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">tree_map_filter</span> <span class="id">b</span>)); <span class="id">last</span> <span class="id">exact</span>: <span class="id">cvg_tree_map</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">invar_cl</span>; <span class="id">exact</span>: <span class="id">tree_map_invar</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">n</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">tree_map_cts</span> : <span class="id">continuous</span> <span class="id">tree_map</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof15')">Proof.</span></div>
<div class="proofscript" id="proof15">
<span class="id">move</span>=&gt; <span class="id">b</span> <span class="id">U</span> /<span class="id">cvg_tree_map</span> [<span class="id">n</span> <span class="id">_</span>] /<span class="id">filterS</span>; <span class="id">apply</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>/<span class="id">fmap_filter</span>/<span class="id">nbhs_filter</span>.<br/>
<span class="id">rewrite</span> <span class="id">nbhs_simpl</span> /=; <span class="id">near_simpl</span>; <span class="id">have</span> := <span class="id">tree_prefix</span> <span class="id">b</span> <span class="id">n</span>; <span class="id">apply</span>: <span class="id">filter_app</span>.<br/>
<span class="kwd">by</span> <span class="id">near</span>=&gt; <span class="id">z</span> =&gt; /<span class="id">apx_prefix</span> -&gt;; <span class="id">exact</span>: <span class="id">tree_map_apx</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">tree_map_setI</span> <span class="id">x</span> <span class="id">y</span> <span class="id">n</span> : <span class="id">tree_map</span> <span class="id">x</span> = <span class="id">tree_map</span> <span class="id">y</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">refine_apx</span> (<span class="id">branch_apx</span> <span class="id">x</span> <span class="id">n</span>) (<span class="id">x</span> <span class="id">n</span>) `&amp;` <span class="id">refine_apx</span> (<span class="id">branch_apx</span> <span class="id">y</span> <span class="id">n</span>) (<span class="id">y</span> <span class="id">n</span>) !=<span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof16')">Proof.</span></div>
<div class="proofscript" id="proof16">
<span class="id">move</span>=&gt; <span class="id">xyE</span>; <span class="kwd">exists</span> (<span class="id">tree_map</span> <span class="id">y</span>); <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">xyE</span> -/(<span class="id">branch_apx</span> <span class="id">x</span> <span class="id">n</span>.+1); <span class="id">exact</span>: <span class="id">tree_map_apx</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -/(<span class="id">branch_apx</span> <span class="id">y</span> <span class="id">n</span>.+1); <span class="id">exact</span>: <span class="id">tree_map_apx</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">tree_map_inj</span> : (<span class="kwd">forall</span> <span class="id">n</span> <span class="id">U</span>, <span class="id">trivIset</span> [<span class="id">set</span>: <span class="id">K</span> <span class="id">n</span>] (@<span class="id">refine_apx</span> <span class="id">n</span> <span class="id">U</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">set_inj</span> [<span class="id">set</span>: <span class="id">T</span>] <span class="id">tree_map</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof17')">Proof.</span></div>
<div class="proofscript" id="proof17">
<span class="id">move</span>=&gt; <span class="id">triv</span> <span class="id">x</span> <span class="id">y</span> <span class="id">_</span> <span class="id">_</span> <span class="id">xyE</span>; <span class="id">apply</span>: <span class="id">functional_extensionality_dep</span> =&gt; <span class="id">n</span>.<br/>
<span class="id">suff</span> : <span class="kwd">forall</span> <span class="id">n</span>, <span class="id">branch_apx</span> <span class="id">x</span> <span class="id">n</span> = <span class="id">branch_apx</span> <span class="id">y</span> <span class="id">n</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">brE</span>; <span class="id">apply</span>: (@<span class="id">triv</span> <span class="id">n</span> (<span class="id">branch_apx</span> <span class="id">x</span> <span class="id">n</span>) <span class="id">_</span> <span class="id">_</span> <span class="id">I</span> <span class="id">I</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> [<span class="kwd">in</span> <span class="id">X</span> <span class="kwd">in</span> <span class="id">_</span> `&amp;` <span class="id">X</span>]<span class="id">brE</span>; <span class="id">exact</span>: <span class="id">tree_map_setI</span>.<br/>
<span class="id">elim</span> =&gt; // <span class="id">m</span> /= <span class="id">brE</span>.<br/>
<span class="id">rewrite</span> (@<span class="id">triv</span> <span class="id">m</span> (<span class="id">branch_apx</span> <span class="id">x</span> <span class="id">m</span>) (<span class="id">x</span> <span class="id">m</span>) (<span class="id">y</span> <span class="id">m</span>) <span class="id">I</span> <span class="id">I</span>) 1?<span class="id">brE</span>//.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -[<span class="kwd">in</span> <span class="id">X</span> <span class="kwd">in</span> <span class="id">X</span> `&amp;` <span class="id">_</span>]<span class="id">brE</span>; <span class="id">exact</span>: <span class="id">tree_map_setI</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">tree_map_props</span> : <span class="kwd">exists</span> <span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">X</span>,<br/>
&nbsp;&nbsp;[/\ <span class="id">continuous</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">set_surj</span> [<span class="id">set</span>: <span class="id">T</span>] [<span class="id">set</span>: <span class="id">X</span>] <span class="id">f</span> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">n</span> <span class="id">U</span>, <span class="id">trivIset</span> [<span class="id">set</span>: <span class="id">K</span> <span class="id">n</span>] (@<span class="id">refine_apx</span> <span class="id">n</span> <span class="id">U</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">set_inj</span> [<span class="id">set</span>: <span class="id">T</span>] <span class="id">f</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof18')">Proof.</span></div>
<div class="proofscript" id="proof18">
<span class="kwd">exists</span> <span class="id">tree_map</span>; <span class="id">split</span>.<br/>
- <span class="id">exact</span>: <span class="id">tree_map_cts</span>.<br/>
- <span class="id">exact</span>: <span class="id">tree_map_surj</span>.<br/>
- <span class="id">exact</span>: <span class="id">tree_map_inj</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">topological_trees</span>.<br/>
<br/>
<br/>
<span class="kwd">Section</span> <span class="id">TreeStructure</span>.<br/>
<span class="kwd">Context</span> {<span class="id">R</span> : <span class="id">realType</span>} {<span class="id">T</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>}.<br/>
<span class="kwd">Hypothesis</span> <span class="id">cantorT</span> : <span class="id">cantor_like</span> <span class="id">T</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">dsctT</span> : <span class="id">zero_dimensional</span> <span class="id">T</span><br/>
<div>&nbsp;&nbsp;<span class="toggleproof" onclick="toggleDisplay('proof19')">Proof.</span></div>
<div class="proofscript" id="proof19">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id">cantorT</span>. Qed.</div>
<span class="kwd">Let</span> <span class="id">pftT</span>  : <span class="id">perfect_set</span> [<span class="id">set</span>: <span class="id">T</span>]<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof20')">Proof.</span></div>
<div class="proofscript" id="proof20">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id">cantorT</span>. Qed.</div>
<span class="kwd">Let</span> <span class="id">cmptT</span> : <span class="id">compact</span> [<span class="id">set</span>: <span class="id">T</span>]<br/>
<div>&nbsp;&nbsp;&nbsp;&nbsp;<span class="toggleproof" onclick="toggleDisplay('proof21')">Proof.</span></div>
<div class="proofscript" id="proof21">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id">cantorT</span>. Qed.</div>
<span class="kwd">Let</span> <span class="id">hsdfT</span> : @<span class="id">hausdorff_space</span> <span class="id">T</span><br/>
<div>&nbsp;&nbsp;<span class="toggleproof" onclick="toggleDisplay('proof22')">Proof.</span></div>
<div class="proofscript" id="proof22">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id">cantorT</span>. Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">c_invar</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) := <span class="id">clopen</span> <span class="id">U</span> /\ <span class="id">U</span> !=<span class="id">set0</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">U_</span> := <span class="id">unsquash</span> (<span class="id">clopen_surj</span> <span class="id">cmptT</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">split_clopen</span>' (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="kwd">exists</span> <span class="id">V</span>,<br/>
&nbsp;&nbsp;<span class="id">open</span> <span class="id">U</span> -&gt; <span class="id">U</span> !=<span class="id">set0</span> -&gt; [/\ <span class="id">clopen</span> <span class="id">V</span>, <span class="id">V</span> `&amp;` <span class="id">U</span> !=<span class="id">set0</span> &amp; ~`<span class="id">V</span> `&amp;` <span class="id">U</span> !=<span class="id">set0</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof23')">Proof.</span></div>
<div class="proofscript" id="proof23">
<span class="id">have</span> [<span class="id">oU</span>|?] := <span class="id">pselect</span> (<span class="id">open</span> <span class="id">U</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">point</span>.<br/>
<span class="id">have</span> [<span class="id">Un0</span>|?] := <span class="id">pselect</span> (<span class="id">U</span> !=<span class="id">set0</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">point</span>.<br/>
<span class="id">have</span> [<span class="id">x</span> [<span class="id">y</span>] [<span class="id">Ux</span>] <span class="id">Uy</span> <span class="id">xny</span>] := (<span class="id">iffLR</span> <span class="id">perfect_set2</span>) <span class="id">pftT</span> <span class="id">U</span> <span class="id">oU</span> <span class="id">Un0</span>.<br/>
<span class="id">have</span> [<span class="id">V</span> [<span class="id">clV</span> <span class="id">Vx</span> <span class="id">Vy</span>]] := <span class="id">dsctT</span> <span class="id">xny</span>; <span class="kwd">exists</span> <span class="id">V</span> =&gt; <span class="id">_</span> <span class="id">_</span>.<br/>
<span class="kwd">by</span> <span class="id">split</span> =&gt; //; [<span class="kwd">exists</span> <span class="id">x</span> | <span class="kwd">exists</span> <span class="id">y</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">split_clopen</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) := <span class="id">projT1</span> (<span class="id">cid</span> (<span class="id">split_clopen</span>' <span class="id">U</span>)).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">c_ind</span> <span class="id">n</span> (<span class="id">V</span> : <span class="id">set</span> <span class="id">T</span>) (<span class="id">b</span> : <span class="id">bool</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">Wn</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">pselect</span> ((<span class="id">U_</span> <span class="id">n</span>) `&amp;` <span class="id">V</span> !=<span class="id">set0</span> /\ ~` (<span class="id">U_</span> <span class="id">n</span>) `&amp;` <span class="id">V</span> !=<span class="id">set0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">U_</span> <span class="id">n</span> <span class="kwd">else</span> <span class="id">split_clopen</span> <span class="id">V</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;(<span class="kwd">if</span> <span class="id">b</span> <span class="kwd">then</span> <span class="id">Wn</span> <span class="kwd">else</span> ~` <span class="id">Wn</span>) `&amp;` <span class="id">V</span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">cantor_map</span> : <span class="kwd">exists</span> <span class="id">f</span> : <span class="id">cantor_space</span> -&gt; <span class="id">T</span>,<br/>
&nbsp;&nbsp;[/\ <span class="id">continuous</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">set_surj</span> [<span class="id">set</span>: <span class="id">cantor_space</span>] [<span class="id">set</span>: <span class="id">T</span>] <span class="id">f</span> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">set_inj</span> [<span class="id">set</span>: <span class="id">cantor_space</span>] <span class="id">f</span> ].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof24')">Proof.</span></div>
<div class="proofscript" id="proof24">
<span class="id">have</span> [] := @<span class="id">tree_map_props</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span>=&gt; [<span class="id">topologicalType</span> <span class="id">of</span> <span class="id">bool</span>]) <span class="id">T</span> <span class="id">c_ind</span> <span class="id">c_invar</span> <span class="id">cmptT</span> <span class="id">hsdfT</span>.<br/>
- <span class="kwd">by</span> [].<br/>
- <span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">V</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; [<span class="id">t</span> <span class="id">Vt</span>|<span class="id">t</span> [? ? []]//].<br/>
&nbsp;&nbsp;<span class="id">have</span> [?|?] := <span class="id">pselect</span> (<span class="id">U_</span> <span class="id">n</span> `&amp;` <span class="id">V</span> !=<span class="id">set0</span> /\ ~` <span class="id">U_</span> <span class="id">n</span> `&amp;` <span class="id">V</span> !=<span class="id">set0</span>).<br/>
&nbsp;&nbsp;+ <span class="id">have</span> [<span class="id">Unt</span>|<span class="id">Unt</span>] := <span class="id">pselect</span> (<span class="id">U_</span> <span class="id">n</span> <span class="id">t</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">true</span> =&gt; //; <span class="id">rewrite</span> /<span class="id">c_ind</span>; <span class="id">case</span>: <span class="id">pselect</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">false</span> =&gt; //; <span class="id">rewrite</span> /<span class="id">c_ind</span>; <span class="id">case</span>: <span class="id">pselect</span>.<br/>
&nbsp;&nbsp;+ <span class="id">have</span> [<span class="id">scVt</span>|<span class="id">scVt</span>] := <span class="id">pselect</span> (<span class="id">split_clopen</span> <span class="id">V</span> <span class="id">t</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">true</span> =&gt; //; <span class="id">rewrite</span> /<span class="id">c_ind</span>; <span class="id">case</span>: <span class="id">pselect</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">false</span> =&gt; //; <span class="id">rewrite</span> /<span class="id">c_ind</span>; <span class="id">case</span>: <span class="id">pselect</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">U</span> <span class="id">e</span> [] <span class="id">clU</span> <span class="id">Un0</span>; <span class="id">rewrite</span> /<span class="id">c_ind</span>; <span class="id">case</span>: <span class="id">pselect</span> =&gt; /=.<br/>
&nbsp;&nbsp;+ <span class="id">move</span>=&gt; [<span class="id">UU</span> <span class="id">CUU</span>]; <span class="id">case</span>: <span class="id">e</span> =&gt; //; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: <span class="id">clopenI</span> =&gt; //.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">funS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">clopenC</span> =&gt; //; <span class="id">exact</span>: <span class="id">funS</span>.<br/>
&nbsp;&nbsp;+ <span class="id">move</span>=&gt; <span class="id">_</span>; <span class="id">have</span> [|//|<span class="id">clscU</span> <span class="id">scUU</span> <span class="id">CscUU</span>] := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">split_clopen</span>' <span class="id">U</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>: <span class="id">clU</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case</span>: <span class="id">e</span>; <span class="id">split</span> =&gt; //; <span class="id">first</span> <span class="id">exact</span>: <span class="id">clopenI</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">clopenI</span> =&gt; //; <span class="id">exact</span>: <span class="id">clopenC</span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ? [].<br/>
- <span class="kwd">by</span> <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">clopenT</span> | <span class="kwd">exists</span> <span class="id">point</span>].<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ? [[]].<br/>
- <span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">y</span> /<span class="id">dsctT</span> [<span class="id">A</span> [<span class="id">clA</span> <span class="id">Ax</span> <span class="id">Any</span>]].<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">n</span> <span class="id">_</span> <span class="id">UnA</span>] := @<span class="id">surj</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">U_</span> <span class="id">_</span> <span class="id">clA</span>; <span class="kwd">exists</span> <span class="id">n</span> =&gt; <span class="id">V</span> <span class="id">e</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [|+ <span class="id">_</span>] := <span class="id">pselect</span> (<span class="id">V</span> <span class="id">y</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">subsetC</span> =&gt; ? [].<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">Vx</span> <span class="id">Vy</span>|? <span class="id">_</span> []//] := <span class="id">pselect</span> (<span class="id">V</span> <span class="id">x</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> {1 2}/<span class="id">c_ind</span>; <span class="id">case</span>: <span class="id">pselect</span> =&gt; /=; <span class="id">rewrite</span> ?<span class="id">UnA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">_</span>; <span class="id">case</span>: <span class="id">e</span>; <span class="id">case</span> =&gt; // ? ?; <span class="id">apply</span>/<span class="id">not_andP</span>; <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">absurd</span>; <span class="id">split</span>; [<span class="kwd">exists</span> <span class="id">x</span> | <span class="kwd">exists</span> <span class="id">y</span>].<br/>
- <span class="id">move</span>=&gt; <span class="id">f</span> [<span class="id">ctsf</span> <span class="id">surjf</span> <span class="id">injf</span>]; <span class="kwd">exists</span> <span class="id">f</span>; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: <span class="id">injf</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">U</span> <span class="id">i</span> <span class="id">j</span> <span class="id">_</span> <span class="id">_</span> [<span class="id">z</span>] [] [] + <span class="id">Uz</span> [+ <span class="id">_</span>]; <span class="id">move</span>: <span class="id">i</span> <span class="id">j</span> =&gt; [] [].<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">tree_map</span> := <span class="id">projT1</span> (<span class="id">cid</span> <span class="id">cantor_map</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">tree_map_bij</span> : <span class="id">bijective</span> <span class="id">tree_map</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof25')">Proof.</span></div>
<div class="proofscript" id="proof25">
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">setTT_bijective</span>; <span class="id">have</span> [? ? ?] := <span class="id">projT2</span> (<span class="id">cid</span> <span class="id">cantor_map</span>); <span class="id">split</span>.<br/>
Qed.</div>
<br/>
#[<span class="id">local</span>] <span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> := @<span class="id">BijTT.Build</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">tree_map_bij</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">homeomorphism_cantor_like</span> :<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">f</span> : {<span class="id">splitbij</span> [<span class="id">set</span>: <span class="id">cantor_space</span>] &gt;-&gt; [<span class="id">set</span>: <span class="id">T</span>]},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">continuous</span> <span class="id">f</span> /\ (<span class="kwd">forall</span> <span class="id">A</span>, <span class="id">closed</span> <span class="id">A</span> -&gt; <span class="id">closed</span> (<span class="id">f</span> @` <span class="id">A</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof26')">Proof.</span></div>
<div class="proofscript" id="proof26">
<span class="kwd">exists</span> [<span class="id">the</span> {<span class="id">splitbij</span> <span class="id">_</span> &gt;-&gt; <span class="id">_</span>} <span class="id">of</span> <span class="id">tree_map</span>] =&gt; /=.<br/>
<span class="id">have</span> [<span class="id">cts</span> <span class="id">surj</span> <span class="id">inje</span>] := <span class="id">projT2</span> (<span class="id">cid</span> <span class="id">cantor_map</span>); <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">cts</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">clA</span>; <span class="id">apply</span>: (<span class="id">compact_closed</span> <span class="id">hsdfT</span>).<br/>
<span class="id">apply</span>: (@<span class="id">continuous_compact</span> <span class="id">_</span> <span class="id">_</span> <span class="id">tree_map</span>); <span class="id">first</span> <span class="id">exact</span>: <span class="id">continuous_subspaceT</span>.<br/>
<span class="id">apply</span>: (@<span class="id">subclosed_compact</span> <span class="id">_</span> <span class="id">_</span> [<span class="id">set</span>: <span class="id">cantor_space</span>]) =&gt; //.<br/>
<span class="id">exact</span>: <span class="id">cantor_space_compact</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">TreeStructure</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">FinitelyBranchingTrees</span>.<br/>
<span class="kwd">Context</span> {<span class="id">R</span> : <span class="id">realType</span>}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">pointed_discrete</span> (<span class="id">P</span> : <span class="id">pointedType</span>) : <span class="id">pseudoMetricType</span> <span class="id">R</span> :=<br/>
&nbsp;&nbsp;@<span class="id">discrete_pseudoMetricType</span> <span class="id">R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id">discrete_uniformType</span> (<span class="id">TopologicalType</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">FilteredType</span> <span class="id">P</span> <span class="id">P</span> <span class="id">principal_filter</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">discrete_topological_mixin</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erefl</span>) <span class="id">erefl</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">tree_of</span> (<span class="id">T</span> : <span class="id">nat</span> -&gt; <span class="id">pointedType</span>) : <span class="id">pseudoMetricType</span> <span class="id">R</span> :=<br/>
&nbsp;&nbsp;@<span class="id">product_pseudoMetricType</span> <span class="id">R</span> <span class="id">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">n</span> =&gt; <span class="id">pointed_discrete</span> (<span class="id">T</span> <span class="id">n</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">countableP</span> <span class="id">_</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cantor_like_finite_prod</span> (<span class="id">T</span> : <span class="id">nat</span> -&gt; <span class="id">topologicalType</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">n</span>, <span class="id">finite_set</span> [<span class="id">set</span>: <span class="id">pointed_discrete</span> (<span class="id">T</span> <span class="id">n</span>)]) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">n</span>, (<span class="kwd">exists</span> <span class="id">xy</span> : <span class="id">T</span> <span class="id">n</span> * <span class="id">T</span> <span class="id">n</span>, <span class="id">xy</span>.1 != <span class="id">xy</span>.2)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">cantor_like</span> (<span class="id">tree_of</span> <span class="id">T</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof27')">Proof.</span></div>
<div class="proofscript" id="proof27">
<span class="id">move</span>=&gt; <span class="id">finiteT</span> <span class="id">twoElems</span>; <span class="id">split</span>.<br/>
- <span class="id">exact</span>/(@<span class="id">perfect_diagonal</span> (<span class="id">pointed_discrete</span> \<span class="id">o</span> <span class="id">T</span>))/<span class="id">twoElems</span>.<br/>
- <span class="id">have</span> := <span class="id">tychonoff</span> (<span class="kwd">fun</span> <span class="id">n</span> =&gt; <span class="id">finite_compact</span> (<span class="id">finiteT</span> <span class="id">n</span>)).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">congr</span> (<span class="id">compact</span> <span class="id">_</span>) =&gt; //=; <span class="id">rewrite</span> <span class="id">eqEsubset</span>.<br/>
- <span class="id">apply</span>: (@<span class="id">hausdorff_product</span> <span class="id">_</span> (<span class="id">pointed_discrete</span> \<span class="id">o</span> <span class="id">T</span>)) =&gt; <span class="id">n</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">discrete_hausdorff</span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span> <span class="id">zero_dimension_prod</span> =&gt; ?; <span class="id">exact</span>: <span class="id">discrete_zero_dimension</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">FinitelyBranchingTrees</span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "<span class="id">A</span> ^-1" := ([<span class="id">set</span> <span class="id">xy</span> | <span class="id">A</span> (<span class="id">xy</span>.2, <span class="id">xy</span>.1)]) : <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">alexandroff_hausdorff</span>.<br/>
<span class="kwd">Context</span> {<span class="id">R</span> : <span class="id">realType</span>} {<span class="id">T</span> : <span class="id">pseudoMetricType</span> <span class="id">R</span>}.<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">cptT</span> : <span class="id">compact</span> [<span class="id">set</span>: <span class="id">T</span>].<br/>
<span class="kwd">Hypothesis</span> <span class="id">hsdfT</span> : <span class="id">hausdorff_space</span> <span class="id">T</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">two_pointed</span>.<br/>
<span class="kwd">Context</span> (<span class="id">t0</span> <span class="id">t1</span> : <span class="id">T</span>).<br/>
<span class="kwd">Hypothesis</span> <span class="id">T2e</span> : <span class="id">t0</span> != <span class="id">t1</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">ent_balls</span>' (<span class="id">E</span> : <span class="id">set</span> (<span class="id">T</span> * <span class="id">T</span>)) :<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">M</span> : <span class="id">set</span> (<span class="id">set</span> <span class="id">T</span>), <span class="id">entourage</span> <span class="id">E</span> -&gt; [/\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span> <span class="id">M</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">A</span>, <span class="id">M</span> <span class="id">A</span> -&gt; <span class="kwd">exists</span> <span class="id">a</span>, <span class="id">A</span> <span class="id">a</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span> `&lt;=` <span class="id">closure</span> [<span class="id">set</span> <span class="id">y</span> | <span class="id">split_ent</span> <span class="id">E</span> (<span class="id">a</span>, <span class="id">y</span>)],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">A</span> <span class="id">B</span> : <span class="id">set</span> <span class="id">T</span>, <span class="id">M</span> <span class="id">A</span> /\ <span class="id">M</span> <span class="id">B</span> /\ <span class="id">A</span> != <span class="id">B</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;\<span class="id">bigcup_</span>(<span class="id">A</span> <span class="kwd">in</span> <span class="id">M</span>) <span class="id">A</span> = [<span class="id">set</span>: <span class="id">T</span>] &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">M</span> `&lt;=` <span class="id">closed</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof28')">Proof.</span></div>
<div class="proofscript" id="proof28">
<span class="id">have</span> [<span class="id">entE</span>|?] := <span class="id">pselect</span> (<span class="id">entourage</span> <span class="id">E</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">point</span>.<br/>
<span class="id">move</span>: <span class="id">cptT</span>; <span class="id">rewrite</span> <span class="id">compact_cover</span>.<br/>
<span class="id">pose</span> <span class="id">fs</span> <span class="id">x</span> := <span class="id">interior</span> [<span class="id">set</span> <span class="id">y</span> | <span class="id">split_ent</span> <span class="id">E</span> (<span class="id">x</span>, <span class="id">y</span>)].<br/>
<span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id">T</span> [ <span class="id">set</span>: <span class="id">T</span>] <span class="id">fs</span>)[<span class="id">t</span> <span class="id">_</span>|<span class="id">t</span> <span class="id">_</span> |].<br/>
- <span class="id">exact</span>: <span class="id">open_interior</span>.<br/>
- <span class="kwd">exists</span> <span class="id">t</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">fs</span> /<span class="id">interior</span> -<span class="id">nbhs_entourageE</span>; <span class="kwd">exists</span> (<span class="id">split_ent</span> <span class="id">E</span>).<br/>
<span class="id">move</span>=&gt; <span class="id">M</span>' <span class="id">_</span> <span class="id">Mcov</span>; <span class="kwd">exists</span><br/>
&nbsp;&nbsp;((<span class="id">closure</span> \<span class="id">o</span> <span class="id">fs</span>) @` [<span class="id">set</span>` <span class="id">M</span>'] `|` [<span class="id">set</span> [<span class="id">set</span> <span class="id">t0</span>]; [<span class="id">set</span> <span class="id">t1</span>]]).<br/>
<span class="id">move</span>=&gt; <span class="id">_</span>; <span class="id">split</span>=&gt; [|<span class="id">A</span> [|]| | |].<br/>
- <span class="id">rewrite</span> <span class="id">finite_setU</span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>/<span class="id">finite_image</span>/<span class="id">finite_fset</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">finite_set2</span>.<br/>
- <span class="id">move</span>=&gt; [<span class="id">z</span> <span class="id">M</span>'<span class="id">z</span>] &lt;-; <span class="kwd">exists</span> <span class="id">z</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;+ <span class="id">apply</span>: <span class="id">subset_closure</span>; <span class="id">apply</span>: <span class="id">nbhs_singleton</span>; <span class="id">apply</span>: <span class="id">nbhs_interior</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">nbhs_entourageE</span>; <span class="kwd">exists</span> (<span class="id">split_ent</span> <span class="id">E</span>).<br/>
&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">closure_subset</span>; <span class="id">exact</span>: <span class="id">interior_subset</span>.<br/>
- <span class="kwd">by</span> <span class="id">case</span> =&gt; -&gt;; [<span class="kwd">exists</span> <span class="id">t0</span> | <span class="kwd">exists</span> <span class="id">t1</span>]; <span class="id">split</span> =&gt; // <span class="id">t</span> -&gt;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">subset_closure</span>; <span class="id">exact</span>: <span class="id">entourage_refl</span>.<br/>
- <span class="kwd">exists</span> [<span class="id">set</span> <span class="id">t0</span>], [<span class="id">set</span> <span class="id">t1</span>]; <span class="id">split</span>;[|<span class="id">split</span>].<br/>
&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">right</span>; <span class="id">left</span>.<br/>
&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">right</span>; <span class="id">right</span>.<br/>
&nbsp;&nbsp;+ <span class="id">apply</span>/<span class="id">eqP</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span> =&gt; -[] /(<span class="id">_</span> <span class="id">t0</span> <span class="id">erefl</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>: <span class="id">T2e</span> =&gt; /[<span class="id">swap</span>] -&gt; /<span class="id">eqP</span>.<br/>
- <span class="id">rewrite</span> -<span class="id">subTset</span> =&gt; <span class="id">t</span> /<span class="id">Mcov</span> [<span class="id">t</span>' <span class="id">M</span>'<span class="id">t</span>' <span class="id">fsxt</span>]; <span class="kwd">exists</span> (<span class="id">closure</span> (<span class="id">fs</span> <span class="id">t</span>')).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">left</span>; <span class="kwd">exists</span> <span class="id">t</span>'.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">subset_closure</span>.<br/>
- <span class="id">move</span>=&gt; ? [[? ?] &lt;-|]; <span class="id">first</span> <span class="id">exact</span>: <span class="id">closed_closure</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [|] -&gt;; <span class="id">exact</span>/<span class="id">accessible_closed_set1</span>/<span class="id">hausdorff_accessible</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">ent_balls</span> <span class="id">E</span> := <span class="id">projT1</span> (<span class="id">cid</span> (<span class="id">ent_balls</span>' <span class="id">E</span>)).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">count_unif</span>' := <span class="id">cid2</span><br/>
&nbsp;&nbsp;((<span class="id">iffLR</span> <span class="id">countable_uniformityP</span>) (@<span class="id">countable_uniformity_metric</span> <span class="id">_</span> <span class="id">T</span>)).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">count_unif</span> := <span class="id">projT1</span> <span class="id">count_unif</span>'.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">ent_count_unif</span> <span class="id">n</span> : <span class="id">entourage</span> (<span class="id">count_unif</span> <span class="id">n</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof29')">Proof.</span></div>
<div class="proofscript" id="proof29">
<span class="id">have</span> := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">ent_balls</span>' (<span class="id">count_unif</span> <span class="id">n</span>))).<br/>
<span class="id">rewrite</span> /<span class="id">count_unif</span>; <span class="id">case</span>: <span class="id">count_unif</span>'.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; /= <span class="id">f</span> <span class="id">fnA</span> <span class="id">fnE</span>; <span class="id">case</span> /(<span class="id">_</span> (<span class="id">fnE</span> <span class="id">_</span>)) =&gt; <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> + <span class="id">_</span>; <span class="id">rewrite</span> -<span class="id">subTset</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">count_unif_sub</span> <span class="id">E</span> : <span class="id">entourage</span> <span class="id">E</span> -&gt; <span class="kwd">exists</span> <span class="id">N</span>, <span class="id">count_unif</span> <span class="id">N</span> `&lt;=` <span class="id">E</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof30')">Proof.</span></div>
<div class="proofscript" id="proof30">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">entE</span>; <span class="id">rewrite</span> /<span class="id">count_unif</span>; <span class="id">case</span>: <span class="id">count_unif</span>' =&gt; <span class="id">f</span> + ? /=; <span class="id">exact</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">K</span>' <span class="id">n</span> : <span class="kwd">Type</span> := @<span class="id">sigT</span> (<span class="id">set</span> <span class="id">T</span>) (<span class="id">ent_balls</span> (<span class="id">count_unif</span> <span class="id">n</span>)).<br/>
<br/>
<span class="kwd">Let</span> <span class="id">K</span>'<span class="id">p</span> <span class="id">n</span> : <span class="id">K</span>' <span class="id">n</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof31')">Proof.</span></div>
<div class="proofscript" id="proof31">
<span class="id">apply</span>: <span class="id">cid</span>; <span class="id">have</span> [//| <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> + <span class="id">_</span>] := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">ent_balls</span>' (<span class="id">count_unif</span> <span class="id">n</span>))).<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">subTset</span> =&gt; /(<span class="id">_</span> <span class="id">point</span> <span class="id">I</span>) [<span class="id">W</span> <span class="id">Q</span> ?]; <span class="kwd">exists</span> <span class="id">W</span>; <span class="id">exact</span>: <span class="id">Q</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">K</span> <span class="id">n</span> := <span class="id">PointedType</span> (<span class="id">classicType_choiceType</span> (<span class="id">K</span>' <span class="id">n</span>)) (<span class="id">K</span>'<span class="id">p</span> <span class="id">n</span>).<br/>
<span class="kwd">Let</span> <span class="id">Tree</span> := @<span class="id">tree_of</span> <span class="id">R</span> <span class="id">K</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">embed_refine</span> <span class="id">n</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) (<span class="id">k</span> : <span class="id">K</span> <span class="id">n</span>) :=<br/>
&nbsp;&nbsp;(<span class="kwd">if</span> <span class="id">pselect</span> (<span class="id">projT1</span> <span class="id">k</span> `&amp;` <span class="id">U</span> !=<span class="id">set0</span>)<br/>
&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">projT1</span> <span class="id">k</span><br/>
&nbsp;&nbsp;<span class="kwd">else</span> <span class="kwd">if</span> <span class="id">pselect</span> (<span class="kwd">exists</span> <span class="id">e</span> : <span class="id">K</span> <span class="id">n</span> , <span class="id">projT1</span> <span class="id">e</span> `&amp;` <span class="id">U</span> !=<span class="id">set0</span>) <span class="id">is</span> <span class="id">left</span> <span class="id">e</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">projT1</span> (<span class="id">projT1</span> (<span class="id">cid</span> <span class="id">e</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">set0</span>) `&amp;` <span class="id">U</span>.<br/>
<span class="kwd">Let</span> <span class="id">embed_invar</span> (<span class="id">U</span> : <span class="id">set</span> <span class="id">T</span>) := <span class="id">closed</span> <span class="id">U</span> /\ <span class="id">U</span> !=<span class="id">set0</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">Kn_closed</span> <span class="id">n</span> (<span class="id">e</span> : <span class="id">K</span> <span class="id">n</span>) : <span class="id">closed</span> (<span class="id">projT1</span> <span class="id">e</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof32')">Proof.</span></div>
<div class="proofscript" id="proof32">
<span class="id">case</span>: <span class="id">e</span> =&gt; <span class="id">W</span>; <span class="id">have</span> [//| <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>] := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">ent_balls</span>' (<span class="id">count_unif</span> <span class="id">n</span>))).<br/>
<span class="id">exact</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">cantor_surj_pt1</span> : <span class="kwd">exists2</span> <span class="id">f</span> : <span class="id">Tree</span> -&gt; <span class="id">T</span>,<br/>
&nbsp;&nbsp;<span class="id">continuous</span> <span class="id">f</span> &amp; <span class="id">set_surj</span> [<span class="id">set</span>: <span class="id">Tree</span>] [<span class="id">set</span>: <span class="id">T</span>] <span class="id">f</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof33')">Proof.</span></div>
<div class="proofscript" id="proof33">
<span class="id">pose</span> <span class="id">entn</span> <span class="id">n</span> := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">ent_balls</span>' (<span class="id">count_unif</span> <span class="id">n</span>))).<br/>
<span class="id">have</span> [//| | |? []//| |? []// | |] := @<span class="id">tree_map_props</span> (@<span class="id">pointed_discrete</span> <span class="id">R</span> \<span class="id">o</span> <span class="id">K</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">T</span> (<span class="id">embed_refine</span>) (<span class="id">embed_invar</span>) <span class="id">cptT</span> <span class="id">hsdfT</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">U</span>; <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span>=&gt; [<span class="id">t</span> <span class="id">Ut</span>|<span class="id">t</span> [? ? []]//].<br/>
&nbsp;&nbsp;<span class="id">have</span> [//|<span class="id">_</span> <span class="id">_</span> <span class="id">_</span> + <span class="id">_</span>] := <span class="id">entn</span> <span class="id">n</span>; <span class="id">rewrite</span> -<span class="id">subTset</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id">t</span> <span class="id">I</span>)[<span class="id">W</span> <span class="id">cbW</span> <span class="id">Wt</span>]; <span class="kwd">exists</span> (<span class="id">existT</span> <span class="id">_</span> <span class="id">W</span> <span class="id">cbW</span>) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">embed_refine</span>; <span class="id">case</span>: <span class="id">pselect</span> =&gt; //=; <span class="id">apply</span>: <span class="id">absurd</span>; <span class="kwd">exists</span> <span class="id">t</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">U</span> <span class="id">e</span> [<span class="id">clU</span> <span class="id">Un0</span>]; <span class="id">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span>: <span class="id">closedI</span> =&gt; //; <span class="id">case</span>: <span class="id">pselect</span> =&gt; //= ?.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>: <span class="id">pselect</span> =&gt; ?; [<span class="id">exact</span>: <span class="id">Kn_closed</span>|<span class="id">exact</span>: <span class="id">closed0</span>].<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">embed_refine</span>; <span class="id">case</span>: <span class="id">pselect</span> =&gt; //= ?; <span class="id">case</span>: <span class="id">pselect</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">i</span> [<span class="id">z</span> [<span class="id">pz</span> <span class="id">bz</span>]]; <span class="id">set</span> <span class="id">P</span> := <span class="id">cid</span> <span class="id">_</span>; <span class="id">have</span> := <span class="id">projT2</span> <span class="id">P</span>; <span class="id">apply</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>: <span class="id">Un0</span> =&gt; <span class="id">z</span> <span class="id">Uz</span>; <span class="id">apply</span>: <span class="id">absurd</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [//|<span class="id">_</span> <span class="id">_</span> <span class="id">_</span> + <span class="id">_</span>] := <span class="id">entn</span> <span class="id">n</span>; <span class="id">rewrite</span> -<span class="id">subTset</span>; <span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id">z</span> <span class="id">I</span>)[<span class="id">i</span> <span class="id">bi</span> <span class="id">iz</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id">existT</span> <span class="id">_</span> <span class="id">_</span> <span class="id">bi</span>), <span class="id">z</span>.<br/>
- <span class="kwd">by</span> <span class="id">split</span>; [<span class="id">exact</span>: <span class="id">closedT</span> | <span class="kwd">exists</span> <span class="id">point</span>].<br/>
- <span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">y</span> <span class="id">xny</span>; <span class="id">move</span>: <span class="id">hsdfT</span>; <span class="id">rewrite</span> <span class="id">open_hausdorff</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">xny</span>)[[<span class="id">U</span> <span class="id">V</span>]] /= [/<span class="id">set_mem</span> <span class="id">Ux</span> /<span class="id">set_mem</span> <span class="id">Vy</span>] [+ <span class="id">oV</span> <span class="id">UVI0</span>].<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">openE</span> =&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">Ux</span>); <span class="id">rewrite</span> /<span class="id">interior</span> -<span class="id">nbhs_entourageE</span> =&gt; -[<span class="id">E</span> <span class="id">entE</span> <span class="id">ExU</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> [//| <span class="id">n</span> <span class="id">ctE</span>] :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@<span class="id">count_unif_sub</span> (<span class="id">split_ent</span> <span class="id">E</span> `&amp;` (<span class="id">split_ent</span> <span class="id">E</span>)^-1%<span class="id">classic</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>: <span class="id">filterI</span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">n</span> =&gt; <span class="id">B</span> [<span class="id">C</span> <span class="id">ebC</span>]; <span class="id">have</span> [//|<span class="id">_</span> <span class="id">Csub</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">embx</span> <span class="id">emby</span>] := <span class="id">entn</span> <span class="id">n</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [[<span class="id">D</span> <span class="id">cbD</span>] /= <span class="id">Dx</span> <span class="id">Dy</span>] : <span class="kwd">exists2</span> <span class="id">e</span> : <span class="id">K</span> <span class="id">n</span>, <span class="id">projT1</span> <span class="id">e</span> <span class="id">x</span> &amp; <span class="id">projT1</span> <span class="id">e</span> <span class="id">y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>: <span class="id">embx</span> <span class="id">emby</span>; <span class="id">rewrite</span> /<span class="id">embed_refine</span>; <span class="id">case</span>: <span class="id">pselect</span> =&gt; /=.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? [? ?] [? ?]; <span class="kwd">exists</span> (<span class="id">existT</span> <span class="id">_</span> <span class="id">_</span> <span class="id">ebC</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case</span>: <span class="id">pselect</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span> =&gt; ? ? [].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">e</span> <span class="id">_</span> [? ?] [? ?]; <span class="kwd">exists</span> (<span class="id">projT1</span> (<span class="id">cid</span> <span class="id">e</span>)).<br/>
&nbsp;&nbsp;<span class="id">suff</span> : <span class="id">E</span> (<span class="id">x</span>, <span class="id">y</span>) <span class="kwd">by</span> <span class="id">move</span>/<span class="id">ExU</span>; <span class="id">move</span>/<span class="id">eqP</span>/<span class="id">disjoints_subset</span>: <span class="id">UVI0</span> =&gt; /[<span class="id">apply</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">z</span> [<span class="id">Dz</span> <span class="id">DzE</span>]] := <span class="id">Csub</span> <span class="id">_</span> <span class="id">cbD</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> /<span class="id">ent_closure</span>:= <span class="id">DzE</span> <span class="id">_</span> <span class="id">Dx</span> =&gt; /(<span class="id">_</span> (<span class="id">ent_count_unif</span> <span class="id">n</span>))/<span class="id">ctE</span> [<span class="id">_</span> /= <span class="id">Exz</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> /<span class="id">ent_closure</span>:= <span class="id">DzE</span> <span class="id">_</span> <span class="id">Dy</span> =&gt; /(<span class="id">_</span> (<span class="id">ent_count_unif</span> <span class="id">n</span>))/<span class="id">ctE</span> [<span class="id">Ezy</span> <span class="id">_</span>].<br/>
&nbsp;&nbsp;<span class="id">exact</span>: (@<span class="id">entourage_split</span> [<span class="id">uniformType</span> <span class="id">of</span> <span class="id">T</span>] <span class="id">z</span>).<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">f</span> [<span class="id">ctsf</span> <span class="id">surjf</span> <span class="id">_</span>]; <span class="kwd">exists</span> <span class="id">f</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">cantor_surj_pt2</span> :<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">f</span> : {<span class="id">surj</span> [<span class="id">set</span>: <span class="id">cantor_space</span>] &gt;-&gt; [<span class="id">set</span>: <span class="id">Tree</span>]}, <span class="id">continuous</span> <span class="id">f</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof34')">Proof.</span></div>
<div class="proofscript" id="proof34">
<span class="id">have</span> [|<span class="id">f</span> [<span class="id">ctsf</span> <span class="id">_</span>]] := @<span class="id">homeomorphism_cantor_like</span> <span class="id">R</span> <span class="id">Tree</span>; <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">f</span>.<br/>
<span class="id">apply</span>: (@<span class="id">cantor_like_finite_prod</span> <span class="id">_</span> (@<span class="id">pointed_discrete</span> <span class="id">R</span> \<span class="id">o</span> <span class="id">K</span>)) =&gt; [<span class="id">n</span> /=|<span class="id">n</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> [//| <span class="id">fs</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>] := <span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">ent_balls</span>' (<span class="id">count_unif</span> <span class="id">n</span>))).<br/>
&nbsp;&nbsp;<span class="id">suff</span> -&gt; : [<span class="id">set</span>: {<span class="id">classic</span> <span class="id">K</span>' <span class="id">n</span>}] =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id">projT1</span> (<span class="id">set</span> <span class="id">T</span>) <span class="id">_</span>) @^-1` (<span class="id">projT1</span> (<span class="id">cid</span> (<span class="id">ent_balls</span>' (<span class="id">count_unif</span> <span class="id">n</span>)))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">finite_preimage</span> =&gt; // ? ? <span class="id">_</span> <span class="id">_</span>; <span class="id">exact</span>: <span class="id">eq_sigT_hprop</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">eqEsubset</span>; <span class="id">split</span> =&gt; // -[].<br/>
<span class="id">have</span> [//| <span class="id">_</span> <span class="id">_</span> [<span class="id">A</span> [<span class="id">B</span> [<span class="id">pA</span> [<span class="id">pB</span> <span class="id">AB</span>]]]] <span class="id">_</span> <span class="id">_</span>] :=<br/>
&nbsp;&nbsp;<span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">ent_balls</span>' (<span class="id">count_unif</span> <span class="id">n</span>))).<br/>
<span class="kwd">exists</span> (<span class="id">existT</span> <span class="id">_</span> <span class="id">_</span> <span class="id">pA</span>, <span class="id">existT</span> <span class="id">_</span> <span class="id">_</span> <span class="id">pB</span>) =&gt; /=.<br/>
<span class="kwd">by</span> <span class="id">move</span>: <span class="id">AB</span>; <span class="id">apply</span>: <span class="id">contra_neq</span> =&gt; -[].<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id">cantor_surj_twop</span> :<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">f</span> : {<span class="id">surj</span> [<span class="id">set</span>: <span class="id">cantor_space</span>] &gt;-&gt; [<span class="id">set</span>: <span class="id">T</span>]}, <span class="id">continuous</span> <span class="id">f</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof35')">Proof.</span></div>
<div class="proofscript" id="proof35">
<span class="id">move</span>: <span class="id">cantor_surj_pt2</span> <span class="id">cantor_surj_pt1</span> =&gt; -[<span class="id">f</span> <span class="id">ctsf</span>] [<span class="id">g</span> <span class="id">ctsg</span> /<span class="id">Psurj</span>[<span class="id">sjg</span> <span class="id">gsjg</span>]].<br/>
<span class="kwd">exists</span> [<span class="id">surj</span> <span class="id">of</span> <span class="id">sjg</span> \<span class="id">o</span> <span class="id">f</span>] =&gt; <span class="id">z</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span> <span class="id">continuous_comp</span>; [<span class="id">exact</span>: <span class="id">ctsf</span>|<span class="id">rewrite</span> -<span class="id">gsjg</span>; <span class="id">exact</span>: <span class="id">ctsg</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">two_pointed</span>.<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">cantor_surj</span> :<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">f</span> : {<span class="id">surj</span> [<span class="id">set</span>: <span class="id">cantor_space</span>] &gt;-&gt; [<span class="id">set</span>: <span class="id">T</span>]}, <span class="id">continuous</span> <span class="id">f</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof36')">Proof.</span></div>
<div class="proofscript" id="proof36">
<span class="id">have</span> [[<span class="id">p</span> <span class="id">ppt</span>]|/<span class="id">forallNP</span> <span class="id">xpt</span>] := <span class="id">pselect</span> (<span class="kwd">exists</span> <span class="id">p</span> : <span class="id">T</span>, <span class="id">p</span> != <span class="id">point</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id">cantor_surj_twop</span>; <span class="id">exact</span>: <span class="id">ppt</span>.<br/>
<span class="id">have</span> /<span class="id">Psurj</span>[<span class="id">f</span> <span class="id">cstf</span>] : <span class="id">set_surj</span> [<span class="id">set</span>: <span class="id">cantor_space</span>] [<span class="id">set</span>: <span class="id">T</span>] (<span class="id">cst</span> <span class="id">point</span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">q</span> <span class="id">_</span>; <span class="kwd">exists</span> <span class="id">point</span> =&gt; //; <span class="id">have</span> /<span class="id">negP</span>/<span class="id">negPn</span>/<span class="id">eqP</span> -&gt; := <span class="id">xpt</span> <span class="id">q</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">f</span>; <span class="id">rewrite</span> -<span class="id">cstf</span>; <span class="id">exact</span>: <span class="id">cst_continuous</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">alexandroff_hausdorff</span>.<br/>

</div>
<div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/tree/yoshihiro503%40generate_index">a fork of coq2html</a></div>
</body>
</html>
