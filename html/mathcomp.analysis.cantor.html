
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.analysis.cantor</title>
<meta name="description" content="Documentation of Coq module mathcomp.analysis.cantor" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>

<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init('proofscript')">
<h1 class="title">Module mathcomp.analysis.cantor</h1>
<div class="coq">
<span class="kwd">From</span> <span class="id">mathcomp</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">all_ssreflect</span> <span class="id">ssralg</span> <span class="id">ssrint</span> <span class="id">ssrnum</span> <span class="id">interval</span> <span class="id">rat</span>.<br/>
<span class="kwd">From</span> <span class="id">mathcomp</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">finmap</span>.<br/>
<span class="kwd">From</span> <span class="id">mathcomp</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id"><a href="mathcomp.classical.mathcomp_extra.html">mathcomp_extra</a></span> <span class="id"><a href="mathcomp.classical.boolp.html">boolp</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html">classical_sets</a></span> <span class="id"><a href="mathcomp.classical.functions.html">functions</a></span>.<br/>
<span class="kwd">From</span> <span class="id">mathcomp</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id"><a href="mathcomp.classical.cardinality.html">cardinality</a></span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id"><a href="mathcomp.analysis.reals.html">reals</a></span> <span class="id"><a href="mathcomp.analysis.signed.html">signed</a></span> <span class="id"><a href="mathcomp.analysis.topology.html">topology</a></span>.<br/>
<span class="kwd">From</span> <span class="id">HB</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">structures</span>.<br/>
<br/>
<pre class="ssrdoc">
                     The Cantor Space and Applications                     
                                                                           
This file develops the theory of the Cantor space, that is bool^nat with   
the product topology. The two main theorems proved here are                
homeomorphism_cantor_like, and cantor_surj, a.k.a. Alexandroff-Hausdorff.  
                                                                           
         cantor_space == the Cantor space, with its canonical metric       
        cantor_like T == perfect + compact + hausdroff + zero dimensional  
   pointed_discrete T == equips T with the discrete topology               
            tree_of T == builds a topological tree with levels (T n)       
                                                                           
</pre>
<br/>
<span class="kwd">Set</span> <span class="kwd">Implicit</span> <span class="kwd">Arguments</span>.<br/>
<span class="id">Unset</span> <span class="id">Strict</span> <span class="kwd">Implicit</span>.<br/>
<span class="id">Unset</span> <span class="id">Printing</span> <span class="kwd">Implicit</span> <span class="id">Defensive</span>.<br/>
<br/>
<span class="kwd">Import</span> <span class="id">Order.TTheory</span> <span class="id">GRing.Theory</span> <span class="id">Num.Def</span> <span class="id">Num.Theory</span>.<br/>
<span class="kwd">Import</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.Exports">numFieldTopology.Exports</a></span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="cantor_space">cantor_space</a></span> :=<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#product_uniformType">product_uniformType</a></span> (<span class="kwd">fun</span> <span class="id">_</span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span> =&gt; @<span class="id"><a href="mathcomp.analysis.topology.html#discrete_uniformType">discrete_uniformType</a></span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.topology.html#discrete_bool">discrete_bool</a></span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="cantor_like">cantor_like</a></span> (<span class="id"><a name="T:1">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological.Exports.topologicalType">topologicalType</a></span>) :=<br/>
&nbsp;&nbsp;[/\ <span class="id"><a href="mathcomp.analysis.topology.html#perfect_set">perfect_set</a></span> [<span class="id">set</span>: <span class="id">T</span>],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#compact">compact</a></span> [<span class="id">set</span>: <span class="id">T</span>],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#hausdorff_space">hausdorff_space</a></span> <span class="id">T</span> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#zero_dimensional">zero_dimensional</a></span> <span class="id">T</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cantor_space_compact">cantor_space_compact</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#compact">compact</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_space">cantor_space</a></span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof1')">Proof.</span></div>
<div class="proofscript" id="proof1">
<span class="id">have</span> := @<span class="id"><a href="mathcomp.analysis.topology.html#tychonoff">tychonoff</a></span> <span class="id">_</span> (<span class="kwd">fun</span> <span class="id">_</span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span> =&gt; <span class="id">_</span>) <span class="id">_</span> (<span class="kwd">fun</span>=&gt; <span class="id"><a href="mathcomp.analysis.topology.html#bool_compact">bool_compact</a></span>).<br/>
<span class="kwd">by</span> <span class="id">congr</span> (<span class="id"><a href="mathcomp.analysis.topology.html#compact">compact</a></span> <span class="id">_</span>); <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cantor_space_hausdorff">cantor_space_hausdorff</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#hausdorff_space">hausdorff_space</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_space">cantor_space</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof2')">Proof.</span></div>
<div class="proofscript" id="proof2">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#hausdorff_product">hausdorff_product</a></span> =&gt; ?; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#discrete_hausdorff">discrete_hausdorff</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cantor_zero_dimensional">cantor_zero_dimensional</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#zero_dimensional">zero_dimensional</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_space">cantor_space</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof3')">Proof.</span></div>
<div class="proofscript" id="proof3">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#zero_dimension_prod">zero_dimension_prod</a></span> =&gt; <span class="id">_</span>; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#discrete_zero_dimension">discrete_zero_dimension</a></span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cantor_perfect">cantor_perfect</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#perfect_set">perfect_set</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_space">cantor_space</a></span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof4')">Proof.</span></div>
<div class="proofscript" id="proof4">
 <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#perfect_diagonal">perfect_diagonal</a></span> =&gt; <span class="id">_</span>; <span class="kwd">exists</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#true">true</a></span>, <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#false">false</a></span>). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cantor_like_cantor_space">cantor_like_cantor_space</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_like">cantor_like</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_space">cantor_space</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof5')">Proof.</span></div>
<div class="proofscript" id="proof5">
<span class="id">split</span>.<br/>
- <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_perfect">cantor_perfect</a></span>.<br/>
- <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_space_compact">cantor_space_compact</a></span>.<br/>
- <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_space_hausdorff">cantor_space_hausdorff</a></span>.<br/>
- <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_zero_dimensional">cantor_zero_dimensional</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="topological_trees">topological_trees</a></span>.<br/>
<span class="kwd">Context</span> {<span class="id"><a name="K:2">K</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Topological.Exports.topologicalType">topologicalType</a></span>} {<span class="id"><a name="X:3">X</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#Topological.Exports.topologicalType">topologicalType</a></span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a name="refine_apx:5">refine_apx</a></span> : <span class="kwd">forall</span> <span class="id"><a name="n:4">n</a></span>, <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">X</span> -&gt; <span class="id">K</span> <span class="id">n</span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">X</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a name="tree_invariant:6">tree_invariant</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">X</span> -&gt; <span class="kwd">Prop</span>).<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id"><a name="topological_trees.cmptX">cmptX</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#compact">compact</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.X">X</a></span>].<br/>
<span class="kwd">Hypothesis</span> <span class="id"><a name="topological_trees.hsdfX">hsdfX</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#hausdorff_space">hausdorff_space</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.X">X</a></span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id"><a name="topological_trees.discreteK">discreteK</a></span> : <span class="kwd">forall</span> <span class="id"><a name="n:9">n</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#discrete_space">discrete_space</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.K">K</a></span> <span class="id">n</span>).<br/>
<span class="kwd">Hypothesis</span> <span class="id"><a name="topological_trees.refine_cover">refine_cover</a></span> : <span class="kwd">forall</span> <span class="id"><a name="n:11">n</a></span> <span class="id"><a name="U:12">U</a></span>, <span class="id">U</span> = \<span class="id">bigcup_e</span> @<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.refine_apx">refine_apx</a></span> <span class="id">n</span> <span class="id">U</span> <span class="id">e</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id"><a name="topological_trees.refine_invar">refine_invar</a></span> : <span class="kwd">forall</span> <span class="id"><a name="n:15">n</a></span> <span class="id"><a name="U:16">U</a></span> <span class="id"><a name="e:17">e</a></span>,<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_invariant">tree_invariant</a></span> <span class="id">U</span> -&gt; <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_invariant">tree_invariant</a></span> (@<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.refine_apx">refine_apx</a></span> <span class="id">n</span> <span class="id">U</span> <span class="id">e</span>).<br/>
<span class="kwd">Hypothesis</span> <span class="id"><a name="topological_trees.invar_n0">invar_n0</a></span> : <span class="kwd">forall</span> <span class="id"><a name="U:19">U</a></span>, <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_invariant">tree_invariant</a></span> <span class="id">U</span> -&gt; <span class="id">U</span> !=<span class="id">set0</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id"><a name="topological_trees.invarT">invarT</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_invariant">tree_invariant</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.X">X</a></span>].<br/>
<span class="kwd">Hypothesis</span> <span class="id"><a name="topological_trees.invar_cl">invar_cl</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_invariant">tree_invariant</a></span> `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#closed">closed</a></span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id"><a name="topological_trees.refine_separates">refine_separates</a></span>: <span class="kwd">forall</span> <span class="id"><a name="x:23">x</a></span> <span class="id"><a name="y:24">y</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.X">X</a></span>, <span class="id">x</span> != <span class="id">y</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id"><a name="n:25">n</a></span>, <span class="kwd">forall</span> (<span class="id"><a name="U:26">U</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.X">X</a></span>) <span class="id"><a name="e:27">e</a></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.refine_apx">refine_apx</a></span> <span class="id">n</span> <span class="id">U</span> <span class="id">e</span> <span class="id">x</span> -&gt; ~@<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.refine_apx">refine_apx</a></span> <span class="id">n</span> <span class="id">U</span> <span class="id">e</span> <span class="id">y</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="topological_trees.refine_subset">refine_subset</a></span> <span class="id"><a name="n:29">n</a></span> <span class="id"><a name="U:30">U</a></span> <span class="id"><a name="e:31">e</a></span> : @<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.refine_apx">refine_apx</a></span> <span class="id">n</span> <span class="id">U</span> <span class="id">e</span> `&lt;=` <span class="id">U</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof6')">Proof.</span></div>
<div class="proofscript" id="proof6">
 <span class="kwd">by</span> <span class="id">rewrite</span> [<span class="id">X</span> <span class="kwd">in</span> <span class="id">_</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.X">X</a></span>](<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.refine_cover">refine_cover</a></span> <span class="id">n</span>); <span class="id">exact</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#bigcup_sup">bigcup_sup</a></span>. Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="topological_trees.T">T</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#product_topologicalType">product_topologicalType</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.K">K</a></span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Fixpoint</span> <span class="id"><a name="branch_apx">branch_apx</a></span> (<span class="id"><a name="b:33">b</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.T">T</a></span>) <span class="id"><a name="n:34">n</a></span> :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">n</span> <span class="id">is</span> <span class="id">m</span>.+1 <span class="kwd">then</span> <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.refine_apx">refine_apx</a></span> (<span class="id">branch_apx</span> <span class="id">b</span> <span class="id">m</span>) (<span class="id">b</span> <span class="id">m</span>) <span class="kwd">else</span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.X">X</a></span>].<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="topological_trees.tree_mapF">tree_mapF</a></span> <span class="id"><a name="b:37">b</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#filter_from">filter_from</a></span> [<span class="id">set</span>: <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span>] (<span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">b</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="topological_trees.tree_map_invar">tree_map_invar</a></span> <span class="id"><a name="b:38">b</a></span> <span class="id"><a name="n:39">n</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_invariant">tree_invariant</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">b</span> <span class="id">n</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof7')">Proof.</span></div>
<div class="proofscript" id="proof7">
 <span class="kwd">by</span> <span class="id">elim</span>: <span class="id">n</span> =&gt; // <span class="id">n</span> ?; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.refine_invar">refine_invar</a></span>. Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="topological_trees.tree_map_sub">tree_map_sub</a></span> <span class="id"><a name="b:40">b</a></span> <span class="id"><a name="i:41">i</a></span> <span class="id"><a name="j:42">j</a></span> : (<span class="id">i</span> &lt;= <span class="id">j</span>)%<span class="id">N</span> -&gt; <span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">b</span> <span class="id">j</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">b</span> <span class="id">i</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof8')">Proof.</span></div>
<div class="proofscript" id="proof8">
<span class="id">elim</span>: <span class="id">j</span> <span class="id">i</span> =&gt; [?|<span class="id">j</span> <span class="id">IH</span> <span class="id">i</span>]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">leqn0</span> =&gt; /<span class="id">eqP</span> -&gt;.<br/>
<span class="id">rewrite</span> <span class="id">leq_eqVlt</span> =&gt; /<span class="id">predU1P</span>[-&gt;//|/<span class="id">IH</span>].<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#subset_trans">subset_trans</a></span>; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.refine_subset">refine_subset</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Instance</span> <span class="id"><a name="tree_map_filter">tree_map_filter</a></span> <span class="id"><a name="b:43">b</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#ProperFilter">ProperFilter</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_mapF">tree_mapF</a></span> <span class="id">b</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof9')">Proof.</span></div>
<div class="proofscript" id="proof9">
<span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">case</span> =&gt; <span class="id">n</span> <span class="id">_</span> <span class="id">P</span>; <span class="id">case</span>: (<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.invar_n0">invar_n0</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_map_invar">tree_map_invar</a></span> <span class="id">b</span> <span class="id">n</span>)) =&gt; <span class="id">x</span> /<span class="id">P</span>.<br/>
<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_from_filter">filter_from_filter</a></span>; <span class="id">first</span> <span class="kwd">by</span> <span class="kwd">exists</span> 0%<span class="id">N</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">j</span> <span class="id">_</span> <span class="id">_</span>; <span class="kwd">exists</span> (<span class="id">maxn</span> <span class="id">i</span> <span class="id">j</span>)  =&gt; //; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#subsetI">subsetI</a></span>.<br/>
<span class="kwd">by</span> <span class="id">split</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_map_sub">tree_map_sub</a></span>; [<span class="id">exact</span>: <span class="id">leq_maxl</span> | <span class="id">exact</span>: <span class="id">leq_maxr</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="topological_trees.tree_map">tree_map</a></span> <span class="id"><a name="b:44">b</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#lim">lim</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_mapF">tree_mapF</a></span> <span class="id">b</span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="topological_trees.cvg_tree_map">cvg_tree_map</a></span> <span class="id"><a name="b:45">b</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#cvg">cvg</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_mapF">tree_mapF</a></span> <span class="id">b</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof10')">Proof.</span></div>
<div class="proofscript" id="proof10">
<span class="id">have</span> [|<span class="id">x</span> [<span class="id">_</span> <span class="id">clx</span>]] := <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.cmptX">cmptX</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#tree_map_filter">tree_map_filter</a></span> <span class="id">b</span>); <span class="id">first</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
<span class="id">apply</span>/<span class="id"><a href="mathcomp.analysis.topology.html#cvg_ex">cvg_ex</a></span>; <span class="kwd">exists</span> <span class="id">x</span> =&gt; /=; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#compact_cluster_set1">compact_cluster_set1</a></span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.cmptX">cmptX</a></span>) =&gt; //.<br/>
- <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
- <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterT">filterT</a></span>.<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>; <span class="id">split</span>=&gt; [<span class="id">y</span> <span class="id">cly</span>|? -&gt; //].<br/>
<span class="id">have</span> [-&gt;//|/<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.refine_separates">refine_separates</a></span>[<span class="id">n</span> <span class="id">sep</span>]] := <span class="id">eqVneq</span> <span class="id">x</span> <span class="id">y</span>.<br/>
<span class="id">have</span> <span class="id">bry</span> : <span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">b</span> <span class="id">n</span>.+1 <span class="id">y</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> /<span class="id"><a href="mathcomp.analysis.topology.html#closure_id">closure_id</a></span> -&gt; := <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.invar_cl">invar_cl</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_map_invar">tree_map_invar</a></span> <span class="id">b</span> <span class="id">n</span>.+1).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>: <span class="id">cly</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#clusterE">clusterE</a></span>; <span class="id">apply</span>; <span class="kwd">exists</span> <span class="id">n</span>.+1.<br/>
<span class="id">suff</span> /<span class="id">sep</span> : <span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">b</span> <span class="id">n</span>.+1 <span class="id">x</span> <span class="kwd">by</span> [].<br/>
<span class="id">have</span> /<span class="id"><a href="mathcomp.analysis.topology.html#closure_id">closure_id</a></span> -&gt; := <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.invar_cl">invar_cl</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_map_invar">tree_map_invar</a></span> <span class="id">b</span> <span class="id">n</span>.+1).<br/>
<span class="kwd">by</span> <span class="id">move</span>: <span class="id">clx</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#clusterE">clusterE</a></span>; <span class="id">apply</span>; <span class="kwd">exists</span> <span class="id">n</span>.+1.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id"><a name="tree_map_surj">tree_map_surj</a></span> : <span class="id"><a href="mathcomp.classical.functions.html#set_surj">set_surj</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.T">T</a></span>] [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.X">X</a></span>] <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_map">tree_map</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof11')">Proof.</span></div>
<div class="proofscript" id="proof11">
<span class="id">move</span>=&gt; <span class="id">z</span> <span class="id">_</span>; <span class="id">suff</span> : <span class="kwd">exists</span> <span class="id"><a name="g:46">g</a></span>, <span class="kwd">forall</span> <span class="id"><a name="n:47">n</a></span>, <span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">g</span> <span class="id">n</span> <span class="id">z</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>=&gt; <span class="id">g</span> <span class="id">gnz</span>; <span class="kwd">exists</span> <span class="id">g</span> =&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#close_eq">close_eq</a></span> =&gt; // <span class="id">U</span> [<span class="id">oU</span> <span class="id">Uz</span>] <span class="id">V</span> <span class="id">ngV</span>; <span class="kwd">exists</span> <span class="id">z</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">split</span> =&gt; //; <span class="id">have</span> [<span class="id">n</span> <span class="id">_</span>] := @<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.cvg_tree_map">cvg_tree_map</a></span> <span class="id">g</span> <span class="id">_</span> <span class="id">ngV</span>; <span class="id">exact</span>.<br/>
<span class="id">have</span> <span class="id">zcov</span>' : <span class="kwd">forall</span> <span class="id"><a name="n:48">n</a></span> (<span class="id"><a name="U:49">U</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.X">X</a></span>), <span class="kwd">exists</span> <span class="id"><a name="e:50">e</a></span>, <span class="id">U</span> <span class="id">z</span> -&gt; @<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.refine_apx">refine_apx</a></span> <span class="id">n</span> <span class="id">U</span> <span class="id">e</span> <span class="id">z</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">U</span>; <span class="id">have</span> [|?] := <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> (<span class="id">U</span> <span class="id">z</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#point">point</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> [<span class="id">X</span> <span class="kwd">in</span> <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.X">X</a></span> <span class="id">z</span> -&gt; <span class="id">_</span>](@<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.refine_cover">refine_cover</a></span> <span class="id">n</span> <span class="id">U</span>); <span class="id">case</span> =&gt; <span class="id">e</span> <span class="id">_</span> ?; <span class="kwd">exists</span> <span class="id">e</span>.<br/>
<span class="id">pose</span> <span class="id">zcov</span> <span class="id"><a name="n:52">n</a></span> <span class="id"><a name="U:53">U</a></span> := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">projT1</a></span> (<span class="id"><a href="mathcomp.classical.boolp.html#cid">cid</a></span> (<span class="id">zcov</span>' <span class="id">n</span> <span class="id">U</span>)).<br/>
<span class="id">pose</span> <span class="kwd">fix</span> <span class="id">g</span> <span class="id"><a name="n:54">n</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.K">K</a></span> <span class="id">n</span> * <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.X">X</a></span> :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">n</span> <span class="id">is</span> <span class="id">m</span>.+1<br/>
&nbsp;&nbsp;<span class="kwd">then</span> (<span class="id">zcov</span> <span class="id">m</span>.+1 (<span class="id">g</span> <span class="id">m</span>).2, @<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.refine_apx">refine_apx</a></span> <span class="id">m</span>.+1 (<span class="id">g</span> <span class="id">m</span>).2 (<span class="id">zcov</span> <span class="id">m</span>.+1 (<span class="id">g</span> <span class="id">m</span>).2))<br/>
&nbsp;&nbsp;<span class="kwd">else</span> (<span class="id">zcov</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#O">O</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.X">X</a></span>], @<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.refine_apx">refine_apx</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#O">O</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.X">X</a></span>] (<span class="id">zcov</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#O">O</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.X">X</a></span>])).<br/>
<span class="id">pose</span> <span class="id">g</span>' <span class="id"><a name="n:57">n</a></span> := (<span class="id">g</span> <span class="id">n</span>).1; <span class="id">have</span> <span class="id">apxg</span> <span class="id">n</span> : <span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">g</span>' <span class="id">n</span>.+1 = (<span class="id">g</span> <span class="id">n</span>).2.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">elim</span>: <span class="id">n</span> =&gt; //= <span class="id">n</span> -&gt;.<br/>
<span class="kwd">exists</span> <span class="id">g</span>'; <span class="id">elim</span> =&gt; // <span class="id">n</span> /= <span class="id">IH</span>.<br/>
<span class="id">have</span> /(<span class="id">_</span> <span class="id">IH</span>) := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">projT2</a></span> (<span class="id"><a href="mathcomp.classical.boolp.html#cid">cid</a></span> (<span class="id">zcov</span>' <span class="id">n</span> (<span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">g</span>' <span class="id">n</span>))).<br/>
<span class="kwd">by</span> <span class="id">case</span>: <span class="id">n</span> {<span class="id">IH</span>} =&gt; // <span class="id">n</span>; <span class="id">rewrite</span> <span class="id">apxg</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="topological_trees.tree_prefix">tree_prefix</a></span> (<span class="id"><a name="b:59">b</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.T">T</a></span>) (<span class="id"><a name="n:60">n</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span>) :<br/>
&nbsp;&nbsp;\<span class="kwd">forall</span> <span class="id"><a name="c:61">c</a></span> \<span class="id">near</span> <span class="id">b</span>, <span class="kwd">forall</span> <span class="id"><a name="i:62">i</a></span>,  (<span class="id">i</span> &lt; <span class="id">n</span>)%<span class="id">N</span> -&gt; <span class="id">b</span> <span class="id">i</span> = <span class="id">c</span> <span class="id">i</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof12')">Proof.</span></div>
<div class="proofscript" id="proof12">
<span class="id">elim</span>: <span class="id">n</span> =&gt; [|<span class="id">n</span> <span class="id">IH</span>]; <span class="id">first</span> <span class="kwd">by</span> <span class="id">near</span>=&gt; <span class="id">z</span> =&gt; ?; <span class="id">rewrite</span> <span class="id">ltn0</span>.<br/>
<span class="id">near</span>=&gt; <span class="id">z</span> =&gt; <span class="id">i</span>; <span class="id">rewrite</span> <span class="id">leq_eqVlt</span> =&gt; /<span class="id">predU1P</span>[|<span class="id">iSn</span>]; <span class="id">last</span> <span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id"><a href="mathcomp.analysis.topology.html#near">near</a></span> <span class="id">IH</span> <span class="id">z</span>).<br/>
<span class="id">move</span>=&gt; [-&gt;]; <span class="id">near</span>: <span class="id">z</span>; <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.classical.mathcomp_extra.html#proj">proj</a></span> <span class="id">n</span> @^-1` [<span class="id">set</span> <span class="id">b</span> <span class="id">n</span>]).<br/>
<span class="id">split</span> =&gt; //; <span class="id">suff</span> : @<span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.T">T</a></span> (<span class="id"><a href="mathcomp.classical.mathcomp_extra.html#proj">proj</a></span> <span class="id">n</span> @^-1` [<span class="id">set</span> <span class="id">b</span> <span class="id">n</span>]) <span class="kwd">by</span> [].<br/>
<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#open_comp">open_comp</a></span>; [<span class="id">move</span>=&gt; + <span class="id">_</span>; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#proj_continuous">proj_continuous</a></span>| <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#discrete_open">discrete_open</a></span>].<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="topological_trees.apx_prefix">apx_prefix</a></span> <span class="id"><a name="b:63">b</a></span> <span class="id"><a name="c:64">c</a></span> <span class="id"><a name="n:65">n</a></span> :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="i:66">i</a></span>, (<span class="id">i</span> &lt; <span class="id">n</span>)%<span class="id">N</span> -&gt; <span class="id">b</span> <span class="id">i</span> = <span class="id">c</span> <span class="id">i</span>) -&gt; <span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">b</span> <span class="id">n</span> = <span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">c</span> <span class="id">n</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof13')">Proof.</span></div>
<div class="proofscript" id="proof13">
<span class="id">elim</span>: <span class="id">n</span> =&gt; //= <span class="id">n</span> <span class="id">IH</span> <span class="id">inS</span>; <span class="id">rewrite</span> <span class="id">IH</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">inS</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; ? ?; <span class="id">exact</span>/<span class="id">inS</span>/<span class="id">ltnW</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="topological_trees.tree_map_apx">tree_map_apx</a></span> <span class="id"><a name="b:67">b</a></span> <span class="id"><a name="n:68">n</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">b</span> <span class="id">n</span> (<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_map">tree_map</a></span> <span class="id">b</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof14')">Proof.</span></div>
<div class="proofscript" id="proof14">
<span class="id">apply</span>: (@<span class="id"><a href="mathcomp.analysis.topology.html#closed_cvg">closed_cvg</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.cantor.html#tree_map_filter">tree_map_filter</a></span> <span class="id">b</span>)); <span class="id">last</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.cvg_tree_map">cvg_tree_map</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.invar_cl">invar_cl</a></span>; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_map_invar">tree_map_invar</a></span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">n</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id"><a name="tree_map_cts">tree_map_cts</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_map">tree_map</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof15')">Proof.</span></div>
<div class="proofscript" id="proof15">
<span class="id">move</span>=&gt; <span class="id">b</span> <span class="id">U</span> /<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.cvg_tree_map">cvg_tree_map</a></span> [<span class="id">n</span> <span class="id">_</span>] /<span class="id"><a href="mathcomp.analysis.topology.html#filterS">filterS</a></span>; <span class="id">apply</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>/<span class="id"><a href="mathcomp.analysis.topology.html#fmap_filter">fmap_filter</a></span>/<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_filter">nbhs_filter</a></span>.<br/>
<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#NbhsBall.nbhs_simpl">nbhs_simpl</a></span> /=; <span class="id">near_simpl</span>; <span class="id">have</span> := <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_prefix">tree_prefix</a></span> <span class="id">b</span> <span class="id">n</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filter_app">filter_app</a></span>.<br/>
<span class="kwd">by</span> <span class="id">near</span>=&gt; <span class="id">z</span> =&gt; /<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.apx_prefix">apx_prefix</a></span> -&gt;; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_map_apx">tree_map_apx</a></span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="id">end_near</span>. Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="topological_trees.tree_map_setI">tree_map_setI</a></span> <span class="id"><a name="x:69">x</a></span> <span class="id"><a name="y:70">y</a></span> <span class="id"><a name="n:71">n</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_map">tree_map</a></span> <span class="id">x</span> = <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_map">tree_map</a></span> <span class="id">y</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.refine_apx">refine_apx</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">x</span> <span class="id">n</span>) (<span class="id">x</span> <span class="id">n</span>) `&amp;` <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.refine_apx">refine_apx</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">y</span> <span class="id">n</span>) (<span class="id">y</span> <span class="id">n</span>) !=<span class="id">set0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof16')">Proof.</span></div>
<div class="proofscript" id="proof16">
<span class="id">move</span>=&gt; <span class="id">xyE</span>; <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_map">tree_map</a></span> <span class="id">y</span>); <span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id">xyE</span> -/(<span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">x</span> <span class="id">n</span>.+1); <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_map_apx">tree_map_apx</a></span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -/(<span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">y</span> <span class="id">n</span>.+1); <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_map_apx">tree_map_apx</a></span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id"><a name="tree_map_inj">tree_map_inj</a></span> : (<span class="kwd">forall</span> <span class="id"><a name="n:72">n</a></span> <span class="id"><a name="U:73">U</a></span>, <span class="id"><a href="mathcomp.classical.classical_sets.html#trivIset">trivIset</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.K">K</a></span> <span class="id">n</span>] (@<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.refine_apx">refine_apx</a></span> <span class="id">n</span> <span class="id">U</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.functions.html#set_inj">set_inj</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.T">T</a></span>] <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_map">tree_map</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof17')">Proof.</span></div>
<div class="proofscript" id="proof17">
<span class="id">move</span>=&gt; <span class="id">triv</span> <span class="id">x</span> <span class="id">y</span> <span class="id">_</span> <span class="id">_</span> <span class="id">xyE</span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.boolp.html#functional_extensionality_dep">functional_extensionality_dep</a></span> =&gt; <span class="id">n</span>.<br/>
<span class="id">suff</span> : <span class="kwd">forall</span> <span class="id"><a name="n:74">n</a></span>, <span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">x</span> <span class="id">n</span> = <span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">y</span> <span class="id">n</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; <span class="id">brE</span>; <span class="id">apply</span>: (@<span class="id">triv</span> <span class="id">n</span> (<span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">x</span> <span class="id">n</span>) <span class="id">_</span> <span class="id">_</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#I">I</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#I">I</a></span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> [<span class="kwd">in</span> <span class="id">X</span> <span class="kwd">in</span> <span class="id">_</span> `&amp;` <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.X">X</a></span>]<span class="id">brE</span>; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_map_setI">tree_map_setI</a></span>.<br/>
<span class="id">elim</span> =&gt; // <span class="id">m</span> /= <span class="id">brE</span>.<br/>
<span class="id">rewrite</span> (@<span class="id">triv</span> <span class="id">m</span> (<span class="id"><a href="mathcomp.analysis.cantor.html#branch_apx">branch_apx</a></span> <span class="id">x</span> <span class="id">m</span>) (<span class="id">x</span> <span class="id">m</span>) (<span class="id">y</span> <span class="id">m</span>) <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#I">I</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#I">I</a></span>) 1?<span class="id">brE</span>//.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -[<span class="kwd">in</span> <span class="id">X</span> <span class="kwd">in</span> <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.X">X</a></span> `&amp;` <span class="id">_</span>]<span class="id">brE</span>; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_map_setI">tree_map_setI</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="tree_map_props">tree_map_props</a></span> : <span class="kwd">exists</span> <span class="id"><a name="f:77">f</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.T">T</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.X">X</a></span>,<br/>
&nbsp;&nbsp;[/\ <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.functions.html#set_surj">set_surj</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.T">T</a></span>] [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.X">X</a></span>] <span class="id">f</span> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="n:78">n</a></span> <span class="id"><a name="U:79">U</a></span>, <span class="id"><a href="mathcomp.classical.classical_sets.html#trivIset">trivIset</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.K">K</a></span> <span class="id">n</span>] (@<span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.refine_apx">refine_apx</a></span> <span class="id">n</span> <span class="id">U</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.functions.html#set_inj">set_inj</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.T">T</a></span>] <span class="id">f</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof18')">Proof.</span></div>
<div class="proofscript" id="proof18">
<span class="kwd">exists</span> <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees.tree_map">tree_map</a></span>; <span class="id">split</span>.<br/>
- <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#tree_map_cts">tree_map_cts</a></span>.<br/>
- <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#tree_map_surj">tree_map_surj</a></span>.<br/>
- <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#tree_map_inj">tree_map_inj</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.cantor.html#topological_trees">topological_trees</a></span>.<br/>
<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="TreeStructure">TreeStructure</a></span>.<br/>
<span class="kwd">Context</span> {<span class="id"><a name="R:80">R</a></span> : <span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">realType</a></span>} {<span class="id"><a name="T:81">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.Exports.pseudoMetricType">pseudoMetricType</a></span> <span class="id">R</span>}.<br/>
<span class="kwd">Hypothesis</span> <span class="id"><a name="TreeStructure.cantorT">cantorT</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_like">cantor_like</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.T">T</a></span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="TreeStructure.dsctT">dsctT</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#zero_dimensional">zero_dimensional</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.T">T</a></span><br/>
<div>&nbsp;&nbsp;<span class="toggleproof" onclick="toggleDisplay('proof19')">Proof.</span></div>
<div class="proofscript" id="proof19">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.cantorT">cantorT</a></span>. Qed.</div>
<span class="kwd">Let</span> <span class="id"><a name="TreeStructure.pftT">pftT</a></span>  : <span class="id"><a href="mathcomp.analysis.topology.html#perfect_set">perfect_set</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.T">T</a></span>]<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof20')">Proof.</span></div>
<div class="proofscript" id="proof20">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.cantorT">cantorT</a></span>. Qed.</div>
<span class="kwd">Let</span> <span class="id"><a name="TreeStructure.cmptT">cmptT</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#compact">compact</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.T">T</a></span>]<br/>
<div>&nbsp;&nbsp;&nbsp;&nbsp;<span class="toggleproof" onclick="toggleDisplay('proof21')">Proof.</span></div>
<div class="proofscript" id="proof21">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.cantorT">cantorT</a></span>. Qed.</div>
<span class="kwd">Let</span> <span class="id"><a name="TreeStructure.hsdfT">hsdfT</a></span> : @<span class="id"><a href="mathcomp.analysis.topology.html#hausdorff_space">hausdorff_space</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.T">T</a></span><br/>
<div>&nbsp;&nbsp;<span class="toggleproof" onclick="toggleDisplay('proof22')">Proof.</span></div>
<div class="proofscript" id="proof22">
 <span class="kwd">by</span> <span class="id">case</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.cantorT">cantorT</a></span>. Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="TreeStructure.c_invar">c_invar</a></span> (<span class="id"><a name="U:83">U</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.T">T</a></span>) := <span class="id"><a href="mathcomp.analysis.topology.html#clopen">clopen</a></span> <span class="id">U</span> /\ <span class="id">U</span> !=<span class="id">set0</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="TreeStructure.U_">U_</a></span> := <span class="id"><a href="mathcomp.classical.classical_sets.html#unsquash">unsquash</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#clopen_surj">clopen_surj</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.cmptT">cmptT</a></span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="TreeStructure.split_clopen'">split_clopen</a></span>' (<span class="id"><a name="U:84">U</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.T">T</a></span>) : <span class="kwd">exists</span> <span class="id"><a name="V:85">V</a></span>,<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">U</span> -&gt; <span class="id">U</span> !=<span class="id">set0</span> -&gt; [/\ <span class="id"><a href="mathcomp.analysis.topology.html#clopen">clopen</a></span> <span class="id">V</span>, <span class="id">V</span> `&amp;` <span class="id">U</span> !=<span class="id">set0</span> &amp; ~`<span class="id">V</span> `&amp;` <span class="id">U</span> !=<span class="id">set0</span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof23')">Proof.</span></div>
<div class="proofscript" id="proof23">
<span class="id">have</span> [<span class="id">oU</span>|?] := <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#open">open</a></span> <span class="id">U</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#point">point</a></span>.<br/>
<span class="id">have</span> [<span class="id">Un0</span>|?] := <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> (<span class="id">U</span> !=<span class="id">set0</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#point">point</a></span>.<br/>
<span class="id">have</span> [<span class="id">x</span> [<span class="id">y</span>] [<span class="id">Ux</span>] <span class="id">Uy</span> <span class="id">xny</span>] := (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#iffLR">iffLR</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#perfect_set2">perfect_set2</a></span>) <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.pftT">pftT</a></span> <span class="id">U</span> <span class="id">oU</span> <span class="id">Un0</span>.<br/>
<span class="id">have</span> [<span class="id">V</span> [<span class="id">clV</span> <span class="id">Vx</span> <span class="id">Vy</span>]] := <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.dsctT">dsctT</a></span> <span class="id">xny</span>; <span class="kwd">exists</span> <span class="id">V</span> =&gt; <span class="id">_</span> <span class="id">_</span>.<br/>
<span class="kwd">by</span> <span class="id">split</span> =&gt; //; [<span class="kwd">exists</span> <span class="id">x</span> | <span class="kwd">exists</span> <span class="id">y</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="TreeStructure.split_clopen">split_clopen</a></span> (<span class="id"><a name="U:86">U</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.T">T</a></span>) := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">projT1</a></span> (<span class="id"><a href="mathcomp.classical.boolp.html#cid">cid</a></span> (<span class="id">split_clopen</span>' <span class="id">U</span>)).<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="TreeStructure.c_ind">c_ind</a></span> <span class="id"><a name="n:87">n</a></span> (<span class="id"><a name="V:88">V</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.T">T</a></span>) (<span class="id"><a name="b:89">b</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#bool">bool</a></span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id"><a name="Wn:90">Wn</a></span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> ((<span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.U_">U_</a></span> <span class="id">n</span>) `&amp;` <span class="id">V</span> !=<span class="id">set0</span> /\ ~` (<span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.U_">U_</a></span> <span class="id">n</span>) `&amp;` <span class="id">V</span> !=<span class="id">set0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.U_">U_</a></span> <span class="id">n</span> <span class="kwd">else</span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.split_clopen">split_clopen</a></span> <span class="id">V</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;(<span class="kwd">if</span> <span class="id">b</span> <span class="kwd">then</span> <span class="id">Wn</span> <span class="kwd">else</span> ~` <span class="id">Wn</span>) `&amp;` <span class="id">V</span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id"><a name="cantor_map">cantor_map</a></span> : <span class="kwd">exists</span> <span class="id"><a name="f:91">f</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_space">cantor_space</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.T">T</a></span>,<br/>
&nbsp;&nbsp;[/\ <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.functions.html#set_surj">set_surj</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_space">cantor_space</a></span>] [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.T">T</a></span>] <span class="id">f</span> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.functions.html#set_inj">set_inj</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_space">cantor_space</a></span>] <span class="id">f</span> ].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof24')">Proof.</span></div>
<div class="proofscript" id="proof24">
<span class="id">have</span> [] := @<span class="id"><a href="mathcomp.analysis.cantor.html#tree_map_props">tree_map_props</a></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span>=&gt; [<span class="id">topologicalType</span> <span class="id">of</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#bool">bool</a></span>]) <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.T">T</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.c_ind">c_ind</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.c_invar">c_invar</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.cmptT">cmptT</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.hsdfT">hsdfT</a></span>.<br/>
- <span class="kwd">by</span> [].<br/>
- <span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">V</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>; <span class="id">split</span> =&gt; [<span class="id">t</span> <span class="id">Vt</span>|<span class="id">t</span> [? ? []]//].<br/>
&nbsp;&nbsp;<span class="id">have</span> [?|?] := <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.U_">U_</a></span> <span class="id">n</span> `&amp;` <span class="id">V</span> !=<span class="id">set0</span> /\ ~` <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.U_">U_</a></span> <span class="id">n</span> `&amp;` <span class="id">V</span> !=<span class="id">set0</span>).<br/>
&nbsp;&nbsp;+ <span class="id">have</span> [<span class="id">Unt</span>|<span class="id">Unt</span>] := <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.U_">U_</a></span> <span class="id">n</span> <span class="id">t</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#true">true</a></span> =&gt; //; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.c_ind">c_ind</a></span>; <span class="id">case</span>: <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#false">false</a></span> =&gt; //; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.c_ind">c_ind</a></span>; <span class="id">case</span>: <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span>.<br/>
&nbsp;&nbsp;+ <span class="id">have</span> [<span class="id">scVt</span>|<span class="id">scVt</span>] := <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.split_clopen">split_clopen</a></span> <span class="id">V</span> <span class="id">t</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#true">true</a></span> =&gt; //; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.c_ind">c_ind</a></span>; <span class="id">case</span>: <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#false">false</a></span> =&gt; //; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.c_ind">c_ind</a></span>; <span class="id">case</span>: <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">U</span> <span class="id">e</span> [] <span class="id">clU</span> <span class="id">Un0</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.c_ind">c_ind</a></span>; <span class="id">case</span>: <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> =&gt; /=.<br/>
&nbsp;&nbsp;+ <span class="id">move</span>=&gt; [<span class="id">UU</span> <span class="id">CUU</span>]; <span class="id">case</span>: <span class="id">e</span> =&gt; //; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#clopenI">clopenI</a></span> =&gt; //.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>: <span class="id"><a href="mathcomp.classical.functions.html#funS">funS</a></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#clopenC">clopenC</a></span> =&gt; //; <span class="id">exact</span>: <span class="id"><a href="mathcomp.classical.functions.html#funS">funS</a></span>.<br/>
&nbsp;&nbsp;+ <span class="id">move</span>=&gt; <span class="id">_</span>; <span class="id">have</span> [|//|<span class="id">clscU</span> <span class="id">scUU</span> <span class="id">CscUU</span>] := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">projT2</a></span> (<span class="id"><a href="mathcomp.classical.boolp.html#cid">cid</a></span> (<span class="id">split_clopen</span>' <span class="id">U</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>: <span class="id">clU</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case</span>: <span class="id">e</span>; <span class="id">split</span> =&gt; //; <span class="id">first</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#clopenI">clopenI</a></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#clopenI">clopenI</a></span> =&gt; //; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#clopenC">clopenC</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ? [].<br/>
- <span class="kwd">by</span> <span class="id">split</span>; [<span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#clopenT">clopenT</a></span> | <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#point">point</a></span>].<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; ? [[]].<br/>
- <span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">y</span> /<span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.dsctT">dsctT</a></span> [<span class="id">A</span> [<span class="id">clA</span> <span class="id">Ax</span> <span class="id">Any</span>]].<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">n</span> <span class="id">_</span> <span class="id">UnA</span>] := @<span class="id"><a href="mathcomp.classical.functions.html#surj">surj</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.U_">U_</a></span> <span class="id">_</span> <span class="id">clA</span>; <span class="kwd">exists</span> <span class="id">n</span> =&gt; <span class="id">V</span> <span class="id">e</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [|+ <span class="id">_</span>] := <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> (<span class="id">V</span> <span class="id">y</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.classical_sets.html#subsetC">subsetC</a></span> =&gt; ? [].<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">Vx</span> <span class="id">Vy</span>|? <span class="id">_</span> []//] := <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> (<span class="id">V</span> <span class="id">x</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> {1 2}/<span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.c_ind">c_ind</a></span>; <span class="id">case</span>: <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> =&gt; /=; <span class="id">rewrite</span> ?<span class="id">UnA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">_</span>; <span class="id">case</span>: <span class="id">e</span>; <span class="id">case</span> =&gt; // ? ?; <span class="id">apply</span>/<span class="id"><a href="mathcomp.classical.boolp.html#not_andP">not_andP</a></span>; <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#absurd">absurd</a></span>; <span class="id">split</span>; [<span class="kwd">exists</span> <span class="id">x</span> | <span class="kwd">exists</span> <span class="id">y</span>].<br/>
- <span class="id">move</span>=&gt; <span class="id">f</span> [<span class="id">ctsf</span> <span class="id">surjf</span> <span class="id">injf</span>]; <span class="kwd">exists</span> <span class="id">f</span>; <span class="id">split</span> =&gt; //; <span class="id">apply</span>: <span class="id">injf</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">U</span> <span class="id">i</span> <span class="id">j</span> <span class="id">_</span> <span class="id">_</span> [<span class="id">z</span>] [] [] + <span class="id">Uz</span> [+ <span class="id">_</span>]; <span class="id">move</span>: <span class="id">i</span> <span class="id">j</span> =&gt; [] [].<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="TreeStructure.tree_map">tree_map</a></span> := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">projT1</a></span> (<span class="id"><a href="mathcomp.classical.boolp.html#cid">cid</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_map">cantor_map</a></span>).<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="TreeStructure.tree_map_bij">tree_map_bij</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#bijective">bijective</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.tree_map">tree_map</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof25')">Proof.</span></div>
<div class="proofscript" id="proof25">
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.classical.functions.html#setTT_bijective">setTT_bijective</a></span>; <span class="id">have</span> [? ? ?] := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">projT2</a></span> (<span class="id"><a href="mathcomp.classical.boolp.html#cid">cid</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_map">cantor_map</a></span>); <span class="id">split</span>.<br/>
Qed.</div>
<br/>
#[<span class="id">local</span>] <span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> := @<span class="id"><a href="mathcomp.classical.functions.html#BijTT.Build">BijTT.Build</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.tree_map_bij">tree_map_bij</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="homeomorphism_cantor_like">homeomorphism_cantor_like</a></span> :<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id"><a name="f:92">f</a></span> : {<span class="id">splitbij</span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_space">cantor_space</a></span>] &gt;-&gt; [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.T">T</a></span>]},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">f</span> /\ (<span class="kwd">forall</span> <span class="id"><a name="A:93">A</a></span>, <span class="id"><a href="mathcomp.analysis.topology.html#closed">closed</a></span> <span class="id">A</span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#closed">closed</a></span> (<span class="id">f</span> @` <span class="id">A</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof26')">Proof.</span></div>
<div class="proofscript" id="proof26">
<span class="kwd">exists</span> [<span class="id">the</span> {<span class="id">splitbij</span> <span class="id">_</span> &gt;-&gt; <span class="id">_</span>} <span class="id">of</span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.tree_map">tree_map</a></span>] =&gt; /=.<br/>
<span class="id">have</span> [<span class="id">cts</span> <span class="id">surj</span> <span class="id">inje</span>] := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">projT2</a></span> (<span class="id"><a href="mathcomp.classical.boolp.html#cid">cid</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_map">cantor_map</a></span>); <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>: <span class="id">cts</span>.<br/>
<span class="id">move</span>=&gt; <span class="id">A</span> <span class="id">clA</span>; <span class="id">apply</span>: (<span class="id"><a href="mathcomp.analysis.topology.html#compact_closed">compact_closed</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.hsdfT">hsdfT</a></span>).<br/>
<span class="id">apply</span>: (@<span class="id"><a href="mathcomp.analysis.topology.html#continuous_compact">continuous_compact</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure.tree_map">tree_map</a></span>); <span class="id">first</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#continuous_subspaceT">continuous_subspaceT</a></span>.<br/>
<span class="id">apply</span>: (@<span class="id"><a href="mathcomp.analysis.topology.html#subclosed_compact">subclosed_compact</a></span> <span class="id">_</span> <span class="id">_</span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_space">cantor_space</a></span>]) =&gt; //.<br/>
<span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_space_compact">cantor_space_compact</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.cantor.html#TreeStructure">TreeStructure</a></span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="FinitelyBranchingTrees">FinitelyBranchingTrees</a></span>.<br/>
<span class="kwd">Context</span> {<span class="id"><a name="R:94">R</a></span> : <span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">realType</a></span>}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="pointed_discrete">pointed_discrete</a></span> (<span class="id"><a name="P:95">P</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.pointedType">pointedType</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.Exports.pseudoMetricType">pseudoMetricType</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#FinitelyBranchingTrees.R">R</a></span> :=<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#discrete_pseudoMetricType">discrete_pseudoMetricType</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#FinitelyBranchingTrees.R">R</a></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id"><a href="mathcomp.analysis.topology.html#discrete_uniformType">discrete_uniformType</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#Topological.Exports.TopologicalType">TopologicalType</a></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a href="mathcomp.analysis.topology.html#Filtered.Exports.FilteredType">FilteredType</a></span> <span class="id">P</span> <span class="id">P</span> <span class="id"><a href="mathcomp.analysis.topology.html#principal_filter">principal_filter</a></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#discrete_topological_mixin">discrete_topological_mixin</a></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#erefl">erefl</a></span>) <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#erefl">erefl</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="tree_of">tree_of</a></span> (<span class="id"><a name="T:96">T</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span> -&gt; <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.pointedType">pointedType</a></span>) : <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.Exports.pseudoMetricType">pseudoMetricType</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#FinitelyBranchingTrees.R">R</a></span> :=<br/>
&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.topology.html#product_pseudoMetricType">product_pseudoMetricType</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#FinitelyBranchingTrees.R">R</a></span> <span class="id">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id"><a name="n:97">n</a></span> =&gt; <span class="id"><a href="mathcomp.analysis.cantor.html#pointed_discrete">pointed_discrete</a></span> (<span class="id">T</span> <span class="id">n</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a href="mathcomp.classical.cardinality.html#countableP">countableP</a></span> <span class="id">_</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cantor_like_finite_prod">cantor_like_finite_prod</a></span> (<span class="id"><a name="T:98">T</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Datatypes.html#nat">nat</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.topology.html#Topological.Exports.topologicalType">topologicalType</a></span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="n:99">n</a></span>, <span class="id"><a href="mathcomp.classical.cardinality.html#finite_set">finite_set</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#pointed_discrete">pointed_discrete</a></span> (<span class="id">T</span> <span class="id">n</span>)]) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="n:100">n</a></span>, (<span class="kwd">exists</span> <span class="id"><a name="xy:101">xy</a></span> : <span class="id">T</span> <span class="id">n</span> * <span class="id">T</span> <span class="id">n</span>, <span class="id">xy</span>.1 != <span class="id">xy</span>.2)) -&gt;<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.cantor.html#cantor_like">cantor_like</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#tree_of">tree_of</a></span> <span class="id">T</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof27')">Proof.</span></div>
<div class="proofscript" id="proof27">
<span class="id">move</span>=&gt; <span class="id">finiteT</span> <span class="id">twoElems</span>; <span class="id">split</span>.<br/>
- <span class="id">exact</span>/(@<span class="id"><a href="mathcomp.analysis.topology.html#perfect_diagonal">perfect_diagonal</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#pointed_discrete">pointed_discrete</a></span> \<span class="id">o</span> <span class="id">T</span>))/<span class="id">twoElems</span>.<br/>
- <span class="id">have</span> := <span class="id"><a href="mathcomp.analysis.topology.html#tychonoff">tychonoff</a></span> (<span class="kwd">fun</span> <span class="id"><a name="n:102">n</a></span> =&gt; <span class="id"><a href="mathcomp.analysis.topology.html#finite_compact">finite_compact</a></span> (<span class="id">finiteT</span> <span class="id">n</span>)).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">congr</span> (<span class="id"><a href="mathcomp.analysis.topology.html#compact">compact</a></span> <span class="id">_</span>) =&gt; //=; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>.<br/>
- <span class="id">apply</span>: (@<span class="id"><a href="mathcomp.analysis.topology.html#hausdorff_product">hausdorff_product</a></span> <span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.cantor.html#pointed_discrete">pointed_discrete</a></span> \<span class="id">o</span> <span class="id">T</span>)) =&gt; <span class="id">n</span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#discrete_hausdorff">discrete_hausdorff</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span> <span class="id"><a href="mathcomp.analysis.topology.html#zero_dimension_prod">zero_dimension_prod</a></span> =&gt; ?; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#discrete_zero_dimension">discrete_zero_dimension</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.cantor.html#FinitelyBranchingTrees">FinitelyBranchingTrees</a></span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Notation</span> "<span class="id">A</span> ^-1" := ([<span class="id">set</span> <span class="id"><a name="xy:103">xy</a></span> | <span class="id">A</span> (<span class="id">xy</span>.2, <span class="id">xy</span>.1)]) : <span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="alexandroff_hausdorff">alexandroff_hausdorff</a></span>.<br/>
<span class="kwd">Context</span> {<span class="id"><a name="R:104">R</a></span> : <span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">realType</a></span>} {<span class="id"><a name="T:105">T</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#PseudoMetric.Exports.pseudoMetricType">pseudoMetricType</a></span> <span class="id">R</span>}.<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id"><a name="alexandroff_hausdorff.cptT">cptT</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#compact">compact</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>].<br/>
<span class="kwd">Hypothesis</span> <span class="id"><a name="alexandroff_hausdorff.hsdfT">hsdfT</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#hausdorff_space">hausdorff_space</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="alexandroff_hausdorff.two_pointed">two_pointed</a></span>.<br/>
<span class="kwd">Context</span> (<span class="id"><a name="t0:108">t0</a></span> <span class="id"><a name="t1:109">t1</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>).<br/>
<span class="kwd">Hypothesis</span> <span class="id"><a name="alexandroff_hausdorff.two_pointed.T2e">T2e</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.t0">t0</a></span> != <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.t1">t1</a></span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="alexandroff_hausdorff.two_pointed.ent_balls'">ent_balls</a></span>' (<span class="id"><a name="E:111">E</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span> * <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>)) :<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id"><a name="M:112">M</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>), <span class="id"><a href="mathcomp.analysis.topology.html#entourage">entourage</a></span> <span class="id">E</span> -&gt; [/\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.classical.cardinality.html#finite_set">finite_set</a></span> <span class="id">M</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id"><a name="A:113">A</a></span>, <span class="id">M</span> <span class="id">A</span> -&gt; <span class="kwd">exists</span> <span class="id"><a name="a:114">a</a></span>, <span class="id">A</span> <span class="id">a</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#closure">closure</a></span> [<span class="id">set</span> <span class="id"><a name="y:115">y</a></span> | <span class="id"><a href="mathcomp.analysis.topology.html#split_ent">split_ent</a></span> <span class="id">E</span> (<span class="id">a</span>, <span class="id">y</span>)],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id"><a name="A:116">A</a></span> <span class="id"><a name="B:117">B</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>, <span class="id">M</span> <span class="id">A</span> /\ <span class="id">M</span> <span class="id">B</span> /\ <span class="id">A</span> != <span class="id">B</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;\<span class="id">bigcup_</span>(<span class="id"><a name="A:118">A</a></span> <span class="kwd">in</span> <span class="id">M</span>) <span class="id">A</span> = [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>] &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">M</span> `&lt;=` <span class="id"><a href="mathcomp.analysis.topology.html#closed">closed</a></span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof28')">Proof.</span></div>
<div class="proofscript" id="proof28">
<span class="id">have</span> [<span class="id">entE</span>|?] := <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#entourage">entourage</a></span> <span class="id">E</span>); <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#point">point</a></span>.<br/>
<span class="id">move</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.cptT">cptT</a></span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#compact_cover">compact_cover</a></span>.<br/>
<span class="id">pose</span> <span class="id">fs</span> <span class="id"><a name="x:119">x</a></span> := <span class="id"><a href="mathcomp.analysis.topology.html#interior">interior</a></span> [<span class="id">set</span> <span class="id"><a name="y:120">y</a></span> | <span class="id"><a href="mathcomp.analysis.topology.html#split_ent">split_ent</a></span> <span class="id">E</span> (<span class="id">x</span>, <span class="id">y</span>)].<br/>
<span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span> [ <span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>] <span class="id">fs</span>)[<span class="id">t</span> <span class="id">_</span>|<span class="id">t</span> <span class="id">_</span> |].<br/>
- <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#open_interior">open_interior</a></span>.<br/>
- <span class="kwd">exists</span> <span class="id">t</span> =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">fs</span> /<span class="id"><a href="mathcomp.analysis.topology.html#interior">interior</a></span> -<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_entourageE">nbhs_entourageE</a></span>; <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.analysis.topology.html#split_ent">split_ent</a></span> <span class="id">E</span>).<br/>
<span class="id">move</span>=&gt; <span class="id">M</span>' <span class="id">_</span> <span class="id">Mcov</span>; <span class="kwd">exists</span><br/>
&nbsp;&nbsp;((<span class="id"><a href="mathcomp.analysis.topology.html#closure">closure</a></span> \<span class="id">o</span> <span class="id">fs</span>) @` [<span class="id">set</span>` <span class="id">M</span>'] `|` [<span class="id">set</span> [<span class="id">set</span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.t0">t0</a></span>]; [<span class="id">set</span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.t1">t1</a></span>]]).<br/>
<span class="id">move</span>=&gt; <span class="id">_</span>; <span class="id">split</span>=&gt; [|<span class="id">A</span> [|]| | |].<br/>
- <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.cardinality.html#finite_setU">finite_setU</a></span>; <span class="id">split</span>; <span class="id">first</span> <span class="id">exact</span>/<span class="id"><a href="mathcomp.classical.cardinality.html#finite_image">finite_image</a></span>/<span class="id"><a href="mathcomp.classical.cardinality.html#finite_fset">finite_fset</a></span>.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id"><a href="mathcomp.classical.cardinality.html#finite_set2">finite_set2</a></span>.<br/>
- <span class="id">move</span>=&gt; [<span class="id">z</span> <span class="id">M</span>'<span class="id">z</span>] &lt;-; <span class="kwd">exists</span> <span class="id">z</span>; <span class="id">split</span>.<br/>
&nbsp;&nbsp;+ <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#subset_closure">subset_closure</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_singleton">nbhs_singleton</a></span>; <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#nbhs_interior">nbhs_interior</a></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_entourageE">nbhs_entourageE</a></span>; <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.analysis.topology.html#split_ent">split_ent</a></span> <span class="id">E</span>).<br/>
&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#closure_subset">closure_subset</a></span>; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#interior_subset">interior_subset</a></span>.<br/>
- <span class="kwd">by</span> <span class="id">case</span> =&gt; -&gt;; [<span class="kwd">exists</span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.t0">t0</a></span> | <span class="kwd">exists</span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.t1">t1</a></span>]; <span class="id">split</span> =&gt; // <span class="id">t</span> -&gt;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#subset_closure">subset_closure</a></span>; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#entourage_refl">entourage_refl</a></span>.<br/>
- <span class="kwd">exists</span> [<span class="id">set</span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.t0">t0</a></span>], [<span class="id">set</span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.t1">t1</a></span>]; <span class="id">split</span>;[|<span class="id">split</span>].<br/>
&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">right</span>; <span class="id">left</span>.<br/>
&nbsp;&nbsp;+ <span class="kwd">by</span> <span class="id">right</span>; <span class="id">right</span>.<br/>
&nbsp;&nbsp;+ <span class="id">apply</span>/<span class="id">eqP</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span> =&gt; -[] /(<span class="id">_</span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.t0">t0</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrfun.html#erefl">erefl</a></span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.T2e">T2e</a></span> =&gt; /[<span class="id">swap</span>] -&gt; /<span class="id">eqP</span>.<br/>
- <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.classical.classical_sets.html#subTset">subTset</a></span> =&gt; <span class="id">t</span> /<span class="id">Mcov</span> [<span class="id">t</span>' <span class="id">M</span>'<span class="id">t</span>' <span class="id">fsxt</span>]; <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.analysis.topology.html#closure">closure</a></span> (<span class="id">fs</span> <span class="id">t</span>')).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">left</span>; <span class="kwd">exists</span> <span class="id">t</span>'.<br/>
&nbsp;&nbsp;<span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#subset_closure">subset_closure</a></span>.<br/>
- <span class="id">move</span>=&gt; ? [[? ?] &lt;-|]; <span class="id">first</span> <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#closed_closure">closed_closure</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; [|] -&gt;; <span class="id">exact</span>/<span class="id"><a href="mathcomp.analysis.topology.html#accessible_closed_set1">accessible_closed_set1</a></span>/<span class="id"><a href="mathcomp.analysis.topology.html#hausdorff_accessible">hausdorff_accessible</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="alexandroff_hausdorff.two_pointed.ent_balls">ent_balls</a></span> <span class="id"><a name="E:121">E</a></span> := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">projT1</a></span> (<span class="id"><a href="mathcomp.classical.boolp.html#cid">cid</a></span> (<span class="id">ent_balls</span>' <span class="id">E</span>)).<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="alexandroff_hausdorff.two_pointed.count_unif'">count_unif</a></span>' := <span class="id"><a href="mathcomp.classical.boolp.html#cid2">cid2</a></span><br/>
&nbsp;&nbsp;((<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssreflect.html#iffLR">iffLR</a></span> <span class="id"><a href="mathcomp.analysis.topology.html#countable_uniformityP">countable_uniformityP</a></span>) (@<span class="id"><a href="mathcomp.analysis.topology.html#countable_uniformity_metric">countable_uniformity_metric</a></span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>)).<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="alexandroff_hausdorff.two_pointed.count_unif">count_unif</a></span> := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">projT1</a></span> <span class="id">count_unif</span>'.<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="alexandroff_hausdorff.two_pointed.ent_count_unif">ent_count_unif</a></span> <span class="id"><a name="n:122">n</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#entourage">entourage</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.count_unif">count_unif</a></span> <span class="id">n</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof29')">Proof.</span></div>
<div class="proofscript" id="proof29">
<span class="id">have</span> := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">projT2</a></span> (<span class="id"><a href="mathcomp.classical.boolp.html#cid">cid</a></span> (<span class="id">ent_balls</span>' (<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.count_unif">count_unif</a></span> <span class="id">n</span>))).<br/>
<span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.count_unif">count_unif</a></span>; <span class="id">case</span>: <span class="id">count_unif</span>'.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; /= <span class="id">f</span> <span class="id">fnA</span> <span class="id">fnE</span>; <span class="id">case</span> /(<span class="id">_</span> (<span class="id">fnE</span> <span class="id">_</span>)) =&gt; <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> + <span class="id">_</span>; <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.classical.classical_sets.html#subTset">subTset</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="alexandroff_hausdorff.two_pointed.count_unif_sub">count_unif_sub</a></span> <span class="id"><a name="E:123">E</a></span> : <span class="id"><a href="mathcomp.analysis.topology.html#entourage">entourage</a></span> <span class="id">E</span> -&gt; <span class="kwd">exists</span> <span class="id"><a name="N:124">N</a></span>, <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.count_unif">count_unif</a></span> <span class="id">N</span> `&lt;=` <span class="id">E</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof30')">Proof.</span></div>
<div class="proofscript" id="proof30">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">entE</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.count_unif">count_unif</a></span>; <span class="id">case</span>: <span class="id">count_unif</span>' =&gt; <span class="id">f</span> + ? /=; <span class="id">exact</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="alexandroff_hausdorff.two_pointed.K'">K</a></span>' <span class="id"><a name="n:125">n</a></span> : <span class="kwd">Type</span> := @<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#sigT">sigT</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>) (<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.ent_balls">ent_balls</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.count_unif">count_unif</a></span> <span class="id">n</span>)).<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="alexandroff_hausdorff.two_pointed.K'p">K</a></span>'<span class="id">p</span> <span class="id"><a name="n:126">n</a></span> : <span class="id">K</span>' <span class="id">n</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof31')">Proof.</span></div>
<div class="proofscript" id="proof31">
<span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.boolp.html#cid">cid</a></span>; <span class="id">have</span> [//| <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> + <span class="id">_</span>] := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">projT2</a></span> (<span class="id"><a href="mathcomp.classical.boolp.html#cid">cid</a></span> (<span class="id">ent_balls</span>' (<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.count_unif">count_unif</a></span> <span class="id">n</span>))).<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.classical.classical_sets.html#subTset">subTset</a></span> =&gt; /(<span class="id">_</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#point">point</a></span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#I">I</a></span>) [<span class="id">W</span> <span class="id">Q</span> ?]; <span class="kwd">exists</span> <span class="id">W</span>; <span class="id">exact</span>: <span class="id">Q</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="alexandroff_hausdorff.two_pointed.K">K</a></span> <span class="id"><a name="n:127">n</a></span> := <span class="id"><a href="mathcomp.classical.classical_sets.html#Pointed.Exports.PointedType">PointedType</a></span> (<span class="id"><a href="mathcomp.classical.boolp.html#classicType_choiceType">classicType_choiceType</a></span> (<span class="id">K</span>' <span class="id">n</span>)) (<span class="id">K</span>'<span class="id">p</span> <span class="id">n</span>).<br/>
<span class="kwd">Let</span> <span class="id"><a name="alexandroff_hausdorff.two_pointed.Tree">Tree</a></span> := @<span class="id"><a href="mathcomp.analysis.cantor.html#tree_of">tree_of</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.R">R</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.K">K</a></span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="alexandroff_hausdorff.two_pointed.embed_refine">embed_refine</a></span> <span class="id"><a name="n:128">n</a></span> (<span class="id"><a name="U:129">U</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>) (<span class="id"><a name="k:130">k</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.K">K</a></span> <span class="id">n</span>) :=<br/>
&nbsp;&nbsp;(<span class="kwd">if</span> <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">projT1</a></span> <span class="id">k</span> `&amp;` <span class="id">U</span> !=<span class="id">set0</span>)<br/>
&nbsp;&nbsp;<span class="kwd">then</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">projT1</a></span> <span class="id">k</span><br/>
&nbsp;&nbsp;<span class="kwd">else</span> <span class="kwd">if</span> <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> (<span class="kwd">exists</span> <span class="id"><a name="e:131">e</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.K">K</a></span> <span class="id">n</span> , <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">projT1</a></span> <span class="id">e</span> `&amp;` <span class="id">U</span> !=<span class="id">set0</span>) <span class="id">is</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#left">left</a></span> <span class="id">e</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">projT1</a></span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">projT1</a></span> (<span class="id"><a href="mathcomp.classical.boolp.html#cid">cid</a></span> <span class="id">e</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set0">set0</a></span>) `&amp;` <span class="id">U</span>.<br/>
<span class="kwd">Let</span> <span class="id"><a name="alexandroff_hausdorff.two_pointed.embed_invar">embed_invar</a></span> (<span class="id"><a name="U:132">U</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>) := <span class="id"><a href="mathcomp.analysis.topology.html#closed">closed</a></span> <span class="id">U</span> /\ <span class="id">U</span> !=<span class="id">set0</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id"><a name="alexandroff_hausdorff.two_pointed.Kn_closed">Kn_closed</a></span> <span class="id"><a name="n:133">n</a></span> (<span class="id"><a name="e:134">e</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.K">K</a></span> <span class="id">n</span>) : <span class="id"><a href="mathcomp.analysis.topology.html#closed">closed</a></span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">projT1</a></span> <span class="id">e</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof32')">Proof.</span></div>
<div class="proofscript" id="proof32">
<span class="id">case</span>: <span class="id">e</span> =&gt; <span class="id">W</span>; <span class="id">have</span> [//| <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>] := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">projT2</a></span> (<span class="id"><a href="mathcomp.classical.boolp.html#cid">cid</a></span> (<span class="id">ent_balls</span>' (<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.count_unif">count_unif</a></span> <span class="id">n</span>))).<br/>
<span class="id">exact</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id"><a name="cantor_surj_pt1">cantor_surj_pt1</a></span> : <span class="kwd">exists2</span> <span class="id"><a name="f:135">f</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.Tree">Tree</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>,<br/>
&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">f</span> &amp; <span class="id"><a href="mathcomp.classical.functions.html#set_surj">set_surj</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.Tree">Tree</a></span>] [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>] <span class="id">f</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof33')">Proof.</span></div>
<div class="proofscript" id="proof33">
<span class="id">pose</span> <span class="id">entn</span> <span class="id"><a name="n:137">n</a></span> := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">projT2</a></span> (<span class="id"><a href="mathcomp.classical.boolp.html#cid">cid</a></span> (<span class="id">ent_balls</span>' (<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.count_unif">count_unif</a></span> <span class="id">n</span>))).<br/>
<span class="id">have</span> [//| | |? []//| |? []// | |] := @<span class="id"><a href="mathcomp.analysis.cantor.html#tree_map_props">tree_map_props</a></span> (@<span class="id"><a href="mathcomp.analysis.cantor.html#pointed_discrete">pointed_discrete</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.R">R</a></span> \<span class="id">o</span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.K">K</a></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span> (<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.embed_refine">embed_refine</a></span>) (<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.embed_invar">embed_invar</a></span>) <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.cptT">cptT</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.hsdfT">hsdfT</a></span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">U</span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>; <span class="id">split</span>=&gt; [<span class="id">t</span> <span class="id">Ut</span>|<span class="id">t</span> [? ? []]//].<br/>
&nbsp;&nbsp;<span class="id">have</span> [//|<span class="id">_</span> <span class="id">_</span> <span class="id">_</span> + <span class="id">_</span>] := <span class="id">entn</span> <span class="id">n</span>; <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.classical.classical_sets.html#subTset">subTset</a></span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id">t</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#I">I</a></span>)[<span class="id">W</span> <span class="id">cbW</span> <span class="id">Wt</span>]; <span class="kwd">exists</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#existT">existT</a></span> <span class="id">_</span> <span class="id">W</span> <span class="id">cbW</span>) =&gt; //.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.embed_refine">embed_refine</a></span>; <span class="id">case</span>: <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> =&gt; //=; <span class="id">apply</span>: <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#absurd">absurd</a></span>; <span class="kwd">exists</span> <span class="id">t</span>.<br/>
- <span class="id">move</span>=&gt; <span class="id">n</span> <span class="id">U</span> <span class="id">e</span> [<span class="id">clU</span> <span class="id">Un0</span>]; <span class="id">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.topology.html#closedI">closedI</a></span> =&gt; //; <span class="id">case</span>: <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> =&gt; //= ?.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>: <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> =&gt; ?; [<span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.Kn_closed">Kn_closed</a></span>|<span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#closed0">closed0</a></span>].<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.embed_refine">embed_refine</a></span>; <span class="id">case</span>: <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> =&gt; //= ?; <span class="id">case</span>: <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">case</span>=&gt; <span class="id">i</span> [<span class="id">z</span> [<span class="id">pz</span> <span class="id">bz</span>]]; <span class="id">set</span> <span class="id">P</span> := <span class="id"><a href="mathcomp.classical.boolp.html#cid">cid</a></span> <span class="id">_</span>; <span class="id">have</span> := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">projT2</a></span> <span class="id">P</span>; <span class="id">apply</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span>: <span class="id">Un0</span> =&gt; <span class="id">z</span> <span class="id">Uz</span>; <span class="id">apply</span>: <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#absurd">absurd</a></span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [//|<span class="id">_</span> <span class="id">_</span> <span class="id">_</span> + <span class="id">_</span>] := <span class="id">entn</span> <span class="id">n</span>; <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.classical.classical_sets.html#subTset">subTset</a></span>; <span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id">z</span> <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Logic.html#I">I</a></span>)[<span class="id">i</span> <span class="id">bi</span> <span class="id">iz</span>].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#existT">existT</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">bi</span>), <span class="id">z</span>.<br/>
- <span class="kwd">by</span> <span class="id">split</span>; [<span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#closedT">closedT</a></span> | <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#point">point</a></span>].<br/>
- <span class="id">move</span>=&gt; <span class="id">x</span> <span class="id">y</span> <span class="id">xny</span>; <span class="id">move</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.hsdfT">hsdfT</a></span>; <span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#open_hausdorff">open_hausdorff</a></span>.<br/>
&nbsp;&nbsp;<span class="id">move</span>=&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">xny</span>)[[<span class="id">U</span> <span class="id">V</span>]] /= [/<span class="id"><a href="mathcomp.classical.classical_sets.html#set_mem">set_mem</a></span> <span class="id">Ux</span> /<span class="id"><a href="mathcomp.classical.classical_sets.html#set_mem">set_mem</a></span> <span class="id">Vy</span>] [+ <span class="id">oV</span> <span class="id">UVI0</span>].<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id"><a href="mathcomp.analysis.topology.html#openE">openE</a></span> =&gt; /(<span class="id">_</span> <span class="id">_</span> <span class="id">Ux</span>); <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.topology.html#interior">interior</a></span> -<span class="id"><a href="mathcomp.analysis.topology.html#nbhs_entourageE">nbhs_entourageE</a></span> =&gt; -[<span class="id">E</span> <span class="id">entE</span> <span class="id">ExU</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> [//| <span class="id">n</span> <span class="id">ctE</span>] :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.count_unif_sub">count_unif_sub</a></span> (<span class="id"><a href="mathcomp.analysis.topology.html#split_ent">split_ent</a></span> <span class="id">E</span> `&amp;` (<span class="id"><a href="mathcomp.analysis.topology.html#split_ent">split_ent</a></span> <span class="id">E</span>)^-1%<span class="id">classic</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#filterI">filterI</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id">n</span> =&gt; <span class="id">B</span> [<span class="id">C</span> <span class="id">ebC</span>]; <span class="id">have</span> [//|<span class="id">_</span> <span class="id">Csub</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">embx</span> <span class="id">emby</span>] := <span class="id">entn</span> <span class="id">n</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> [[<span class="id">D</span> <span class="id">cbD</span>] /= <span class="id">Dx</span> <span class="id">Dy</span>] : <span class="kwd">exists2</span> <span class="id"><a name="e:138">e</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.K">K</a></span> <span class="id">n</span>, <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">projT1</a></span> <span class="id">e</span> <span class="id">x</span> &amp; <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">projT1</a></span> <span class="id">e</span> <span class="id">y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move</span>: <span class="id">embx</span> <span class="id">emby</span>; <span class="id">rewrite</span> /<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.embed_refine">embed_refine</a></span>; <span class="id">case</span>: <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> =&gt; /=.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; ? [? ?] [? ?]; <span class="kwd">exists</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#existT">existT</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">ebC</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case</span>: <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span>; <span class="id">last</span> <span class="kwd">by</span> <span class="id">move</span> =&gt; ? ? [].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">e</span> <span class="id">_</span> [? ?] [? ?]; <span class="kwd">exists</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">projT1</a></span> (<span class="id"><a href="mathcomp.classical.boolp.html#cid">cid</a></span> <span class="id">e</span>)).<br/>
&nbsp;&nbsp;<span class="id">suff</span> : <span class="id">E</span> (<span class="id">x</span>, <span class="id">y</span>) <span class="kwd">by</span> <span class="id">move</span>/<span class="id">ExU</span>; <span class="id">move</span>/<span class="id">eqP</span>/<span class="id"><a href="mathcomp.classical.classical_sets.html#disjoints_subset">disjoints_subset</a></span>: <span class="id">UVI0</span> =&gt; /[<span class="id">apply</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> [<span class="id">z</span> [<span class="id">Dz</span> <span class="id">DzE</span>]] := <span class="id">Csub</span> <span class="id">_</span> <span class="id">cbD</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span> /<span class="id"><a href="mathcomp.analysis.topology.html#ent_closure">ent_closure</a></span>:= <span class="id">DzE</span> <span class="id">_</span> <span class="id">Dx</span> =&gt; /(<span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.ent_count_unif">ent_count_unif</a></span> <span class="id">n</span>))/<span class="id">ctE</span> [<span class="id">_</span> /= <span class="id">Exz</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> /<span class="id"><a href="mathcomp.analysis.topology.html#ent_closure">ent_closure</a></span>:= <span class="id">DzE</span> <span class="id">_</span> <span class="id">Dy</span> =&gt; /(<span class="id">_</span> (<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.ent_count_unif">ent_count_unif</a></span> <span class="id">n</span>))/<span class="id">ctE</span> [<span class="id">Ezy</span> <span class="id">_</span>].<br/>
&nbsp;&nbsp;<span class="id">exact</span>: (@<span class="id"><a href="mathcomp.analysis.topology.html#entourage_split">entourage_split</a></span> [<span class="id">uniformType</span> <span class="id">of</span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>] <span class="id">z</span>).<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">f</span> [<span class="id">ctsf</span> <span class="id">surjf</span> <span class="id">_</span>]; <span class="kwd">exists</span> <span class="id">f</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id"><a name="cantor_surj_pt2">cantor_surj_pt2</a></span> :<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id"><a name="f:140">f</a></span> : {<span class="id">surj</span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_space">cantor_space</a></span>] &gt;-&gt; [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.Tree">Tree</a></span>]}, <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">f</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof34')">Proof.</span></div>
<div class="proofscript" id="proof34">
<span class="id">have</span> [|<span class="id">f</span> [<span class="id">ctsf</span> <span class="id">_</span>]] := @<span class="id"><a href="mathcomp.analysis.cantor.html#homeomorphism_cantor_like">homeomorphism_cantor_like</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.R">R</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.Tree">Tree</a></span>; <span class="id">last</span> <span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">f</span>.<br/>
<span class="id">apply</span>: (@<span class="id"><a href="mathcomp.analysis.cantor.html#cantor_like_finite_prod">cantor_like_finite_prod</a></span> <span class="id">_</span> (@<span class="id"><a href="mathcomp.analysis.cantor.html#pointed_discrete">pointed_discrete</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.R">R</a></span> \<span class="id">o</span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.K">K</a></span>)) =&gt; [<span class="id">n</span> /=|<span class="id">n</span>].<br/>
&nbsp;&nbsp;<span class="id">have</span> [//| <span class="id">fs</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>] := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">projT2</a></span> (<span class="id"><a href="mathcomp.classical.boolp.html#cid">cid</a></span> (<span class="id">ent_balls</span>' (<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.count_unif">count_unif</a></span> <span class="id">n</span>))).<br/>
&nbsp;&nbsp;<span class="id">suff</span> -&gt; : [<span class="id">set</span>: {<span class="id">classic</span> <span class="id">K</span>' <span class="id">n</span>}] =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">projT1</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>) <span class="id">_</span>) @^-1` (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT1">projT1</a></span> (<span class="id"><a href="mathcomp.classical.boolp.html#cid">cid</a></span> (<span class="id">ent_balls</span>' (<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.count_unif">count_unif</a></span> <span class="id">n</span>)))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.classical.cardinality.html#finite_preimage">finite_preimage</a></span> =&gt; // ? ? <span class="id">_</span> <span class="id">_</span>; <span class="id">exact</span>: <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#eq_sigT_hprop">eq_sigT_hprop</a></span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#eqEsubset">eqEsubset</a></span>; <span class="id">split</span> =&gt; // -[].<br/>
<span class="id">have</span> [//| <span class="id">_</span> <span class="id">_</span> [<span class="id">A</span> [<span class="id">B</span> [<span class="id">pA</span> [<span class="id">pB</span> <span class="id">AB</span>]]]] <span class="id">_</span> <span class="id">_</span>] :=<br/>
&nbsp;&nbsp;<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#projT2">projT2</a></span> (<span class="id"><a href="mathcomp.classical.boolp.html#cid">cid</a></span> (<span class="id">ent_balls</span>' (<span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed.count_unif">count_unif</a></span> <span class="id">n</span>))).<br/>
<span class="kwd">exists</span> (<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#existT">existT</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">pA</span>, <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Init.Specif.html#existT">existT</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id">pB</span>) =&gt; /=.<br/>
<span class="kwd">by</span> <span class="id">move</span>: <span class="id">AB</span>; <span class="id">apply</span>: <span class="id">contra_neq</span> =&gt; -[].<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="kwd">Lemma</span> <span class="id"><a name="cantor_surj_twop">cantor_surj_twop</a></span> :<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id"><a name="f:141">f</a></span> : {<span class="id">surj</span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_space">cantor_space</a></span>] &gt;-&gt; [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>]}, <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">f</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof35')">Proof.</span></div>
<div class="proofscript" id="proof35">
<span class="id">move</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_surj_pt2">cantor_surj_pt2</a></span> <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_surj_pt1">cantor_surj_pt1</a></span> =&gt; -[<span class="id">f</span> <span class="id">ctsf</span>] [<span class="id">g</span> <span class="id">ctsg</span> /<span class="id"><a href="mathcomp.classical.functions.html#Psurj">Psurj</a></span>[<span class="id">sjg</span> <span class="id">gsjg</span>]].<br/>
<span class="kwd">exists</span> [<span class="id">surj</span> <span class="id">of</span> <span class="id">sjg</span> \<span class="id">o</span> <span class="id">f</span>] =&gt; <span class="id">z</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span> <span class="id"><a href="mathcomp.analysis.topology.html#continuous_comp">continuous_comp</a></span>; [<span class="id">exact</span>: <span class="id">ctsf</span>|<span class="id">rewrite</span> -<span class="id">gsjg</span>; <span class="id">exact</span>: <span class="id">ctsg</span>].<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.two_pointed">two_pointed</a></span>.<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id"><a name="cantor_surj">cantor_surj</a></span> :<br/>
&nbsp;&nbsp;<span class="kwd">exists</span> <span class="id"><a name="f:142">f</a></span> : {<span class="id">surj</span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_space">cantor_space</a></span>] &gt;-&gt; [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>]}, <span class="id"><a href="mathcomp.analysis.topology.html#continuous">continuous</a></span> <span class="id">f</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof36')">Proof.</span></div>
<div class="proofscript" id="proof36">
<span class="id">have</span> [[<span class="id">p</span> <span class="id">ppt</span>]|/<span class="id"><a href="mathcomp.classical.boolp.html#forallNP">forallNP</a></span> <span class="id">xpt</span>] := <span class="id"><a href="mathcomp.classical.boolp.html#pselect">pselect</a></span> (<span class="kwd">exists</span> <span class="id"><a name="p:143">p</a></span> : <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>, <span class="id">p</span> != <span class="id"><a href="mathcomp.classical.classical_sets.html#point">point</a></span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_surj_twop">cantor_surj_twop</a></span>; <span class="id">exact</span>: <span class="id">ppt</span>.<br/>
<span class="id">have</span> /<span class="id"><a href="mathcomp.classical.functions.html#Psurj">Psurj</a></span>[<span class="id">f</span> <span class="id">cstf</span>] : <span class="id"><a href="mathcomp.classical.functions.html#set_surj">set_surj</a></span> [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#cantor_space">cantor_space</a></span>] [<span class="id">set</span>: <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff.T">T</a></span>] (<span class="id"><a href="mathcomp.classical.functions.html#cst">cst</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#point">point</a></span>).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">q</span> <span class="id">_</span>; <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#point">point</a></span> =&gt; //; <span class="id">have</span> /<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negP">negP</a></span>/<span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#negPn">negPn</a></span>/<span class="id">eqP</span> -&gt; := <span class="id">xpt</span> <span class="id">q</span>.<br/>
<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id">f</span>; <span class="id">rewrite</span> -<span class="id">cstf</span>; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.topology.html#cst_continuous">cst_continuous</a></span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.cantor.html#alexandroff_hausdorff">alexandroff_hausdorff</a></span>.<br/>

</div>
<div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/tree/yoshihiro503%40generate_index">a fork of coq2html</a></div>
</body>
</html>
