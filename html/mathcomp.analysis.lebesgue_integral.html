
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.analysis.lebesgue_integral</title>
<meta name="description" content="Documentation of Coq module mathcomp.analysis.lebesgue_integral" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>

<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init('proofscript')">
<h1 class="title">Module mathcomp.analysis.lebesgue_integral</h1>
<div class="coq">
<span class="kwd">From</span> <span class="id">HB</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">structures</span>.<br/>
<span class="kwd">From</span> <span class="id">mathcomp</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">all_ssreflect</span> <span class="id">ssralg</span> <span class="id">ssrnum</span> <span class="id">ssrint</span> <span class="id">interval</span> <span class="id">finmap</span>.<br/>
<span class="kwd">From</span> <span class="id">mathcomp</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id"><a href="mathcomp.classical.mathcomp_extra.html">mathcomp_extra</a></span> <span class="id"><a href="mathcomp.classical.boolp.html">boolp</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html">classical_sets</a></span> <span class="id"><a href="mathcomp.classical.functions.html">functions</a></span>.<br/>
<span class="kwd">From</span> <span class="id">mathcomp</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id"><a href="mathcomp.classical.cardinality.html">cardinality</a></span> <span class="id"><a href="mathcomp.classical.fsbigop.html">fsbigop</a></span> .<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id"><a href="mathcomp.analysis.signed.html">signed</a></span> <span class="id"><a href="mathcomp.analysis.reals.html">reals</a></span> <span class="id"><a href="mathcomp.analysis.ereal.html">ereal</a></span> <span class="id"><a href="mathcomp.analysis.topology.html">topology</a></span> <span class="id"><a href="mathcomp.analysis.normedtype.html">normedtype</a></span> <span class="id"><a href="mathcomp.analysis.sequences.html">sequences</a></span> <span class="id"><a href="mathcomp.analysis.real_interval.html">real_interval</a></span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id"><a href="mathcomp.analysis.esum.html">esum</a></span> <span class="id"><a href="mathcomp.analysis.measure.html">measure</a></span> <span class="id"><a href="mathcomp.analysis.lebesgue_measure.html">lebesgue_measure</a></span> <span class="id"><a href="mathcomp.analysis.numfun.html">numfun</a></span>.<br/>
<br/>
<pre class="ssrdoc">
                           Lebesgue Integral                               
                                                                           
This file contains a formalization of the Lebesgue integral. It starts     
with simple functions and their integral, provides basic operations        
(addition, etc.), and proves the properties of their integral              
(semi-linearity, non-decreasingness). It then defines the integral of      
measurable functions, proves the approximation theorem, the properties of  
their integral (semi-linearity, non-decreasingness), the monotone          
convergence theorem, and Fatou's lemma. Finally, it proves the linearity   
properties of the integral, the dominated convergence theorem and Fubini's 
theorem.                                                                   
                                                                           
Main reference:                                                            
- Daniel Li, Int√©gration et applications, 2016                             
                                                                           
        {mfun T &gt;-&gt; R} == type of real-valued measurable functions         
        {sfun T &gt;-&gt; R} == type of simple functions                         
      {nnsfun T &gt;-&gt; R} == type of non-negative simple functions            
          cst_nnsfun r == constant simple function                         
               nnsfun0 := cst_nnsfun 0                                     
        sintegral mu f == integral of the function f with the measure mu   
 \int[mu]_(x in D) f x == integral of the measurable function f over the   
                          domain D with measure mu                         
        \int[mu]_x f x := \int[mu]_(x in setT) f x                         
        dyadic_itv n k == the interval                                     
                          `[(k%:R * 2 ^- n), (k.+1%:R * 2 ^- n)[           
            approx D f == nondecreasing sequence of functions that         
                          approximates f over D using dyadic intervals     
      Rintegral mu D f := fine (\int[mu]_(x in D) f x).                    
    mu.-integrable D f == f is measurable over D and the integral of f     
                          w.r.t. D is &lt; +oo                                
           ae_eq D f g == f is equal to g almost everywhere                
              m1 \x m2 == product measure over T1 * T2, m1 is a measure    
                          measure over T1, and m2 is a sigma finite        
                          measure over T2                                  
             m1 \x^ m2 == product measure over T1 * T2, m2 is a measure    
                          measure over T1, and m1 is a sigma finite        
                          measure over T2                                  
                                                                           
</pre>
<br/>
<span class="kwd">Set</span> <span class="kwd">Implicit</span> <span class="kwd">Arguments</span>.<br/>
<span class="id">Unset</span> <span class="id">Strict</span> <span class="kwd">Implicit</span>.<br/>
<span class="id">Unset</span> <span class="id">Printing</span> <span class="kwd">Implicit</span> <span class="id">Defensive</span>.<br/>
<span class="kwd">Import</span> <span class="id">Order.TTheory</span> <span class="id">GRing.Theory</span> <span class="id">Num.Def</span> <span class="id">Num.Theory</span>.<br/>
<span class="kwd">Import</span> <span class="id"><a href="mathcomp.analysis.topology.html#numFieldTopology.Exports">numFieldTopology.Exports</a></span>.<br/>
<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">classical_set_scope</span>.<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">ring_scope</span>.<br/>
<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "\<span class="id">int</span> [ <span class="id">mu</span> ]<span class="id">_</span> ( <span class="id">i</span> '<span class="kwd">in</span>' <span class="id">D</span> ) <span class="id">F</span>"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 36, <span class="id">F</span> <span class="kwd">at</span> <span class="id">level</span> 36, <span class="id">mu</span> <span class="kwd">at</span> <span class="id">level</span> 10, <span class="id">i</span>, <span class="id">D</span> <span class="kwd">at</span> <span class="id">level</span> 50,<br/>
&nbsp;&nbsp;<span class="id">format</span> "'[' \<span class="id">int</span> [ <span class="id">mu</span> ]<span class="id">_</span> ( <span class="id">i</span>  '<span class="kwd">in</span>'  <span class="id">D</span> ) '/  '  <span class="id">F</span> ']'").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "\<span class="id">int</span> [ <span class="id">mu</span> ]<span class="id">_</span> <span class="id">i</span> <span class="id">F</span>"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 36, <span class="id">F</span> <span class="kwd">at</span> <span class="id">level</span> 36, <span class="id">mu</span> <span class="kwd">at</span> <span class="id">level</span> 10, <span class="id">i</span> <span class="kwd">at</span> <span class="id">level</span> 0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">right</span> <span class="id">associativity</span>, <span class="id">format</span> "'[' \<span class="id">int</span> [ <span class="id">mu</span> ]<span class="id">_</span> <span class="id">i</span> '/  '  <span class="id">F</span> ']'").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">mu</span> .-<span class="id">integrable</span>" (<span class="kwd">at</span> <span class="id">level</span> 2, <span class="id">format</span> "<span class="id">mu</span> .-<span class="id">integrable</span>").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">m1</span> '\<span class="id">x</span>' <span class="id">m2</span>" (<span class="kwd">at</span> <span class="id">level</span> 40, <span class="id">m2</span> <span class="kwd">at</span> <span class="id">next</span> <span class="id">level</span>).<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "<span class="id">m1</span> '\<span class="id">x</span>^' <span class="id">m2</span>" (<span class="kwd">at</span> <span class="id">level</span> 40, <span class="id">m2</span> <span class="kwd">at</span> <span class="id">next</span> <span class="id">level</span>).<br/>
<br/>
#[<span class="id">global</span>]<br/>
<span class="kwd">Hint</span> <span class="id">Extern</span> 0 (<span class="id"><a href="mathcomp.analysis.measure.html#measurable">measurable</a></span> [<span class="id">set</span> <span class="id">_</span>]) =&gt; <span class="id">solve</span> [<span class="id">apply</span>: <span class="id"><a href="mathcomp.analysis.lebesgue_measure.html#measurable_set1">measurable_set1</a></span>] : <span class="id">core</span>.<br/>
<br/>
<span class="id"><a name="isMeasurableFun">HB.mixin</a></span> <span class="kwd">Record</span> <span class="id">isMeasurableFun</span> <span class="id"><a name="d:1">d</a></span> (<span class="id"><a name="aT:2">aT</a></span> : <span class="id"><a href="mathcomp.analysis.measure.html#Measurable.Exports.measurableType">measurableType</a></span> <span class="id">d</span>) (<span class="id"><a name="rT:3">rT</a></span> : <span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">realType</a></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id"><a name="f:4">f</a></span> : <span class="id">aT</span> -&gt; <span class="id">rT</span>) := {<br/>
&nbsp;&nbsp;<span class="id"><a name="measurable_funP:5">measurable_funP</a></span> : <span class="id"><a href="mathcomp.analysis.measure.html#measurable_fun">measurable_fun</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> <span class="id">f</span><br/>
}.<br/>
<span class="id"><a name="MeasurableFun">HB.structure</a></span> <span class="kwd">Definition</span> <span class="id">MeasurableFun</span> <span class="id"><a name="d:10">d</a></span> <span class="id"><a name="aT:11">aT</a></span> <span class="id"><a name="rT:12">rT</a></span> :=<br/>
&nbsp;&nbsp;{<span class="id"><a name="f:13">f</a></span> <span class="id">of</span> @<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#isMeasurableFun">isMeasurableFun</a></span> <span class="id">d</span> <span class="id">aT</span> <span class="id">rT</span> <span class="id">f</span>}.<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">mfun</span>' <span class="id">aT</span> &gt;-&gt; <span class="id">T</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "{ '<span class="id">mfun</span>'  <span class="id">aT</span>  &gt;-&gt;  <span class="id">T</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "[ '<span class="id">mfun</span>' '<span class="id">of</span>' <span class="id">f</span> ]"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">mfun</span>'  '<span class="id">of</span>'  <span class="id">f</span> ]").<br/>
<span class="kwd">Notation</span> "{ '<span class="id">mfun</span>' <span class="id">aT</span> &gt;-&gt; <span class="id">T</span> }" := (@<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#type">MeasurableFun.type</a></span> <span class="id">_</span> <span class="id">aT</span> <span class="id">T</span>) : <span class="id">form_scope</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">mfun</span>' '<span class="id">of</span>' <span class="id">f</span> ]" := [<span class="id">the</span> {<span class="id">mfun</span> <span class="id">_</span> &gt;-&gt; <span class="id">_</span>} <span class="id">of</span> <span class="id">f</span>] : <span class="id">form_scope</span>.<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Resolve</span> <span class="id">measurable_funP</span> : <span class="id">core</span>.<br/>
<br/>
<span class="id"><a name="SimpleFun">HB.structure</a></span> <span class="kwd">Definition</span> <span class="id">SimpleFun</span> <span class="id"><a name="d:16">d</a></span> (<span class="id"><a name="aT:17">aT</a></span> : <span class="id"><a href="mathcomp.analysis.measure.html#Measurable.Exports.measurableType">measurableType</a></span> <span class="id">d</span>) (<span class="id"><a name="rT:18">rT</a></span> : <span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">realType</a></span>) :=<br/>
&nbsp;&nbsp;{<span class="id"><a name="f:19">f</a></span> <span class="id">of</span> @<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#isMeasurableFun">isMeasurableFun</a></span> <span class="id">d</span> <span class="id">aT</span> <span class="id">rT</span> <span class="id">f</span> &amp; @<span class="id"><a href="mathcomp.classical.cardinality.html#FiniteImage">FiniteImage</a></span> <span class="id">aT</span> <span class="id">rT</span> <span class="id">f</span>}.<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">sfun</span>' <span class="id">aT</span> &gt;-&gt; <span class="id">T</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "{ '<span class="id">sfun</span>'  <span class="id">aT</span>  &gt;-&gt;  <span class="id">T</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "[ '<span class="id">sfun</span>' '<span class="id">of</span>' <span class="id">f</span> ]"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">sfun</span>'  '<span class="id">of</span>'  <span class="id">f</span> ]").<br/>
<span class="kwd">Notation</span> "{ '<span class="id">sfun</span>' <span class="id">aT</span> &gt;-&gt; <span class="id">T</span> }" := (@<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#type">SimpleFun.type</a></span> <span class="id">_</span> <span class="id">aT</span> <span class="id">T</span>) : <span class="id">form_scope</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">sfun</span>' '<span class="id">of</span>' <span class="id">f</span> ]" := [<span class="id">the</span> {<span class="id">sfun</span> <span class="id">_</span> &gt;-&gt; <span class="id">_</span>} <span class="id">of</span> <span class="id">f</span>] : <span class="id">form_scope</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="measurable_sfunP">measurable_sfunP</a></span> {<span class="id"><a name="d:22">d</a></span>} {<span class="id"><a name="aT:23">aT</a></span> : <span class="id"><a href="mathcomp.analysis.measure.html#Measurable.Exports.measurableType">measurableType</a></span> <span class="id">d</span>} {<span class="id"><a name="rT:24">rT</a></span> : <span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">realType</a></span>}<br/>
&nbsp;&nbsp;(<span class="id"><a name="f:25">f</a></span> : {<span class="id">mfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>}) (<span class="id"><a name="Y:26">Y</a></span> : <span class="id"><a href="mathcomp.classical.classical_sets.html#set">set</a></span> <span class="id">rT</span>) : <span class="id"><a href="mathcomp.analysis.measure.html#measurable">measurable</a></span> <span class="id">Y</span> -&gt; <span class="id"><a href="mathcomp.analysis.measure.html#measurable">measurable</a></span> (<span class="id">f</span> @^-1` <span class="id">Y</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof1')">Proof.</span></div>
<div class="proofscript" id="proof1">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">mY</span>; <span class="id">rewrite</span> -[<span class="id">f</span> @^-1` <span class="id">_</span>]<span class="id"><a href="mathcomp.classical.classical_sets.html#setTI">setTI</a></span>; <span class="id">exact</span>: <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#measurable_funP">measurable_funP</a></span>. Qed.</div>
<br/>
<span class="id"><a name="NonNegSimpleFun">HB.structure</a></span> <span class="kwd">Definition</span> <span class="id">NonNegSimpleFun</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id"><a name="d:27">d</a></span> (<span class="id"><a name="aT:28">aT</a></span> : <span class="id"><a href="mathcomp.analysis.measure.html#Measurable.Exports.measurableType">measurableType</a></span> <span class="id">d</span>) (<span class="id"><a name="rT:29">rT</a></span> : <span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">realType</a></span>) :=<br/>
&nbsp;&nbsp;{<span class="id"><a name="f:30">f</a></span> <span class="id">of</span> @<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#SimpleFun">SimpleFun</a></span> <span class="id">d</span> <span class="id">_</span> <span class="id">_</span> <span class="id">f</span> &amp; @<span class="id"><a href="mathcomp.analysis.numfun.html#NonNegFun">NonNegFun</a></span> <span class="id">aT</span> <span class="id">rT</span> <span class="id">f</span>}.<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "{ '<span class="id">nnsfun</span>' <span class="id">aT</span> &gt;-&gt; <span class="id">T</span> }"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "{ '<span class="id">nnsfun</span>'  <span class="id">aT</span>  &gt;-&gt;  <span class="id">T</span> }").<br/>
<span class="kwd">Reserved</span> <span class="kwd">Notation</span> "[ '<span class="id">nnsfun</span>' '<span class="id">of</span>' <span class="id">f</span> ]"<br/>
&nbsp;&nbsp;(<span class="kwd">at</span> <span class="id">level</span> 0, <span class="id">format</span> "[ '<span class="id">nnsfun</span>'  '<span class="id">of</span>'  <span class="id">f</span> ]").<br/>
<span class="kwd">Notation</span> "{ '<span class="id">nnsfun</span>' <span class="id">aT</span> &gt;-&gt; <span class="id">T</span> }" := (@<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#type">NonNegSimpleFun.type</a></span> <span class="id">_</span> <span class="id">aT</span>%<span class="id">type</span> <span class="id">T</span>) : <span class="id">form_scope</span>.<br/>
<span class="kwd">Notation</span> "[ '<span class="id">nnsfun</span>' '<span class="id">of</span>' <span class="id">f</span> ]" := [<span class="id">the</span> {<span class="id">nnsfun</span> <span class="id">_</span> &gt;-&gt; <span class="id">_</span>} <span class="id">of</span> <span class="id">f</span>] : <span class="id">form_scope</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="mfun_pred">mfun_pred</a></span>.<br/>
<span class="kwd">Context</span> {<span class="id"><a name="d:33">d</a></span>} {<span class="id"><a name="aT:34">aT</a></span> : <span class="id"><a href="mathcomp.analysis.measure.html#Measurable.Exports.measurableType">measurableType</a></span> <span class="id">d</span>} {<span class="id"><a name="rT:35">rT</a></span> : <span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">realType</a></span>}.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="mfun">mfun</a></span> : {<span class="id">pred</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun_pred.aT">aT</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun_pred.rT">rT</a></span>} := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#mem">mem</a></span> [<span class="id">set</span> <span class="id"><a name="f:36">f</a></span> | <span class="id"><a href="mathcomp.analysis.measure.html#measurable_fun">measurable_fun</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span> <span class="id">f</span>].<br/>
<span class="kwd">Definition</span> <span class="id"><a name="mfun_key">mfun_key</a></span> : <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#pred_key">pred_key</a></span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun">mfun</a></span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof2')">Proof.</span></div>
<div class="proofscript" id="proof2">
 <span class="id">exact</span>. Qed.</div>
<span class="kwd">Canonical</span> <span class="id"><a name="mfun_keyed">mfun_keyed</a></span> := <span class="id"><a href="https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.ssr.ssrbool.html#KeyedPred">KeyedPred</a></span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun_key">mfun_key</a></span>.<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun_pred">mfun_pred</a></span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id"><a name="mfun">mfun</a></span>.<br/>
<span class="kwd">Context</span> {<span class="id"><a name="d:37">d</a></span>} {<span class="id"><a name="aT:38">aT</a></span> : <span class="id"><a href="mathcomp.analysis.measure.html#Measurable.Exports.measurableType">measurableType</a></span> <span class="id">d</span>} {<span class="id"><a name="rT:39">rT</a></span> : <span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">realType</a></span>}.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="T">T</a></span> := {<span class="id">mfun</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.aT">aT</a></span> &gt;-&gt; <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.rT">rT</a></span>}.<br/>
<span class="kwd">Notation</span> <span class="id"><a name="mfun">mfun</a></span> := (@<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun">mfun</a></span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.aT">aT</a></span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.rT">rT</a></span>).<br/>
<span class="kwd">Section</span> <span class="id"><a name="mfun.Sub">Sub</a></span>.<br/>
<span class="kwd">Context</span> (<span class="id"><a name="f:40">f</a></span> : <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.aT">aT</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.rT">rT</a></span>) (<span class="id"><a name="fP:41">fP</a></span> : <span class="id">f</span> \<span class="kwd">in</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun">mfun</a></span>).<br/>
<span class="kwd">Definition</span> <span class="id"><a name="mfun_Sub_subproof">mfun_Sub_subproof</a></span> := @<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#Build">isMeasurableFun.Build</a></span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.d">d</a></span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.aT">aT</a></span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.rT">rT</a></span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.Sub.f">f</a></span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set_mem">set_mem</a></span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.Sub.fP">fP</a></span>).<br/>
#[<span class="id">local</span>] <span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> := <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun_Sub_subproof">mfun_Sub_subproof</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="mfun_Sub">mfun_Sub</a></span> := [<span class="id">mfun</span> <span class="id">of</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.Sub.f">f</a></span>].<br/>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.Sub">Sub</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="mfun_rect">mfun_rect</a></span> (<span class="id"><a name="K:42">K</a></span> : <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#T">T</a></span> -&gt; <span class="kwd">Type</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id"><a name="f:43">f</a></span> (<span class="id"><a name="Pf:44">Pf</a></span> : <span class="id">f</span> \<span class="kwd">in</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun">mfun</a></span>), <span class="id">K</span> (<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun_Sub">mfun_Sub</a></span> <span class="id">Pf</span>)) -&gt; <span class="kwd">forall</span> <span class="id"><a name="u:45">u</a></span> : <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#T">T</a></span>, <span class="id">K</span> <span class="id">u</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof3')">Proof.</span></div>
<div class="proofscript" id="proof3">
<span class="id">move</span>=&gt; <span class="id">Ksub</span> [<span class="id">f</span> [[<span class="id">Pf</span>]]]/=.<br/>
<span class="kwd">by</span> <span class="id">suff</span> -&gt; : <span class="id">Pf</span> = (<span class="id"><a href="mathcomp.classical.classical_sets.html#set_mem">set_mem</a></span> (@<span class="id"><a href="mathcomp.classical.classical_sets.html#mem_set">mem_set</a></span> <span class="id">_</span> [<span class="id">set</span> <span class="id"><a name="f:46">f</a></span> | <span class="id">_</span>] <span class="id">f</span> <span class="id">Pf</span>)) <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">Ksub</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="mfun_valP">mfun_valP</a></span> <span class="id"><a name="f:47">f</a></span> (<span class="id"><a name="Pf:48">Pf</a></span> : <span class="id">f</span> \<span class="kwd">in</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun">mfun</a></span>) : <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun_Sub">mfun_Sub</a></span> <span class="id">Pf</span> = <span class="id">f</span> :&gt; (<span class="id">_</span> -&gt; <span class="id">_</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof4')">Proof.</span></div>
<div class="proofscript" id="proof4">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="mfun_subType">mfun_subType</a></span> := <span class="id">SubType</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#T">T</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun_rect">mfun_rect</a></span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun_valP">mfun_valP</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="mfuneqP">mfuneqP</a></span> (<span class="id"><a name="f:49">f</a></span> <span class="id"><a name="g:50">g</a></span> : {<span class="id">mfun</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.aT">aT</a></span> &gt;-&gt; <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.rT">rT</a></span>}) : <span class="id">f</span> = <span class="id">g</span> &lt;-&gt; <span class="id">f</span> =1 <span class="id">g</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof5')">Proof.</span></div>
<div class="proofscript" id="proof5">
 <span class="kwd">by</span> <span class="id">split</span>=&gt; [-&gt;//|<span class="id">fg</span>]; <span class="id">apply</span>/<span class="id">val_inj</span>/<span class="id"><a href="mathcomp.classical.boolp.html#funext">funext</a></span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="mfuneqMixin">mfuneqMixin</a></span> := [<span class="id">eqMixin</span> <span class="id">of</span> {<span class="id">mfun</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.aT">aT</a></span> &gt;-&gt; <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.rT">rT</a></span>} <span class="kwd">by</span> &lt;:].<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="mfuneqType">mfuneqType</a></span> := <span class="id">EqType</span> {<span class="id">mfun</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.aT">aT</a></span> &gt;-&gt; <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.rT">rT</a></span>} <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfuneqMixin">mfuneqMixin</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="mfunchoiceMixin">mfunchoiceMixin</a></span> := [<span class="id">choiceMixin</span> <span class="id">of</span> {<span class="id">mfun</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.aT">aT</a></span> &gt;-&gt; <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.rT">rT</a></span>} <span class="kwd">by</span> &lt;:].<br/>
<span class="kwd">Canonical</span> <span class="id"><a name="mfunchoiceType">mfunchoiceType</a></span> := <span class="id">ChoiceType</span> {<span class="id">mfun</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.aT">aT</a></span> &gt;-&gt; <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.rT">rT</a></span>} <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfunchoiceMixin">mfunchoiceMixin</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="cst_mfun_subproof">cst_mfun_subproof</a></span> <span class="id"><a name="x:51">x</a></span> : @<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#isMeasurableFun">isMeasurableFun</a></span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.d">d</a></span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.aT">aT</a></span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.rT">rT</a></span> (<span class="id"><a href="mathcomp.classical.functions.html#cst">cst</a></span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof6')">Proof.</span></div>
<div class="proofscript" id="proof6">
 <span class="kwd">by</span> <span class="id">split</span>. Qed.</div>
<span class="id"><a name="mfun.hb_instance_19">HB.instance</a></span> <span class="kwd">Definition</span> <span class="id">_</span> <span class="id"><a name="x:52">x</a></span> := @<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#cst_mfun_subproof">cst_mfun_subproof</a></span> <span class="id">x</span>.<br/>
<span class="kwd">Definition</span> <span class="id"><a name="cst_mfun">cst_mfun</a></span> <span class="id"><a name="x:53">x</a></span> := [<span class="id">the</span> {<span class="id">mfun</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.aT">aT</a></span> &gt;-&gt; <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.rT">rT</a></span>} <span class="id">of</span> <span class="id"><a href="mathcomp.classical.functions.html#cst">cst</a></span> <span class="id">x</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="mfun_cst">mfun_cst</a></span> <span class="id"><a name="x:54">x</a></span> : @<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#cst_mfun">cst_mfun</a></span> <span class="id">x</span> =1 <span class="id"><a href="mathcomp.classical.functions.html#cst">cst</a></span> <span class="id">x</span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof7')">Proof.</span></div>
<div class="proofscript" id="proof7">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="id"><a name="HB_unnamed_factory_22">HB.instance</a></span> <span class="kwd">Definition</span> <span class="id">_</span> := @<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#Build">isMeasurableFun.Build</a></span> <span class="id">_</span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.rT">rT</a></span><br/>
&nbsp;&nbsp;(@<span class="id">normr</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.rT">rT</a></span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.rT">rT</a></span>) (@<span class="id"><a href="mathcomp.analysis.lebesgue_measure.html#measurable_normr">measurable_normr</a></span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun.rT">rT</a></span> <span class="id"><a href="mathcomp.classical.classical_sets.html#setT">setT</a></span>).<br/>
<br/>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> :=<br/>
&nbsp;&nbsp;<span class="id">isMeasurableFun.Build</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (@<span class="id"><a name="rT:57">expR</a></span> <span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">rT</a></span>) (@<span class="id">measurable_expR</span> <span class="id">rT</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">measurableT_comp_subproof</span> (<span class="id">f</span> : {<span class="id">mfun</span> <span class="id">_</span> &gt;-&gt; <span class="id">rT</span>}) (<span class="id">g</span> : {<span class="id">mfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>}) :<br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span> <span class="id"><a href="mathcomp.analysis.measure.html#measurable_cst">setT</a></span> (<span class="id">f</span> \<span class="id">o</span> <span class="id">g</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof8')">Proof.</span></div>
<div class="proofscript" id="proof8">
 <span class="id">apply</span>: <span class="id">measurableT_comp</span>. <span class="id">exact</span>. <span class="id">apply</span>: @<span class="id">measurable_funP</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">g</span>. Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> (<span class="id">f</span> : {<span class="id">mfun</span> <span class="id">_</span> &gt;-&gt; <span class="id"><a name="mfun_zmod">rT</a></span>}) (<span class="id">g</span> : {<span class="id">mfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>}) :=<br/>
&nbsp;&nbsp;<span class="id">isMeasurableFun.Build</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">f</span> \<span class="id">o</span> <span class="id">g</span>) (<span class="id">measurableT_comp_subproof</span> <span class="id">_</span> <span class="id">_</span>).<br/>
<br/>
<span class="kwd">End</span> <span class="id">mfun</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">ring</span>.<br/>
<span class="kwd">Context</span> <span class="id">d</span> (<span class="id">aT</span> : <span class="id">measurableType</span> <span class="id">d</span>) (<span class="id">rT</span> : <span class="id">realType</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">mfun_subring_closed</span> : <span class="id">subring_closed</span> (@<span class="id">mfun</span> <span class="id">_</span> <span class="id">aT</span> <span class="id">rT</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof9')">Proof.</span></div>
<div class="proofscript" id="proof9">
<span class="id">split</span>=&gt; [|<span class="id">f</span> <span class="id">g</span>|<span class="id">f</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#ring.aT">g</a></span>]; <span class="id">rewrite</span> !<span class="id">inE</span>/=.<br/>
- <span class="id">exact</span>: <span class="id">measurable_cst</span>.<br/>
- <span class="id">exact</span>: <span class="id">measurable_funB</span>.<br/>
- <span class="id">exact</span>: <span class="id">measurable_funM</span>.<br/>
Qed.</div>
<span class="kwd">Canonical</span> <span class="id">mfun_add</span> := <span class="id">AddrPred</span> <span class="id">mfun_subring_closed</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">mfun_zmod</span> := <span class="id">ZmodPred</span> <span class="id">mfun_subring_closed</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">mfun_mul</span> := <span class="id">MulrPred</span> <span class="id">mfun_subring_closed</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">mfun_subring</span> := <span class="id">SubringPred</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfun_comRingMixin">mfun_subring_closed</a></span>.<br/>
<span class="kwd">Definition</span> <span class="id">mfun_zmodMixin</span> := [<span class="id">zmodMixin</span> <span class="id">of</span> {<span class="id">mfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>} <span class="kwd">by</span> &lt;:].<br/>
<span class="kwd">Canonical</span> <span class="id">mfun_zmodType</span> := <span class="id">ZmodType</span> {<span class="id">mfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>} <span class="id">mfun_zmodMixin</span>.<br/>
<span class="kwd">Definition</span> <span class="id">mfun_ringMixin</span> := [<span class="id">ringMixin</span> <span class="id">of</span> {<span class="id">mfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>} <span class="kwd">by</span> &lt;:].<br/>
<span class="kwd">Canonical</span> <span class="id">mfun_ringType</span> := <span class="id">RingType</span> {<span class="id">mfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>} <span class="id">mfun_ringMixin</span>.<br/>
<span class="kwd">Definition</span> <span class="id">mfun_comRingMixin</span> := [<span class="id">comRingMixin</span> <span class="id">of</span> {<span class="id">mfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>} <span class="kwd">by</span> &lt;:].<br/>
<span class="kwd">Canonical</span> <span class="id">mfun_comRingType</span> := <span class="id">ComRingType</span> {<span class="id">mfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>} <span class="id">mfun_comRingMixin</span>.<br/>
<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> (<span class="id">f</span> <span class="id">g</span> : {<span class="id">mfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>}).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">mfun0</span> : (0 : {<span class="id">mfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#ring.aT">rT</a></span>}) =1 <span class="id">cst</span> 0 :&gt; (<span class="id">_</span> -&gt; <span class="id">_</span>)<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof10')">Proof.</span></div>
<div class="proofscript" id="proof10">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">mfun1</span> : (1 : {<span class="id">mfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>}) =1 <span class="id">cst</span> 1 :&gt; (<span class="id">_</span> -&gt; <span class="id">_</span>)<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof11')">Proof.</span></div>
<div class="proofscript" id="proof11">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">mfunN</span> <span class="id">f</span> : - <span class="id">f</span> = \- <span class="id">f</span> :&gt; (<span class="id"><a name="P:78">_</a></span> -&gt; <span class="id">_</span>)<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof12')">Proof.</span></div>
<div class="proofscript" id="proof12">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">mfunD</span> <span class="id">f</span> <span class="id">g</span> : <span class="id">f</span> + <span class="id">g</span> = <span class="id">f</span> \+ <span class="id">g</span> :&gt; (<span class="id">_</span> -&gt; <span class="id">_</span>)<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof13')">Proof.</span></div>
<div class="proofscript" id="proof13">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">mfunB</span> <span class="id">f</span> <span class="id">g</span> : <span class="id">f</span> - <span class="id">g</span> = <span class="id">f</span> \- <span class="id">g</span> :&gt; (<span class="id">_</span> -&gt; <span class="id">_</span>)<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof14')">Proof.</span></div>
<div class="proofscript" id="proof14">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">mfunM</span> <span class="id"><a name="mfunX">f</a></span> <span class="id">g</span> : <span class="id"><a name="f:87">f</a></span> * <span class="id">g</span> = <span class="id">f</span> \* <span class="id">g</span> :&gt; (<span class="id">_</span> -&gt; <span class="id">_</span>)<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof15')">Proof.</span></div>
<div class="proofscript" id="proof15">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">mfun_sum</span> <span class="id">I</span> <span class="id"><a href="mathcomp.classical.boolp.html#funext">r</a></span> (<span class="id">P</span> : {<span class="id">pred</span> <span class="id">I</span>}) (<span class="id">f</span> : <span class="id">I</span> -&gt; {<span class="id">mfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>}) (<span class="id">x</span> : <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mfunM">aT</a></span>) :<br/>
&nbsp;&nbsp;(\<span class="id">sum_</span>(<span class="id">i</span> &lt;- <span class="id">r</span> | <span class="id">P</span> <span class="id">i</span>) <span class="id">f</span> <span class="id">i</span>) <span class="id">x</span> = \<span class="id">sum_</span>(<span class="id"><a name="f:90">i</a></span> &lt;- <span class="id">r</span> | <span class="id">P</span> <span class="id">i</span>) <span class="id">f</span> <span class="id">i</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof16')">Proof.</span></div>
<div class="proofscript" id="proof16">
 <span class="kwd">by</span> <span class="id">elim</span>/<span class="id">big_rec2</span>: <span class="id">_</span> =&gt; //= <span class="id">i</span> <span class="id">y</span> ? <span class="id">Pi</span> &lt;-. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">mfun_prod</span> <span class="id">I</span> <span class="id">r</span> (<span class="id">P</span> : {<span class="id">pred</span> <span class="id">I</span>}) (<span class="id"><a name="ring.hb_instance_33">f</a></span> : <span class="id">I</span> -&gt; {<span class="id">mfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>}) (<span class="id">x</span> : <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#copy">aT</a></span>) :<br/>
&nbsp;&nbsp;(\<span class="id">sum_</span>(<span class="id">i</span> &lt;- <span class="id">r</span> | <span class="id">P</span> <span class="id">i</span>) <span class="id">f</span> <span class="id">i</span>) <span class="id">x</span> = \<span class="id">sum_</span>(<span class="id">i</span> &lt;- <span class="id">r</span> | <span class="id">P</span> <span class="id">i</span>) <span class="id">f</span> <span class="id">i</span> <span class="id"><a name="f:96">x</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof17')">Proof.</span></div>
<div class="proofscript" id="proof17">
 <span class="kwd">by</span> <span class="id">elim</span>/<span class="id">big_rec2</span>: <span class="id">_</span> =&gt; //= <span class="id">i</span> <span class="id">y</span> ? <span class="id">Pi</span> &lt;-. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">mfunX</span> <span class="id">f</span> <span class="id">n</span> : <span class="id">f</span> ^+ <span class="id">n</span> = (<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">f</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#ring.aT">x</a></span> ^+ <span class="id">n</span>) :&gt; (<span class="id">_</span> -&gt; <span class="id">_</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof18')">Proof.</span></div>
<div class="proofscript" id="proof18">
 <span class="kwd">by</span> <span class="id">apply</span>/<span class="id"><a href="mathcomp.classical.classical_sets.html#set">funext</a></span>=&gt; <span class="id"><a name="mD:100">x</a></span>; <span class="id">elim</span>: <span class="id">n</span> =&gt; [|<span class="id">n</span> <span class="id">IHn</span>]//; <span class="id">rewrite</span> !<span class="id">exprS</span> <span class="id">mfunM</span>/= <span class="id">IHn</span>. Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> <span class="id">f</span> <span class="id">g</span> := <span class="id">MeasurableFun.copy</span> (<span class="id">f</span> \+ <span class="id">g</span>) (<span class="id">f</span> + <span class="id">g</span>).<br/>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#ring.aT">f</a></span> <span class="id">g</span> := <span class="id">MeasurableFun.copy</span> (\- <span class="id"><a href="mathcomp.classical.cardinality.html#FImFun">f</a></span>) (- <span class="id">f</span>).<br/>
<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#ring.rT">HB.instance</a></span> <span class="kwd">Definition</span> <span class="id">_</span> <span class="id">f</span> <span class="id">g</span> := <span class="id">MeasurableFun.copy</span> (<span class="id">f</span> \- <span class="id">g</span>) (<span class="id">f</span> - <span class="id">g</span>).<br/>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> <span class="id">f</span> <span class="id">g</span> := <span class="id">MeasurableFun.copy</span> (<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#ring.d">f</a></span> \* <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#ring.rT">g</a></span>) (<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mindic">f</a></span> * <span class="id">g</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">mindic</span> (<span class="id">D</span> : <span class="id">set</span> <span class="id">aT</span>) <span class="id">of</span> <span class="id">measurable</span> <span class="id">D</span> : <span class="id">aT</span> -&gt; <span class="id">rT</span> := \1<span class="id">_D</span>.<br/>
<span class="kwd">Lemma</span> <span class="id">mindicE</span> (<span class="id">D</span> : <span class="id">set</span> <span class="id">aT</span>) (<span class="id">mD</span> : <span class="id">measurable</span> <span class="id">D</span>) :<br/>
&nbsp;&nbsp;<span class="id">mindic</span> <span class="id">mD</span> = (<span class="kwd">fun</span> <span class="id">x</span> =&gt; (<span class="id">x</span> \<span class="kwd">in</span> <span class="id"><a href="mathcomp.analysis.measure.html#measurableI">D</a></span>)%:<span class="id">R</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof19')">Proof.</span></div>
<div class="proofscript" id="proof19">
 <span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">mindic</span> <span class="id">funeqE</span> =&gt; <span class="id">t</span>; <span class="id">rewrite</span> <span class="id">indicE</span>. Qed.</div>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id"><a name="mD:107">_</a></span> (<span class="id">D</span> : <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#indic_mfun_subproof">set</a></span> <span class="id">aT</span>) (<span class="id">mD</span> : <span class="id">measurable</span> <span class="id">D</span>) :<br/>
&nbsp;&nbsp;&nbsp;@<span class="id">FImFun</span> <span class="id">aT</span> <span class="id">rT</span> (<span class="id">mindic</span> <span class="id">mD</span>) := <span class="id">FImFun.on</span> (<span class="id">mindic</span> <span class="id">mD</span>).<br/>
<span class="kwd">Lemma</span> <span class="id">indic_mfun_subproof</span> (<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#mindic">D</a></span> : <span class="id">set</span> <span class="id">aT</span>) (<span class="id"><a name="ring.hb_instance_50">mD</a></span> : <span class="id">measurable</span> <span class="id">D</span>) :<br/>
&nbsp;&nbsp;@<span class="id">isMeasurableFun</span> <span class="id">d</span> <span class="id">aT</span> <span class="id">rT</span> (<span class="id">mindic</span> <span class="id">mD</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof20')">Proof.</span></div>
<div class="proofscript" id="proof20">
<span class="id">split</span>=&gt; <span class="id">mA</span> /= <span class="id">B</span> <span class="id">mB</span>; <span class="id">rewrite</span> <span class="id">preimage_indic</span>.<br/>
<span class="id">case</span>: <span class="id">ifPn</span> =&gt; <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#ring.rT">B1</a></span>; <span class="id">case</span>: <span class="id">ifPn</span> =&gt; <span class="id">B0</span> //.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">setIT</span>.<br/>
- <span class="id">exact</span>: <span class="id">measurableI</span>.<br/>
- <span class="kwd">by</span> <span class="id">apply</span>: <span class="id">measurableI</span> =&gt; //; <span class="id">apply</span>: <span class="id">measurableC</span>.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a name="ring.hb_instance_55">setI0</a></span>.<br/>
Qed.</div>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> <span class="id">D</span> <span class="id">mD</span> := @<span class="id">indic_mfun_subproof</span> <span class="id"><a name="max_mfun">D</a></span> <span class="id">mD</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">indic_mfun</span> (<span class="id">D</span> : <span class="id">set</span> <span class="id">aT</span>) (<span class="id">mD</span> : <span class="id">measurable</span> <span class="id">D</span>) :=<br/>
&nbsp;&nbsp;[<span class="id">the</span> {<span class="id">mfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>} <span class="id">of</span> <span class="id">mindic</span> <span class="id">mD</span>].<br/>
<br/>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> <span class="id">k</span> <span class="id">f</span> := <span class="id">MeasurableFun.copy</span> (<span class="id">k</span> \<span class="id">o</span>* <span class="id">f</span>) (<span class="id"><a name="A:124">f</a></span> * <span class="id"><a href="mathcomp.classical.classical_sets.html#set">cst_mfun</a></span> <span class="id"><a href="mathcomp.analysis.measure.html#measurable">k</a></span>).<br/>
<span class="kwd">Definition</span> <span class="id">scale_mfun</span> <span class="id">k</span> <span class="id">f</span> := [<span class="id">the</span> {<span class="id">mfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>} <span class="id">of</span> <span class="id">k</span> \<span class="id">o</span>* <span class="id">f</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">max_mfun_subproof</span> <span class="id">f</span> <span class="id">g</span> : @<span class="id">isMeasurableFun</span> <span class="id">d</span> <span class="id">aT</span> <span class="id">rT</span> (<span class="id">f</span> \<span class="id">max</span> <span class="id">g</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof21')">Proof.</span></div>
<div class="proofscript" id="proof21">
 <span class="kwd">by</span> <span class="id">split</span>; <span class="id">apply</span>: <span class="id">measurable_maxr</span>. Qed.</div>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> <span class="id">f</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#measurable_indic">g</a></span> := <span class="id">max_mfun_subproof</span> <span class="id">f</span> <span class="id">g</span>.<br/>
<span class="kwd">Definition</span> <span class="id">max_mfun</span> <span class="id">f</span> <span class="id">g</span> := [<span class="id">the</span> {<span class="id">mfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">_</span>} <span class="id">of</span> <span class="id">f</span> \<span class="id">max</span> <span class="id">g</span>].<br/>
<br/>
<span class="kwd">End</span> <span class="id">ring</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">indic_mfun</span> {<span class="id">d</span> <span class="id">aT</span> <span class="id">rT</span>} <span class="id">_</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">measurable_indic</span> <span class="id">d</span> (<span class="id">T</span> : <span class="id">measurableType</span> <span class="id">d</span>) (<span class="id">R</span> : <span class="id">realType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">D</span> <span class="id">A</span> : <span class="id">set</span> <span class="id">T</span>) : <span class="id">measurable</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span> <span class="id">D</span> (\1<span class="id">_A</span> : <span class="id">T</span> -&gt; <span class="id">R</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof22')">Proof.</span></div>
<div class="proofscript" id="proof22">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">mA</span>; <span class="id">apply</span>/<span class="id">measurable_funTS</span>; <span class="id">rewrite</span> (<span class="id">_</span> : \1<span class="id">__</span> = <span class="id">mindic</span> <span class="id">R</span> <span class="id">mA</span>).<br/>
Qed.</div>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id"><a name="sfun_keyed">Extern</a></span> 0  (<span class="id">measurable_fun</span> <span class="id">_</span> (\1<span class="id">__</span> : <span class="id">_</span> -&gt; <span class="id">_</span>)) =&gt;<br/>
&nbsp;&nbsp;(<span class="id">exact</span>: <span class="id">measurable_indic</span> ) : <span class="id">core</span>.<br/>
#[<span class="id">deprecated</span>(<span class="id">since</span>="<span class="id">mathcomp</span>-<span class="id">analysis</span> 0.6.3", <span class="id">note</span>="<span class="id">use</span> `<span class="id">measurable_indic</span>` <span class="id">instead</span>")]<br/>
<span class="kwd">Notation</span> <span class="id">measurable_fun_indic</span> := <span class="id">measurable_indic</span> (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<br/>
<span class="kwd">Section</span> <span class="id">sfun_pred</span>.<br/>
<span class="kwd">Context</span> {<span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">d</a></span>} {<span class="id">aT</span> : <span class="id">measurableType</span> <span class="id">d</span>} {<span class="id">rT</span> : <span class="id">realType</span>}.<br/>
<span class="kwd">Definition</span> <span class="id">sfun</span> : {<span class="id">pred</span> <span class="id">_</span> -&gt; <span class="id">_</span>} := [<span class="id">predI</span> @<span class="id">mfun</span> <span class="id">_</span> <span class="id">aT</span> <span class="id">rT</span> &amp; <span class="id">fimfun</span>].<br/>
<span class="kwd">Definition</span> <span class="id">sfun_key</span> : <span class="id">pred_key</span> <span class="id">sfun</span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof23')">Proof.</span></div>
<div class="proofscript" id="proof23">
 <span class="id">exact</span>. Qed.</div>
<span class="kwd">Canonical</span> <span class="id">sfun_keyed</span> := <span class="id">KeyedPred</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set_mem">sfun_key</a></span>.<br/>
<span class="kwd">Lemma</span> <span class="id">sub_sfun_mfun</span> : {<span class="id">subset</span> <span class="id">sfun</span> &lt;= <span class="id">mfun</span>}<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof24')">Proof.</span></div>
<div class="proofscript" id="proof24">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">x</span> /<span class="id">andP</span>[]. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">sub_sfun_fimfun</span> : {<span class="id">subset</span> <span class="id">sfun</span> &lt;= <span class="id">fimfun</span>}<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof25')">Proof.</span></div>
<div class="proofscript" id="proof25">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">x</span> /<span class="id">andP</span>[]. Qed.</div>
<span class="kwd">End</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#sfun.Sub.fP">sfun_pred</a></span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">sfun</span>.<br/>
<span class="kwd">Context</span> {<span class="id">d</span>} {<span class="id">aT</span> : <span class="id">measurableType</span> <span class="id">d</span>} {<span class="id">rT</span> : <span class="id">realType</span>}.<br/>
<span class="kwd">Notation</span> <span class="id">T</span> := {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>}.<br/>
<span class="kwd">Notation</span> <span class="id">sfun</span> := (@<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#T">sfun</a></span> <span class="id">_</span> <span class="id">aT</span> <span class="id">rT</span>).<br/>
<span class="kwd">Section</span> <span class="id"><a name="f:134">Sub</a></span>.<br/>
<span class="kwd">Context</span> (<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#sfun">f</a></span> : <span class="id">aT</span> -&gt; <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#sfun_Sub">rT</a></span>) (<span class="id">fP</span> : <span class="id">f</span> \<span class="kwd">in</span> <span class="id">sfun</span>).<br/>
<span class="kwd">Definition</span> <span class="id">sfun_Sub1_subproof</span> :=<br/>
&nbsp;&nbsp;@<span class="id">isMeasurableFun.Build</span> <span class="id">d</span> <span class="id">aT</span> <span class="id">rT</span> <span class="id">f</span> (<span class="id">set_mem</span> (<span class="id">sub_sfun_mfun</span> <span class="id">fP</span>)).<br/>
#[<span class="id">local</span>] <span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> := <span class="id">sfun_Sub1_subproof</span>.<br/>
<span class="kwd">Definition</span> <span class="id">sfun_Sub2_subproof</span> :=<br/>
&nbsp;&nbsp;@<span class="id">FiniteImage.Build</span> <span class="id">aT</span> <span class="id">rT</span> <span class="id">f</span> (<span class="id">set_mem</span> (<span class="id">sub_sfun_fimfun</span> <span class="id">fP</span>)).<br/>
#[<span class="id">local</span>] <span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> := <span class="id">sfun_Sub2_subproof</span>.<br/>
<span class="kwd">Definition</span> <span class="id">sfun_Sub</span> := [<span class="id">sfun</span> <span class="id">of</span> <span class="id">f</span>].<br/>
<span class="kwd">End</span> <span class="id">Sub</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">sfun_rect</span> (<span class="id">K</span> : <span class="id">T</span> -&gt; <span class="kwd">Type</span>) :<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">f</span> (<span class="id">Pf</span> : <span class="id">f</span> \<span class="kwd">in</span> <span class="id">sfun</span>), <span class="id">K</span> (<span class="id">sfun_Sub</span> <span class="id">Pf</span>)) -&gt; <span class="kwd">forall</span> <span class="id">u</span> : <span class="id">T</span>, <span class="id">K</span> <span class="id">u</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof26')">Proof.</span></div>
<div class="proofscript" id="proof26">
<span class="id">move</span>=&gt; <span class="id">Ksub</span> [<span class="id">f</span> [[<span class="id">Pf1</span>] [<span class="id">Pf2</span>]]]; <span class="id">have</span> <span class="id">Pf</span> : <span class="id">f</span> \<span class="kwd">in</span> <span class="id">sfun</span> <span class="kwd">by</span> <span class="id">apply</span>/<span class="id">andP</span>; <span class="id">rewrite</span> ?<span class="id">inE</span>.<br/>
<span class="id">have</span> -&gt; : <span class="id">Pf1</span> = (<span class="id">set_mem</span> (<span class="id">sub_sfun_mfun</span> <span class="id">Pf</span>)) <span class="kwd">by</span> [].<br/>
<span class="id">have</span> -&gt; : <span class="id">Pf2</span> = (<span class="id">set_mem</span> (<span class="id">sub_sfun_fimfun</span> <span class="id">Pf</span>)) <span class="kwd">by</span> [].<br/>
<span class="id">exact</span>: <span class="id">Ksub</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">sfun_valP</span> <span class="id">f</span> (<span class="id">Pf</span> : <span class="id">f</span> \<span class="kwd">in</span> <span class="id">sfun</span>) : <span class="id">sfun_Sub</span> <span class="id">Pf</span> = <span class="id">f</span> :&gt; (<span class="id">_</span> -&gt; <span class="id">_</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof27')">Proof.</span></div>
<div class="proofscript" id="proof27">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id">sfun_subType</span> := <span class="id">SubType</span> <span class="id">T</span> <span class="id">_</span> <span class="id">_</span> <span class="id">sfun_rect</span> <span class="id">sfun_valP</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">sfuneqP</span> (<span class="id">f</span> <span class="id">g</span> : {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>}) : <span class="id">f</span> = <span class="id">g</span> &lt;-&gt; <span class="id">f</span> =1 <span class="id">g</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof28')">Proof.</span></div>
<div class="proofscript" id="proof28">
 <span class="kwd">by</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#sfun.aT">split</a></span>=&gt; [-&gt;//|<span class="id"><a href="mathcomp.classical.functions.html#cst">fg</a></span>]; <span class="id">apply</span>/<span class="id">val_inj</span>/<span class="id">funext</span>. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id"><a href="mathcomp.classical.functions.html#cst">sfuneqMixin</a></span> := [<span class="id">eqMixin</span> <span class="id">of</span> {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>} <span class="kwd">by</span> &lt;:].<br/>
<span class="kwd">Canonical</span> <span class="id">sfuneqType</span> := <span class="id">EqType</span> {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>} <span class="id">sfuneqMixin</span>.<br/>
<span class="kwd">Definition</span> <span class="id">sfunchoiceMixin</span> := [<span class="id">choiceMixin</span> <span class="id">of</span> {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>} <span class="kwd">by</span> &lt;:].<br/>
<span class="kwd">Canonical</span> <span class="id">sfunchoiceType</span> := <span class="id">ChoiceType</span> {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>} <span class="id">sfunchoiceMixin</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">cst_sfun</span> <span class="id">x</span> := [<span class="id">the</span> {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>} <span class="id">of</span> <span class="id">cst</span> <span class="id">x</span>].<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cst_sfunE</span> <span class="id">x</span> : @<span class="id">cst_sfun</span> <span class="id">x</span> =1 <span class="id">cst</span> <span class="id">x</span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof29')">Proof.</span></div>
<div class="proofscript" id="proof29">
 <span class="kwd">by</span> []. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">sfun</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">fctD</span> (<span class="id">T</span> : <span class="id">pointedType</span>) (<span class="id">K</span> : <span class="id">ringType</span>) (<span class="id">f</span> <span class="id">g</span> : <span class="id"><a name="d:159">T</a></span> -&gt; <span class="id">K</span>) : <span class="id">f</span> + <span class="id">g</span> = <span class="id">f</span> \+ <span class="id">g</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof30')">Proof.</span></div>
<div class="proofscript" id="proof30">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">fctN</span> (<span class="id">T</span> : <span class="id">pointedType</span>) (<span class="id">K</span> : <span class="id">ringType</span>) (<span class="id">f</span> : <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#ring.d">T</a></span> -&gt; <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#ring.rT">K</a></span>) : - <span class="id">f</span> = \- <span class="id">f</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof31')">Proof.</span></div>
<div class="proofscript" id="proof31">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">fctM</span> (<span class="id">T</span> : <span class="id">pointedType</span>) (<span class="id">K</span> : <span class="id">ringType</span>) (<span class="id">f</span> <span class="id">g</span> : <span class="id">T</span> -&gt; <span class="id">K</span>) : <span class="id">f</span> * <span class="id">g</span> = <span class="id">f</span> \* <span class="id">g</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof32')">Proof.</span></div>
<div class="proofscript" id="proof32">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">fctZ</span> (<span class="id">T</span> : <span class="id">pointedType</span>) (<span class="id">K</span> : <span class="id">ringType</span>) (<span class="id">L</span> : <span class="id">lmodType</span> <span class="id">K</span>) <span class="id">k</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">L</span>) :<br/>
&nbsp;&nbsp;&nbsp;<span class="id">k</span> *: <span class="id">f</span> = <span class="id">k</span> \*: <span class="id">f</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof33')">Proof.</span></div>
<div class="proofscript" id="proof33">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Arguments</span> <span class="id">cst</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> /.<br/>
<span class="kwd">Definition</span> <span class="id">fctWE</span> := (<span class="id">fctD</span>, <span class="id">fctN</span>, <span class="id">fctM</span>, <span class="id">fctZ</span>).<br/>
<br/>
<span class="kwd">Section</span> <span class="id">ring</span>.<br/>
<span class="kwd">Context</span> <span class="id">d</span> (<span class="id">aT</span> : <span class="id">measurableType</span> <span class="id">d</span>) (<span class="id">rT</span> : <span class="id">realType</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">sfun_subring_closed</span> : <span class="id">subring_closed</span> (@<span class="id">sfun</span> <span class="id">d</span> <span class="id">aT</span> <span class="id">rT</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof34')">Proof.</span></div>
<div class="proofscript" id="proof34">
<span class="kwd">by</span> <span class="id">split</span>=&gt; [|<span class="id">f</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#ring.rT">g</a></span>|<span class="id">f</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#sfun_zmodMixin">g</a></span>]; <span class="id">rewrite</span> ?<span class="id">inE</span>/= ?<span class="id">rpred1</span>//;<br/>
&nbsp;&nbsp;&nbsp;<span class="id">move</span>=&gt; /<span class="id">andP</span>[/= <span class="id">mf</span> <span class="id">ff</span>] /<span class="id">andP</span>[/= <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#ring.aT">mg</a></span> <span class="id">fg</span>]; <span class="id">rewrite</span> !(<span class="id">rpredB</span>, <span class="id">rpredM</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Canonical</span> <span class="id">sfun_add</span> := <span class="id">AddrPred</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#sfun_ringMixin">sfun_subring_closed</a></span>.<br/>
<span class="kwd">Canonical</span> <span class="id">sfun_zmod</span> := <span class="id">ZmodPred</span> <span class="id">sfun_subring_closed</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">sfun_mul</span> := <span class="id">MulrPred</span> <span class="id">sfun_subring_closed</span>.<br/>
<span class="kwd">Canonical</span> <span class="id">sfun_subring</span> := <span class="id">SubringPred</span> <span class="id">sfun_subring_closed</span>.<br/>
<span class="kwd">Definition</span> <span class="id">sfun_zmodMixin</span> := [<span class="id">zmodMixin</span> <span class="id">of</span> {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>} <span class="kwd">by</span> &lt;:].<br/>
<span class="kwd">Canonical</span> <span class="id">sfun_zmodType</span> := <span class="id">ZmodType</span> {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#ring.aT">rT</a></span>} <span class="id">sfun_zmodMixin</span>.<br/>
<span class="kwd">Definition</span> <span class="id">sfun_ringMixin</span> := [<span class="id">ringMixin</span> <span class="id">of</span> {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>} <span class="kwd">by</span> &lt;:].<br/>
<span class="kwd">Canonical</span> <span class="id">sfun_ringType</span> := <span class="id">RingType</span> {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>} <span class="id">sfun_ringMixin</span>.<br/>
<span class="kwd">Definition</span> <span class="id">sfun_comRingMixin</span> := [<span class="id">comRingMixin</span> <span class="id"><a name="sfunM">of</a></span> {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>} <span class="kwd">by</span> &lt;:].<br/>
<span class="kwd">Canonical</span> <span class="id">sfun_comRingType</span> := <span class="id">ComRingType</span> {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id"><a name="f:172">rT</a></span>} <span class="id">sfun_comRingMixin</span>.<br/>
<br/>
<span class="kwd">Implicit</span> <span class="id">Types</span> (<span class="id">f</span> <span class="id">g</span> : {<span class="id"><a name="i:174">sfun</a></span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>}).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">sfun0</span> : (0 : {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>}) =1 <span class="id">cst</span> 0<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof35')">Proof.</span></div>
<div class="proofscript" id="proof35">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">sfun1</span> : (1 : {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>}) =1 <span class="id">cst</span> 1<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof36')">Proof.</span></div>
<div class="proofscript" id="proof36">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">sfunN</span> <span class="id">f</span> : - <span class="id">f</span> =1 \- <span class="id">f</span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof37')">Proof.</span></div>
<div class="proofscript" id="proof37">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">sfunD</span> <span class="id">f</span> <span class="id">g</span> : <span class="id">f</span> + <span class="id">g</span> =1 <span class="id">f</span> \+ <span class="id">g</span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof38')">Proof.</span></div>
<div class="proofscript" id="proof38">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">sfunB</span> <span class="id">f</span> <span class="id">g</span> : <span class="id">f</span> - <span class="id">g</span> =1 <span class="id">f</span> \- <span class="id">g</span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof39')">Proof.</span></div>
<div class="proofscript" id="proof39">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">sfunM</span> <span class="id">f</span> <span class="id">g</span> : <span class="id">f</span> * <span class="id">g</span> =1 <span class="id">f</span> \* <span class="id">g</span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof40')">Proof.</span></div>
<div class="proofscript" id="proof40">
 <span class="kwd">by</span> []. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">sfun_sum</span> <span class="id">I</span> <span class="id">r</span> (<span class="id">P</span> : {<span class="id">pred</span> <span class="id">I</span>}) (<span class="id">f</span> : <span class="id">I</span> -&gt; {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>}) (<span class="id">x</span> : <span class="id">aT</span>) :<br/>
&nbsp;&nbsp;(\<span class="id"><a name="f:194">sum_</a></span>(<span class="id">i</span> &lt;- <span class="id">r</span> | <span class="id">P</span> <span class="id">i</span>) <span class="id">f</span> <span class="id">i</span>) <span class="id">x</span> = \<span class="id">sum_</span>(<span class="id">i</span> &lt;- <span class="id">r</span> | <span class="id">P</span> <span class="id">i</span>) <span class="id">f</span> <span class="id">i</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof41')">Proof.</span></div>
<div class="proofscript" id="proof41">
 <span class="kwd">by</span> <span class="id">elim</span>/<span class="id">big_rec2</span>: <span class="id">_</span> =&gt; //= <span class="id">i</span> <span class="id">y</span> ? <span class="id">Pi</span> &lt;-. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">sfun_prod</span> <span class="id">I</span> <span class="id">r</span> (<span class="id">P</span> : {<span class="id">pred</span> <span class="id">I</span>}) (<span class="id">f</span> : <span class="id">I</span> -&gt; {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>}) (<span class="id">x</span> : <span class="id">aT</span>) :<br/>
&nbsp;&nbsp;(\<span class="id">sum_</span>(<span class="id">i</span> &lt;- <span class="id">r</span> | <span class="id">P</span> <span class="id">i</span>) <span class="id">f</span> <span class="id">i</span>) <span class="id">x</span> = \<span class="id">sum_</span>(<span class="id">i</span> &lt;- <span class="id">r</span> | <span class="id">P</span> <span class="id">i</span>) <span class="id">f</span> <span class="id">i</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof42')">Proof.</span></div>
<div class="proofscript" id="proof42">
 <span class="kwd">by</span> <span class="id">elim</span>/<span class="id">big_rec2</span>: <span class="id">_</span> =&gt; //= <span class="id">i</span> <span class="id">y</span> ? <span class="id">Pi</span> &lt;-. Qed.</div>
<span class="kwd">Lemma</span> <span class="id">sfunX</span> <span class="id">f</span> <span class="id">n</span> : <span class="id">f</span> ^+ <span class="id">n</span> =1 (<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">f</span> <span class="id">x</span> ^+ <span class="id">n</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof43')">Proof.</span></div>
<div class="proofscript" id="proof43">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">x</span>; <span class="id">elim</span>: <span class="id">n</span> =&gt; [|<span class="id"><a name="k:204">n</a></span> <span class="id"><a name="f:205">IHn</a></span>]//; <span class="id">rewrite</span> !<span class="id">exprS</span> <span class="id">sfunM</span>/= <span class="id">IHn</span>. Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> <span class="id">f</span> <span class="id">g</span> := <span class="id"><a name="k:206">MeasurableFun.copy</a></span> (<span class="id">f</span> \+ <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#ring.rT">g</a></span>) (<span class="id">f</span> + <span class="id">g</span>).<br/>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> <span class="id">f</span> <span class="id">g</span> := <span class="id">MeasurableFun.copy</span> (\- <span class="id">f</span>) (- <span class="id">f</span>).<br/>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> <span class="id">f</span> <span class="id">g</span> := <span class="id">MeasurableFun.copy</span> (<span class="id">f</span> \- <span class="id">g</span>) (<span class="id">f</span> - <span class="id">g</span>).<br/>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> <span class="id">f</span> <span class="id">g</span> := <span class="id">MeasurableFun.copy</span> (<span class="id">f</span> \* <span class="id">g</span>) (<span class="id">f</span> * <span class="id">g</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">indic_sfun</span> (<span class="id"><a href="mathcomp.classical.classical_sets.html#set">D</a></span> : <span class="id">set</span> <span class="id">aT</span>) (<span class="id"><a name="f:216">mD</a></span> : <span class="id">measurable</span> <span class="id">D</span>) :=<br/>
&nbsp;&nbsp;[<span class="id"><a name="g:217">the</a></span> {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>} <span class="id">of</span> <span class="id">mindic</span> <span class="id">rT</span> <span class="id">mD</span>].<br/>
<br/>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> <span class="id">k</span> <span class="id">f</span> := <span class="id">MeasurableFun.copy</span> (<span class="id">k</span> \<span class="id">o</span>* <span class="id">f</span>) (<span class="id">f</span> * <span class="id">cst_sfun</span> <span class="id">k</span>).<br/>
<span class="kwd">Definition</span> <span class="id">scale_sfun</span> <span class="id">k</span> <span class="id">f</span> := [<span class="id">the</span> {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">rT</span>} <span class="id">of</span> <span class="id"><a name="preimage_nnfun0">k</a></span> \<span class="id">o</span>* <span class="id">f</span>].<br/>
<br/>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> <span class="id">f</span> <span class="id">g</span> := <span class="id">max_mfun_subproof</span> <span class="id"><a name="t:224">f</a></span> <span class="id">g</span>.<br/>
<span class="kwd">Definition</span> <span class="id">max_sfun</span> <span class="id">f</span> <span class="id">g</span> := [<span class="id"><a href="mathcomp.classical.classical_sets.html#set0">the</a></span> {<span class="id">sfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id">_</span>} <span class="id">of</span> <span class="id">f</span> \<span class="id">max</span> <span class="id">g</span>].<br/>
<br/>
<span class="kwd">End</span> <span class="id">ring</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">indic_sfun</span> {<span class="id">d</span> <span class="id">aT</span> <span class="id">rT</span>} <span class="id">_</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">fset_set_comp</span> (<span class="id">T1</span> : <span class="kwd">Type</span>) (<span class="id">T2</span> <span class="id">T3</span> : <span class="id">choiceType</span>) (<span class="id">D</span> : <span class="id">set</span> <span class="id">T1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">f</span> : {<span class="id">fimfun</span> <span class="id">T1</span> &gt;-&gt; <span class="id">T2</span>}) (<span class="id">g</span> : <span class="id">T2</span> -&gt; <span class="id">T3</span>) :<br/>
&nbsp;&nbsp;<span class="id">fset_set</span> [<span class="id">set</span> (<span class="id">g</span> \<span class="id">o</span> <span class="id">f</span>) <span class="id">x</span> | <span class="id">x</span> <span class="kwd">in</span> <span class="id">D</span>] =<br/>
&nbsp;&nbsp;[<span class="id">fset</span> <span class="id">g</span> <span class="id">x</span> | <span class="id">x</span> <span class="kwd">in</span> <span class="id">fset_set</span> [<span class="id">set</span> <span class="id">f</span> <span class="id">x</span> | <span class="id">x</span> <span class="kwd">in</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#preimage">D</a></span>]]%<span class="id">fset</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof44')">Proof.</span></div>
<div class="proofscript" id="proof44">
 <span class="kwd">by</span> <span class="id">rewrite</span> -(<span class="id">image_comp</span> <span class="id">f</span> <span class="id">g</span>) <span class="id">fset_set_image</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">preimage_nnfun0</span> <span class="id">T</span> (<span class="id">R</span> : <span class="id">realDomainType</span>) (<span class="id">f</span> : {<span class="id">nnfun</span> <span class="id">T</span> &gt;-&gt; <span class="id">R</span>}) <span class="id">t</span> :<br/>
&nbsp;&nbsp;<span class="id">t</span> &lt; 0 -&gt; <span class="id">f</span> @^-1` [<span class="id">set</span> <span class="id">t</span>] = <span class="id"><a name="f:232">set0</a></span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof45')">Proof.</span></div>
<div class="proofscript" id="proof45">
<span class="id">move</span>=&gt; <span class="id">t0</span>.<br/>
<span class="kwd">by</span> <span class="id">apply</span>/<span class="id">preimage10</span> =&gt; -[<span class="id">x</span> <span class="id">_</span>]; <span class="id">apply</span>: <span class="id">contraPnot</span> <span class="id">t0</span> =&gt; &lt;-; <span class="id">rewrite</span> <span class="id">le_gtF</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">preimage_cstM</span> <span class="id">T</span> (<span class="id">R</span> : <span class="id">realFieldType</span>) (<span class="id">x</span> <span class="id">y</span> : <span class="id">R</span>) (<span class="id">f</span> : <span class="id">T</span> -&gt; <span class="id">R</span>) :<br/>
&nbsp;&nbsp;<span class="id">x</span> != 0 -&gt; (<span class="id">cst</span> <span class="id">x</span> \* <span class="id">f</span>) @^-1` [<span class="id">set</span> <span class="id">y</span>] = <span class="id">f</span> @^-1` [<span class="id">set</span> <span class="id">y</span> / <span class="id"><a href="mathcomp.classical.classical_sets.html#inE">x</a></span>].<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof46')">Proof.</span></div>
<div class="proofscript" id="proof46">
<span class="id">move</span>=&gt; <span class="id">x0</span>; <span class="id">apply</span>/<span class="id">seteqP</span>; <span class="id">rewrite</span> /<span class="id">preimage</span>; <span class="id">split</span> =&gt; [<span class="id">z</span>/= &lt;-|<span class="id">z</span>/= -&gt;].<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">mulrAC</span> <span class="id">divrr</span> ?<span class="id">mul1r</span>// <span class="id">unitfE</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">mulrCA</span> <span class="id">divrr</span> ?<span class="id">mulr1</span>// <span class="id">unitfE</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">preimage_add</span> <span class="id">T</span> (<span class="id">R</span> : <span class="id">numDomainType</span>) (<span class="id">f</span> <span class="id">g</span> : <span class="id">T</span> -&gt; <span class="id">R</span>) <span class="id">z</span> :<br/>
&nbsp;&nbsp;(<span class="id">f</span> \+ <span class="id">g</span>) @^-1` [<span class="id">set</span> <span class="id">z</span>] = \<span class="id">bigcup_</span>(<span class="id">a</span> <span class="kwd">in</span> <span class="id">f</span> @` <span class="id">setT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id">f</span> @^-1` [<span class="id">set</span> <span class="id">a</span>]) `&amp;` (<span class="id">g</span> @^-1` [<span class="id">set</span> <span class="id">z</span> - <span class="id">a</span>])).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof47')">Proof.</span></div>
<div class="proofscript" id="proof47">
<span class="id">apply</span>/<span class="id">seteqP</span>; <span class="id">split</span>=&gt; [<span class="id">x</span> /= <span class="id">fgz</span>|<span class="id">x</span> [<span class="id">_</span> /= [<span class="id">y</span> <span class="id">_</span> &lt;-]] []].<br/>
&nbsp;&nbsp;<span class="id"><a name="T:237">have</a></span> : <span class="id">z</span> - <span class="id">f</span> <span class="id">x</span> \<span class="kwd">in</span> <span class="id">g</span> @` <span class="id">setT</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id"><a name="simple_bounded">inE</a></span> /=; <span class="kwd">exists</span> <span class="id">x</span>=&gt; //; <span class="id">rewrite</span> -<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#simple_bounded.R">fgz</a></span> <span class="id">addrC</span> <span class="id">addKr</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">inE</span> /= =&gt; -[<span class="id">x</span>' <span class="id">_</span> <span class="id">gzf</span>]; <span class="kwd">exists</span> (<span class="id">z</span> - <span class="id">g</span> <span class="id">x</span>')%<span class="id">R</span> =&gt; /=.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">by</span> <span class="kwd">exists</span> <span class="id"><a href="mathcomp.classical.cardinality.html#fimfunP">x</a></span> =&gt; //; <span class="id">rewrite</span> <span class="id">gzf</span> <span class="id">opprB</span> <span class="id">addrC</span> <span class="id">subrK</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> /<span class="id">preimage</span> /=; <span class="id">split</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">gzf</span> <span class="id">opprB</span> <span class="id">addrC</span> <span class="id">subrK</span>.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">gzf</span> <span class="id">opprB</span> <span class="id">addrC</span> <span class="id">subrK</span> -<span class="id">fgz</span> <span class="id">addrC</span> <span class="id">addKr</span>.<br/>
<span class="id">rewrite</span> /<span class="id">preimage</span> /= =&gt; [<span class="id">fxfy</span> <span class="id">gzf</span>].<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">gzf</span> -<span class="id">fxfy</span> <span class="id">addrC</span> <span class="id">subrK</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">simple_bounded</span>.<br/>
<span class="kwd">Context</span> <span class="id">d</span> (<span class="id">T</span> : <span class="id">measurableType</span> <span class="id">d</span>) (<span class="id">R</span> : <span class="id">realType</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">simple_bounded</span> (<span class="id">f</span> : {<span class="id">sfun</span> <span class="id">T</span> &gt;-&gt; <span class="id">R</span>}) :<br/>
&nbsp;&nbsp;<span class="id">bounded_fun</span> (<span class="id">f</span> : <span class="id">T</span> -&gt; [<span class="id">normedModType</span> <span class="id">R</span> <span class="id">of</span> <span class="id">R</span>^<span class="id">o</span>]).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof48')">Proof.</span></div>
<div class="proofscript" id="proof48">
<span class="id">have</span> /<span class="id">finite_seqP</span>[<span class="id">r</span> <span class="id">fr</span>] := <span class="id">fimfunP</span> <span class="id">f</span>.<br/>
<span class="kwd">exists</span> (<span class="id">fine</span> (\<span class="id">big</span>[<span class="id">maxe</span>/-<span class="id">oo</span>%<span class="id">E</span>]<span class="id">_</span>(<span class="id">i</span> &lt;- <span class="id">r</span>) `|<span class="id">i</span>|%:<span class="id">E</span>)).<br/>
<span class="id">split</span>; <span class="id">rewrite</span> ?<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#nnsfun_functions.R">num_real</a></span>// =&gt; <span class="id">x</span> <span class="id">mx</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#nnsfun_functions.T">z</a></span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#nnsfun_functions.R">_</a></span>; <span class="id"><a href="mathcomp.classical.functions.html#cst">apply</a></span>/<span class="id">ltW</span>/(<span class="id">le_lt_trans</span> <span class="id">_</span> <span class="id">mx</span>).<br/>
<span class="id">have</span> ? : <span class="id">f</span> <span class="id">z</span> \<span class="kwd">in</span> <span class="id">r</span> <span class="kwd">by</span> <span class="id">have</span> := <span class="id">imageT</span> <span class="id">f</span> <span class="id">z</span>; <span class="id">rewrite</span> <span class="id">fr</span>.<br/>
<span class="id">rewrite</span> -[<span class="id">leLHS</span>]/(<span class="id">fine</span> `|<span class="id">f</span> <span class="id">z</span>|%:<span class="id">E</span>) <span class="id">fine_le</span>//.<br/>
&nbsp;&nbsp;<span class="id">have</span> := @<span class="id">bigmaxe_fin_num</span> <span class="id">_</span> (<span class="id">map</span> <span class="id">normr</span> <span class="id">r</span>) `|<span class="id">f</span> <span class="id">z</span>|.<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">big_map</span> =&gt; -&gt;//; <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#nnsfun_functions.R">apply</a></span>/<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#cst_nnsfun">mapP</a></span>; <span class="kwd">exists</span> (<span class="id">f</span> <span class="id">z</span>).<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> (<span class="id">bigmax_sup_seq</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">lexx</span> <span class="id">_</span>)).<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">simple_bounded</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">nnsfun_functions</span>.<br/>
<span class="kwd">Context</span> <span class="id">d</span> (<span class="id">T</span> : <span class="id">measurableType</span> <span class="id">d</span>) (<span class="id">R</span> : <span class="id">realType</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">cst_nnfun_subproof</span> (<span class="id">x</span> : {<span class="id">nonneg</span> <span class="id">R</span>}) : @<span class="id">isNonNegFun</span> <span class="id">T</span> <span class="id">R</span> (<span class="id">cst</span> <span class="id">x</span>%:<span class="id">num</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof49')">Proof.</span></div>
<div class="proofscript" id="proof49">
 <span class="kwd">by</span> <span class="id">split</span>=&gt; /=. Qed.</div>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> <span class="id">x</span> := @<span class="id">cst_nnfun_subproof</span> <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">cst_nnsfun</span> (<span class="id">r</span> : {<span class="id">nonneg</span> <span class="id">R</span>}) := [<span class="id">the</span> {<span class="id">nnsfun</span> <span class="id">T</span> &gt;-&gt; <span class="id">R</span>} <span class="id">of</span> <span class="id">cst</span> <span class="id"><a name="nnfun_bin.R">r</a></span>%:<span class="id">num</span>].<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">nnsfun0</span> : {<span class="id">nnsfun</span> <span class="id">T</span> &gt;-&gt; <span class="id">R</span>} := <span class="id"><a name="add_nnfun_subproof">cst_nnsfun</a></span> 0%<span class="id">R</span>%:<span class="id">nng</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">indic_nnfun_subproof</span> (<span class="id">D</span> : <span class="id">set</span> <span class="id">T</span>) : @<span class="id">isNonNegFun</span> <span class="id">T</span> <span class="id">R</span> (\1<span class="id">_D</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof50')">Proof.</span></div>
<div class="proofscript" id="proof50">
 <span class="kwd">by</span> <span class="id">split</span>=&gt; //=; <span class="id">rewrite</span> /<span class="id">indic</span>. Qed.</div>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> <span class="id">D</span> := @<span class="id">indic_nnfun_subproof</span> <span class="id">D</span>.<br/>
<br/>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> <span class="id">D</span> (<span class="id">mD</span> : <span class="id">measurable</span> <span class="id">D</span>) :<br/>
&nbsp;&nbsp;&nbsp;@<span class="id">NonNegFun</span> <span class="id">T</span> <span class="id">R</span> (<span class="id">mindic</span> <span class="id">R</span> <span class="id">mD</span>) := <span class="id">NonNegFun.on</span> (<span class="id">mindic</span> <span class="id">R</span> <span class="id">mD</span>).<br/>
<br/>
<span class="kwd">End</span> <span class="id">nnsfun_functions</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">nnsfun0</span> {<span class="id">d</span> <span class="id">T</span> <span class="id">R</span>}.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">nnfun_bin</span>.<br/>
<span class="kwd">Variables</span> (<span class="id">T</span> : <span class="kwd">Type</span>) (<span class="id">R</span> : <span class="id">numDomainType</span>) (<span class="id">f</span> <span class="id">g</span> : {<span class="id">nnfun</span> <span class="id">T</span> &gt;-&gt; <span class="id">R</span>}).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">add_nnfun_subproof</span> : @<span class="id">isNonNegFun</span> <span class="id">T</span> <span class="id">R</span> (<span class="id">f</span> \+ <span class="id">g</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof51')">Proof.</span></div>
<div class="proofscript" id="proof51">
 <span class="kwd">by</span> <span class="id">split</span> =&gt; <span class="id">x</span>; <span class="id">rewrite</span> <span class="id">addr_ge0</span>//; <span class="id">apply</span>/<span class="id">fun_ge0</span>. Qed.</div>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> := <span class="id"><a href="mathcomp.analysis.reals.html#Real.Exports.realType">add_nnfun_subproof</a></span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">mul_nnfun_subproof</span> : @<span class="id">isNonNegFun</span> <span class="id">T</span> <span class="id">R</span> (<span class="id">f</span> \* <span class="id">g</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof52')">Proof.</span></div>
<div class="proofscript" id="proof52">
 <span class="kwd">by</span> <span class="id">split</span> =&gt; <span class="id">x</span>; <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#nnsfun_bin.g">rewrite</a></span> <span class="id">mulr_ge0</span>//; <span class="id">apply</span>/<span class="id">fun_ge0</span>. Qed.</div>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> := <span class="id">mul_nnfun_subproof</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">max_nnfun_subproof</span> : @<span class="id">isNonNegFun</span> <span class="id">T</span> <span class="id">R</span> (<span class="id">f</span> \<span class="id">max</span> <span class="id">g</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof53')">Proof.</span></div>
<div class="proofscript" id="proof53">
 <span class="kwd">by</span> <span class="id">split</span> =&gt; <span class="id">x</span> /=; <span class="id">rewrite</span> /<span class="id"><a name="HB_unnamed_factory_108">maxr</a></span>; <span class="id">case</span>: <span class="id">ifPn</span> =&gt; <span class="id">_</span>; <span class="id">apply</span>: <span class="id">fun_ge0</span>. Qed.</div>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> := <span class="id">max_nnfun_subproof</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">nnfun_bin</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">nnsfun_bin</span>.<br/>
<span class="kwd">Context</span> <span class="id">d</span> (<span class="id">T</span> : <span class="id">measurableType</span> <span class="id">d</span>) (<span class="id">R</span> : <span class="id">realType</span>).<br/>
<span class="kwd">Variables</span> <span class="id">f</span> <span class="id">g</span> : {<span class="id">nnsfun</span> <span class="id">T</span> &gt;-&gt; <span class="id">R</span>}.<br/>
<br/>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> := <span class="id">MeasurableFun.on</span> (<span class="id">f</span> \+ <span class="id">g</span>).<br/>
<span class="kwd">Definition</span> <span class="id">add_nnsfun</span> := [<span class="id">the</span> {<span class="id">nnsfun</span> <span class="id">T</span> &gt;-&gt; <span class="id">R</span>} <span class="id">of</span> <span class="id">f</span> \+ <span class="id">g</span>].<br/>
<br/>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> := <span class="id"><a name="d:267">MeasurableFun.on</a></span> (<span class="id">f</span> \* <span class="id">g</span>).<br/>
<span class="kwd">Definition</span> <span class="id">mul_nnsfun</span> := [<span class="id">the</span> {<span class="id">nnsfun</span> <span class="id">T</span> &gt;-&gt; <span class="id">R</span>} <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#nnsfun_iter.T">of</a></span> <span class="id">f</span> \* <span class="id">g</span>].<br/>
<br/>
<span class="id">HB.instance</span> <span class="kwd">Definition</span> <span class="id">_</span> := <span class="id">MeasurableFun.on</span> (<span class="id">f</span> \<span class="id">max</span> <span class="id">g</span>).<br/>
<span class="kwd">Definition</span> <span class="id">max_nnsfun</span> := [<span class="id">the</span> {<span class="id"><a name="t:277">nnsfun</a></span> <span class="id">T</span> &gt;-&gt; <span class="id">R</span>} <span class="id">of</span> <span class="id">f</span> \<span class="id">max</span> <span class="id">g</span>].<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">indic_nnsfun</span> <span class="id">A</span> (<span class="id">mA</span> : <span class="id">measurable</span> <span class="id">A</span>) := [<span class="id">the</span> {<span class="id">nnsfun</span> <span class="id">T</span> &gt;-&gt; <span class="id">R</span>} <span class="id">of</span> <span class="id">mindic</span> <span class="id">R</span> <span class="id">mA</span>].<br/>
<br/>
<span class="kwd">End</span> <span class="id">nnsfun_bin</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">add_nnsfun</span> {<span class="id">d</span> <span class="id">T</span> <span class="id">R</span>} <span class="id">_</span> <span class="id">_</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">mul_nnsfun</span> {<span class="id">d</span> <span class="id">T</span> <span class="id">R</span>} <span class="id">_</span> <span class="id">_</span>.<br/>
<span class="kwd">Arguments</span> <span class="id">max_nnsfun</span> {<span class="id">d</span> <span class="id">T</span> <span class="id">R</span>} <span class="id">_</span> <span class="id">_</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">nnsfun_iter</span>.<br/>
<span class="kwd">Context</span> <span class="id">d</span> (<span class="id">T</span> : <span class="id">measurableType</span> <span class="id">d</span>) (<span class="id">R</span> : <span class="id">realType</span>) (<span class="id">D</span> : <span class="id">set</span> <span class="id">T</span>).<br/>
<span class="kwd">Variable</span> <span class="id">f</span> : {<span class="id">nnsfun</span> <span class="id">T</span> &gt;-&gt; <span class="id">R</span>}^<span class="id">nat</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">sum_nnsfun</span> <span class="id">n</span> := \<span class="id">big</span>[<span class="id">add_nnsfun</span>/<span class="id">nnsfun0</span>]<span class="id">_</span>(<span class="id">i</span> &lt; <span class="id">n</span>) <span class="id">f</span> <span class="id">i</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">sum_nnsfunE</span> <span class="id">n</span> <span class="id">t</span> : <span class="id">sum_nnsfun</span> <span class="id">n</span> <span class="id">t</span> = \<span class="id">sum_</span>(<span class="id">i</span> &lt; <span class="id"><a name="nnsfun_cover.f">n</a></span>) (<span class="id">f</span> <span class="id">i</span> <span class="id">t</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof54')">Proof.</span></div>
<div class="proofscript" id="proof54">
 <span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">sum_nnsfun</span>; <span class="id">elim</span>/<span class="id">big_ind2</span> : <span class="id">_</span> =&gt; [|<span class="id">x</span> <span class="id">g</span> <span class="id">y</span> <span class="id">h</span> &lt;- &lt;-|]. Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">bigmax_nnsfun</span> <span class="id">n</span> := \<span class="id">big</span>[<span class="id">max_nnsfun</span>/<span class="id">nnsfun0</span>]<span class="id">_</span>(<span class="id">i</span> &lt; <span class="id">n</span>) <span class="id">f</span> <span class="id">i</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">bigmax_nnsfunE</span> <span class="id"><a name="nnsfun_coverT">n</a></span> <span class="id">t</span> : <span class="id">bigmax_nnsfun</span> <span class="id">n</span> <span class="id">t</span> = \<span class="id">big</span>[<span class="id">maxr</span>/0]<span class="id">_</span>(<span class="id">i</span> &lt; <span class="id">n</span>) (<span class="id">f</span> <span class="id">i</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#nnsfun_cover.f">t</a></span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof55')">Proof.</span></div>
<div class="proofscript" id="proof55">
 <span class="kwd">by</span> <span class="id">rewrite</span> /<span class="id">bigmax_nnsfun</span>; <span class="id">elim</span>/<span class="id">big_ind2</span> : <span class="id">_</span> =&gt; [|<span class="id">x</span> <span class="id">g</span> <span class="id">y</span> <span class="id">h</span> &lt;- &lt;-|]. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">nnsfun_iter</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">nnsfun_cover</span>.<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">ereal_scope</span>.<br/>
<span class="kwd">Context</span> <span class="id"><a href="mathcomp.analysis.measure.html#measurable">d</a></span> (<span class="id">T</span> : <span class="id">measurableType</span> <span class="id">d</span>) (<span class="id">R</span> : <span class="id">realType</span>).<br/>
<span class="kwd">Variable</span> <span class="id">f</span> : {<span class="id">nnsfun</span> <span class="id">T</span> &gt;-&gt; <span class="id">R</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nnsfun_cover</span> :<br/>
&nbsp;&nbsp;\<span class="id">big</span>[<span class="id">setU</span>/<span class="id"><a name="measurable_sfun_inP">set0</a></span>]<span class="id">_</span>(<span class="id">i</span> \<span class="kwd">in</span> <span class="id">range</span> <span class="id">f</span>) (<span class="id">f</span> @^-1` [<span class="id">set</span> <span class="id">i</span>]) = <span class="id">setT</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof56')">Proof.</span></div>
<div class="proofscript" id="proof56">
 <span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">fsbig_setU</span>//= -<span class="id">subTset</span> =&gt; <span class="id">x</span> <span class="id">_</span>; <span class="kwd">exists</span> (<span class="id"><a href="mathcomp.analysis.measure.html#measurable">f</a></span> <span class="id">x</span>). Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nnsfun_coverT</span> :<br/>
&nbsp;&nbsp;\<span class="id">big</span>[<span class="id">setU</span>/<span class="id">set0</span>]<span class="id">_</span>(<span class="id">i</span> \<span class="kwd">in</span> [<span class="id">set</span>: <span class="id">R</span>]) (<span class="id">f</span> @^-1` [<span class="id">set</span> <span class="id">i</span>]) = <span class="id">setT</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof57')">Proof.</span></div>
<div class="proofscript" id="proof57">
<span class="kwd">by</span> <span class="id">rewrite</span> -(<span class="id">fsbig_widen</span> (<span class="id">range</span> <span class="id">f</span>)) ?<span class="id">nnsfun_cover</span>//= =&gt; <span class="id">x</span> [<span class="id">_</span> /= /<span class="id">preimage10</span>-&gt;].<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">nnsfun_cover</span>.<br/>
<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Extern</span> 0 (<span class="id">measurable</span> (<span class="id">_</span> @^-1` [<span class="id">set</span> <span class="id">_</span>])) =&gt;<br/>
&nbsp;&nbsp;<span class="id">solve</span> [<span class="id">apply</span>: <span class="id">measurable_sfunP</span>; <span class="id">exact</span>: <span class="id">measurable_set1</span>] : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">measurable_sfun_inP</span> {<span class="id"><a name="T:309">d</a></span>} {<span class="id"><a href="mathcomp.analysis.measure.html#Measurable.Exports.measurableType">aT</a></span> : <span class="id">measurableType</span> <span class="id">d</span>} {<span class="id">rT</span> : <span class="id">realType</span>}<br/>
&nbsp;&nbsp;&nbsp;(<span class="id"><a name="measure_fsbig.m">f</a></span> : {<span class="id">mfun</span> <span class="id">aT</span> &gt;-&gt; <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#measure_fsbig.T">rT</a></span>}) <span class="id">D</span> (<span class="id">y</span> : <span class="id">rT</span>) :<br/>
&nbsp;&nbsp;<span class="id">measurable</span> <span class="id">D</span> -&gt; <span class="id"><a name="I:312">measurable</a></span> (<span class="id">D</span> `&amp;` <span class="id">f</span> @^-1` [<span class="id">set</span> <span class="id">y</span>]).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof58')">Proof.</span></div>
<div class="proofscript" id="proof58">
 <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">Dm</span>; <span class="id">apply</span>: <span class="id">measurableI</span>. Qed.</div>
<br/>
#[<span class="id"><a href="mathcomp.analysis.measure.html#measurable">global</a></span>] <span class="kwd">Hint</span> <span class="id">Extern</span> 0 (<span class="id">measurable</span> (<span class="id">_</span> `&amp;` <span class="id">_</span> @^-1` [<span class="id">set</span> <span class="id">_</span>])) =&gt;<br/>
&nbsp;&nbsp;<span class="id">solve</span> [<span class="id">apply</span>: <span class="id">measurable_sfun_inP</span>; <span class="id">assumption</span>] : <span class="id">core</span>.<br/>
<br/>
#[<span class="id">global</span>] <span class="kwd">Hint</span> <span class="id">Extern</span> 0 (<span class="id">finite_set</span> <span class="id">_</span>) =&gt; <span class="id">solve</span> [<span class="id">apply</span>: <span class="id">fimfunP</span>] : <span class="id">core</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">measure_fsbig</span>.<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">ereal_scope</span>.<br/>
<span class="kwd">Context</span> <span class="id">d</span> (<span class="id"><a name="i:327">T</a></span> : <span class="id">measurableType</span> <span class="id">d</span>) (<span class="id">R</span> : <span class="id">realType</span>).<br/>
<span class="kwd">Variable</span> <span class="id">m</span> : {<span class="id">measure</span> <span class="id">set</span> <span class="id">T</span> -&gt; \<span class="id">bar</span> <span class="id">R</span>}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">measure_fsbig</span> (<span class="id">I</span> : <span class="id">choiceType</span>) (<span class="id">A</span> : <span class="id">set</span> <span class="id">I</span>) (<span class="id">F</span> : <span class="id">I</span> -&gt; <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;<span class="id">finite_set</span> <span class="id">A</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">A</span> <span class="id">i</span> -&gt; <span class="id">measurable</span> (<span class="id">F</span> <span class="id">i</span>)) -&gt; <span class="id">trivIset</span> <span class="id">A</span> <span class="id">F</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">m</span> (\<span class="id">big</span>[<span class="id">setU</span>/<span class="id">set0</span>]<span class="id">_</span>(<span class="id">i</span> \<span class="kwd">in</span> <span class="id">A</span>) <span class="id">F</span> <span class="id">i</span>) = \<span class="id">sum_</span>(<span class="id"><a href="mathcomp.classical.classical_sets.html#trivIset_setIl">i</a></span> \<span class="kwd">in</span> <span class="id">A</span>) <span class="id">m</span> (<span class="id">F</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof59')">Proof.</span></div>
<div class="proofscript" id="proof59">
<span class="id">move</span>=&gt; <span class="id">Afin</span> <span class="id">Fm</span> <span class="id">Ft</span>.<br/>
<span class="kwd">by</span> <span class="id"><a name="additive_nnsfunl">rewrite</a></span> <span class="id">fsbig_finite</span>// -<span class="id">measure_fin_bigcup</span>// -<span class="id">bigsetU_fset_set</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">additive_nnsfunr</span> (<span class="id">g</span> <span class="id">f</span> : {<span class="id">nnsfun</span> <span class="id">T</span> &gt;-&gt; <span class="id">R</span>}) <span class="id">x</span> :<br/>
&nbsp;&nbsp;\<span class="id">sum_</span>(<span class="id">i</span> \<span class="kwd">in</span> <span class="id">range</span> <span class="id">g</span>) <span class="id">m</span> (<span class="id">f</span> @^-1` [<span class="id">set</span> <span class="id">x</span>] `&amp;` (<span class="id">g</span> @^-1` [<span class="id">set</span> <span class="id">i</span>])) =<br/>
&nbsp;&nbsp;<span class="id">m</span> (<span class="id">f</span> @^-1` [<span class="id">set</span> <span class="id">x</span>] `&amp;` \<span class="id">big</span>[<span class="id">setU</span>/<span class="id">set0</span>]<span class="id">_</span>(<span class="id">i</span> \<span class="kwd">in</span> <span class="id">range</span> <span class="id">g</span>) (<span class="id">g</span> @^-1` [<span class="id">set</span> <span class="id">i</span>])).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof60')">Proof.</span></div>
<div class="proofscript" id="proof60">
<span class="id">rewrite</span> -?<span class="id">measure_fsbig</span>//.<br/>
- <span class="kwd">by</span> <span class="id">rewrite</span> !<span class="id">fsbig_finite</span>//= <span class="id">big_distrr</span>//.<br/>
- <span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">i</span> <span class="id">Ai</span>; <span class="id">apply</span>: <span class="id">measurableI</span> =&gt; //.<br/>
- <span class="id">exact</span>/<span class="id">trivIset_setIl</span>/<span class="id">trivIset_preimage1</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">additive_nnsfunl</span> (<span class="id">g</span> <span class="id">f</span> : {<span class="id">nnsfun</span> <span class="id">T</span> &gt;-&gt; <span class="id">R</span>}) <span class="id">x</span> :<br/>
&nbsp;&nbsp;\<span class="id">sum_</span>(<span class="id">i</span> \<span class="kwd">in</span> <span class="id">range</span> <span class="id">g</span>) <span class="id">m</span> (<span class="id">g</span> @^-1` [<span class="id">set</span> <span class="id">i</span>] `&amp;` (<span class="id">f</span> @^-1` [<span class="id">set</span> <span class="id">x</span>])) =<br/>
&nbsp;&nbsp;<span class="id">m</span> (\<span class="id">big</span>[<span class="id">setU</span>/<span class="id">set0</span>]<span class="id">_</span>(<span class="id">i</span> \<span class="kwd">in</span> <span class="id">range</span> <span class="id">g</span>) (<span class="id">g</span> @^-1` [<span class="id">set</span> <span class="id">i</span>]) `&amp;` <span class="id">f</span> @^-1` [<span class="id">set</span> <span class="id">x</span>]).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof61')">Proof.</span></div>
<div class="proofscript" id="proof61">
 <span class="kwd">by</span> <span class="id">under</span> <span class="id">eq_fsbigr</span> <span class="id">do</span> <span class="id"><a name="r:353">rewrite</a></span> <span class="id">setIC</span>; <span class="id">rewrite</span> <span class="id">setIC</span> <span class="id">additive_nnsfunr</span>. Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">measure_fsbig</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">mulem_ge0</span>.<br/>
<span class="id">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">ereal_scope</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">mulef_ge0</span> (<span class="id">R</span> : <span class="id">realDomainType</span>) <span class="id">x</span> (<span class="id">f</span> : <span class="id">R</span> -&gt; \<span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#preimage_nnfun0">bar</a></span> <span class="id">R</span>) :<br/>
&nbsp;&nbsp;0 &lt;= <span class="id">f</span> <span class="id"><a href="mathcomp.analysis.numfun.html#indic0">x</a></span> -&gt; ((<span class="id">x</span> &lt; 0)%<span class="id">R</span> -&gt; <span class="id">f</span> <span class="id">x</span> = 0) -&gt; 0 &lt;= <span class="id">x</span>%:<span class="id">E</span> * <span class="id">f</span> <span class="id">x</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof62')">Proof.</span></div>
<div class="proofscript" id="proof62">
<span class="id">move</span>=&gt; <span class="id">A0</span> <span class="id">xA</span> /=; <span class="id">have</span> [<span class="id">x0</span>|<span class="id">x0</span>] := <span class="id">ltP</span> <span class="id">x</span> 0%<span class="id">R</span>; <span class="id">first</span> <span class="kwd">by</span> <span class="id"><a name="x:361">rewrite</a></span> (<span class="id">xA</span> <span class="id"><a href="mathcomp.classical.classical_sets.html#set">x0</a></span>) <span class="id">mule0</span>.<br/>
<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">mule_ge0</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nnfun_muleindic_ge0</span> <span class="id">d</span> (<span class="id">T</span> : <span class="id">measurableType</span> <span class="id">d</span>) (<span class="id">R</span> : <span class="id">realDomainType</span>)<br/>
&nbsp;&nbsp;(<span class="id">f</span> : {<span class="id">nnfun</span> <span class="id">T</span> &gt;-&gt; <span class="id">R</span>}) <span class="id">r</span> <span class="id">z</span> : 0 &lt;= <span class="id">r</span>%:<span class="id">E</span> * (\1<span class="id">_</span>(<span class="id">f</span> @^-1` [<span class="id">set</span> <span class="id">r</span>]) <span class="id">z</span>)%:<span class="id">E</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof63')">Proof.</span></div>
<div class="proofscript" id="proof63">
<span class="id">apply</span>: (@<span class="id">mulef_ge0</span> <span class="id">_</span> <span class="id">_</span> (<span class="kwd">fun</span> <span class="id">r</span> =&gt; (\1<span class="id"><a name="d:363">_</a></span>(<span class="id">f</span> @^-1` [<span class="id">set</span> <span class="id">r</span>]) <span class="id">z</span>)%:<span class="id">E</span>)).<br/>
&nbsp;&nbsp;<span class="kwd">by</span> <span class="id">rewrite</span> <span class="id">lee_fin</span>// <span class="id">indicE</span>.<br/>
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">r0</span>; <span class="id">rewrite</span> <span class="id">preimage_nnfun0</span>// <span class="id">indic0</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">mulemu_ge0</span> <span class="id">d</span> (<span class="id">T</span> : <span class="id">measurableType</span> <span class="id">d</span>) (<span class="id">R</span> : <span class="id">realType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span> : {<span class="id">measure</span> <span class="id">set</span> <span class="id">T</span> -&gt; \<span class="id">bar</span> <span class="id">R</span>}) <span class="id">x</span> (<span class="id">A</span> : <span class="id">R</span> -&gt; <span class="id">set</span> <span class="id">T</span>) :<br/>
&nbsp;&nbsp;((<span class="id">x</span> &lt; 0)%<span class="id">R</span> -&gt; <span class="id">A</span> <span class="id">x</span> = <span class="id">set0</span>) -&gt; 0 &lt;= <span class="id">x</span>%:<span class="id">E</span> * <span class="id">mu</span> (<span class="id">A</span> <span class="id">x</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof64')">Proof.</span></div>
<div class="proofscript" id="proof64">
<span class="kwd">by</span> <span class="id">move</span>=&gt; <span class="id">xA</span>; <span class="id">rewrite</span> (@<span class="id">mulef_ge0</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">mu</span> \<span class="id">o</span> <span class="id">_</span>))//= =&gt; /<span class="id">xA</span> -&gt;; <span class="id">rewrite</span> <span class="id">measure0</span>.<br/>
Qed.</div>
<span class="id">Global</span> <span class="kwd">Arguments</span> <span class="id">mulemu_ge0</span> {<span class="id"><a name="simple_fun_raw_integral.R">d</a></span> <span class="id">T</span> <span class="id">R</span> <span class="id">mu</span> <span class="id">x</span>} <span class="id">A</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nnsfun_mulemu_ge0</span> <span class="id">d</span> (<span class="id"><a name="simple_fun_raw_integral.f">T</a></span> : <span class="id">measurableType</span> <span class="id">d</span>) (<span class="id">R</span> : <span class="id">realType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span> : {<span class="id">measure</span> <span class="id"><a href="mathcomp.analysis.lebesgue_integral.html#simple_fun_raw_integral.R">set</a></span> <span class="id">T</span> -&gt; \<span class="id">bar</span> <span class="id">R</span>}) (<span class="id">f</span> : {<span class="id">nnsfun</span> <span class="id">T</span> &gt;-&gt; <span class="id">R</span>}) <span class="id">x</span> :<br/>
&nbsp;&nbsp;0 &lt;= <span class="id">x</span>%:<span class="id">E</span> * <span class="id">mu</span> (<span class="id">f</span> @^-1` [<span class="id">set</span> <span class="id">x</span>]).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof65')">Proof.</span></div>
<div class="proofscript" id="proof65">
<span class="kwd">by</span> <span class="id">apply</span>: (<span class="id">mulemu_ge0</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">f</span> @^-1` [<span class="id">set</span> <span class="id">x</span>])); <span class="id">exact</span>: <span class="id">preimage_nnfun0</span>.<br/>
Qed.</div>
<span class="kwd">End</span> <span class="id">mulem_ge0</span>.<br/>
<br/>
<pre class="ssrdoc">
Section simple_fun_raw_integral.
Local Open Scope ereal_scope.
Variables (T : Type) (R : numDomainType) (mu : set T -&gt; \bar R) (f : T -&gt; R).
Definition sintegral := \sum_(x \in [set: R]) x%:E * mu (f @^-1` [set x]).
Lemma sintegralET :
  sintegral = \sum_(x \in [set: R]) x%:E * mu (f @^-1` [set x]).
Proof. by []. Qed.
End simple_fun_raw_integral.
#[global] Hint Extern 0 (is_true (0 &lt;= (_ : {measure set _ -&gt; \bar _}) _)%E) =&gt;
  solve [apply: measure_ge0] : core.
Section sintegral_lemmas.
Context d (T : measurableType d) (R : realType).
Variable mu : {measure set T -&gt; \bar R}.
Local Open Scope ereal_scope.
Lemma sintegralE f :
  sintegral mu f = \sum_(x \in range f) x%:E * mu (f @^-1` [set x]).
Proof.
rewrite (fsbig_widen (range f) setT)//= =&gt; x [_ Nfx] /=.
by rewrite preimage10// measure0 mule0.
Qed.
Lemma sintegral0 : sintegral mu (cst 0%R) = 0.
Proof.
rewrite sintegralE fsbig1// =&gt; r _; rewrite preimage_cst.
by case: ifPn =&gt; [/[!inE] &lt;-|]; rewrite ?mul0e// measure0 mule0.
Qed.
Lemma sintegral_ge0 (f : {nnsfun T &gt;-&gt; R}) : 0 &lt;= sintegral mu f.
Proof. by rewrite sintegralE fsume_ge0// =&gt; r _; exact: nnsfun_mulemu_ge0. Qed.
Lemma sintegral_indic (A : set T) : sintegral mu \1_A = mu A.
Proof.
rewrite sintegralE (fsbig_widen _ [set 0%R; 1%R]) =&gt; //; last 2 first.
  - exact: image_indic_sub.
  - by move=&gt; t [[] -&gt; /= /preimage10-&gt;]; rewrite measure0 mule0.
have N01 : (0 &lt;&gt; 1:&gt; R)%R by move=&gt; /esym/eqP; rewrite oner_eq0.
rewrite fsbigU//=; last by move=&gt; t [-&gt;]//.
rewrite !fsbig_set1 mul0e add0e mul1e.
by rewrite preimage_indic ifT ?inE// ifN ?notin_set.
Qed.
NB: not used 
Lemma sintegralEnnsfun (f : {nnsfun T &gt;-&gt; R}) : sintegral mu f =
  (\sum_(x \in [set r | r &gt; 0]%R) (x%:E * mu (f @^-1` [set x])))%E.
Proof.
rewrite (fsbig_widen _ setT) ?sintegralET//.
move=&gt; x [_ /=]; case: ltgtP =&gt; //= [xlt0 _|&lt;-]; last by rewrite mul0e.
rewrite preimage10 ?measure0 ?mule0//= =&gt; -[t _].
by apply/eqP; apply: contra_ltN xlt0 =&gt; /eqP&lt;-.
Qed.
End sintegral_lemmas.
Lemma eq_sintegral d (T : measurableType d) (R : numDomainType)
     (mu : set T -&gt; \bar R) g f :
   f =1 g -&gt; sintegral mu f = sintegral mu g.
Proof. by move=&gt; /funext-&gt;. Qed.
Arguments eq_sintegral {d T R mu} g.
Section sintegralrM.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (m : {measure set T -&gt; \bar R}) (r : R) (f : {nnsfun T &gt;-&gt; R}).
Lemma sintegralrM : sintegral m (cst r \* f)%R = r%:E * sintegral m f.
Proof.
have [-&gt;|r0] := eqVneq r 0%R.
  by rewrite mul0e (eq_sintegral (cst 0%R)) ?sintegral0// =&gt; x/=; rewrite mul0r.
rewrite !sintegralET.
transitivity (\sum_(x \in [set: R]) x%:E * m (f @^-1` [set x / r])).
  by under eq_fsbigr do rewrite preimage_cstM//.
transitivity (\sum_(x \in [set: R]) r%:E * (x%:E * m (f @^-1` [set x]))).
  rewrite (reindex_fsbigT (fun x =&gt; r * x)%R)//; last first.
    by exists ( *%R r ^-1)%R; [exact: mulKf|exact: mulVKf].
  by apply: eq_fsbigr =&gt; x; rewrite mulrAC divrr ?unitfE// mul1r muleA EFinM.
by rewrite ge0_mule_fsumr// =&gt; x; exact: nnsfun_mulemu_ge0.
Qed.
End sintegralrM.
Section sintegralD.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (m : {measure set T -&gt; \bar R}).
Variables (D : set T) (mD : measurable D) (f g : {nnsfun T &gt;-&gt; R}).
Lemma sintegralD : sintegral m (f \+ g)%R = sintegral m f + sintegral m g.
Proof.
rewrite !sintegralE; set F := f @` _; set G := g @` _; set FG := _ @` _.
pose pf x := f @^-1` [set x]; pose pg y := g @^-1` [set y].
transitivity (\sum_(z \in FG) z%:E * \sum_(a \in F) m (pf a `&amp;` pg (z - a)%R)).
  apply: eq_fsbigr =&gt; z _; rewrite preimage_add -fsbig_setU// measure_fsbig//.
    by move=&gt; x Fx; exact: measurableI.
  exact/trivIset_setIr/trivIset_preimage1.
under eq_fsbigr do rewrite ge0_mule_fsumr//; rewrite exchange_fsbig//.
transitivity (\sum_(x \in F) \sum_(y \in G) (x + y)%:E * m (pf x `&amp;` pg y)).
  apply: eq_fsbigr =&gt; x _; rewrite /pf /pg (fsbig_widen G setT)//=; last first.
    by move=&gt; y [_ /= /preimage10-&gt;]; rewrite setI0 measure0 mule0.
  rewrite (fsbig_widen FG setT)//=; last first.
    move=&gt; z [_ /= FGz]; rewrite [X in m X](_ : _ = set0) ?measure0 ?mule0//.
    rewrite -subset0 =&gt; //= {x}i /= [&lt;-] /(canLR (@addrNK _ _)).
    by apply: contra_not FGz =&gt; &lt;-; exists i; rewrite //= addrC.
  rewrite (reindex_fsbigT (+%R x))//=.
  by apply: eq_fsbigr =&gt; y; rewrite addrC addrK.
transitivity (\sum_(x \in F) \sum_(y \in G) x%:E * m (pf x `&amp;` pg y) +
              \sum_(x \in F) \sum_(y \in G) y%:E * m (pf x `&amp;` pg y)).
  do 2![rewrite -fsbig_split//; apply: eq_fsbigr =&gt; _ /set_mem [? _ &lt;-]].
  by rewrite EFinD ge0_muleDl// ?lee_fin.
congr (_ + _)%E; last rewrite exchange_fsbig//; apply: eq_fsbigr =&gt; x _.
  by rewrite -ge0_mule_fsumr// additive_nnsfunr nnsfun_cover setIT.
by rewrite -ge0_mule_fsumr// additive_nnsfunl nnsfun_cover setTI.
Qed.
End sintegralD.
Section le_sintegral.
Context d (T : measurableType d) (R : realType) (m : {measure set T -&gt; \bar R}).
Variables f g : {nnsfun T &gt;-&gt; R}.
Hypothesis fg : forall x, f x &lt;= g x.
Let fgnn : @isNonNegFun T R (g \- f).
Proof. by split=&gt; x; rewrite subr_ge0 fg. Qed.
#[local] HB.instance Definition _ := fgnn.
Lemma le_sintegral : (sintegral m f &lt;= sintegral m g)%E.
Proof.
have gfgf : g =1 f \+ (g \- f) by move=&gt; x /=; rewrite addrC subrK.
by rewrite (eq_sintegral _ _ gfgf) sintegralD// lee_addl // sintegral_ge0.
Qed.
End le_sintegral.
Lemma is_cvg_sintegral d (T : measurableType d) (R : realType)
  (m : {measure set T -&gt; \bar R}) (f : {nnsfun T &gt;-&gt; R}^nat) :
  (forall x, nondecreasing_seq (f ^~ x)) -&gt; cvg (sintegral m \o f).
Proof.
move=&gt; nd_f; apply/cvg_ex; eexists; apply/ereal_nondecreasing_cvgn =&gt; a b ab.
by apply: le_sintegral =&gt; // =&gt; x; exact/nd_f.
Qed.
Definition proj_nnsfun d (T : measurableType d) (R : realType)
    (f : {nnsfun T &gt;-&gt; R}) (A : set T) (mA : measurable A) :=
  mul_nnsfun f (indic_nnsfun R mA).
Definition mrestrict d (T : measurableType d) (R : realType) (f : {nnsfun T &gt;-&gt; R})
  A (mA : measurable A) : f \_ A = proj_nnsfun f mA.
Proof.
apply/funext =&gt; x /=; rewrite /patch mindicE.
by case: ifP; rewrite (mulr0, mulr1).
Qed.
Definition scale_nnsfun d (T : measurableType d) (R : realType)
    (f : {nnsfun T &gt;-&gt; R}) (k : R) (k0 : 0 &lt;= k) :=
  mul_nnsfun (cst_nnsfun T (NngNum k0)) f.
Section sintegral_nondecreasing_limit_lemma.
Context d (T : measurableType d) (R : realType).
Variable mu : {measure set T -&gt; \bar R}.
Variables (g : {nnsfun T &gt;-&gt; R}^nat) (f : {nnsfun T &gt;-&gt; R}).
Hypothesis nd_g : forall x, nondecreasing_seq (g^~ x).
Hypothesis gf : forall x, cvg (g^~ x) -&gt; f x &lt;= lim (g^~ x).
Let fleg c : (set T)^nat := fun n =&gt; [set x | c * f x &lt;= g n x].
Let nd_fleg c : {homo fleg c : n m / (n &lt;= m)%N &gt;-&gt; (n &lt;= m)%O}.
Proof.
move=&gt; n m nm; rewrite /fleg; apply/subsetPset =&gt; x /= cfg.
by move: cfg =&gt; /le_trans; apply; exact: nd_g.
Qed.
Let mfleg c n : measurable (fleg c n).
Proof.
rewrite /fleg [X in _ X](_ : _ = \big[setU/set0]_(y &lt;- fset_set (range f))
    \big[setU/set0]_(x &lt;- fset_set (range (g n)) | c * y &lt;= x)
      (f @^-1` [set y] `&amp;` (g n @^-1` [set x]))).
  apply: bigsetU_measurable =&gt; r _; apply: bigsetU_measurable =&gt; r' crr'.
  exact/measurableI/measurable_sfunP.
rewrite predeqE =&gt; t; split =&gt; [/= cfgn|].
- rewrite -bigcup_seq; exists (f t); first by rewrite /= in_fset_set//= mem_set.
  rewrite -bigcup_seq_cond; exists (g n t) =&gt; //=.
  by rewrite in_fset_set// mem_set.
- rewrite bigsetU_fset_set// =&gt; -[r [x _ fxr]].
  rewrite bigsetU_fset_set_cond// =&gt; -[r' [[x' _ gnx'r'] crr']].
  by rewrite /preimage/= =&gt; -[-&gt; -&gt;].
Qed.
Let g1 c n : {nnsfun T &gt;-&gt; R} := proj_nnsfun f (mfleg c n).
Let le_ffleg c : {homo (fun p x =&gt; g1 c p x): m n / (m &lt;= n)%N &gt;-&gt; (m &lt;= n)%O}.
Proof.
move=&gt; m n mn; apply/asboolP =&gt; t; rewrite /g1/= ler_pmul// 2!mindicE/= ler_nat.
have [|//] := boolP (t \in fleg c m); rewrite inE =&gt; cnt.
by have := nd_fleg c mn =&gt; /subsetPset/(_ _ cnt) cmt; rewrite mem_set.
Qed.
Let bigcup_fleg c : c &lt; 1 -&gt; \bigcup_n fleg c n = setT.
Proof.
move=&gt; c1; rewrite predeqE =&gt; x; split=&gt; // _.
have := @fun_ge0 _ _ f x; rewrite le_eqVlt =&gt; /predU1P[|] gx0.
  by exists O =&gt; //; rewrite /fleg /=; rewrite -gx0 mulr0 fun_ge0.
have [cf|df] := pselect (cvg (g^~ x)).
  have cfg : lim (g^~ x) &gt; c * f x.
    by rewrite (lt_le_trans _ (gf cf)) // gtr_pmull.
  suff [n cfgn] : exists n, g n x &gt;= c * f x by exists n.
  move/(@lt_lim _ _ _ (nd_g x) cf) : cfg =&gt; [n _ nf].
  by exists n; apply: nf =&gt; /=.
have /cvgryPge/(_ (c * f x))[n _ ncfgn]:= nondecreasing_dvgn_lt (nd_g x) df.
by exists n =&gt; //; rewrite /fleg /=; apply: ncfgn =&gt; /=.
Qed.
Local Open Scope ereal_scope.
Lemma nd_sintegral_lim_lemma : sintegral mu f &lt;= lim (sintegral mu \o g).
Proof.
suff ? : forall c, (0 &lt; c &lt; 1)%R -&gt;
    c%:E * sintegral mu f &lt;= lim (sintegral mu \o g).
  by apply/lee_mul01Pr =&gt; //; exact: sintegral_ge0.
move=&gt; c /andP[c0 c1].
have cg1g n : c%:E * sintegral mu (g1 c n) &lt;= sintegral mu (g n).
  rewrite -sintegralrM (_ : (_ \* _)%R = scale_nnsfun (g1 c n) (ltW c0)) //.
  apply: le_sintegral =&gt; // t.
  suff : forall m x, (c * g1 c m x &lt;= g m x)%R by move=&gt; /(_ n t).
  move=&gt; m x; rewrite /g1 /proj_nnsfun/= mindicE.
  by have [|] := boolP (_ \in _); [rewrite inE mulr1|rewrite 2!mulr0 fun_ge0].
suff {cg1g}&lt;- : lim (fun n =&gt; sintegral mu (g1 c n)) = sintegral mu f.
  have is_cvg_g1 : cvg (fun n =&gt; sintegral mu (g1 c n)).
    by apply: is_cvg_sintegral =&gt; //= x m n /(le_ffleg c)/lefP/(_ x).
  rewrite -limeMl // lee_lim//; first exact: is_cvgeMl.
  - by apply: is_cvg_sintegral =&gt; // m n mn; apply/lefP =&gt; t; apply: nd_g.
  - by apply: nearW; exact: cg1g.
suff : (fun n =&gt; sintegral mu (g1 c n)) --&gt; sintegral mu f by apply/cvg_lim.
rewrite [X in X --&gt; _](_ : _ = fun n =&gt; \sum_(x &lt;- fset_set (range f))
    x%:E * mu (f @^-1` [set x] `&amp;` fleg c n)); last first.
  rewrite funeqE =&gt; n; rewrite sintegralE.
  transitivity (\sum_(x \in range f) x%:E * mu (g1 c n @^-1` [set x])).
    apply: eq_fbigl =&gt; r.
    do 2 (rewrite in_finite_support; last exact/finite_setIl).
    apply/idP/idP.
      rewrite in_setI =&gt; /andP[]; rewrite inE/= =&gt; -[x _]; rewrite mindicE.
      have [_|xcn] := boolP (_ \in _).
        by rewrite mulr1 =&gt; &lt;-; rewrite !inE/= =&gt; ?; split =&gt; //; exists x.
      by rewrite mulr0 =&gt; /esym -&gt;; rewrite !inE/= mul0e.
    rewrite in_setI =&gt; /andP[]; rewrite inE =&gt; -[x _ &lt;-].
    rewrite !inE/= =&gt; h; split=&gt; //; move: h; rewrite mindicE =&gt; /eqP.
    rewrite mule_eq0 negb_or =&gt; /andP[_]; set S := (X in mu X) =&gt; mS0.
    suff : S !=set0 by move=&gt; [y yx]; exists y.
    by apply/set0P; apply: contra mS0 =&gt; /eqP -&gt;; rewrite measure0.
  rewrite fsbig_finite//=; apply: eq_fbigr =&gt; r.
  rewrite in_fset_set// inE =&gt; -[t _ ftr _].
  have [-&gt;|r0] := eqVneq r 0%R; first by rewrite 2!mul0e.
  congr (_ * mu _); apply/seteqP; split =&gt; x.
    rewrite /preimage/= mindicE.
    have [|_] := boolP (_ \in _); first by rewrite mulr1 inE.
    by rewrite mulr0 =&gt; /esym/eqP; rewrite (negbTE r0).
  by rewrite /preimage/= =&gt; -[fxr cnx]; rewrite mindicE mem_set// mulr1.
rewrite sintegralE fsbig_finite//=.
apply: cvg_nnesum=&gt; [r _|r _].
  near=&gt; A; apply: (mulemu_ge0 (fun x =&gt; f @^-1` [set x] `&amp;` fleg c A)) =&gt; r0.
  by rewrite preimage_nnfun0// set0I.
apply: cvgeMl =&gt; //=; rewrite [X in _ --&gt; X](_ : _ =
    mu (\bigcup_n (f @^-1` [set r] `&amp;` fleg c n))); last first.
  by rewrite -setI_bigcupr bigcup_fleg// setIT.
have ? k i : measurable (f @^-1` [set k] `&amp;` fleg c i) by exact: measurableI.
apply: nondecreasing_cvg_mu; [by []|exact: bigcupT_measurable|].
move=&gt; n m nm; apply/subsetPset; apply: setIS.
by move/(nd_fleg c) : nm =&gt; /subsetPset.
Unshelve. all: by end_near. Qed.
End sintegral_nondecreasing_limit_lemma.
Section sintegral_nondecreasing_limit.
Context d (T : measurableType d) (R : realType).
Variable mu : {measure set T -&gt; \bar R}.
Variables (g : {nnsfun T &gt;-&gt; R}^nat) (f : {nnsfun T &gt;-&gt; R}).
Hypothesis nd_g : forall x, nondecreasing_seq (g^~ x).
Hypothesis gf : forall x, g ^~ x --&gt; f x.
Let limg x : lim (g^~x) = f x.
Proof. by apply/cvg_lim; [exact: Rhausdorff| exact: gf]. Qed.
Lemma nd_sintegral_lim : sintegral mu f = lim (sintegral mu \o g).
Proof.
apply/eqP; rewrite eq_le; apply/andP; split.
  by apply: nd_sintegral_lim_lemma =&gt; // x; rewrite -limg.
have : nondecreasing_seq (sintegral mu \o g).
  by move=&gt; m n mn; apply: le_sintegral =&gt; // x; exact/nd_g.
move=&gt; /ereal_nondecreasing_cvgn/cvg_lim -&gt; //.
apply: ub_ereal_sup =&gt; _ [n _ &lt;-] /=; apply: le_sintegral =&gt; // x.
rewrite -limg // (nondecreasing_cvgn_le (nd_g x)) //.
by apply/cvg_ex; exists (f x); exact: gf.
Qed.
End sintegral_nondecreasing_limit.
Section integral.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Implicit Types (f g : T -&gt; \bar R) (D : set T).
Let nnintegral mu f := ereal_sup [set sintegral mu h |
  h in [set h : {nnsfun T &gt;-&gt; R} | forall x, (h x)%:E &lt;= f x]].
Definition integral mu D f (g := f \_ D) :=
  nnintegral mu (g ^\+) - nnintegral mu (g ^\-).
Variable (mu : {measure set T -&gt; \bar R}).
Let nnintegral_ge0 f : (forall x, 0 &lt;= f x) -&gt; 0 &lt;= nnintegral mu f.
Proof.
by move=&gt; f0; apply: ereal_sup_ub; exists nnsfun0; last by rewrite sintegral0.
Qed.
Let eq_nnintegral g f : f =1 g -&gt; nnintegral mu f = nnintegral mu g.
Proof. by move=&gt; /funext-&gt;. Qed.
Let nnintegral0 : nnintegral mu (cst 0) = 0.
Proof.
rewrite /nnintegral /=; apply/eqP; rewrite eq_le; apply/andP; split; last first.
  apply/ereal_sup_ub; exists nnsfun0; last by rewrite sintegral0.
  by [].
apply/ub_ereal_sup =&gt; /= x [f /= f0 &lt;-]; have {}f0 : forall x, f x = 0%R.
  by move=&gt; y; apply/eqP; rewrite eq_le -2!lee_fin f0 //= lee_fin//.
by rewrite (eq_sintegral (@nnsfun0 _ T R)) ?sintegral0.
Qed.
Let nnintegral_nnsfun (h : {nnsfun T &gt;-&gt; R}) :
  nnintegral mu (EFin \o h) = sintegral mu h.
Proof.
apply/eqP; rewrite eq_le; apply/andP; split.
  by apply/ub_ereal_sup =&gt; /= _ -[g /= gh &lt;-]; rewrite le_sintegral.
by apply: ereal_sup_ub =&gt; /=; exists h.
Qed.
Local Notation "\int_ ( x 'in' D ) F" := (integral mu D (fun x =&gt; F))
  (at level 36, F at level 36, x, D at level 50,
  format "'[' \int_ ( x  'in'  D ) '/  '  F ']'").
Lemma eq_integral D g f : {in D, f =1 g} -&gt;
  \int_(x in D) f x = \int_(x in D) g x.
Proof. by rewrite /integral =&gt; /eq_restrictP-&gt;. Qed.
Lemma ge0_integralE D f : (forall x, D x -&gt; 0 &lt;= f x) -&gt;
  \int_(x in D) f x = nnintegral mu (f \_ D).
Proof.
move=&gt; f0; rewrite /integral funeneg_restrict funepos_restrict.
have /eq_restrictP-&gt; := ge0_funeposE f0.
have /eq_restrictP-&gt; := ge0_funenegE f0.
by rewrite erestrict0 nnintegral0 sube0.
Qed.
Lemma ge0_integralTE f : (forall x, 0 &lt;= f x) -&gt;
  \int_(x in setT) f x = nnintegral mu f.
Proof. by move=&gt; f0; rewrite ge0_integralE// patch_setT. Qed.
Lemma integralE D f :
  \int_(x in D) f x = \int_(x in D) (f ^\+ x) - \int_(x in D) f ^\- x.
Proof.
by rewrite [in LHS]/integral funepos_restrict funeneg_restrict -!ge0_integralE.
Qed.
Lemma integral0 D : \int_(x in D) (cst 0 x) = 0.
Proof. by rewrite ge0_integralE// erestrict0 nnintegral0. Qed.
Lemma integral0_eq D f :
  (forall x, D x -&gt; f x = 0) -&gt; \int_(x in D) f x = 0.
Proof.
move=&gt; f0; under eq_integral; first by move=&gt; x /[1!inE] /f0 -&gt;; over.
by rewrite integral0.
Qed.
Lemma integral_ge0 D f : (forall x, D x -&gt; 0 &lt;= f x) -&gt; 0 &lt;= \int_(x in D) f x.
Proof.
move=&gt; f0; rewrite ge0_integralE// nnintegral_ge0// =&gt; x.
by rewrite /patch; case: ifP; rewrite // inE =&gt; /f0-&gt;.
Qed.
Lemma integral_nnsfun D (mD : measurable D) (h : {nnsfun T &gt;-&gt; R}) :
  \int_(x in D) (h x)%:E = sintegral mu (h \_ D).
Proof.
rewrite mrestrict -nnintegral_nnsfun// -mrestrict ge0_integralE ?comp_patch//.
by move=&gt; x Dx /=; rewrite lee_fin; exact: fun_ge0.
Qed.
End integral.
Notation "\int [ mu ]_ ( x 'in' D ) f" :=
  (integral mu D (fun x =&gt; f)) : ereal_scope.
Notation "\int [ mu ]_ x f" :=
  ((integral mu setT (fun x =&gt; f)))%E : ereal_scope.
Arguments eq_integral {d T R mu D} g.
Section eq_measure_integral.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType) (D : set T).
Implicit Types m : {measure set T -&gt; \bar R}.
Let eq_measure_integral0 m2 m1 (f : T -&gt; \bar R) :
  (forall A, measurable A -&gt; A `&lt;=` D -&gt; m1 A = m2 A) -&gt;
  [set sintegral m1 h | h in
    [set h : {nnsfun T &gt;-&gt; R} | (forall x, (h x)%:E &lt;= (f \_ D) x)]] `&lt;=`
  [set sintegral m2 h | h in
    [set h : {nnsfun T &gt;-&gt; R} | (forall x, (h x)%:E &lt;= (f \_ D) x)]].
Proof.
move=&gt; m12 _ [h hfD &lt;-] /=; exists h =&gt; //; apply: eq_fsbigr =&gt; r _.
have [hrD|hrD] := pselect (h @^-1` [set r] `&lt;=` D); first by rewrite m12.
suff : r = 0%R by move=&gt; -&gt;; rewrite !mul0e.
apply: contra_notP hrD =&gt; /eqP r0 t/= htr.
have := hfD t.
rewrite /patch/=; case: ifPn; first by rewrite inE.
move=&gt; tD.
move: r0; rewrite -htr =&gt; ht0.
by rewrite le_eqVlt eqe (negbTE ht0)/= lte_fin// ltNge// fun_ge0.
Qed.
Lemma eq_measure_integral m2 m1 (f : T -&gt; \bar R) :
    (forall A, measurable A -&gt; A `&lt;=` D -&gt; m1 A = m2 A) -&gt;
  \int[m1]_(x in D) f x = \int[m2]_(x in D) f x.
Proof.
move=&gt; m12; rewrite /integral funepos_restrict funeneg_restrict.
by congr (ereal_sup _ - ereal_sup _)%E; rewrite eqEsubset; split;
  apply: eq_measure_integral0 =&gt; A /m12 // /[apply].
Qed.
End eq_measure_integral.
Arguments eq_measure_integral {d T R D} m2 {m1 f}.
Section integral_measure_zero.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Let sintegral_measure_zero (f : T -&gt; R) : sintegral mzero f = 0.
Proof. by rewrite sintegralE big1// =&gt; r _ /=; rewrite /mzero mule0. Qed.
Lemma integral_measure_zero (D : set T) (f : T -&gt; \bar R) :
  \int[mzero]_(x in D) f x = 0.
Proof.
have h g : (forall x, 0 &lt;= g x) -&gt; [set sintegral mzero h |
    h in [set h : {nnsfun T &gt;-&gt; R} | forall x, (h x)%:E &lt;= g x]] = [set 0].
  move=&gt; g0; apply/seteqP; split =&gt; [_ [h/= Dt &lt;-]|x -&gt; /=].
    by rewrite sintegral_measure_zero.
  by exists (cst_nnsfun _ (@NngNum _ 0 (lexx _))).
rewrite integralE !ge0_integralE//= h ?ereal_sup1; last first.
  by move=&gt; r; rewrite erestrict_ge0.
by rewrite h ?ereal_sup1 ?subee// =&gt; r; rewrite erestrict_ge0.
Qed.
End integral_measure_zero.
Section domain_change.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variable mu : {measure set T -&gt; \bar R}.
Lemma integral_mkcond D f : \int[mu]_(x in D) f x = \int[mu]_x (f \_ D) x.
Proof. by rewrite /integral patch_setT. Qed.
Lemma integralT_nnsfun (h : {nnsfun T &gt;-&gt; R}) :
  \int[mu]_x (h x)%:E = sintegral mu h.
Proof. by rewrite integral_nnsfun// patch_setT. Qed.
Lemma integral_mkcondr D P f :
  \int[mu]_(x in D `&amp;` P) f x = \int[mu]_(x in D) (f \_ P) x.
Proof. by rewrite integral_mkcond [RHS]integral_mkcond patch_setI. Qed.
Lemma integral_mkcondl D P f :
  \int[mu]_(x in P `&amp;` D) f x = \int[mu]_(x in D) (f \_ P) x.
Proof. by rewrite setIC integral_mkcondr. Qed.
End domain_change.
Arguments integral_mkcond {d T R mu} D f.
Section nondecreasing_integral_limit.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (mu : {measure set T -&gt; \bar R}) (f : T -&gt; \bar R)
          (g : {nnsfun T &gt;-&gt; R}^nat).
Hypothesis f0 : forall x, 0 &lt;= f x.
Hypothesis mf : measurable_fun setT f.
Hypothesis nd_g : forall x, nondecreasing_seq (g^~x).
Hypothesis gf : forall x, EFin \o g^~x --&gt; f x.
Local Open Scope ereal_scope.
Lemma nd_ge0_integral_lim : \int[mu]_x f x = lim (sintegral mu \o g).
Proof.
rewrite ge0_integralTE//.
apply/eqP; rewrite eq_le; apply/andP; split; last first.
  apply: lime_le; first exact: is_cvg_sintegral.
  near=&gt; n; apply: ereal_sup_ub; exists (g n) =&gt; //= =&gt; x.
  have &lt;- : lim (EFin \o g ^~ x) = f x by apply/cvg_lim =&gt; //; exact: gf.
  have : (EFin \o g ^~ x) --&gt; ereal_sup (range (EFin \o g ^~ x)).
    by apply: ereal_nondecreasing_cvgn =&gt; p q pq /=; rewrite lee_fin; exact/nd_g.
  by move/cvg_lim =&gt; -&gt; //; apply: ereal_sup_ub; exists n.
have := leey (\int[mu]_x (f x)).
rewrite le_eqVlt =&gt; /predU1P[|] mufoo; last first.
  have : \int[mu]_x (f x) \is a fin_num by rewrite ge0_fin_numE// integral_ge0.
  rewrite ge0_integralTE// =&gt; /ub_ereal_sup_adherent h.
  apply/lee_addgt0Pr =&gt; _/posnumP[e].
  have {h} [/= _ [G Gf &lt;-]] := h _ [gt0 of e%:num].
  rewrite EFinN lte_subl_addr// =&gt; fGe.
  have : forall x, cvg (g^~ x) -&gt; (G x &lt;= lim (g ^~ x))%R.
    move=&gt; x cg; rewrite -lee_fin -(EFin_lim cg).
    by have /cvg_lim gxfx := @gf x; rewrite (le_trans (Gf _))// gxfx.
  move=&gt; /(nd_sintegral_lim_lemma mu nd_g)/(lee_add2r e%:num%:E).
  by apply: le_trans; exact: ltW.
suff : lim (sintegral mu \o g) = +oo.
  by move=&gt; -&gt;; rewrite -ge0_integralTE// mufoo.
apply/eqyP =&gt; r r0.
have [G [Gf rG]] : exists h : {nnsfun T &gt;-&gt; R},
    (forall x, (h x)%:E &lt;= f x) /\ (r%:E &lt;= sintegral mu h).
  have : r%:E &lt; \int[mu]_x (f x).
    move: (mufoo) =&gt; /eqyP/(_ _ (addr_gt0 r0 r0)).
    by apply: lt_le_trans =&gt; //; rewrite lte_fin ltr_addr.
  rewrite ge0_integralTE// =&gt; /ereal_sup_gt[x [/= G Gf Gx rx]].
  by exists G; split =&gt; //; rewrite (le_trans (ltW rx)) // Gx.
have : forall x, cvg (g^~ x) -&gt; (G x &lt;= lim (g^~ x))%R.
  move=&gt; x cg; rewrite -lee_fin -(EFin_lim cg).
  by have /cvg_lim gxfx := @gf x; rewrite (le_trans (Gf _)) // gxfx.
by move/(nd_sintegral_lim_lemma mu nd_g) =&gt; Gg; rewrite (le_trans rG).
Unshelve. all: by end_near. Qed.
End nondecreasing_integral_limit.
Section dyadic_interval.
Variable R : realType.
Definition dyadic_itv n k : interval R :=
  `[(k%:R * 2 ^- n), (k.+1%:R * 2 ^- n)[.
Local Notation I := dyadic_itv.
Lemma dyadic_itv_subU n k : [set` I n k] `&lt;=`
  [set` I n.+1 k.*2] `|` [set` I n.+1 k.*2.+1].
Proof.
move=&gt; r /=; rewrite in_itv /= =&gt; /andP[Ir rI].
have [rk|rk] := ltP r (k.*2.+1%:R * (2%:R ^- n.+1)); [left|right].
- rewrite in_itv /= rk andbT (le_trans _ Ir)// -muln2.
  rewrite natrM exprS invrM ?unitfE// ?expf_neq0// -mulrA (mulrCA 2).
  by rewrite divrr ?unitfE// mulr1.
- rewrite in_itv /= rk /= (lt_le_trans rI)// -doubleS.
  rewrite -muln2 natrM exprS invrM ?unitfE// ?expf_neq0// -mulrA (mulrCA 2).
  by rewrite divrr ?unitfE// mulr1.
Qed.
Lemma bigsetU_dyadic_itv n : `[n%:R, n.+1%:R[%classic =
  \big[setU/set0]_(n * 2 ^ n.+1 &lt;= k &lt; n.+1 * 2 ^ n.+1) [set` I n.+1 k].
Proof.
rewrite predeqE =&gt; r; split =&gt; [/= /[!in_itv]/= /andP[nr rn1]|].
- rewrite -bigcup_seq /=; exists `|floor (r * 2 ^+ n.+1)|%N.
    rewrite /= mem_index_iota; apply/andP; split.
      rewrite -ltez_nat gez0_abs ?floor_ge0; last first.
        by rewrite mulr_ge0// (le_trans _ nr).
      apply: (@le_trans _ _ (floor (n * 2 ^ n.+1)%:R)); last first.
        by apply: le_floor; rewrite natrM natrX ler_pmul2r.
      by rewrite floor_natz intz.
    rewrite -ltz_nat gez0_abs; last first.
      by rewrite floor_ge0 mulr_ge0// (le_trans _ nr).
    rewrite -(@ltr_int R) (le_lt_trans (floor_le _))//.
    by rewrite PoszM intrM -natrX ltr_pmul2r.
  rewrite /= in_itv /=; apply/andP; split.
    rewrite ler_pdivr_mulr// (le_trans _ (floor_le _))//.
    by rewrite -(@gez0_abs (floor _))// floor_ge0 mulr_ge0// (le_trans _ nr).
  rewrite ltr_pdivl_mulr// (lt_le_trans (lt_succ_floor _))//.
  rewrite -[in leRHS]natr1 ler_add2r// -(@gez0_abs (floor _))// floor_ge0.
  by rewrite mulr_ge0// (le_trans _ nr).
- rewrite -bigcup_seq =&gt; -[/= k] /[!mem_index_iota] /andP[nk kn].
  rewrite in_itv /= =&gt; /andP[knr rkn]; rewrite in_itv /=; apply/andP; split.
    by rewrite (le_trans _ knr)// ler_pdivl_mulr// -natrX -natrM ler_nat.
  by rewrite (lt_le_trans rkn)// ler_pdivr_mulr// -natrX -natrM ler_nat.
Qed.
Lemma dyadic_itv_image n T (f : T -&gt; \bar R) x :
  (n%:R%:E &lt;= f x &lt; n.+1%:R%:E)%E -&gt;
  exists k, (2 ^ n.+1 * n &lt;= k &lt; 2 ^ n.+1 * n.+1)%N /\
    f x \in EFin @` [set` I n.+1 k].
Proof.
move=&gt; fxn; have fxfin : f x \is a fin_num.
  by rewrite fin_numE; move: fxn; case: (f x) =&gt; // /andP[].
have : f x \in EFin @` `[n%:R, n.+1%:R[%classic.
  rewrite inE /=; exists (fine (f x)); last by rewrite fineK.
  by rewrite in_itv /= -lee_fin -lte_fin (fineK fxfin).
rewrite (bigsetU_dyadic_itv n) inE /= =&gt; -[r]; rewrite -bigcup_seq =&gt; -[k /=].
rewrite mem_index_iota =&gt; nk Ir rfx.
by exists k; split; [rewrite !(mulnC (2 ^ n.+1)%N)|rewrite !inE /=; exists r].
Qed.
End dyadic_interval.
Section approximation.
Context d (T : measurableType d) (R : realType).
Variables (D : set T) (mD : measurable D).
Variables (f : T -&gt; \bar R) (mf : measurable_fun D f).
Local Notation I := (@dyadic_itv R).
Let A n k := if (k &lt; n * 2 ^ n)%N then
  D `&amp;` [set x | f x \in EFin @` [set` I n k]] else set0.
Let B n := D `&amp;` [set x | n%:R%:E &lt;= f x]%E.
Definition approx : (T -&gt; R)^nat := fun n x =&gt;
  \sum_(k &lt; n * 2 ^ n) k%:R * 2 ^- n * \1_(A n k) x + n%:R * \1_(B n) x.
technical properties of the sets A and B 
Let mA n k : measurable (A n k).
Proof.
rewrite /A; case: ifPn =&gt; [kn|_]//; rewrite -preimage_comp.
by apply: mf =&gt; //; apply/measurable_image_EFin; exact: measurable_itv.
Qed.
Let trivIsetA n : trivIset setT (A n).
Proof.
apply/trivIsetP =&gt; i j _ _.
wlog : i j / (i &lt; j)%N.
  move=&gt; h; rewrite neq_lt =&gt; /orP[ij|ji].
    by apply: h =&gt; //; rewrite lt_eqF.
  by rewrite setIC; apply: h =&gt; //; rewrite lt_eqF.
move=&gt; ij _.
rewrite /A; case: ifPn =&gt; /= ni; last by rewrite set0I.
case: ifPn =&gt; /= nj; last by rewrite setI0.
rewrite predeqE =&gt; t; split =&gt; // -[/=] [_].
rewrite inE =&gt; -[r /=]; rewrite in_itv /= =&gt; /andP[r1 r2] rft [_].
rewrite inE =&gt; -[s /=]; rewrite in_itv /= =&gt; /andP[s1 s2].
rewrite -rft =&gt; -[sr]; rewrite {}sr {s} in s1 s2.
by have := le_lt_trans s1 r2; rewrite ltr_pmul2r// ltr_nat ltnS leqNgt ij.
Qed.
Let f0_A0 n (i : 'I_(n * 2 ^ n)) x : f x = 0%:E -&gt; i != O :&gt; nat -&gt;
  \1_(A n i) x = 0 :&gt; R.
Proof.
move=&gt; fx0 i0; rewrite indicE memNset// /A ltn_ord =&gt; -[Dx/=] /[1!inE]/= -[r].
rewrite in_itv/= fx0 =&gt; + r0; move/eqP : r0 =&gt; /[1!eqe] /eqP -&gt; /andP[+ _].
by rewrite ler_pdivr_mulr// mul0r lern0 (negbTE i0).
Qed.
Let fgen_A0 n x (i : 'I_(n * 2 ^ n)) : (n%:R%:E &lt;= f x)%E -&gt;
  \1_(A n i) x = 0 :&gt; R.
Proof.
move=&gt; fxn; rewrite indicE /A ltn_ord memNset// =&gt; -[Dx/=] /[1!inE]/= -[r].
rewrite in_itv/= =&gt; /andP[_ h] rfx; move: fxn; rewrite -rfx lee_fin; apply/negP.
rewrite -ltNge (lt_le_trans h)// -natrX ler_pdivr_mulr// -natrM ler_nat.
by rewrite (leq_trans (ltn_ord i)).
Qed.
Let disj_A0 x n (i k : 'I_(n * 2 ^ n)) : i != k -&gt; x \in A n k -&gt;
  \1_(A n i) x = 0 :&gt; R.
Proof.
move=&gt; ik /[1!inE] xAn1k; rewrite indicE memNset// =&gt; xAi.
have /trivIsetP/(_ _ _ Logic.I Logic.I ik)/= := @trivIsetA n.
by rewrite predeqE =&gt; /(_ x)[+ _]; exact.
Qed.
Arguments disj_A0 {x n i} k.
Let mB n : measurable (B n). Proof. exact: emeasurable_fun_c_infty. Qed.
Let foo_B1 x n : D x -&gt; f x = +oo%E -&gt; \1_(B n) x = 1 :&gt; R.
Proof. by move=&gt; Dx fxoo; rewrite indicE mem_set// /B/= fxoo leey. Qed.
Let f0_B0 x n : f x = 0%:E -&gt; n != 0%N -&gt; \1_(B n) x = 0 :&gt; R.
Proof.
by move=&gt; h /negbTE n0; rewrite indicE memNset// /B/= h lee_fin lern0 n0 =&gt; -[].
Qed.
Let fgtn_B0 x n : (f x &lt; n%:R%:E)%E -&gt; \1_(B n) x = 0 :&gt; R.
Proof. by move=&gt; h; rewrite indicE memNset// =&gt; -[_/=]; rewrite leNgt h. Qed.
Let f0_approx0 n x : f x = 0%E -&gt; approx n x = 0.
Proof.
move=&gt; fx0; rewrite /approx; have [-&gt;|n0] := eqVneq n O.
  by rewrite mul0n mul0r addr0 big_ord0.
rewrite f0_B0// mulr0 addr0 big1// =&gt; i _.
have [-&gt;|i0] := eqVneq (nat_of_ord i) 0%N; first by rewrite mul0r mul0r.
by rewrite f0_A0 // mulr0.
Qed.
Let fpos_approx_neq0 x : D x -&gt; (0%E &lt; f x &lt; +oo)%E -&gt;
  \forall n \near \oo, approx n x != 0.
Proof.
move=&gt; Dx /andP[fx_gt0 fxoo].
have fxfin : f x \is a fin_num by rewrite gt0_fin_numE.
rewrite -(fineK fxfin) lte_fin in fx_gt0; near=&gt; n.
rewrite /approx paddr_eq0//; last 2 first.
  by apply: sumr_ge0 =&gt; i _; rewrite mulr_ge0.
  by rewrite mulr_ge0.
rewrite psumr_eq0//; last by move=&gt; i _; rewrite mulr_ge0.
apply/negP =&gt; /andP[/allP An0]; rewrite mulf_eq0 =&gt; /orP[|].
  by apply/negP; near: n; exists 1%N =&gt; //= m /=; rewrite lt0n pnatr_eq0.
rewrite indicE mem_set ?oner_eq0// /B /= leNgt; split=&gt; //; apply/negP =&gt; fxn.
have K : (`|floor (fine (f x) * 2 ^+ n)| &lt; n * 2 ^ n)%N.
  rewrite -ltz_nat gez0_abs; last by rewrite floor_ge0 mulr_ge0// ltW.
  rewrite -(@ltr_int R); rewrite (le_lt_trans (floor_le _))// PoszM intrM.
  by rewrite -natrX ltr_pmul2r// -lte_fin (fineK fxfin).
have /[!mem_index_enum]/(_ isT) := An0 (Ordinal K).
rewrite implyTb indicE mem_set ?mulr1; last first.
  rewrite /A K /= inE; split=&gt; //=; exists (fine (f x)); last by rewrite fineK.
  rewrite in_itv /=; apply/andP; split.
    rewrite ler_pdivr_mulr// (le_trans _ (floor_le _))//.
    by rewrite -(@gez0_abs (floor _))// floor_ge0 mulr_ge0// ltW.
  rewrite ltr_pdivl_mulr// (lt_le_trans (lt_succ_floor _))// -[in leRHS]natr1.
  by rewrite ler_add2r// -{1}(@gez0_abs (floor _))// floor_ge0// mulr_ge0// ltW.
rewrite mulf_eq0// -exprVn; apply/negP; rewrite negb_or expf_neq0//= andbT.
rewrite pnatr_eq0 -lt0n absz_gt0 floor_neq0// -ler_pdivr_mulr//.
apply/orP; right; apply/ltW; near: n.
exact: near_infty_natSinv_expn_lt (PosNum fx_gt0).
Unshelve. all: by end_near. Qed.
Let f_ub_approx n x : (f x &lt; n%:R%:E)%E -&gt;
  approx n x == 0 \/ exists k,
    [/\ (0 &lt; k &lt; n * 2 ^ n)%N,
       x \in A n k, approx n x = k%:R / 2 ^+ n &amp;
       f x \in EFin @` [set` I n k]].
Proof.
move=&gt; fxn; rewrite /approx fgtn_B0 // mulr0 addr0.
set lhs := (X in X == 0); have [|] := eqVneq lhs 0; first by left.
rewrite {}/lhs psumr_eq0; last by move=&gt; i _; rewrite mulr_ge0.
move=&gt; /allPn[/= k _].
rewrite mulf_eq0 negb_or mulf_eq0 negb_or -andbA =&gt; /and3P[k_neq0 _].
rewrite pnatr_eq0 eqb0 negbK =&gt; xAnk; right.
rewrite (bigD1 k) //= indicE xAnk mulr1 big1 ?addr0; last first.
  by move=&gt; i ik; rewrite (disj_A0 k)// mulr0.
exists k; split =&gt; //; first by rewrite lt0n -(@pnatr_eq0 R) k_neq0/=.
by move: xAnk; rewrite inE /A ltn_ord /= inE /= =&gt; -[/[swap] Dx].
Qed.
Let notinD_approx0 x n : ~ D x -&gt; approx n x = 0 :&gt; R.
Proof.
move=&gt; Dx; rewrite /approx big1; last first.
  by move=&gt; i _; rewrite indicE memNset ?mulr0// /A; case: ifPn =&gt; [? []|_].
by rewrite indicE memNset// ?mulr0 ?addr0// =&gt; -[].
Qed.
Lemma nd_approx : nondecreasing_seq approx.
Proof.
apply/nondecreasing_seqP =&gt; n; apply/lefP =&gt; x.
have [Dx|Dx] := pselect (D x); last by rewrite ?notinD_approx0.
have [fxn|fxn] := ltP (f x) n%:R%:E.
  rewrite {2}/approx fgtn_B0 ?mulr0 ?addr0; last first.
    by rewrite (lt_trans fxn) // lte_fin ltr_nat.
  have [/eqP -&gt;|[k [/andP[k0 kn] xAnk -&gt; _]]] := f_ub_approx fxn.
    by apply: sumr_ge0 =&gt; i _; rewrite mulr_ge0.
  move: (xAnk); rewrite inE {1}/A kn =&gt; -[_] /=.
  rewrite inE =&gt; -[r] /dyadic_itv_subU[|] rnk rfx.
  - have k2n : (k.*2 &lt; n.+1 * 2 ^ n.+1)%N.
      rewrite expnS mulnCA mul2n ltn_double (ltn_trans kn) //.
      by rewrite ltn_mul2r expn_gt0 /= ltnS.
    rewrite (bigD1 (Ordinal k2n)) //= indicE.
    have xAn1k : x \in A n.+1 k.*2.
      by rewrite inE /A k2n; split =&gt; //=; rewrite inE; exists r.
    rewrite xAn1k mulr1 big1 ?addr0; last first.
      by move=&gt; i ik2n; rewrite (disj_A0 (Ordinal k2n)) ?mulr0.
    rewrite exprS invrM ?unitfE// -muln2 natrM -mulrA (mulrCA 2).
    by rewrite divrr ?mulr1 ?unitfE.
  - have k2n : (k.*2.+1 &lt; n.+1 * 2 ^ n.+1)%N.
      move: kn; rewrite -ltn_double -(ltn_add2r 1) 2!addn1 =&gt; /leq_trans; apply.
      by rewrite -muln2 -mulnA -expnSr ltn_mul2r expn_gt0 /= ltnS.
    rewrite (bigD1 (Ordinal k2n)) //= indicE.
    have xAn1k : x \in A n.+1 k.*2.+1.
      by rewrite /A /= k2n inE; split =&gt; //=; rewrite inE/=; exists r.
    rewrite xAn1k mulr1 big1 ?addr0; last first.
      by move=&gt; i ik2n; rewrite (disj_A0 (Ordinal k2n)) // mulr0.
    rewrite -(@natr1 _ k.*2) mulrDl exprS -mul2n natrM -mulf_div divrr ?unitfE//.
    by rewrite !mul1r ler_addl.
have /orP[{}fxn|{}fxn] :
    ((n%:R%:E &lt;= f x &lt; n.+1%:R%:E) || (n.+1%:R%:E &lt;= f x))%E.
  - by move: fxn; case: leP =&gt; /= [_ _|_ -&gt;//]; rewrite orbT.
  - have [k [k1 k2]] := dyadic_itv_image fxn.
    have xBn : x \in B n by rewrite /B /= inE /=; case/andP : fxn =&gt; -&gt;.
    rewrite /approx indicE xBn mulr1 big1 ?add0r; last first.
      by move=&gt; /= i _; rewrite fgen_A0 ?mulr0//; case/andP : fxn.
    rewrite fgtn_B0 ?mulr0 ?addr0; last by case/andP : fxn.
    have kn2 : (k &lt; n.+1 * 2 ^ n.+1)%N by case/andP : k1 =&gt; _; rewrite mulnC.
    rewrite (bigD1 (Ordinal kn2)) //=.
    have xAn1k : x \in A n.+1 k by rewrite inE /A kn2.
    rewrite indicE xAn1k mulr1 big1 ?addr0; last first.
      by move=&gt; i /= ikn2; rewrite (disj_A0 (Ordinal kn2)) // mulr0.
    by rewrite -natrX ler_pdivl_mulr// mulrC -natrM ler_nat; case/andP : k1.
- have xBn : x \in B n by rewrite /B inE /= (le_trans _ fxn) // lee_fin ler_nat.
  rewrite /approx indicE xBn mulr1.
  have xBn1 : x \in B n.+1 by rewrite /B /= inE.
  rewrite indicE xBn1 mulr1 big1 ?add0r.
    by rewrite big1 ?add0r ?ler_nat// =&gt; /= i _; rewrite fgen_A0// mulr0.
  by move=&gt; /= i _; rewrite fgen_A0 ?mulr0// (le_trans _ fxn)// lee_fin ler_nat.
Qed.
Lemma cvg_approx x (f0 : forall x, D x -&gt; (0 &lt;= f x)%E) : D x -&gt;
  (f x &lt; +oo)%E -&gt; (approx^~ x) --&gt; fine (f x).
Proof.
move=&gt; Dx fxoo; have fxfin : f x \is a fin_num by rewrite ge0_fin_numE// f0.
apply/(@cvgrPdist_lt _ [normedModType R of R^o]) =&gt; _/posnumP[e].
have [fx0|fx0] := eqVneq (f x) 0%E.
  by near=&gt; n; rewrite f0_approx0 // fx0 /= subrr normr0.
have /(fpos_approx_neq0 Dx)[m _ Hm] : (0 &lt; f x &lt; +oo)%E by rewrite lt0e fx0 f0.
near=&gt; n.
have mn : (m &lt;= n)%N by near: n; exists m.
have : fine (f x) &lt; n%:R.
  near: n.
  exists `|floor (fine (f x))|.+1%N =&gt; //= p /=.
  rewrite -(@ler_nat R); apply: lt_le_trans.
  rewrite -natr1 (_ : `| _ |%:R  = (floor (fine (f x)))%:~R); last first.
    by rewrite -[in RHS](@gez0_abs (floor _))// floor_ge0//; exact/fine_ge0/f0.
  by rewrite lt_succ_floor.
rewrite -lte_fin (fineK fxfin) =&gt; fxn.
have [approx_nx0|[k [/andP[k0 kn2n] ? -&gt;]]] := f_ub_approx fxn.
  by have := Hm _ mn; rewrite approx_nx0.
rewrite inE /= =&gt; -[r /=]; rewrite in_itv /= =&gt; /andP[k1 k2] rfx.
rewrite (@le_lt_trans _ _ (1 / 2 ^+ n)) //.
  rewrite ler_norml; apply/andP; split.
    rewrite ler_subr_addl -mulrBl -lee_fin (fineK fxfin) -rfx lee_fin.
    by rewrite (le_trans _ k1)// ler_pmul2r// ler_subl_addl ler_addr.
  by rewrite ler_subl_addr -mulrDl -lee_fin nat1r fineK// ltW// -rfx lte_fin.
by near: n; exact: near_infty_natSinv_expn_lt.
Unshelve. all: by end_near. Qed.
Lemma le_approx k x (f0 : forall x, D x -&gt; (0 &lt;= f x)%E) : D x -&gt;
  ((approx k x)%:E &lt;= f x)%E.
Proof.
move=&gt; Dx; have [fixoo|] := ltP (f x) (+oo%E); last first.
  by rewrite leye_eq =&gt; /eqP -&gt;; rewrite leey.
have nd_ag : {homo approx ^~ x : n m / (n &lt;= m)%N &gt;-&gt; n &lt;= m}.
  by move=&gt; m n mn; exact/lefP/nd_approx.
have fi0 y : D y -&gt; (0 &lt;= f y)%E by move=&gt; ?; exact: f0.
have cvg_af := cvg_approx fi0 Dx fixoo.
have is_cvg_af : cvg (approx ^~ x) by apply/cvg_ex; eexists; exact: cvg_af.
have {is_cvg_af} := nondecreasing_cvgn_le nd_ag is_cvg_af k.
rewrite -lee_fin =&gt; /le_trans; apply.
rewrite -(@fineK _ (f x)); last by rewrite ge0_fin_numE// f0.
by move/(cvg_lim (@Rhausdorff R)) : cvg_af =&gt; -&gt;.
Qed.
Lemma dvg_approx x : D x -&gt; f x = +oo%E -&gt; ~ cvg (approx^~ x : _ -&gt; R^o).
Proof.
move=&gt; Dx fxoo; have approx_x n : approx n x = n%:R.
  rewrite /approx foo_B1// mulr1 big1 ?add0r// =&gt; /= i _.
  by rewrite fgen_A0 // ?mulr0 // fxoo leey.
case/cvg_ex =&gt; /= l; have [l0|l0] := leP 0%R l.
- move=&gt; /cvgrPdist_lt/(_ _ ltr01) -[n _].
  move=&gt; /(_ (`|ceil l|.+1 + n)%N) /= /(_ (leq_addl _ _)).
  rewrite approx_x.
  apply/negP; rewrite -leNgt distrC (le_trans _ (ler_sub_norm_add _ _)) //.
  rewrite normrN ler_subr_addl addSnnS [leRHS]ger0_norm ?ler0n//.
  rewrite natrD ler_add// ?ler1n// ger0_norm // (le_trans (ceil_ge _)) //.
  by rewrite -(@gez0_abs (ceil _)) // ceil_ge0.
- move/cvgrPdist_lt =&gt; /(_ _ ltr01) -[n _].
  move=&gt; /(_ (`|floor l|.+1 + n)%N) /= /(_ (leq_addl _ _)).
  rewrite approx_x.
  apply/negP; rewrite -leNgt distrC (le_trans _ (ler_sub_norm_add _ _)) //.
  rewrite normrN ler_subr_addl addSnnS [leRHS]ger0_norm ?ler0n//.
  rewrite natrD ler_add// ?ler1n// ler0_norm //; last by rewrite ltW.
  rewrite (@le_trans _ _ (- floor l)%:~R) //.
    by rewrite mulrNz ler_oppl opprK floor_le.
  by rewrite -(@lez0_abs (floor _)) // floor_le0 // ltW.
Qed.
Lemma ecvg_approx (f0 : forall x, D x -&gt; (0 &lt;= f x)%E) x :
  D x -&gt; EFin \o approx^~x --&gt; f x.
Proof.
move=&gt; Dx; have := leey (f x); rewrite le_eqVlt =&gt; /predU1P[|] fxoo.
have dvg_approx := dvg_approx Dx fxoo.
  have : {homo approx ^~ x : n m / (n &lt;= m)%N &gt;-&gt; n &lt;= m}.
    by move=&gt; m n mn; have := nd_approx mn =&gt; /lefP; exact.
  move/nondecreasing_dvgn_lt =&gt; /(_ dvg_approx).
  by rewrite fxoo =&gt; ?; apply/cvgeryP.
rewrite -(@fineK _ (f x)); first exact: (cvg_comp (cvg_approx f0 Dx fxoo)).
by rewrite ge0_fin_numE// f0.
Qed.
Let k2n_ge0 n (k : 'I_(n * 2 ^ n)) : 0 &lt;= k%:R * 2 ^- n :&gt; R.
Proof. by []. Qed.
Definition nnsfun_approx : {nnsfun T &gt;-&gt; R}^nat := fun n =&gt; locked (add_nnsfun
  (sum_nnsfun
    (fun k =&gt; match Bool.bool_dec (k &lt; (n * 2 ^ n))%N true with
      | left h =&gt; scale_nnsfun (indic_nnsfun _ (mA n k)) (k2n_ge0 (Ordinal h))
      | right _ =&gt; nnsfun0
     end) (n * 2 ^ n)%N)
  (scale_nnsfun (indic_nnsfun _ (mB n)) (ler0n _ n))).
Lemma nnsfun_approxE n : nnsfun_approx n = approx n :&gt; (T -&gt; R).
Proof.
rewrite funeqE =&gt; t /=; rewrite /nnsfun_approx; unlock; rewrite /=.
rewrite sum_nnsfunE; congr (_ + _).
by apply: eq_bigr =&gt; i _; case: Bool.bool_dec =&gt; [h|/negP]; [|rewrite ltn_ord].
Qed.
Lemma cvg_nnsfun_approx (f0 : forall x, D x -&gt; (0 &lt;= f x)%E) x :
  D x -&gt; EFin \o nnsfun_approx^~x --&gt; f x.
Proof.
by move=&gt; Dx; under eq_fun do rewrite nnsfun_approxE; exact: ecvg_approx.
Qed.
Lemma nd_nnsfun_approx : nondecreasing_seq (nnsfun_approx : (T -&gt; R)^nat).
Proof.
move=&gt; m n mn; rewrite (nnsfun_approxE n) (nnsfun_approxE m).
exact: nd_approx.
Qed.
Lemma approximation : (forall t, D t -&gt; (0 &lt;= f t)%E) -&gt;
  exists g : {nnsfun T &gt;-&gt; R}^nat, nondecreasing_seq (g : (T -&gt; R)^nat) /\
                        (forall x, D x -&gt; EFin \o g^~x --&gt; f x).
Proof.
exists nnsfun_approx; split; [exact: nd_nnsfun_approx|].
by move=&gt; x Dx; exact: cvg_nnsfun_approx.
Qed.
End approximation.
Section semi_linearity0.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (mu : {measure set T -&gt; \bar R}) (D : set T) (mD : measurable D).
Variables f1 f2 : T -&gt; \bar R.
Hypothesis f10 : forall x, D x -&gt; 0 &lt;= f1 x.
Hypothesis mf1 : measurable_fun D f1.
Lemma ge0_integralZl_EFin k : (0 &lt;= k)%R -&gt;
  \int[mu]_(x in D) (k%:E * f1 x) = k%:E * \int[mu]_(x in D) f1 x.
Proof.
rewrite integral_mkcond erestrict_scale [in RHS]integral_mkcond =&gt; k0.
set h1 := f1 \_ D.
have h10 x : 0 &lt;= h1 x by apply: erestrict_ge0.
have mh1 : measurable_fun setT h1 by apply/(measurable_restrict _ mD).
have [g [nd_g gh1]] := approximation measurableT mh1 (fun x _ =&gt; h10 x).
pose kg := fun n =&gt; scale_nnsfun (g n) k0.
rewrite (@nd_ge0_integral_lim _ _ _ mu (fun x =&gt; k%:E * h1 x) kg).
- rewrite (_ : _ \o _ = fun n =&gt; sintegral mu (scale_nnsfun (g n) k0))//.
  rewrite (_ : (fun _ =&gt; _) = (fun n =&gt; k%:E * sintegral mu (g n))).
    rewrite limeMl //; last first.
      by apply: is_cvg_sintegral =&gt; // x m n mn; apply/(lef_at x nd_g).
    by rewrite -(nd_ge0_integral_lim mu h10) // =&gt; x;
      [exact/(lef_at x nd_g)|exact: gh1].
  by under eq_fun do rewrite (sintegralrM mu k (g _)).
- by move=&gt; t; rewrite mule_ge0.
- by move=&gt; x m n mn; rewrite /kg ler_pmul//; exact/lefP/nd_g.
- move=&gt; x.
  rewrite [X in X --&gt; _](_ : _ = (fun n =&gt; k%:E * (g n x)%:E)) ?funeqE//.
  by apply: cvgeMl =&gt; //; exact: gh1.
Qed.
End semi_linearity0.
#[deprecated(since="mathcomp-analysis 0.6.4", note="use `ge0_integralZl_EFin` instead")]
Notation ge0_integralM_EFin := ge0_integralZl_EFin (only parsing).
Section semi_linearity.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variable mu : {measure set T -&gt; \bar R}.
Variables (D : set T) (mD : measurable D) (f1 f2 : T -&gt; \bar R).
Hypothesis f10 : forall x, D x -&gt; 0 &lt;= f1 x.
Hypothesis mf1 : measurable_fun D f1.
Hypothesis f20 : forall x, D x -&gt; 0 &lt;= f2 x.
Hypothesis mf2 : measurable_fun D f2.
Lemma ge0_integralD : \int[mu]_(x in D) (f1 x + f2 x) =
  \int[mu]_(x in D) f1 x + \int[mu]_(x in D) f2 x.
Proof.
rewrite !(integral_mkcond D) erestrictD.
set h1 := f1 \_ D; set h2 := f2 \_ D.
have h10 x : 0 &lt;= h1 x by apply: erestrict_ge0.
have h20 x : 0 &lt;= h2 x by apply: erestrict_ge0.
have mh1 : measurable_fun setT h1 by apply/(measurable_restrict _ mD).
have mh2 : measurable_fun setT h2 by apply/(measurable_restrict _ mD).
have [g1 [nd_g1 gh1]] := approximation measurableT mh1 (fun x _ =&gt; h10 x).
have [g2 [nd_g2 gh2]] := approximation measurableT mh2 (fun x _ =&gt; h20 x).
pose g12 := fun n =&gt; add_nnsfun (g1 n) (g2 n).
rewrite (@nd_ge0_integral_lim _ _ _ mu _ g12) //; last 3 first.
  - by move=&gt; x; rewrite adde_ge0.
  - by apply: nondecreasing_seqD =&gt; // x;
      [exact/(lef_at x nd_g1)|exact/(lef_at x nd_g2)].
  - move=&gt; x; rewrite (_ : _ \o _ = (fun n =&gt; (g1 n x)%:E + (g2 n x)%:E))//.
    apply: cvgeD =&gt; //; [|exact: gh1|exact: gh2].
    by apply: ge0_adde_def =&gt; //; rewrite !inE; [exact: h10|exact: h20].
under [_ \o _]eq_fun do rewrite sintegralD.
rewrite (nd_ge0_integral_lim _ _ (fun x =&gt; lef_at x nd_g1)) //; last first.
  by move=&gt; x; exact: gh1.
rewrite (nd_ge0_integral_lim _ _ (fun x =&gt; lef_at x nd_g2)) //; last first.
  by move=&gt; x; exact: gh2.
rewrite limeD //.
  by apply: is_cvg_sintegral =&gt; // x Dx; exact/(lef_at x nd_g1).
  by apply: is_cvg_sintegral =&gt; // x Dx; exact/(lef_at x nd_g2).
rewrite ge0_adde_def =&gt; //; rewrite inE; apply: lime_ge.
- by apply: is_cvg_sintegral =&gt; // x Dx; exact/(lef_at x nd_g1).
- by apply: nearW =&gt; n; exact: sintegral_ge0.
- by apply: is_cvg_sintegral =&gt; // x Dx; exact/(lef_at x nd_g2).
- by apply: nearW =&gt; n; exact: sintegral_ge0.
Qed.
Lemma ge0_le_integral : (forall x, D x -&gt; f1 x &lt;= f2 x) -&gt;
  \int[mu]_(x in D) f1 x &lt;= \int[mu]_(x in D) f2 x.
Proof.
move=&gt; f12; rewrite !(integral_mkcond D).
set h1 := f1 \_ D; set h2 := f2 \_ D.
have h10 x : 0 &lt;= h1 x by apply: erestrict_ge0.
have h20 x : 0 &lt;= h2 x by apply: erestrict_ge0.
have mh1 : measurable_fun setT h1 by apply/(measurable_restrict _ mD).
have mh2 : measurable_fun setT h2 by apply/(measurable_restrict _ mD).
have h12 x : h1 x &lt;= h2 x by apply: lee_restrict.
have [g1 [nd_g1 /(_ _ Logic.I)gh1]] :=
  approximation measurableT mh1 (fun x _ =&gt; h10 _).
rewrite (nd_ge0_integral_lim _ h10 (fun x =&gt; lef_at x nd_g1) gh1)//.
apply: lime_le.
  by apply: is_cvg_sintegral =&gt; // t Dt; exact/(lef_at t nd_g1).
near=&gt; n; rewrite ge0_integralTE//; apply: ereal_sup_ub =&gt; /=.
exists (g1 n) =&gt; // t; rewrite (le_trans _ (h12 _)) //.
have := gh1 t.
have := leey (h1 t); rewrite le_eqVlt =&gt; /predU1P[-&gt;|ftoo].
  by rewrite leey.
have h1tfin : h1 t \is a fin_num.
  by rewrite fin_numE gt_eqF/= ?lt_eqF// (lt_le_trans _ (h10 t)).
have := gh1 t.
rewrite -(fineK h1tfin) =&gt; /fine_cvgP[ft_near].
set u_ := (X in X --&gt; _) =&gt; u_h1 g1h1.
have &lt;- : lim u_ = fine (h1 t) by apply/cvg_lim =&gt; //; exact: Rhausdorff.
rewrite lee_fin; apply: nondecreasing_cvgn_le.
  by move=&gt; // a b ab; rewrite /u_ /=; exact/lefP/nd_g1.
by apply/cvg_ex; eexists; exact: u_h1.
Unshelve. all: by end_near. Qed.
End semi_linearity.
Section approximation_sfun.
Context d (T : measurableType d) (R : realType) (f : T -&gt; \bar R).
Variables (D : set T) (mD : measurable D) (mf : measurable_fun D f).
Lemma approximation_sfun :
  exists g : {sfun T &gt;-&gt; R}^nat, (forall x, D x -&gt; EFin \o g^~x --&gt; f x).
Proof.
have [fp_ [fp_nd fp_cvg]] :=
  approximation mD (measurable_funepos mf) (fun=&gt; ltac:(by [])).
have [fn_ [fn_nd fn_cvg]] :=
  approximation mD (measurable_funeneg mf) (fun=&gt; ltac:(by [])).
exists (fun n =&gt; [the {sfun T &gt;-&gt; R} of fp_ n \+ cst (-1) \* fn_ n]) =&gt; x /=.
rewrite [X in X --&gt; _](_ : _ =
    EFin \o fp_^~ x \+ (-%E \o EFin \o fn_^~ x))%E; last first.
  by apply/funext =&gt; n/=; rewrite EFinD mulN1r.
by move=&gt; Dx; rewrite (funeposneg f); apply: cvgeD;
  [exact: add_def_funeposneg|apply: fp_cvg|apply:cvgeN; exact: fn_cvg].
Qed.
End approximation_sfun.
Section lusin.
Hint Extern 0  (hausdorff_space _) =&gt; (exact: Rhausdorff ) : core.
Local Open Scope ereal_scope.
Context (rT : realType) (A : set rT).
Let mu := [the measure _ _ of @lebesgue_measure rT].
Let R  := [the measurableType _ of measurableTypeR rT].
Hypothesis mA : measurable A.
Hypothesis finA : mu A &lt; +oo.
Let lusin_simple (f : {sfun R &gt;-&gt; rT}) (eps : rT) : (0 &lt; eps)%R -&gt;
  exists K, [/\ compact K, K `&lt;=` A, mu (A `\` K) &lt; eps%:E &amp;
  {within K, continuous f}].
Proof.
move: eps=&gt; _/posnumP[eps]; have [N /card_fset_set rfN] := fimfunP f.
pose Af x : set R := A `&amp;` f @^-1` [set x].
have mAf x : measurable (Af x) by exact: measurableI.
have finAf x : mu (Af x) &lt; +oo.
  by rewrite (le_lt_trans _ finA)// le_measure// ?inE//; exact: subIsetl.
have eNpos : (0 &lt; eps%:num/N.+1%:R)%R by [].
have dK' x := lebesgue_regularity_inner (mAf x) (finAf x) eNpos.
pose dK x : set R := projT1 (cid (dK' x)); pose J i : set R := Af i `\` dK i.
have dkP x := projT2 (cid (dK' x)).
have mdK i : measurable (dK i).
  by apply: closed_measurable; apply: compact_closed =&gt; //; case: (dkP i).
have mJ i : measurable (J i) by apply: measurableD =&gt; //; exact: measurableI.
have dKsub z : dK z `&lt;=` f @^-1` [set z].
  by case: (dkP z) =&gt; _ /subset_trans + _; apply =&gt; ? [].
exists (\bigcup_(i in range f) dK i); split.
- by rewrite -bigsetU_fset_set//; apply: bigsetU_compact=&gt;// i _; case: (dkP i).
- by move=&gt; z [y _ dy]; have [_ /(_ _ dy) []] := dkP y.
- have -&gt; : A `\` \bigcup_(i in range f) dK i = \bigcup_(i in range f) J i.
    rewrite -bigcupDr /= ?eqEsubset; last by exists (f point), point.
    split =&gt; z; first by move=&gt; /(_ (f z)) [//| ? ?]; exists (f z).
    case =&gt; ? [? _ &lt;-] [[zab /= &lt;- nfz]] ? [r _ &lt;-]; split =&gt; //.
    by move: nfz; apply: contra_not =&gt; /[dup] /dKsub -&gt;.
  apply: (@le_lt_trans _ _ (\sum_(i \in range f) mu (J i))).
    by apply: content_sub_fsum =&gt; //; exact: fin_bigcup_measurable.
  apply: le_lt_trans.
    apply: (@lee_fsum _ _ _ _ (fun=&gt; (eps%:num / N.+1%:R)%:E * 1%:E)) =&gt; //.
    by move=&gt; i ?; rewrite mule1; apply: ltW; have [_ _] := dkP i.
  rewrite /=-ge0_mule_fsumr // -esum_fset // finite_card_sum // -EFinM lte_fin.
  by rewrite rfN -mulrA gtr_pmulr // mulrC ltr_pdivr_mulr // mul1r ltr_nat.
- suff : closed (\bigcup_(i in range f) dK i) /\
    {within \bigcup_(i in range f) dK i, continuous f} by case.
  rewrite -bigsetU_fset_set //.
  apply: (@big_ind _ (fun U =&gt; closed U /\ {within U, continuous f})).
  + by split; [exact: closed0 | exact: continuous_subspace0].
  + by move=&gt; ? ? [? ?][? ?]; split; [exact: closedU|exact: withinU_continuous].
  + move=&gt; i _; split; first by apply: compact_closed; have [] := dkP i.
    apply: (continuous_subspaceW (dKsub i)).
    apply: (@subspace_eq_continuous _ _ _ (fun=&gt; i)).
      by move=&gt; ? /set_mem -&gt;.
    by apply: continuous_subspaceT =&gt; ?; exact: cvg_cst.
Qed.
Let measurable_almost_continuous' (f : R -&gt; R) (eps : rT) :
  (0 &lt; eps)%R -&gt; measurable_fun A f -&gt; exists K,
  [/\ measurable K, K `&lt;=` A, mu (A `\` K) &lt; eps%:E &amp;
  {within K, continuous f}].
Proof.
move: eps=&gt; _/posnumP[eps] mf; pose f' := EFin \o f.
have mf' : measurable_fun A f' by exact/EFin_measurable_fun.
have [/= g_ gf'] := @approximation_sfun _ R rT _ _ mA mf'.
pose e2n n := (eps%:num / 2) / (2 ^ n.+1)%:R.
have e2npos n : (0 &lt; e2n n)%R by rewrite divr_gt0.
have gK' n := @lusin_simple (g_ n) (e2n n) (e2npos n).
pose gK n := projT1 (cid (gK' n)); have gKP n := projT2 (cid (gK' n)).
pose K := \bigcap_i gK i; have mgK n : measurable (gK n).
  by apply: closed_measurable; apply: compact_closed =&gt; //; have [] := gKP n.
have mK : measurable K by exact: bigcap_measurable.
have Kab : K `&lt;=` A by move=&gt; z /(_ O I); have [_ + _ _] := gKP O; apply.
have []// := @pointwise_almost_uniform _ rT R mu g_ f K (eps%:num / 2).
- by move=&gt; n; exact: measurable_funTS.
- exact: (measurable_funS _ Kab).
- by rewrite (@le_lt_trans _ _ (mu A))// le_measure// ?inE.
- by move=&gt; z Kz; have /fine_fcvg := gf' z (Kab _ Kz); rewrite -fmap_comp compA.
move=&gt; D [/= mD Deps KDf]; exists (K `\` D); split =&gt; //.
- exact: measurableD.
- exact: subset_trans Kab.
- rewrite setDDr; apply: le_lt_trans =&gt; /=.
    by apply: measureU2 =&gt; //; apply: measurableI =&gt; //; apply: measurableC.
  rewrite [_%:num]splitr EFinD; apply: lee_lt_add =&gt; //=; first 2 last.
  + by rewrite (@le_lt_trans _ _ (mu D)) ?le_measure ?inE//; exact: measurableI.
  + rewrite ge0_fin_numE// (@le_lt_trans _ _ (mu A))// le_measure ?inE//.
    exact: measurableD.
  rewrite setDE setC_bigcap setI_bigcupr.
  apply: (@le_trans _ _(\sum_(k &lt;oo) mu (A `\` gK k))).
    apply: measure_sigma_sub_additive =&gt; //; [|apply: bigcup_measurable =&gt; + _].
      by move=&gt; k /=; apply: measurableD =&gt; //; apply: mgK.
    by move=&gt; k /=; apply: measurableD =&gt; //; apply: mgK.
  apply: (@le_trans _ _(\sum_(k &lt;oo) (e2n k)%:E)); last exact: epsilon_trick0.
  by apply: lee_nneseries =&gt; // k _; apply: ltW; have [] := gKP k.
apply: (@uniform_limit_continuous_subspace _ _ _ (g_ @ \oo)) =&gt; //.
near_simpl; apply: nearW =&gt; // n; apply: (@continuous_subspaceW _ _ _ (gK n)).
  by move=&gt; z [+ _]; apply.
by have [] := projT2 (cid (gK' n)).
Qed.
Lemma measurable_almost_continuous (f : R -&gt; R) (eps : rT) :
  (0 &lt; eps)%R -&gt; measurable_fun A f -&gt; exists K,
  [/\ compact K, K `&lt;=` A, mu (A `\` K) &lt; eps%:E &amp;
  {within K, continuous f}].
Proof.
move: eps=&gt; _/posnumP[eps] mf; have e2pos : (0 &lt; eps%:num/2)%R by [].
have [K [mK KA ? ?]] := measurable_almost_continuous' e2pos mf.
have Kfin : mu K &lt; +oo by rewrite (le_lt_trans _ finA)// le_measure ?inE.
have [D /= [cD DK KDe]] := lebesgue_regularity_inner mK Kfin e2pos.
exists D; split =&gt; //; last exact: (continuous_subspaceW DK).
  exact: (subset_trans DK).
have -&gt; : A `\` D = (A `\` K) `|` (K `\` D).
  rewrite eqEsubset; split =&gt; z.
    by case: (pselect (K z)) =&gt; // ? [? ?]; [right | left].
  case; case=&gt; az nz; split =&gt; //; [by move: z nz {az}; apply/subsetC|].
  exact: KA.
apply: le_lt_trans.
  apply: measureU2; apply: measurableD =&gt; //; apply: closed_measurable.
  by apply: compact_closed; first exact: Rhausdorff.
by rewrite [_ eps]splitr EFinD lte_add.
Qed.
End lusin.
Section emeasurable_fun.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Implicit Types (D : set T) (f g : T -&gt; \bar R).
Lemma emeasurable_funD D f g :
  measurable_fun D f -&gt; measurable_fun D g -&gt; measurable_fun D (f \+ g).
Proof.
move=&gt; mf mg mD.
have Cnoom : measurable (~` [set -oo] : set (\bar R)) by apply: measurableC.
have Cpoom : measurable (~` [set +oo] : set (\bar R)) by apply: measurableC.
have mfg :  measurable (D `&amp;` [set x | f x +? g x]).
  suff -&gt; : [set x | f x +? g x] =
              (f @^-1` (~` [set +oo]) `|` g @^-1` (~` [set -oo])) `&amp;`
              (f @^-1` (~` [set -oo]) `|` g @^-1` (~` [set +oo])).
     by rewrite setIIr; apply: measurableI;
        rewrite setIUr; apply: measurableU; do ?[apply: mf|apply: mg].
   apply/predeqP=&gt; x; rewrite /preimage/= /adde_def !(negb_and, negb_or).
   by rewrite !(rwP2 eqP idP) !(rwP2 negP idP) !(rwP2 orP idP) !(rwP2 andP idP).
wlog fg : D mD mf mg mfg / forall x, D x -&gt; f x +? g x =&gt; [hwlogD|]; last first.
   have [f_ f_cvg] := approximation_sfun mD mf.
   have [g_ g_cvg] := approximation_sfun mD mg.
   apply: (emeasurable_fun_cvg (fun n x =&gt; (f_ n x + g_ n x)%:E)) =&gt; //.
     by move=&gt; n; apply/EFin_measurable_fun/measurable_funTS/measurable_funD.
  move=&gt; x Dx; under eq_fun do rewrite EFinD.
  exact: cvgeD (fg _ _) (f_cvg _ _) (g_cvg _ _).
move=&gt; A mA; wlog NAnoo: A mD mf mg mA / ~ (A -oo) =&gt; [hwlogA|].
  have [] := pselect (A -oo); last exact: hwlogA.
  move=&gt; /(@setD1K _ -oo)&lt;-; rewrite preimage_setU setIUr.
  apply: measurableU; last by apply: hwlogA=&gt; //; [exact: measurableD|case=&gt;/=].
  have -&gt; : (f \+ g) @^-1` [set -oo] = f @^-1` [set -oo] `|` g @^-1` [set -oo].
     apply/seteqP; split=&gt; x /= =&gt; [/eqP|[]]; rewrite /preimage/=.
     - by rewrite adde_eq_ninfty =&gt; /orP[] /eqP-&gt;; [left|right].
     - by move-&gt;.
     - by move-&gt;; rewrite addeC.
   by rewrite setIUr; apply: measurableU; [apply: mf|apply: mg].
have-&gt; : D `&amp;` (f \+ g) @^-1` A =
       (D `&amp;` [set x | f x +? g x]) `&amp;` (f \+ g) @^-1` A.
  rewrite -setIA; congr (_ `&amp;` _).
  apply/seteqP; split=&gt; x; rewrite /preimage/=; last by case.
  move=&gt; Afgx; split=&gt; //.
  by case: (f x) (g x) Afgx =&gt; [rf||] [rg||].
have Dfg : D `&amp;` [set x | f x +? g x] `&lt;=` D by apply: subIset; left.
apply: hwlogD =&gt; //.
- by apply: (measurable_funS mD) =&gt; //; do ?exact: measurableI.
- by apply: (measurable_funS mD) =&gt; //; do ?exact: measurableI.
- by rewrite -setIA setIid.
- by move=&gt; ? [].
Qed.
Lemma emeasurable_fun_sum D I s (h : I -&gt; (T -&gt; \bar R)) :
  (forall n, measurable_fun D (h n)) -&gt;
  measurable_fun D (fun x =&gt; \sum_(i &lt;- s) h i x).
Proof.
elim: s =&gt; [|s t ih] mf.
  by under eq_fun do rewrite big_nil; exact: measurable_cst.
under eq_fun do rewrite big_cons //=; apply: emeasurable_funD =&gt; //.
exact: ih.
Qed.
Lemma emeasurable_fun_fsum D (I : choiceType) (A : set I)
    (h : I -&gt; (T -&gt; \bar R)) : finite_set A -&gt;
    (forall n, measurable_fun D (h n)) -&gt;
  measurable_fun D (fun x =&gt; \sum_(i \in A) h i x).
Proof.
move=&gt; fs mh; under eq_fun do rewrite fsbig_finite//.
exact: emeasurable_fun_sum.
Qed.
Lemma ge0_emeasurable_fun_sum D (h : nat -&gt; (T -&gt; \bar R)) :
  (forall k x, 0 &lt;= h k x) -&gt; (forall k, measurable_fun D (h k)) -&gt;
  measurable_fun D (fun x =&gt; \sum_(i &lt;oo) h i x).
Proof.
move=&gt; h0 mh; rewrite [X in measurable_fun _ X](_ : _ =
    (fun x =&gt; limn_esup (fun n =&gt; \sum_(0 &lt;= i &lt; n) h i x))); last first.
  apply/funext=&gt; x; rewrite is_cvg_limn_esupE//.
  exact: is_cvg_ereal_nneg_natsum.
by apply: measurable_fun_limn_esup =&gt; k; exact: emeasurable_fun_sum.
Qed.
Lemma emeasurable_funB D f g :
  measurable_fun D f -&gt; measurable_fun D g -&gt; measurable_fun D (f \- g).
Proof.
by move=&gt; mf mg mD; apply: emeasurable_funD =&gt; //; exact: measurableT_comp.
Qed.
Lemma emeasurable_funM D f g :
  measurable_fun D f -&gt; measurable_fun D g -&gt; measurable_fun D (f \* g).
Proof.
move=&gt; mf mg mD.
have m0 : measurable ([set 0] : set (\bar R)) by [].
have mC0 : measurable ([set~ 0] : set (\bar R)) by apply: measurableC.
have mCoo : measurable (~` [set -oo; +oo] : set (\bar R)).
  exact/measurableC/measurableU.
have mfg : measurable (D `&amp;` [set x | f x *? g x]).
  suff -&gt; : [set x | f x *? g x] =
              (f @^-1` (~` [set 0]) `|` g @^-1` (~` [set -oo; +oo])) `&amp;`
              (g @^-1` (~` [set 0]) `|` f @^-1` (~` [set -oo; +oo])).
     by rewrite setIIr; apply: measurableI;
        rewrite setIUr; apply: measurableU; do ?[apply: mf|apply: mg].
   apply/predeqP=&gt; x; rewrite /preimage/= /mule_def !(negb_and, negb_or).
   rewrite !(rwP2 eqP idP) !(rwP2 negP idP) !(rwP2 orP idP).
   rewrite !(rwP2 negP idP) !(rwP2 orP idP) !(rwP2 andP idP).
   rewrite eqe_absl leey andbT (orbC (g x == +oo)).
   by rewrite eqe_absl leey andbT (orbC (f x == +oo)).
wlog fg : D mD mf mg mfg / forall x, D x -&gt; f x *? g x =&gt; [hwlogM|]; last first.
  have [f_ f_cvg] := approximation_sfun mD mf.
  have [g_ g_cvg] := approximation_sfun mD mg.
  apply: (emeasurable_fun_cvg (fun n x =&gt; (f_ n x * g_ n x)%:E)) =&gt; //.
    move=&gt; n; apply/EFin_measurable_fun.
    by apply: measurable_funM =&gt; //; exact: measurable_funTS.
  move=&gt; x Dx; under eq_fun do rewrite EFinM.
  exact: cvgeM (fg _ _) (f_cvg _ _) (g_cvg _ _).
move=&gt; A mA; wlog NA0: A mD mf mg mA / ~ (A 0) =&gt; [hwlogA|].
  have [] := pselect (A 0); last exact: hwlogA.
  move=&gt; /(@setD1K _ 0)&lt;-; rewrite preimage_setU setIUr.
  apply: measurableU; last by apply: hwlogA=&gt; //; [exact: measurableD|case =&gt; /=].
  have -&gt; : (fun x =&gt; f x * g x) @^-1` [set 0] =
           f @^-1` [set 0] `|` g @^-1` [set 0].
     apply/seteqP; split=&gt; x /= =&gt; [/eqP|[]]; rewrite /preimage/=.
       by rewrite mule_eq0 =&gt; /orP[] /eqP-&gt;; [left|right].
     by move=&gt; -&gt;; rewrite mul0e.
     by move=&gt; -&gt;; rewrite mule0.
   by rewrite setIUr; apply: measurableU; [apply: mf|apply: mg].
have-&gt; : D `&amp;` (fun x =&gt; f x * g x) @^-1` A =
       (D `&amp;` [set x | f x *? g x]) `&amp;` (fun x =&gt; f x * g x) @^-1` A.
  rewrite -setIA; congr (_ `&amp;` _).
  apply/seteqP; split=&gt; x; rewrite /preimage/=; last by case.
  move=&gt; Afgx; split=&gt; //; apply: neq0_mule_def.
  by apply: contra_notT NA0; rewrite negbK =&gt; /eqP &lt;-.
have Dfg : D `&amp;` [set x | f x *? g x] `&lt;=` D by apply: subIset; left.
apply: hwlogM =&gt; //.
- by apply: (measurable_funS mD) =&gt; //; do ?exact: measurableI.
- by apply: (measurable_funS mD) =&gt; //; do ?exact: measurableI.
- by rewrite -setIA setIid.
- by move=&gt; ? [].
Qed.
Lemma measurable_funeM D (f : T -&gt; \bar R) (k : \bar R) :
  measurable_fun D f -&gt; measurable_fun D (fun x =&gt; k * f x)%E.
Proof. by move=&gt; mf; exact/(emeasurable_funM _ mf). Qed.
End emeasurable_fun.
Section measurable_fun_measurable2.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (D : set T) (mD : measurable D).
Implicit Types f g : T -&gt; \bar R.
Lemma emeasurable_fun_lt f g : measurable_fun D f -&gt; measurable_fun D g -&gt;
  measurable (D `&amp;` [set x | f x &lt; g x]).
Proof.
move=&gt; mf mg; under eq_set do rewrite -sube_gt0.
by apply: emeasurable_fun_o_infty =&gt; //; exact: emeasurable_funB.
Qed.
Lemma emeasurable_fun_le f g : measurable_fun D f -&gt; measurable_fun D g -&gt;
  measurable (D `&amp;` [set x | f x &lt;= g x]).
Proof.
move=&gt; mf mg; under eq_set do rewrite -sube_le0.
by apply: emeasurable_fun_infty_c =&gt; //; exact: emeasurable_funB.
Qed.
Lemma emeasurable_fun_eq f g : measurable_fun D f -&gt; measurable_fun D g -&gt;
  measurable (D `&amp;` [set x | f x = g x]).
Proof.
move=&gt; mf mg; rewrite set_eq_le setIIr.
by apply: measurableI; apply: emeasurable_fun_le.
Qed.
Lemma emeasurable_fun_neq f g : measurable_fun D f -&gt; measurable_fun D g -&gt;
  measurable (D `&amp;` [set x | f x != g x]).
Proof.
move=&gt; mf mg; rewrite set_neq_lt setIUr.
by apply: measurableU; exact: emeasurable_fun_lt.
Qed.
End measurable_fun_measurable2.
Section ge0_integral_sum.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (mu : {measure set T -&gt; \bar R}) (D : set T) (mD : measurable D).
Variables (I : Type) (f : I -&gt; (T -&gt; \bar R)).
Hypothesis mf : forall n, measurable_fun D (f n).
Hypothesis f0 : forall n x, D x -&gt; 0 &lt;= f n x.
Lemma ge0_integral_sum (s : seq I) :
  \int[mu]_(x in D) (\sum_(k &lt;- s) f k x) =
  \sum_(k &lt;- s) \int[mu]_(x in D) (f k x).
Proof.
elim: s =&gt; [|h t ih].
  by (under eq_fun do rewrite big_nil); rewrite big_nil integral0.
rewrite big_cons /= -ih -ge0_integralD//.
- by apply: eq_integral =&gt; x Dx; rewrite big_cons.
- by move=&gt; *; exact: f0.
- by move=&gt; *; apply: sume_ge0 =&gt; // k _; exact: f0.
- exact: emeasurable_fun_sum.
Qed.
End ge0_integral_sum.
Section ge0_integral_fsum.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (mu : {measure set T -&gt; \bar R}) (D : set T) (mD : measurable D).
Variables (I : choiceType) (f : I -&gt; (T -&gt; \bar R)).
Hypothesis mf : forall n, measurable_fun D (f n).
Hypothesis f0 : forall n x, D x -&gt; 0 &lt;= f n x.
Lemma ge0_integral_fsum (A : set I) : finite_set A -&gt;
  \int[mu]_(x in D) (\sum_(k \in A) f k x) =
  \sum_(k \in A) \int[mu]_(x in D) f k x.
Proof.
move=&gt; fs; rewrite fsbig_finite//= -ge0_integral_sum//.
by apply: eq_integral =&gt; x xD; rewrite fsbig_finite.
Qed.
End ge0_integral_fsum.
Section monotone_convergence_theorem.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variable mu : {measure set T -&gt; \bar R}.
Variables (D : set T) (mD : measurable D) (g' : (T -&gt; \bar R)^nat).
Hypothesis mg' : forall n, measurable_fun D (g' n).
Hypothesis g'0 : forall n x, D x -&gt; 0 &lt;= g' n x.
Hypothesis nd_g' : forall x, D x -&gt; nondecreasing_seq (g'^~ x).
Let f' := fun x =&gt; lim (g'^~ x).
Let g n := (g' n \_ D).
Let g0 n x : 0 &lt;= g n x. Proof. exact/erestrict_ge0/g'0. Qed.
Let mg n : measurable_fun setT (g n).
Proof. exact/(measurable_restrict _ mD). Qed.
Let nd_g x : nondecreasing_seq (g^~ x).
Proof.
by move=&gt; m n mn; rewrite /g/patch; case: ifP =&gt; // /set_mem /nd_g' -&gt;.
Qed.
Let f := fun x =&gt; lim (g^~ x).
Let is_cvg_g t : cvg (g^~ t).
Proof.
by move=&gt; ?; apply: ereal_nondecreasing_is_cvgn =&gt; m n ?; apply/nd_g.
Qed.
Local Definition g2' n : (T -&gt; R)^nat := approx setT (g n).
Local Definition g2 n : {nnsfun T &gt;-&gt; R}^nat := nnsfun_approx measurableT (mg n).
Local Definition max_g2' : (T -&gt; R)^nat :=
  fun k t =&gt; (\big[maxr/0]_(i &lt; k) (g2' i k) t)%R.
Local Definition max_g2 : {nnsfun T &gt;-&gt; R}^nat :=
  fun k =&gt; bigmax_nnsfun (g2^~ k) k.
Let is_cvg_g2 n t : cvg (EFin \o (g2 n ^~ t)).
Proof.
apply: ereal_nondecreasing_is_cvgn =&gt; a b ab.
by rewrite lee_fin 2!nnsfun_approxE; exact/lefP/nd_approx.
Qed.
Let nd_max_g2 : nondecreasing_seq (max_g2 : (T -&gt; R)^nat).
Proof.
apply/nondecreasing_seqP =&gt; n; apply/lefP =&gt; x; rewrite 2!bigmax_nnsfunE.
rewrite (@le_trans _ _ (\big[maxr/0]_(i &lt; n) g2 i n.+1 x)%R) //.
  apply: le_bigmax2 =&gt; i _; apply: (nondecreasing_seqP (g2 i ^~ x)).2 =&gt; a b ab.
   by rewrite !nnsfun_approxE; exact/lefP/nd_approx.
rewrite (bigmaxD1 ord_max)// le_maxr; apply/orP; right.
rewrite [leRHS](eq_bigl (fun i =&gt; nat_of_ord i &lt; n)%N).
  by rewrite (big_ord_narrow (leqnSn n)).
move=&gt; i /=; rewrite neq_lt; apply/orP/idP =&gt; [[//|]|]; last by left.
by move=&gt; /(leq_trans (ltn_ord i)); rewrite ltnn.
Qed.
Let is_cvg_max_g2 t : cvg (EFin \o max_g2 ^~ t).
Proof.
apply: ereal_nondecreasing_is_cvgn =&gt; m n mn; rewrite lee_fin.
exact/lefP/nd_max_g2.
Qed.
Let max_g2_g k x : ((max_g2 k x)%:E &lt;= g k x)%O.
Proof.
rewrite bigmax_nnsfunE.
apply: (@le_trans _ _ (\big[maxe/0%:E]_(i &lt; k) g k x)); last first.
  by apply/bigmax_leP; split =&gt; //; apply: g0D.
rewrite (big_morph _ (@EFin_max R) erefl) //.
apply: le_bigmax2 =&gt; i _; rewrite nnsfun_approxE /=.
by rewrite (le_trans (le_approx _ _ _)) =&gt; //; exact/nd_g/ltnW.
Qed.
Let lim_max_g2_f t : lim (EFin \o max_g2 ^~ t) &lt;= f t.
Proof.
apply: lee_lim =&gt; //=; [apply: is_cvg_max_g2|apply: is_cvg_g|].
by near=&gt; n; exact/max_g2_g.
Unshelve. all: by end_near. Qed.
Let lim_g2_max_g2 t n : lim (EFin\o g2 n ^~ t) &lt;= lim (EFin \o max_g2 ^~ t).
Proof.
apply: lee_lim =&gt; //; [apply: is_cvg_g2|apply: is_cvg_max_g2|].
near=&gt; k; rewrite /= bigmax_nnsfunE lee_fin.
have nk : (n &lt; k)%N by near: k; exists n.+1.
exact: (bigmax_sup (Ordinal nk)).
Unshelve. all: by end_near. Qed.
Let cvg_max_g2_f t : EFin \o max_g2 ^~ t --&gt; f t.
Proof.
have /cvg_ex[l g_l] := @is_cvg_max_g2 t.
suff : l == f t by move=&gt; /eqP &lt;-.
rewrite eq_le; apply/andP; split.
  by rewrite /f (le_trans _ (lim_max_g2_f _)) // (cvg_lim _ g_l).
have := leey l; rewrite le_eqVlt =&gt; /predU1P[-&gt;|loo]; first by rewrite leey.
rewrite -(cvg_lim _ g_l) //= lime_le =&gt; //; first exact: is_cvg_g.
near=&gt; n.
have := leey (g n t); rewrite le_eqVlt =&gt; /predU1P[|] fntoo.
  have h := @dvg_approx _ _ _ setT _ t Logic.I fntoo.
  have g2oo : lim (EFin \o g2 n ^~ t) = +oo.
    apply/cvg_lim =&gt; //; apply/cvgeryP.
    under [in X in X --&gt; _]eq_fun do rewrite nnsfun_approxE.
    have : {homo (approx setT (g n))^~ t : n0 m / (n0 &lt;= m)%N &gt;-&gt; (n0 &lt;= m)%R}.
      exact/lef_at/nd_approx.
    by move/nondecreasing_dvgn_lt =&gt; /(_ h).
  have -&gt; : lim (EFin \o max_g2 ^~ t) = +oo.
    by have := lim_g2_max_g2 t n; rewrite g2oo leye_eq =&gt; /eqP.
  by rewrite leey.
- have approx_g_g := @cvg_approx _ _ _ setT _ t (fun t _ =&gt; g0 n t) Logic.I fntoo.
  suff : lim (EFin \o g2 n ^~ t) = g n t.
    by move=&gt; &lt;-; exact: (le_trans _ (lim_g2_max_g2 t n)).
  have /cvg_lim &lt;- // : EFin \o (approx setT (g n)) ^~ t --&gt; g n t.
    move/cvg_comp : approx_g_g; apply.
    by rewrite -(@fineK _ (g n t))// ge0_fin_numE// g0.
  rewrite (_ : _ \o _ = EFin \o approx setT (g n) ^~ t)// funeqE =&gt; m.
  by rewrite [in RHS]/= -nnsfun_approxE.
Unshelve. all: by end_near. Qed.
Lemma monotone_convergence :
  \int[mu]_(x in D) (f' x) = lim (fun n =&gt; \int[mu]_(x in D) (g' n x)).
Proof.
rewrite integral_mkcond.
under [in RHS]eq_fun do rewrite integral_mkcond -/(g _).
have -&gt; : f' \_ D = f.
  apply/funext =&gt; x; rewrite /f /f' /g /patch /=; case: ifPn =&gt; //=.
  by rewrite lim_cst.
apply/eqP; rewrite eq_le; apply/andP; split; last first.
  have nd_int_g : nondecreasing_seq (fun n =&gt; \int[mu]_x g n x).
    move=&gt; m n mn; apply: ge0_le_integral =&gt; //.
    by move=&gt; *; exact: nd_g.
  have ub n : \int[mu]_x g n x &lt;= \int[mu]_x f x.
    apply: ge0_le_integral =&gt; //.
    - move=&gt; x _; apply: lime_ge =&gt; //; first exact: is_cvg_g.
      by apply: nearW =&gt; k; exact/g0.
    - apply: emeasurable_fun_cvg mg _ =&gt; x _.
      exact: ereal_nondecreasing_is_cvgn.
    - move=&gt; x Dx; apply: lime_ge =&gt; //; first exact: is_cvg_g.
      near=&gt; m; have nm : (n &lt;= m)%N by near: m; exists n.
      exact/nd_g.
  by apply: lime_le =&gt; //; [exact:ereal_nondecreasing_is_cvgn|exact:nearW].
rewrite (@nd_ge0_integral_lim _ _ _ mu _ max_g2) //; last 2 first.
  - move=&gt; t; apply: lime_ge =&gt; //; first exact: is_cvg_g.
    by apply: nearW =&gt; n; exact: g0.
  - by move=&gt; t m n mn; exact/lefP/nd_max_g2.
apply: lee_lim.
- by apply: is_cvg_sintegral =&gt; // t m n mn; exact/lefP/nd_max_g2.
- apply: ereal_nondecreasing_is_cvgn =&gt; // n m nm; apply: ge0_le_integral =&gt; //.
  by move=&gt; *; exact/nd_g.
- apply: nearW =&gt; n; rewrite ge0_integralTE//.
  by apply: ereal_sup_ub; exists (max_g2 n) =&gt; // t; exact: max_g2_g.
Unshelve. all: by end_near. Qed.
Lemma cvg_monotone_convergence :
  (fun n =&gt; \int[mu]_(x in D) g' n x) --&gt; \int[mu]_(x in D) f' x.
Proof.
rewrite monotone_convergence; apply: ereal_nondecreasing_is_cvgn =&gt; m n mn.
by apply: ge0_le_integral =&gt; // t Dt; [exact: g'0|exact: g'0|exact: nd_g'].
Qed.
End monotone_convergence_theorem.
Section integral_nneseries.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (mu : {measure set T -&gt; \bar R}) (D : set T) (mD : measurable D).
Variable f : (T -&gt; \bar R)^nat.
Hypothesis mf : forall n, measurable_fun D (f n).
Hypothesis f0 : forall n x, D x -&gt; 0 &lt;= f n x.
Lemma integral_nneseries : \int[mu]_(x in D) (\sum_(n &lt;oo) f n x) =
                           \sum_(n &lt;oo) (\int[mu]_(x in D) (f n x)).
Proof.
rewrite monotone_convergence //.
- by rewrite -lim_mkord; under eq_fun do rewrite ge0_integral_sum// big_mkord.
- by move=&gt; n; exact: emeasurable_fun_sum.
- by move=&gt; n x Dx; apply: sume_ge0 =&gt; m _; exact: f0.
- by move=&gt; x Dx m n mn; apply: lee_sum_nneg_natr =&gt; // k _ _; exact: f0.
Qed.
End integral_nneseries.
generalization of ge0_integralZl_EFin to a constant potentially +oo
   using the monotone convergence theorem 
Section ge0_integralZl.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variable mu : {measure set T -&gt; \bar R}.
Variables (D : set T) (mD : measurable D) (f : T -&gt; \bar R).
Hypothesis mf : measurable_fun D f.
Lemma ge0_integralZl (k : \bar R) : (forall x, D x -&gt; 0 &lt;= f x) -&gt;
  0 &lt;= k -&gt; \int[mu]_(x in D) (k * f x)%E = k * \int[mu]_(x in D) (f x).
Proof.
move=&gt; f0; move: k =&gt; [k|_|//]; first exact: ge0_integralZl_EFin.
pose g : (T -&gt; \bar R)^nat := fun n x =&gt; n%:R%:E * f x.
have mg n : measurable_fun D (g n) by apply: measurable_funeM.
have g0 n x : D x -&gt; 0 &lt;= g n x.
  by move=&gt; Dx; apply: mule_ge0; [rewrite lee_fin|exact:f0].
have nd_g x : D x -&gt; nondecreasing_seq (g^~x).
  by move=&gt; Dx m n mn; rewrite lee_wpmul2r ?f0// lee_fin ler_nat.
pose h := fun x =&gt; lim (g^~ x).
transitivity (\int[mu]_(x in D) lim (g^~ x)).
  apply: eq_integral =&gt; x Dx; apply/esym/cvg_lim =&gt; //.
  have [fx0|fx0|fx0] := ltgtP 0 (f x).
  - rewrite gt0_mulye//; apply/cvgeyPgey; near=&gt; M.
    have M0 : (0 &lt;= M)%R by [].
    rewrite /g; case: (f x) fx0 =&gt; [r r0|_|//]; last first.
      exists 1%N =&gt; // m /= m0.
      by rewrite mulry gtr0_sg// ?mul1e ?leey// ltr0n.
    near=&gt; n; rewrite lee_fin -ler_pdivr_mulr//.
    near: n; exists `|ceil (M / r)|%N =&gt; // m /=.
    rewrite -(ler_nat R); apply: le_trans.
    by rewrite natr_absz ger0_norm ?ceil_ge// ceil_ge0// divr_ge0// ?ltW.
  - rewrite lt0_mulye//; apply/cvgeNyPleNy; near=&gt; M;
    have M0 : (M &lt;= 0)%R by [].
    rewrite /g; case: (f x) fx0 =&gt; [r r0|//|_]; last first.
      exists 1%N =&gt; // m /= m0.
      by rewrite mulrNy gtr0_sg// ?ltr0n// mul1e ?leNye.
    near=&gt; n; rewrite lee_fin -ler_ndivr_mulr//.
    near: n; exists `|ceil (M / r)|%N =&gt; // m /=.
    rewrite -(ler_nat R); apply: le_trans.
    rewrite natr_absz ger0_norm ?ceil_ge// ceil_ge0// -mulrNN.
    by rewrite mulr_ge0// ler_oppr oppr0// ltW// invr_lt0.
  - rewrite -fx0 mule0 /g -fx0 [X in X @ _ --&gt; _](_ : _ = cst 0).
      exact: cvg_cst.
    by rewrite funeqE =&gt; n /=; rewrite mule0.
rewrite (monotone_convergence mu mD mg g0 nd_g).
under eq_fun do  rewrite /g ge0_integralZl_EFin//.
have : 0 &lt;= \int[mu]_(x in D) (f x) by exact: integral_ge0.
rewrite le_eqVlt =&gt; /predU1P[&lt;-|if_gt0].
  by rewrite mule0; under eq_fun do rewrite mule0; rewrite lim_cst.
rewrite gt0_mulye//; apply/cvg_lim =&gt; //; apply/cvgeyPgey; near=&gt; M.
have M0 : (0 &lt;= M)%R by [].
near=&gt; n; have [ifoo|] := ltP (\int[mu]_(x in D) (f x)) +oo; last first.
  rewrite leye_eq =&gt; /eqP -&gt;; rewrite mulry muleC gt0_mulye ?leey//.
  by near: n; exists 1%N =&gt; // n /= n0; rewrite gtr0_sg// ?lte_fin// ltr0n.
rewrite -(@fineK _ (\int[mu]_(x in D) f x)); last first.
  by rewrite fin_numElt ifoo (le_lt_trans _ if_gt0).
rewrite -lee_pdivr_mulr//; last first.
  by move: if_gt0 ifoo; case: (\int[mu]_(x in D) f x).
near: n.
exists `|ceil (M * (fine (\int[mu]_(x in D) f x))^-1)|%N =&gt; //.
move=&gt; n /=; rewrite -(@ler_nat R) -lee_fin; apply: le_trans.
rewrite lee_fin natr_absz ger0_norm ?ceil_ge// ceil_ge0//.
by rewrite mulr_ge0// ?invr_ge0//; apply/fine_ge0/integral_ge0.
Unshelve. all: by end_near. Qed.
End ge0_integralZl.
#[deprecated(since="mathcomp-analysis 0.6.4", note="use `ge0_integralZl` instead")]
Notation ge0_integralM := ge0_integralZl (only parsing).
Section integral_indic.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType)
        (mu : {measure set T -&gt; \bar R}) (D : set T) (mD : measurable D).
Lemma integral_indic (E : set T) : measurable E -&gt;
  \int[mu]_(x in D) (\1_E x)%:E = mu (E `&amp;` D).
Proof.
move=&gt; mE; rewrite (_ : \1_E = indic_nnsfun R mE)// integral_nnsfun//=.
by rewrite restrict_indic sintegral_indic//; exact: measurableI.
Qed.
End integral_indic.
Section integralZl_indic.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (m : {measure set T -&gt; \bar R}) (D : set T) (mD : measurable D).
Lemma integralZl_indic (f : R -&gt; set T) (k : R) :
    ((k &lt; 0)%R -&gt; f k = set0) -&gt; measurable (f k) -&gt;
  \int[m]_(x in D) (k * \1_(f k) x)%:E =
  k%:E * \int[m]_(x in D) (\1_(f k) x)%:E.
Proof.
move=&gt; fk0 mfk; have [k0|k0] := ltP k 0%R.
  rewrite integral0_eq//; last by move=&gt; x _; rewrite fk0// indic0 mulr0.
  by rewrite integral0_eq ?mule0// =&gt; x _; rewrite fk0// indic0.
under eq_integral do rewrite EFinM.
rewrite ge0_integralZl//; first exact/EFin_measurable_fun.
by move=&gt; y _; rewrite lee_fin.
Qed.
Lemma integralZl_indic_nnsfun (f : {nnsfun T &gt;-&gt; R}) (k : R) :
  \int[m]_(x in D) (k * \1_(f @^-1` [set k]) x)%:E =
  k%:E * \int[m]_(x in D) (\1_(f @^-1` [set k]) x)%:E.
Proof.
rewrite (@integralZl_indic (fun k =&gt; f @^-1` [set k]))// =&gt; k0.
by rewrite preimage_nnfun0.
Qed.
End integralZl_indic.
Arguments integralZl_indic {d T R m D} mD f.
#[deprecated(since="mathcomp-analysis 0.6.4", note="use `integralZl_indic` instead")]
Notation integralM_indic := integralZl_indic (only parsing).
#[deprecated(since="mathcomp-analysis 0.6.4", note="use `integralZl_indic_nnsfun` instead")]
Notation integralM_indic_nnsfun := integralZl_indic_nnsfun (only parsing).
Section integral_mscale.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (m : {measure set T -&gt; \bar R}) (D : set T) (mD : measurable D).
Variables (k : {nonneg R}) (f : T -&gt; \bar R).
Let integral_mscale_indic E : measurable E -&gt;
  \int[mscale k m]_(x in D) (\1_E x)%:E =
  k%:num%:E * \int[m]_(x in D) (\1_E x)%:E.
Proof. by move=&gt; ?; rewrite !integral_indic. Qed.
Let integral_mscale_nnsfun (h : {nnsfun T &gt;-&gt; R}) :
  \int[mscale k m]_(x in D) (h x)%:E = k%:num%:E * \int[m]_(x in D) (h x)%:E.
Proof.
under [LHS]eq_integral do rewrite fimfunE -fsumEFin//.
rewrite [LHS]ge0_integral_fsum//; last 2 first.
  - by move=&gt; r; exact/EFin_measurable_fun/measurableT_comp.
  - by move=&gt; n x _; rewrite EFinM nnfun_muleindic_ge0.
rewrite -[RHS]ge0_integralZl//; last 2 first.
  - exact/EFin_measurable_fun/measurable_funTS.
  - by move=&gt; x _; rewrite lee_fin.
under [RHS]eq_integral.
  move=&gt; x xD; rewrite fimfunE -fsumEFin// ge0_mule_fsumr; last first.
    by move=&gt; r; rewrite EFinM nnfun_muleindic_ge0.
  over.
rewrite [RHS]ge0_integral_fsum//; last 2 first.
  - by move=&gt; r; apply/EFin_measurable_fun; do 2 apply/measurableT_comp =&gt; //.
  - by move=&gt; n x _; rewrite EFinM mule_ge0// nnfun_muleindic_ge0.
apply: eq_fsbigr =&gt; r _; rewrite ge0_integralZl//.
- by rewrite !integralZl_indic_nnsfun//= integral_mscale_indic// muleCA.
- exact/EFin_measurable_fun/measurableT_comp.
- by move=&gt; t _; rewrite nnfun_muleindic_ge0.
Qed.
Lemma ge0_integral_mscale (mf : measurable_fun D f) :
    (forall x, D x -&gt; 0 &lt;= f x) -&gt;
  \int[mscale k m]_(x in D) f x = k%:num%:E * \int[m]_(x in D) f x.
Proof.
move=&gt; f0; have [f_ [ndf_ f_f]] := approximation mD mf f0.
transitivity (lim (fun n =&gt; \int[mscale k m]_(x in D) (f_ n x)%:E)).
  rewrite -monotone_convergence//=.
  - by apply: eq_integral =&gt; x /[!inE] xD; apply/esym/cvg_lim =&gt; //=; exact: f_f.
  - by move=&gt; n; exact/EFin_measurable_fun/measurable_funTS.
  - by move=&gt; n x _; rewrite lee_fin.
  - by move=&gt; x _ a b /ndf_ /lefP; rewrite lee_fin.
rewrite (_ : \int[m]_(x in D) _ =
    lim (fun n =&gt; \int[m]_(x in D) (f_ n x)%:E)); last first.
  rewrite -monotone_convergence//=.
  - by apply: eq_integral =&gt; x /[!inE] xD; apply/esym/cvg_lim =&gt; //; exact: f_f.
  - by move=&gt; n; exact/EFin_measurable_fun/measurable_funTS.
  - by move=&gt; n x _; rewrite lee_fin.
  - by move=&gt; x _ a b /ndf_ /lefP; rewrite lee_fin.
rewrite -limeMl//.
  by congr (lim _); apply/funext =&gt; n /=; rewrite integral_mscale_nnsfun.
apply/ereal_nondecreasing_is_cvgn =&gt; a b ab; apply: ge0_le_integral =&gt; //.
- by move=&gt; x _; rewrite lee_fin.
- exact/EFin_measurable_fun/measurable_funTS.
- by move=&gt; x _; rewrite lee_fin.
- exact/EFin_measurable_fun/measurable_funTS.
- by move=&gt; x _; rewrite lee_fin; move/ndf_ : ab =&gt; /lefP.
Qed.
End integral_mscale.
Section fatou.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (mu : {measure set T -&gt; \bar R}) (D : set T) (mD : measurable D).
Variable (f : (T -&gt; \bar R)^nat).
Hypothesis mf : forall n, measurable_fun D (f n).
Hypothesis f0 : forall n x, D x -&gt; 0 &lt;= f n x.
Lemma fatou : \int[mu]_(x in D) limn_einf (f^~ x) &lt;=
              limn_einf (fun n =&gt; \int[mu]_(x in D) f n x).
Proof.
pose g n := fun x =&gt; einfs (f ^~ x) n.
have mg := measurable_fun_einfs mf.
have g0 n x : D x -&gt; 0 &lt;= g n x.
  by move=&gt; Dx; apply: lb_ereal_inf =&gt; _ [m /= nm &lt;-]; exact: f0.
rewrite monotone_convergence //; last first.
  move=&gt; x Dx m n mn /=; apply: le_ereal_inf =&gt; _ /= [p /= np &lt;-].
  by exists p =&gt; //=; rewrite (leq_trans mn).
apply: lee_lim.
- apply/cvg_ex; eexists; apply/ereal_nondecreasing_cvgn =&gt; a b ab.
  apply: ge0_le_integral =&gt; //; [exact: g0| exact: mg| exact: g0| exact: mg|].
  move=&gt; x Dx; apply: le_ereal_inf =&gt; _ [n /= bn &lt;-].
  by exists n =&gt; //=; rewrite (leq_trans ab).
- apply/cvg_ex; eexists; apply/ereal_nondecreasing_cvgn =&gt; a b ab.
  apply: le_ereal_inf =&gt; // _ [n /= bn &lt;-].
  by exists n =&gt; //=; rewrite (leq_trans ab).
- apply: nearW =&gt; m.
  have : forall n p, (p &gt;= n)%N -&gt;
      \int[mu]_(x in D) g n x &lt;= einfs (fun k =&gt; \int[mu]_(x in D) f k x) n.
    move=&gt; n p np; apply: lb_ereal_inf =&gt; /= _ [k /= nk &lt;-].
    apply: ge0_le_integral =&gt; //; [exact: g0|exact: mg|exact: f0|].
    by move=&gt; x Dx; apply: ereal_inf_lb; exists k.
  exact.
Qed.
End fatou.
Section integralN.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType)
        (mu : {measure set T -&gt; \bar R}).
Lemma integralN D (f : T -&gt; \bar R) :
  \int[mu]_(x in D) f^\+ x +? (- \int[mu]_(x in D) f^\- x) -&gt;
  \int[mu]_(x in D) - f x = - \int[mu]_(x in D) f x.
Proof.
have [f_fin _|] := boolP (\int[mu]_(x in D) f^\- x \is a fin_num).
  rewrite integralE// [in RHS]integralE// fin_num_oppeD ?fin_numN// oppeK addeC.
  by rewrite funenegN.
rewrite fin_numE negb_and 2!negbK =&gt; /orP[nfoo|/eqP nfoo].
  exfalso; move/negP : nfoo; apply; rewrite -leeNy_eq; apply/negP.
  by rewrite -ltNge (lt_le_trans _ (integral_ge0 _ _)).
rewrite nfoo adde_defEninfty -leye_eq -ltNge ltey_eq =&gt; /orP[f_fin|/eqP pfoo].
  rewrite integralE// [in RHS]integralE// nfoo [in RHS]addeC fin_num_oppeD//.
  by rewrite funenegN.
by rewrite integralE// [in RHS]integralE// funeposN funenegN nfoo pfoo.
Qed.
Lemma integral_ge0N (D : set T) (f : T -&gt; \bar R) :
  (forall x, D x -&gt; 0 &lt;= f x) -&gt;
  \int[mu]_(x in D) - f x = - \int[mu]_(x in D) f x.
Proof.
move=&gt; f0; rewrite integralN // (eq_integral _ _ (ge0_funenegE _))// integral0.
by rewrite oppe0 fin_num_adde_defl.
Qed.
End integralN.
Section integral_cst.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType)
        (mu : {measure set T -&gt; \bar R}).
Variables (f : T -&gt; \bar R) (D : set T) (mD : measurable D).
Lemma sintegral_EFin_cst (x : {nonneg R}) :
  sintegral mu (cst x%:num \_ D) = x%:num%:E * mu D.
Proof.
rewrite sintegralE (fsbig_widen _ [set 0%R; x%:num])/=.
- have [-&gt;|x0] := eqVneq x%:num 0%R; first by rewrite setUid fsbig_set1 !mul0e.
  rewrite fsbigU0//=; last by move=&gt; y [-&gt;]/esym; apply/eqP.
  rewrite !fsbig_set1 mul0e add0e preimage_restrict//.
  by rewrite ifN ?set0U ?setIidl//= notin_set =&gt; /esym; exact/eqP.
- by move=&gt; y [t _ &lt;-] /=; rewrite /patch; case: ifPn; [right|left].
- by move=&gt; y [_ /=/preimage10-&gt;]; rewrite measure0 mule0.
Qed.
Local Lemma integral_cstr r : \int[mu]_(x in D) r%:E = r%:E * mu D.
Proof.
wlog r0 : r / (0 &lt;= r)%R.
  move=&gt; h; have [|r0] := leP 0%R r; first exact: h.
  rewrite -[in RHS](opprK r) EFinN mulNe -h ?oppr_ge0; last exact: ltW.
  rewrite -integral_ge0N//; last by move=&gt; t ?; rewrite /= lee_fin oppr_ge0 ltW.
  by under [RHS]eq_integral do rewrite /= opprK.
rewrite (eq_integral (EFin \o cst_nnsfun T (NngNum r0)))//.
by rewrite integral_nnsfun// sintegral_EFin_cst.
Qed.
Local Lemma integral_csty : mu D != 0 -&gt; \int[mu]_(x in D) (cst +oo) x = +oo.
Proof.
move=&gt; muD0; pose g : (T -&gt; \bar R)^nat := fun n =&gt; cst n%:R%:E.
have &lt;- : (fun t =&gt; lim (g^~ t)) = cst +oo.
  rewrite funeqE =&gt; t; apply/cvg_lim =&gt; //=.
  apply/cvgeryP/cvgryPge =&gt; M; exists `|ceil M|%N =&gt; //= m.
  rewrite /= -(ler_nat R); apply: le_trans.
  by rewrite (le_trans (ceil_ge _))// natr_absz ler_int ler_norm.
rewrite monotone_convergence //.
- under [in LHS]eq_fun do rewrite integral_cstr.
  apply/cvg_lim =&gt; //; apply/cvgeyPge =&gt; M.
  have [muDoo|muDoo] := ltP (mu D) +oo; last first.
    exists 1%N =&gt; // m /= m0; move: muDoo; rewrite leye_eq =&gt; /eqP -&gt;.
    by rewrite mulry gtr0_sg ?mul1e ?leey// ltr0n.
  exists `|ceil (M / fine (mu D))|%N =&gt; // m /=.
  rewrite -(ler_nat R) =&gt; MDm; rewrite -(@fineK _ (mu D)) ?ge0_fin_numE//.
  rewrite -lee_pdivr_mulr; last by rewrite fine_gt0// lt0e muD0 measure_ge0.
  rewrite lee_fin (le_trans _ MDm)//.
  by rewrite natr_absz (le_trans (ceil_ge _))// ler_int ler_norm.
- by move=&gt; n; exact: measurable_cst.
- by move=&gt; n x Dx; rewrite lee_fin.
- by move=&gt; t Dt n m nm; rewrite /g lee_fin ler_nat.
Qed.
Local Lemma integral_cstNy : mu D != 0 -&gt; \int[mu]_(x in D) (cst -oo) x = -oo.
Proof.
by move=&gt; ?; rewrite (eq_integral (\- cst +oo)) ?integral_ge0N/= ?integral_csty.
Qed.
End integral_cst.
Section transfer.
Local Open Scope ereal_scope.
Context d1 d2 (X : measurableType d1) (Y : measurableType d2) (R : realType).
Variables (phi : X -&gt; Y) (mphi : measurable_fun setT phi).
Variables (mu : {measure set X -&gt; \bar R}).
Lemma integral_pushforward (f : Y -&gt; \bar R) :
  measurable_fun setT f -&gt; (forall y, 0 &lt;= f y) -&gt;
  \int[pushforward mu mphi]_y f y = \int[mu]_x (f \o phi) x.
Proof.
move=&gt; mf f0.
have [f_ [ndf_ f_f]] := approximation measurableT mf (fun t _ =&gt; f0 t).
transitivity (lim (fun n =&gt; \int[pushforward mu mphi]_x (f_ n x)%:E)).
  rewrite -monotone_convergence//.
  - by apply: eq_integral =&gt; y _; apply/esym/cvg_lim =&gt; //; exact: f_f.
  - by move=&gt; n; exact/EFin_measurable_fun.
  - by move=&gt; n y _; rewrite lee_fin.
  - by move=&gt; y _ m n mn; rewrite lee_fin; apply/lefP/ndf_.
rewrite (_ : (fun _ =&gt; _) = (fun n =&gt; \int[mu]_x (EFin \o f_ n \o phi) x)).
  rewrite -monotone_convergence//; last 3 first.
    - by move=&gt; n /=; apply: measurableT_comp =&gt; //; exact: measurableT_comp.
    - by move=&gt; n x _ /=; rewrite lee_fin.
    - by move=&gt; x _ m n mn; rewrite lee_fin; exact/lefP/ndf_.
  by apply: eq_integral =&gt; x _ /=; apply/cvg_lim =&gt; //; exact: f_f.
apply/funext =&gt; n.
have mfnphi r : measurable (f_ n @^-1` [set r] \o phi).
  rewrite -[_ \o _]/(phi @^-1` (f_ n @^-1` [set r])) -(setTI (_ @^-1` _)).
  exact/mphi.
transitivity (\sum_(k \in range (f_ n))
    \int[mu]_x (k * \1_((f_ n @^-1` [set k]) \o phi) x)%:E).
  under eq_integral do rewrite fimfunE -fsumEFin//.
  rewrite ge0_integral_fsum//; last 2 first.
    - by move=&gt; y; apply/EFin_measurable_fun; exact: measurable_funM.
    - by move=&gt; y x _; rewrite nnfun_muleindic_ge0.
  apply: eq_fsbigr =&gt; r _; rewrite integralZl_indic_nnsfun// integral_indic//=.
  rewrite (integralZl_indic _ (fun r =&gt; f_ n @^-1` [set r] \o phi))//.
    by congr (_ * _); rewrite [RHS](@integral_indic).
  by move=&gt; r0; rewrite preimage_nnfun0.
rewrite -ge0_integral_fsum//; last 2 first.
  - by move=&gt; r; apply/EFin_measurable_fun; exact: measurable_funM.
  - by move=&gt; r x _; rewrite nnfun_muleindic_ge0.
by apply: eq_integral =&gt; x _; rewrite fsumEFin// -fimfunE.
Qed.
End transfer.
Section integral_dirac.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (a : T) (R : realType).
Variables (D : set T) (mD : measurable D).
Let ge0_integral_dirac (f : T -&gt; \bar R) (mf : measurable_fun D f)
    (f0 : forall x, D x -&gt; 0 &lt;= f x) :
  D a -&gt; \int[\d_a]_(x in D) (f x) = f a.
Proof.
move=&gt; Da; have [f_ [ndf_ f_f]] := approximation mD mf f0.
transitivity (lim (fun n =&gt; \int[\d_ a]_(x in D) (f_ n x)%:E)).
  rewrite -monotone_convergence//.
  - apply: eq_integral =&gt; x Dx; apply/esym/cvg_lim =&gt; //; apply: f_f.
    by rewrite inE in Dx.
  - by move=&gt; n; apply/EFin_measurable_fun; exact/measurable_funTS.
  - by move=&gt; *; rewrite lee_fin.
  - by move=&gt; x _ m n mn; rewrite lee_fin; exact/lefP/ndf_.
rewrite (_ : (fun _ =&gt; _) = (fun n =&gt; (f_ n a)%:E)).
  by apply/cvg_lim =&gt; //; exact: f_f.
apply/funext =&gt; n.
under eq_integral do rewrite fimfunE// -fsumEFin//.
rewrite ge0_integral_fsum//.
- under eq_fsbigr do rewrite integralZl_indic_nnsfun//.
  rewrite /= (fsbigD1 (f_ n a))//=; last by exists a.
  rewrite integral_indic//= diracE mem_set// mule1.
  rewrite fsbig1 ?adde0// =&gt; r /= [_ rfna].
  rewrite integral_indic//= diracE memNset ?mule0//=.
  by apply/not_andP; left; exact/nesym.
- by move=&gt; r; exact/EFin_measurable_fun/measurableT_comp.
- by move=&gt; r x _; rewrite nnfun_muleindic_ge0.
Qed.
Lemma integral_dirac (f : T -&gt; \bar R) (mf : measurable_fun D f) :
  \int[\d_ a]_(x in D) f x = \d_a D * f a.
Proof.
have [/[!inE] aD|aD] := boolP (a \in D).
  rewrite integralE ge0_integral_dirac//; last exact/measurable_funepos.
  rewrite ge0_integral_dirac//; last exact/measurable_funeneg.
  by rewrite [in RHS](funeposneg f) diracE mem_set// mul1e.
rewrite diracE (negbTE aD) mul0e -(integral_measure_zero D f)//.
apply: eq_measure_integral =&gt; //= S mS DS; rewrite /dirac indicE memNset//.
by move=&gt; /DS/mem_set; exact/negP.
Qed.
End integral_dirac.
Section integral_measure_sum_nnsfun.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (m_ : {measure set T -&gt; \bar R}^nat) (N : nat).
Let m := msum m_ N.
Let integral_measure_sum_indic (E D : set T) (mE : measurable E)
    (mD : measurable D) :
  \int[m]_(x in E) (\1_D x)%:E = \sum_(n &lt; N) \int[m_ n]_(x in E) (\1_D x)%:E.
Proof.
rewrite integral_indic//= /msum/=; apply: eq_bigr =&gt; i _.
by rewrite integral_indic// setIT.
Qed.
Let integralT_measure_sum (f : {nnsfun T &gt;-&gt; R}) :
  \int[m]_x (f x)%:E = \sum_(n &lt; N) \int[m_ n]_x (f x)%:E.
Proof.
under eq_integral do rewrite fimfunE -fsumEFin//.
rewrite ge0_integral_fsum//; last 2 first.
  - by move=&gt; r /=; apply: measurableT_comp =&gt; //; exact: measurableT_comp.
  - by move=&gt; r t _; rewrite EFinM nnfun_muleindic_ge0.
transitivity (\sum_(i \in range f)
    (\sum_(n &lt; N) i%:E * \int[m_ n]_x (\1_(f @^-1` [set i]) x)%:E)).
  apply: eq_fsbigr =&gt; r _.
  rewrite integralZl_indic_nnsfun// integral_measure_sum_indic//.
  by rewrite ge0_sume_distrr// =&gt; n _; apply: integral_ge0 =&gt; t _; rewrite lee_fin.
rewrite fsbig_finite//= exchange_big/=; apply: eq_bigr =&gt; i _.
rewrite integralT_nnsfun sintegralE fsbig_finite//=; apply: eq_bigr =&gt; r _.
by congr (_ * _); rewrite integral_indic// setIT.
Qed.
Lemma integral_measure_sum_nnsfun (D : set T) (mD : measurable D)
  (f : {nnsfun T &gt;-&gt; R}) :
  \int[m]_(x in D) (f x)%:E = \sum_(n &lt; N) \int[m_ n]_(x in D) (f x)%:E.
Proof.
rewrite integral_mkcond.
transitivity (\int[m]_x (proj_nnsfun f mD x)%:E).
  by apply: eq_integral =&gt; t _ /=; rewrite /patch mindicE;
    case: ifPn =&gt; // tD; rewrite ?mulr1 ?mulr0.
rewrite integralT_measure_sum; apply: eq_bigr =&gt; i _.
rewrite [RHS]integral_mkcond; apply: eq_integral =&gt; t _.
rewrite /= /patch /mindic indicE.
by case: (boolP (t \in D)) =&gt; tD; rewrite ?mulr1 ?mulr0.
Qed.
End integral_measure_sum_nnsfun.
Lemma integral_measure_add_nnsfun d (T : measurableType d) (R : realType)
    (m1 m2 : {measure set T -&gt; \bar R}) (D : set T) (mD : measurable D)
    (f : {nnsfun T &gt;-&gt; R}) :
  (\int[measure_add m1 m2]_(x in D) (f x)%:E =
   \int[m1]_(x in D) (f x)%:E + \int[m2]_(x in D) (f x)%:E)%E.
Proof.
rewrite /measureD integral_measure_sum_nnsfun// 2!big_ord_recl/= big_ord0.
by rewrite adde0.
Qed.
Section integral_mfun_measure_sum.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variable m_ : {measure set T -&gt; \bar R}^nat.
Lemma ge0_integral_measure_sum (D : set T) (mD : measurable D)
    (f : T -&gt; \bar R) :
    (forall x, D x -&gt; 0 &lt;= f x) -&gt; measurable_fun D f -&gt; forall N,
  \int[msum m_ N]_(x in D) f x = \sum_(n &lt; N) \int[m_ n]_(x in D) f x.
Proof.
move=&gt; f0 mf.
have [f_ [f_nd f_f]] := approximation mD mf f0.
elim =&gt; [|N ih]; first by rewrite big_ord0 msum_mzero integral_measure_zero.
rewrite big_ord_recr/= -ih.
rewrite (_ : _ m_ N.+1 = measure_add [the measure _ _ of msum m_ N] (m_ N)); last first.
  by apply/funext =&gt; A; rewrite measure_addE /msum/= big_ord_recr.
have mf_ n : measurable_fun D (fun x =&gt; (f_ n x)%:E).
  exact/measurable_funTS/EFin_measurable_fun.
have f_ge0 n x : D x -&gt; 0 &lt;= (f_ n x)%:E by move=&gt; Dx; rewrite lee_fin.
have cvg_f_ (m : {measure set T -&gt; \bar R}) : cvg (fun x =&gt; \int[m]_(x0 in D) (f_ x x0)%:E).
  apply: ereal_nondecreasing_is_cvgn =&gt; a b ab.
  apply: ge0_le_integral =&gt; //; [exact: f_ge0|exact: f_ge0|].
  by move=&gt; t Dt; rewrite lee_fin; apply/lefP/f_nd.
transitivity (lim (fun n =&gt;
    \int[measure_add [the measure _ _ of msum m_ N] (m_ N)]_(x in D) (f_ n x)%:E)).
  rewrite -monotone_convergence//; last first.
    by move=&gt; t Dt a b ab; rewrite lee_fin; exact/lefP/f_nd.
  by apply: eq_integral =&gt; t /[!inE] Dt; apply/esym/cvg_lim =&gt; //; exact: f_f.
transitivity (lim (fun n =&gt;
  \int[msum m_ N]_(x in D) (f_ n x)%:E + \int[m_ N]_(x in D) (f_ n x)%:E)).
  by congr (lim _); apply/funext =&gt; n; by rewrite integral_measure_add_nnsfun.
rewrite limeD//; do?[exact: cvg_f_]; last first.
  by apply: ge0_adde_def; rewrite inE; apply: lime_ge =&gt; //; do?[exact: cvg_f_];
      apply: nearW =&gt; n;  apply: integral_ge0 =&gt; //; exact: f_ge0.
by congr (_ + _); (rewrite -monotone_convergence//; [
    apply: eq_integral =&gt; t /[!inE] Dt; apply/cvg_lim =&gt; //; exact: f_f |
    move=&gt; t Dt a b ab; rewrite lee_fin; exact/lefP/f_nd]).
Qed.
End integral_mfun_measure_sum.
Lemma integral_measure_add d (T : measurableType d) (R : realType)
    (m1 m2 : {measure set T -&gt; \bar R}) (D : set T) (mD : measurable D)
    (f : T -&gt; \bar R) :
  (forall x, D x -&gt; 0 &lt;= f x)%E -&gt; measurable_fun D f -&gt;
  (\int[measure_add m1 m2]_(x in D) f x =
   \int[m1]_(x in D) f x + \int[m2]_(x in D) f x)%E.
Proof.
move=&gt; f0 mf; rewrite /measureD ge0_integral_measure_sum// 2!big_ord_recl/=.
by rewrite big_ord0 adde0.
Qed.
Section integral_measure_series.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variable m_ : {measure set T -&gt; \bar R}^nat.
Let m := mseries m_ O.
Let integral_measure_series_indic (D : set T) (mD : measurable D) :
  \int[m]_x (\1_D x)%:E = \sum_(n &lt;oo) \int[m_ n]_x (\1_D x)%:E.
Proof.
rewrite integral_indic// setIT /m/= /mseries; apply: eq_eseriesr =&gt; i _.
by rewrite integral_indic// setIT.
Qed.
Lemma integral_measure_series_nnsfun (D : set T) (mD : measurable D)
    (f : {nnsfun T &gt;-&gt; R}) :
  \int[m]_x (f x)%:E = \sum_(n &lt;oo) \int[m_ n]_x (f x)%:E.
Proof.
under eq_integral do rewrite fimfunE -fsumEFin//.
rewrite ge0_integral_fsum//; last 2 first.
  - by move=&gt; r /=; apply: measurableT_comp =&gt; //; exact: measurableT_comp.
  - by move=&gt; r t _; rewrite EFinM nnfun_muleindic_ge0.
transitivity (\sum_(i \in range f)
    (\sum_(n &lt;oo) i%:E * \int[m_ n]_x (\1_(f @^-1` [set i]) x)%:E)).
  apply: eq_fsbigr =&gt; r _.
  rewrite integralZl_indic_nnsfun// integral_measure_series_indic// nneseriesZl//.
  by move=&gt; n _; apply: integral_ge0 =&gt; t _; rewrite lee_fin.
rewrite fsbig_finite//= -nneseries_sum; last first.
  move=&gt; r j _.
  have [r0|r0] := leP 0%R r.
    by rewrite mule_ge0//; apply: integral_ge0 =&gt; // t _; rewrite lee_fin.
  by rewrite integral0_eq// =&gt; x _; rewrite preimage_nnfun0// indicE in_set0.
apply: eq_eseriesr =&gt; k _.
rewrite integralT_nnsfun sintegralE fsbig_finite//=; apply: eq_bigr =&gt; r _.
by congr (_ * _); rewrite integral_indic// setIT.
Qed.
End integral_measure_series.
Section ge0_integral_measure_series.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variable m_ : {measure set T -&gt; \bar R}^nat.
Let m := mseries m_ O.
Lemma ge0_integral_measure_series (D : set T) (mD : measurable D) (f : T -&gt; \bar R) :
  (forall t, D t -&gt; 0 &lt;= f t) -&gt;
  measurable_fun D f -&gt;
  \int[m]_(x in D) f x = \sum_(n &lt;oo) \int[m_ n]_(x in D) f x.
Proof.
move=&gt; f0 mf.
apply/eqP; rewrite eq_le; apply/andP; split; last first.
  suff : forall n, \sum_(k &lt; n) \int[m_ k]_(x in D) f x &lt;= \int[m]_(x in D) f x.
    move=&gt; n; apply: lime_le =&gt; //.
      by apply: is_cvg_ereal_nneg_natsum =&gt; k _; exact: integral_ge0.
    by apply: nearW =&gt; x; rewrite big_mkord.
  move=&gt; n.
  rewrite [X in _ &lt;= X](_ : _ = (\sum_(k &lt; n) \int[m_ k]_(x in D) f x
    + \int[mseries m_ n]_(x in D) f x)); last first.
    transitivity (\int[measure_add [the measure _ _ of msum m_ n]
                                   [the measure _ _ of mseries m_ n]]_(x in D) f x).
      congr (\int[_]_(_ in D) _); apply/funext =&gt; A.
      by rewrite measure_addE; exact: nneseries_split.
    rewrite integral_measure_add//; congr (_ + _).
    by rewrite -ge0_integral_measure_sum.
  by apply: lee_addl; exact: integral_ge0.
rewrite ge0_integralE//=; apply: ub_ereal_sup =&gt; /= _ [g /= gf] &lt;-.
rewrite -integralT_nnsfun (integral_measure_series_nnsfun _ mD).
apply: lee_nneseries =&gt; n _.
  by apply: integral_ge0 =&gt; // x _; rewrite lee_fin.
rewrite [leRHS]integral_mkcond; apply: ge0_le_integral =&gt; //.
- by move=&gt; x _; rewrite lee_fin.
- exact/EFin_measurable_fun.
- by move=&gt; x _; rewrite erestrict_ge0.
- exact/(measurable_restrict _ mD).
Qed.
End ge0_integral_measure_series.
Section subset_integral.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType)
        (mu : {measure set T -&gt; \bar R}).
Lemma integral_setU (A B : set T) (mA : measurable A) (mB : measurable B)
    (f : T -&gt; \bar R) : measurable_fun (A `|` B) f -&gt;
  (forall x, (A `|` B) x -&gt; 0 &lt;= f x) -&gt; [disjoint A &amp; B] -&gt;
  \int[mu]_(x in A `|` B) f x = \int[mu]_(x in A) f x + \int[mu]_(x in B) f x.
Proof.
move=&gt; mf f0 AB.
transitivity (\int[mu]_(x in A `|` B) ((f \_ A) x + (f \_ B) x)).
  apply: eq_integral =&gt; x; rewrite inE =&gt; -[xA|xB].
    rewrite /patch mem_set// ifF ?adde0//; apply/negbTE/negP; rewrite inE =&gt; xB.
    by move: AB; rewrite disj_set2E =&gt; /eqP; apply/eqP/set0P; exists x.
  rewrite /patch addeC mem_set// ifF ?adde0//; apply/negbTE/negP; rewrite inE =&gt; xA.
    by move: AB; rewrite disj_set2E =&gt; /eqP; apply/eqP/set0P; exists x.
rewrite ge0_integralD//; last 5 first.
  - exact: measurableU.
  - by move=&gt; x _; apply: erestrict_ge0 =&gt; y Ay; apply: f0; left.
  - have : measurable_fun A f.
      by apply: measurable_funS mf; [exact: measurableU|exact: subsetUl].
    by apply/(measurable_restrict _ _ _ _).1 =&gt; //; exact: measurableU.
  - by move=&gt; x _; apply: erestrict_ge0 =&gt; y By; apply: f0; right.
  - have : measurable_fun B f.
      by apply: measurable_funS mf; [exact: measurableU|exact: subsetUr].
    by apply/(measurable_restrict _ _ _ _).1 =&gt; //; exact: measurableU.
by rewrite -integral_mkcondl setIC setUK -integral_mkcondl setKU.
Qed.
Lemma subset_integral (A B : set T) (mA : measurable A) (mB : measurable B)
    (f : T -&gt; \bar R) : measurable_fun B f -&gt; (forall x, B x -&gt; 0 &lt;= f x) -&gt;
  A `&lt;=` B -&gt; \int[mu]_(x in A) f x &lt;= \int[mu]_(x in B) f x.
Proof.
move=&gt; mf f0 AB; rewrite -(setDUK AB) integral_setU//; last 4 first.
  - exact: measurableD.
  - by rewrite setDUK.
  - by move=&gt; x; rewrite setDUK//; exact: f0.
  - by rewrite disj_set2E setDIK.
by apply: lee_addl; apply: integral_ge0 =&gt; x [Bx _]; exact: f0.
Qed.
Lemma integral_set0 (f : T -&gt; \bar R) : \int[mu]_(x in set0) f x = 0.
Proof.
rewrite integral_mkcond integral0_eq// =&gt; x _.
by rewrite /restrict; case: ifPn =&gt; //; rewrite in_set0.
Qed.
Lemma ge0_integral_bigsetU (F : (set T)^nat) (f : T -&gt; \bar R) n :
  (forall n, measurable (F n)) -&gt;
  let D := \big[setU/set0]_(i &lt; n) F i in
  measurable_fun D f -&gt;
  (forall x, D x -&gt; 0 &lt;= f x) -&gt;
  trivIset `I_n F -&gt;
  \int[mu]_(x in D) f x = \sum_(i &lt; n) \int[mu]_(x in F i) f x.
Proof.
move=&gt; mF.
elim: n =&gt; [|n ih] D mf f0 tF; first by rewrite /D 2!big_ord0 integral_set0.
rewrite /D big_ord_recr/= integral_setU//; last 4 first.
  - exact: bigsetU_measurable.
  - by move: mf; rewrite /D big_ord_recr.
  - by move: f0; rewrite /D big_ord_recr.
  - apply/eqP; move: (trivIset_bigsetUI tF (ltnSn n) (leqnn n)).
    rewrite [in X in X -&gt; _](eq_bigl xpredT)// =&gt; i.
    by rewrite (leq_trans (ltn_ord i)).
rewrite ih ?big_ord_recr//.
- apply: measurable_funS mf =&gt; //; first exact: bigsetU_measurable.
  by rewrite /D big_ord_recr /=; apply: subsetUl.
- by move=&gt; t Dt; apply: f0; rewrite /D big_ord_recr/=; left.
- by apply: sub_trivIset tF =&gt; x; exact: leq_trans.
Qed.
Lemma le_integral_abse (D : set T) (mD : measurable D) (g : T -&gt; \bar R) a :
  measurable_fun D g -&gt; (0 &lt; a)%R -&gt;
  a%:E * mu (D `&amp;` [set x | `|g x| &gt;= a%:E]) &lt;= \int[mu]_(x in D) `|g x|.
Proof.
move=&gt; mg a0; have ? : measurable (D `&amp;` [set x | a%:E &lt;= `|g x|]).
  by apply: emeasurable_fun_c_infty =&gt; //; exact: measurableT_comp.
apply: (@le_trans _ _ (\int[mu]_(x in D `&amp;` [set x | `|g x| &gt;= a%:E]) `|g x|)).
  rewrite -integral_cstr//; apply: ge0_le_integral =&gt; //.
  - by move=&gt; x _ /=; exact/ltW.
  - by apply: measurableT_comp =&gt; //; exact: measurable_funS mg.
  - by move=&gt; x /= [].
by apply: subset_integral =&gt; //; exact: measurableT_comp.
Qed.
End subset_integral.
Section Rintegral.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType)
        (mu : {measure set T -&gt; \bar R}).
Definition Rintegral (D : set T) (f : T -&gt; R) :=
  fine (\int[mu]_(x in D) (f x)%:E).
End Rintegral.
Notation "\int [ mu ]_ ( x 'in' D ) f" := (Rintegral mu D (fun x =&gt; f)) : ring_scope.
Notation "\int [ mu ]_ x f" := (Rintegral mu setT (fun x =&gt; f)) : ring_scope.
HB.lock Definition integrable {d} {T : measurableType d} {R : realType}
    (mu : set T -&gt; \bar R) D f :=
  `[&lt; measurable_fun D f /\ (\int[mu]_(x in D) `|f x| &lt; +oo)%E &gt;].
Canonical integrable_unlockable := Unlockable integrable.unlock.
Lemma integrableP d T R mu D f :
  reflect (measurable_fun D f /\ (\int[mu]_(x in D) `|f x| &lt; +oo)%E)
    (@integrable d T R mu D f).
Proof. by rewrite unlock; apply/(iffP (asboolP _)). Qed.
Lemma measurable_int d T R mu D f :
  @integrable d T R mu D f -&gt; measurable_fun D f.
Proof. by rewrite unlock =&gt; /asboolP[]. Qed.
Section integrable_theory.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (mu : {measure set T -&gt; \bar R}).
Variables (D : set T) (mD : measurable D).
Implicit Type f g : T -&gt; \bar R.
Notation mu_int := (integrable mu D).
Lemma integrable0 : mu_int (cst 0).
Proof.
apply/integrableP; split=&gt; //; under eq_integral do rewrite (gee0_abs (lexx 0)).
by rewrite integral0.
Qed.
Lemma eq_integrable f g : {in D, f =1 g} -&gt; mu_int f -&gt; mu_int g.
Proof.
move=&gt; fg /integrableP[mf fi]; apply/integrableP; split.
  exact: eq_measurable_fun mf.
rewrite (le_lt_trans _ fi)//; apply: ge0_le_integral=&gt; //.
  by apply: measurableT_comp =&gt; //; exact: eq_measurable_fun mf.
  by apply: measurableT_comp =&gt; //; exact: eq_measurable_fun mf.
by move=&gt; x Dx; rewrite fg// inE.
Qed.
Lemma le_integrable f g : measurable_fun D f -&gt;
  (forall x, D x -&gt; `|f x| &lt;= `|g x|) -&gt; mu_int g -&gt; mu_int f.
Proof.
move=&gt; mf fg /integrableP[mfg goo]; apply/integrableP; split =&gt; //.
by apply: le_lt_trans goo; apply: ge0_le_integral =&gt; //; exact: measurableT_comp.
Qed.
Lemma integrableN f : mu_int f -&gt; mu_int (-%E \o f).
Proof.
move=&gt; /integrableP[mf foo]; apply/integrableP; split; last first.
  by rewrite /comp; under eq_fun do rewrite abseN.
by rewrite /comp; apply: measurableT_comp =&gt;//; exact: measurable_oppe.
Qed.
Lemma integrableZl (k : R) f : mu_int f -&gt; mu_int (fun x =&gt; k%:E * f x).
Proof.
move=&gt; /integrableP[mf foo]; apply/integrableP; split.
  exact: measurable_funeM.
under eq_fun do rewrite abseM.
by rewrite ge0_integralZl// ?lte_mul_pinfty//; exact: measurableT_comp.
Qed.
Lemma integrableZr (k : R) f : mu_int f -&gt; mu_int (f \* cst k%:E).
Proof.
by move=&gt; mf; apply: eq_integrable (integrableZl k mf) =&gt; // x; rewrite muleC.
Qed.
Lemma integrableD f g : mu_int f -&gt; mu_int g -&gt; mu_int (f \+ g).
Proof.
move=&gt; /integrableP[mf foo] /integrableP[mg goo]; apply/integrableP; split.
  exact: emeasurable_funD.
apply: (@le_lt_trans _ _ (\int[mu]_(x in D) (`|f x| + `|g x|))).
  apply: ge0_le_integral =&gt; //.
  - by apply: measurableT_comp =&gt; //; exact: emeasurable_funD.
  - by apply: emeasurable_funD; apply: measurableT_comp.
  - by move=&gt; *; exact: lee_abs_add.
by rewrite ge0_integralD //; [exact: lte_add_pinfty|
  exact: measurableT_comp|exact: measurableT_comp].
Qed.
Lemma integrable_sum (s : seq (T -&gt; \bar R)) :
  (forall h, h \in s -&gt; mu_int h) -&gt; mu_int (fun x =&gt; \sum_(h &lt;- s) h x).
Proof.
elim: s =&gt; [_|h s ih hs].
  by under eq_fun do rewrite big_nil; exact: integrable0.
under eq_fun do rewrite big_cons; apply: integrableD =&gt; //.
- by apply: hs; rewrite in_cons eqxx.
- by apply: ih =&gt; k ks; apply: hs; rewrite in_cons ks orbT.
Qed.
Lemma integrableB f g : mu_int f -&gt; mu_int g -&gt; mu_int (f \- g).
Proof. by move=&gt; fi gi; exact/(integrableD fi)/integrableN. Qed.
Lemma integrable_add_def f : mu_int f -&gt;
  \int[mu]_(x in D) f^\+ x +? - \int[mu]_(x in D) f^\- x.
Proof.
move=&gt; /integrableP[mf]; rewrite -[fun x =&gt; _]/(abse \o f) fune_abse =&gt; foo.
rewrite ge0_integralD // in foo; last 2 first.
- exact: measurable_funepos.
- exact: measurable_funeneg.
apply: ltpinfty_adde_def.
- by apply: le_lt_trans foo; rewrite lee_addl// integral_ge0.
- by rewrite inE (@le_lt_trans _ _ 0)// lee_oppl oppe0 integral_ge0.
Qed.
Lemma integrable_funepos f : mu_int f -&gt; mu_int f^\+.
Proof.
move=&gt; /integrableP[Df foo]; apply/integrableP; split.
  exact: measurable_funepos.
apply: le_lt_trans foo; apply: ge0_le_integral =&gt; //.
- by apply/measurableT_comp =&gt; //; exact: measurable_funepos.
- exact/measurableT_comp.
- by move=&gt; t Dt; rewrite -/((abse \o f) t) fune_abse gee0_abs// lee_addl.
Qed.
Lemma integrable_funeneg f : mu_int f -&gt; mu_int f^\-.
Proof.
move=&gt; /integrableP[Df foo]; apply/integrableP; split.
  exact: measurable_funeneg.
apply: le_lt_trans foo; apply: ge0_le_integral =&gt; //.
- by apply/measurableT_comp =&gt; //; exact: measurable_funeneg.
- exact/measurableT_comp.
- by move=&gt; t Dt; rewrite -/((abse \o f) t) fune_abse gee0_abs// lee_addr.
Qed.
Lemma integral_funeneg_lt_pinfty f : mu_int f -&gt;
  \int[mu]_(x in D) f^\- x &lt; +oo.
Proof.
move=&gt; /integrableP[mf]; apply: le_lt_trans; apply: ge0_le_integral =&gt; //.
- exact: measurable_funeneg.
- exact: measurableT_comp.
- move=&gt; x Dx; have [fx0|/ltW fx0] := leP (f x) 0.
    rewrite lee0_abs// /funeneg.
    by move: fx0; rewrite -{1}oppe0 -lee_oppr =&gt; /max_idPl -&gt;.
  rewrite gee0_abs// /funeneg.
  by move: (fx0); rewrite -{1}oppe0 -lee_oppl =&gt; /max_idPr -&gt;.
Qed.
Lemma integral_funepos_lt_pinfty f : mu_int f -&gt;
  \int[mu]_(x in D) f^\+ x &lt; +oo.
Proof.
move=&gt; /integrableP[mf]; apply: le_lt_trans; apply: ge0_le_integral =&gt; //.
- exact: measurable_funepos.
- exact: measurableT_comp.
- move=&gt; x Dx; have [fx0|/ltW fx0] := leP (f x) 0.
    rewrite lee0_abs// /funepos.
    by move: (fx0) =&gt; /max_idPr -&gt;; rewrite -lee_oppr oppe0.
  by rewrite gee0_abs// /funepos; move: (fx0) =&gt; /max_idPl -&gt;.
Qed.
Lemma integrable_neg_fin_num f :
  mu_int f -&gt; \int[mu]_(x in D) f^\- x \is a fin_num.
Proof.
move=&gt; /integrableP fi.
rewrite fin_numElt; apply/andP; split.
  by rewrite (@lt_le_trans _ _ 0) ?lte_ninfty//; exact: integral_ge0.
case: fi =&gt; mf; apply: le_lt_trans; apply: ge0_le_integral =&gt; //.
- exact/measurable_funeneg.
- exact/measurableT_comp.
- by move=&gt; x Dx; rewrite -/((abse \o f) x) (fune_abse f) lee_addr.
Qed.
Lemma integrable_pos_fin_num f :
  mu_int f -&gt; \int[mu]_(x in D) f^\+ x \is a fin_num.
Proof.
move=&gt; /integrableP fi.
rewrite fin_numElt; apply/andP; split.
  by rewrite (@lt_le_trans _ _ 0) ?lte_ninfty//; exact: integral_ge0.
case: fi =&gt; mf; apply: le_lt_trans; apply: ge0_le_integral =&gt; //.
- exact/measurable_funepos.
- exact/measurableT_comp.
- by move=&gt; x Dx; rewrite -/((abse \o f) x) (fune_abse f) lee_addl.
Qed.
End integrable_theory.
Notation "mu .-integrable" := (integrable mu) : type_scope.
Arguments eq_integrable {d T R mu D} mD f.
#[deprecated(since="mathcomp-analysis 0.6.4", note="use `integrableZl` instead")]
Notation integrablerM := integrableZl (only parsing).
#[deprecated(since="mathcomp-analysis 0.6.4", note="use `integrableZr` instead")]
Notation integrableMr := integrableZr (only parsing).
Section sequence_measure.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variable m_ : {measure set T -&gt; \bar R}^nat.
Let m := mseries m_ O.
Lemma integral_measure_series (D : set T) (mD : measurable D) (f : T -&gt; \bar R) :
  (forall n, integrable (m_ n) D f) -&gt;
  measurable_fun D f -&gt;
  \sum_(n &lt;oo) `|\int[m_ n]_(x in D) f^\- x | &lt; +oo%E -&gt;
  \sum_(n &lt;oo) `|\int[m_ n]_(x in D) f^\+ x | &lt; +oo%E -&gt;
  \int[m]_(x in D) f x = \sum_(n &lt;oo) \int[m_ n]_(x in D) f x.
Proof.
move=&gt; fi mf fmoo fpoo; rewrite integralE.
rewrite ge0_integral_measure_series//; last exact/measurable_funepos.
rewrite ge0_integral_measure_series//; last exact/measurable_funeneg.
transitivity (\sum_(n &lt;oo) (fine (\int[m_ n]_(x in D) f^\+ x))%:E -
              \sum_(n &lt;oo) (fine (\int[m_ n]_(x in D) f^\- x))%:E).
  by congr (_ - _); apply: eq_eseriesr =&gt; n _; rewrite fineK//;
    [exact: integrable_pos_fin_num|exact: integrable_neg_fin_num].
have fineKn : \sum_(n &lt;oo) `|\int[m_ n]_(x in D) f^\- x| =
          \sum_(n &lt;oo) `|(fine (\int[m_ n]_(x in D) f^\- x))%:E|.
  apply: eq_eseriesr =&gt; n _; congr abse; rewrite fineK//.
  exact: integrable_neg_fin_num.
have fineKp : \sum_(n &lt;oo) `|\int[m_ n]_(x in D) f^\+ x| =
          \sum_(n &lt;oo) `|(fine (\int[m_ n]_(x in D) f^\+ x))%:E|.
  apply: eq_eseriesr =&gt; n _; congr abse; rewrite fineK//.
  exact: integrable_pos_fin_num.
rewrite nneseries_esum; last by move=&gt; n _; exact/fine_ge0/integral_ge0.
rewrite nneseries_esum; last by move=&gt; n _; exact/fine_ge0/integral_ge0.
rewrite -esumB//; last 4 first.
  - by rewrite /= /summable -nneseries_esum// -fineKp.
  - by rewrite /summable /= -nneseries_esum// -fineKn; exact: fmoo.
  - by move=&gt; n _; exact/fine_ge0/integral_ge0.
  - by move=&gt; n _; exact/fine_ge0/integral_ge0.
rewrite -summable_eseries_esum; last first.
  apply: (@le_lt_trans _ _ (\esum_(i in (fun=&gt; true))
     `|(fine (\int[m_ i]_(x in D) f x))%:E|)).
    by apply: le_esum =&gt; k _; rewrite -EFinB -fineB// -?integralE//;
      [exact: integrable_pos_fin_num|exact: integrable_neg_fin_num].
  rewrite -nneseries_esum; last by [].
  apply: (@le_lt_trans _ _
      (\sum_(n &lt;oo) `|(fine (\int[m_ n]_(x in D) f^\+ x))%:E| +
       \sum_(n &lt;oo) `|(fine (\int[m_ n]_(x in D) f^\- x))%:E|)).
    rewrite -nneseriesD//; apply: lee_nneseries =&gt; // n _.
    rewrite integralE fineB// ?EFinB.
    - exact: (le_trans (lee_abs_sub _ _)).
    - exact: integrable_pos_fin_num.
    - exact: integrable_neg_fin_num.
  apply: lte_add_pinfty; first by rewrite -fineKp.
  by rewrite -fineKn; exact: fmoo.
by apply: eq_eseriesr =&gt; k _; rewrite !fineK// -?integralE//;
  [exact: integrable_neg_fin_num|exact: integrable_pos_fin_num].
Qed.
End sequence_measure.
Section integrable_lemmas.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType)
        (mu : {measure set T -&gt; \bar R}).
Lemma ge0_integral_bigcup (F : (set _)^nat) (f : T -&gt; \bar R) :
  (forall k, measurable (F k)) -&gt;
  let D := \bigcup_k F k in
  mu.-integrable D f -&gt;
  (forall x, D x -&gt; 0 &lt;= f x) -&gt;
  trivIset setT F -&gt;
  \int[mu]_(x in D) f x = \sum_(i &lt;oo) \int[mu]_(x in F i) f x.
Proof.
move=&gt; mF D /integrableP fi f0 tF.
pose f_ N := f \_ (\big[setU/set0]_(0 &lt;= i &lt; N) F i).
have lim_f_ t : f_ ^~ t --&gt; (f \_ D) t.
  rewrite [X in _ --&gt; X](_ : _ = ereal_sup (range (f_ ^~ t))); last first.
    apply/eqP; rewrite eq_le; apply/andP; split.
      rewrite /restrict; case: ifPn =&gt; [|_].
        rewrite in_setE =&gt; -[n _ Fnt]; apply: ereal_sup_ub; exists n.+1 =&gt; //.
        by rewrite /f_ big_mkord patchT// in_setE big_ord_recr/=; right.
      rewrite (@le_trans _ _ (f_ O t))// ?ereal_sup_ub//.
      by rewrite /f_ patchN// big_mkord big_ord0 inE/= in_set0.
    apply: ub_ereal_sup =&gt; x [n _ &lt;-].
    by rewrite /f_ restrict_lee// big_mkord; exact: bigsetU_bigcup.
  apply: ereal_nondecreasing_cvgn =&gt; a b ab.
  rewrite /f_ !big_mkord restrict_lee //; last exact: subset_bigsetU.
  by move=&gt; x Dx; apply: f0 =&gt; //; exact: bigsetU_bigcup Dx.
transitivity (\int[mu]_x lim (f_ ^~ x)).
  rewrite integral_mkcond; apply: eq_integral =&gt; x _.
  by apply/esym/cvg_lim =&gt; //; exact: lim_f_.
rewrite monotone_convergence//; last 3 first.
  - move=&gt; n; apply/(measurable_restrict f) =&gt; //.
      by apply: bigsetU_measurable =&gt; k _; exact: mF.
    case: fi =&gt; + _; apply/measurable_funS =&gt;//; first exact: bigcup_measurable.
    by rewrite big_mkord; exact: bigsetU_bigcup.
  - move=&gt; n x _; apply: erestrict_ge0 =&gt; y; rewrite big_mkord =&gt; Dy; apply: f0.
    exact: bigsetU_bigcup Dy.
  - move=&gt; x _ a b ab; apply: restrict_lee.
      by move=&gt; y; rewrite big_mkord =&gt; Dy; apply: f0; exact: bigsetU_bigcup Dy.
    by rewrite 2!big_mkord; apply: subset_bigsetU.
transitivity (lim (fun N =&gt; \int[mu]_(x in \big[setU/set0]_(i &lt; N) F i) f x)).
  congr (lim _); rewrite funeqE =&gt; n.
  by rewrite /f_ [in RHS]integral_mkcond big_mkord.
congr (lim _); rewrite funeqE =&gt; /= n; rewrite ge0_integral_bigsetU ?big_mkord//.
- case: fi =&gt; + _; apply: measurable_funS =&gt; //; first exact: bigcup_measurable.
  exact: bigsetU_bigcup.
- by move=&gt; y Dy; apply: f0; exact: bigsetU_bigcup Dy.
- exact: sub_trivIset tF.
Qed.
Lemma integrableS (E D : set T) (f : T -&gt; \bar R) :
  measurable E -&gt; measurable D -&gt; D `&lt;=` E -&gt;
  mu.-integrable E f -&gt; mu.-integrable D f.
Proof.
move=&gt; mE mD DE /integrableP[mf ifoo]; apply/integrableP; split.
  exact: measurable_funS mf.
apply: le_lt_trans ifoo; apply: subset_integral =&gt; //.
exact: measurableT_comp.
Qed.
Lemma integrable_mkcond D f : measurable D -&gt;
  mu.-integrable D f &lt;-&gt; mu.-integrable setT (f \_ D).
Proof.
move=&gt; mD.
rewrite unlock; apply: asbool_equiv; rewrite [in X in X &lt;-&gt; _]integral_mkcond.
under [in X in X &lt;-&gt; _]eq_integral do rewrite restrict_abse.
split =&gt; [|] [mf foo].
- by split; [exact/(measurable_restrict _ _ _ _).1|
             exact: le_lt_trans foo].
- by split; [exact/(measurable_restrict _ _ measurableT _).2|
             exact: le_lt_trans foo].
Qed.
End integrable_lemmas.
Arguments integrable_mkcond {d T R mu D} f.
Lemma finite_measure_integrable_cst d (T : measurableType d) (R : realType)
    (mu : {finite_measure set T -&gt; \bar R}) k :
  mu.-integrable [set: T] (EFin \o cst k).
Proof.
apply/integrableP; split; first exact/EFin_measurable_fun.
have [k0|k0] := leP 0 k.
- under eq_integral do rewrite /= ger0_norm//.
  rewrite integral_cstr//= lte_mul_pinfty// fin_num_fun_lty//.
  exact: fin_num_measure.
- under eq_integral do rewrite /= ltr0_norm//.
  rewrite integral_cstr//= lte_mul_pinfty//.
    by rewrite lee_fin ler_oppr oppr0 ltW.
  by rewrite fin_num_fun_lty//; exact: fin_num_measure.
Qed.
Section integrable_ae.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (mu : {measure set T -&gt; \bar R}) (D : set T) (mD : measurable D).
Variable f : T -&gt; \bar R.
Hypotheses fint : mu.-integrable D f.
Lemma integrable_ae : {ae mu, forall x, D x -&gt; f x \is a fin_num}.
Proof.
have [muD0|muD0] := eqVneq (mu D) 0.
  by exists D; split =&gt; // t /= /not_implyP[].
pose E := [set x | `|f x| = +oo /\ D x ].
have mE : measurable E.
  rewrite (_ : E = D `&amp;` f @^-1` [set -oo; +oo]).
    by apply: (measurable_int fint) =&gt; //; exact: measurableU.
  rewrite /E predeqE =&gt; t; split=&gt; [[/eqP]|[Dt [|]/= -&gt;//]].
  by rewrite eqe_absl leey andbT /preimage/= =&gt; /orP[|]/eqP; tauto.
have [ET|ET] := eqVneq E setT.
  have foo t : `|f t| = +oo by have [] : E t by rewrite ET.
  suff: \int[mu]_(x in D) `|f x| = +oo.
    by case: (integrableP _ _ _ fint) =&gt; _; rewrite ltey =&gt; /eqP.
  by rewrite -(integral_csty mD muD0)//; exact: eq_integral.
suff: mu E = 0.
  move=&gt; muE0; exists E; split =&gt; // t /= /not_implyP[Dt].
  by rewrite fin_num_abs =&gt; /negP; rewrite -leNgt leye_eq =&gt; /eqP.
have [-&gt;|/set0P E0] := eqVneq E set0; first by rewrite measure0.
have [M M0 muM] : exists2 M, (0 &lt;= M)%R &amp;
    forall n, n%:R%:E * mu (E `&amp;` D) &lt;= M%:E.
  exists (fine (\int[mu]_(x in D) `|f x|)); first exact/fine_ge0/integral_ge0.
  move=&gt; n; rewrite -integral_indic// -ge0_integralZl//; last 2 first.
    - exact: measurableT_comp.
    - by move=&gt; *; rewrite lee_fin.
  rewrite fineK//; last first.
    case: (integrableP _ _ _ fint) =&gt; _ foo.
    by rewrite ge0_fin_numE// integral_ge0.
  apply: ge0_le_integral =&gt; //.
  - by move=&gt; *; rewrite lee_fin /indic.
  - exact/EFin_measurable_fun/measurableT_comp.
  - by apply: measurableT_comp =&gt; //; apply: measurable_int fint.
  - move=&gt; x Dx; rewrite /= indicE.
    have [|xE] := boolP (x \in E); last by rewrite mule0.
    by rewrite /E inE /= =&gt; -[-&gt;]; rewrite leey.
apply/eqP/negPn/negP =&gt; /eqP muED0; move/not_forallP : muM; apply.
have [muEDoo|] := ltP (mu (E `&amp;` D)) +oo; last first.
  by rewrite leye_eq =&gt; /eqP -&gt;; exists 1%N; rewrite mul1e leye_eq.
exists `|ceil (M * (fine (mu (E `&amp;` D)))^-1)|%N.+1.
apply/negP; rewrite -ltNge.
rewrite -[X in _ * X](@fineK _ (mu (E `&amp;` D))); last first.
  by rewrite fin_numElt muEDoo (lt_le_trans _ (measure_ge0 _ _)).
rewrite lte_fin -ltr_pdivr_mulr.
  rewrite -natr1 natr_absz ger0_norm.
    by rewrite (le_lt_trans (ceil_ge _))// ltr_addl.
  by rewrite ceil_ge0// divr_ge0//; apply/le0R/measure_ge0; exact: measurableI.
rewrite -lte_fin fineK.
  rewrite lt0e measure_ge0 andbT.
  suff: E `&amp;` D = E by move=&gt; -&gt;; exact/eqP.
  by rewrite predeqE =&gt; t; split=&gt; -[].
by rewrite ge0_fin_numE// measure_ge0//; exact: measurableI.
Qed.
End integrable_ae.
Section linearity.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (mu : {measure set T -&gt; \bar R}) (D : set T) (mD : measurable D).
Variable (f : T -&gt; \bar R).
Hypothesis intf : mu.-integrable D f.
Let mesf : measurable_fun D f. Proof. exact: measurable_int intf. Qed.
Lemma integralZl r :
  \int[mu]_(x in D) (r%:E * f x) = r%:E * \int[mu]_(x in D) f x.
Proof.
have [r0|r0|-&gt;] := ltgtP r 0%R; last first.
  by under eq_fun do rewrite mul0e; rewrite mul0e integral0.
- rewrite [in LHS]integralE// gt0_funeposM// gt0_funenegM//.
  rewrite (ge0_integralZl_EFin _ _ _ _ (ltW r0)) //; last first.
    exact: measurable_funepos.
  rewrite (ge0_integralZl_EFin _ _ _ _ (ltW r0)) //; last first.
    exact: measurable_funeneg.
  rewrite -muleBr 1?[in RHS]integralE//.
  exact: integrable_add_def.
- rewrite [in LHS]integralE// lt0_funeposM// lt0_funenegM//.
  rewrite ge0_integralZl_EFin //; last 2 first.
    + exact: measurable_funeneg.
    + by rewrite -ler_oppr oppr0 ltW.
  rewrite ge0_integralZl_EFin //; last 2 first.
    + exact: measurable_funepos.
    + by rewrite -ler_oppr oppr0 ltW.
  rewrite -mulNe -EFinN opprK addeC EFinN mulNe -muleBr //; last first.
    exact: integrable_add_def.
  by rewrite [in RHS]integralE.
Qed.
End linearity.
#[deprecated(since="mathcomp-analysis 0.6.4", note="use `integralZl` instead")]
Notation integralM := integralZl (only parsing).
Section linearity.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (mu : {measure set T -&gt; \bar R}) (D : set T) (mD : measurable D).
Variables f1 f2 : T -&gt; R.
Let g1 := EFin \o f1.
Let g2 := EFin \o f2.
Hypothesis if1 : mu.-integrable D g1.
Hypothesis if2 : mu.-integrable D g2.
Let mf1 : measurable_fun D g1. Proof. exact: measurable_int if1. Qed.
Let mf2 : measurable_fun D g2. Proof. exact: measurable_int if2. Qed.
Lemma integralD_EFin :
  \int[mu]_(x in D) (g1 \+ g2) x =
  \int[mu]_(x in D) g1 x + \int[mu]_(x in D) g2 x.
Proof.
suff: \int[mu]_(x in D) ((g1 \+ g2)^\+ x) + \int[mu]_(x in D) (g1^\- x) +
        \int[mu]_(x in D) (g2^\- x) =
      \int[mu]_(x in D) ((g1 \+ g2)^\- x) + \int[mu]_(x in D) (g1^\+ x) +
        \int[mu]_(x in D) (g2^\+ x).
  move=&gt; h; rewrite [in LHS]integralE.
  move/eqP : h; rewrite -[in eqRHS]addeA [in eqRHS]addeC.
  have g12pos :
      \int[mu]_(x in D) (g1^\+ x) + \int[mu]_(x in D) (g2^\+ x) \is a fin_num.
    rewrite ge0_fin_numE//.
      by rewrite lte_add_pinfty//; exact: integral_funepos_lt_pinfty.
    by rewrite adde_ge0// integral_ge0.
  have g12neg :
      \int[mu]_(x in D) (g1^\- x) + \int[mu]_(x in D) (g2^\- x) \is a fin_num.
    rewrite ge0_fin_numE//.
      by rewrite lte_add_pinfty// ; exact: integral_funeneg_lt_pinfty.
    by apply: adde_ge0; exact: integral_ge0.
  rewrite -sube_eq; last 2 first.
    - rewrite ge0_fin_numE.
        apply: lte_add_pinfty; last exact: integral_funeneg_lt_pinfty.
        apply: lte_add_pinfty; last exact: integral_funeneg_lt_pinfty.
        exact: integral_funepos_lt_pinfty (integrableD _ _ _).
      rewrite adde_ge0//; last exact: integral_ge0.
      by apply: adde_ge0; exact: integral_ge0.
    - by rewrite fin_num_adde_defr.
  rewrite -(addeA (\int[mu]_(x in D) (g1 \+ g2)^\+ x)).
  rewrite (addeC (\int[mu]_(x in D) (g1 \+ g2)^\+ x)).
  rewrite -addeA (addeC (\int[mu]_(x in D) g1^\- x + \int[mu]_(x in D) g2^\- x)).
  rewrite eq_sym -(sube_eq g12pos) ?fin_num_adde_defl// =&gt; /eqP &lt;-.
  rewrite fin_num_oppeD; last first.
    rewrite ge0_fin_numE; first exact: integral_funeneg_lt_pinfty if2.
    exact: integral_ge0.
  rewrite -addeA (addeCA (\int[mu]_(x in D) (g2^\+ x) )).
  by rewrite addeA -(integralE _ _ g1) -(integralE _ _ g2).
have : (g1 \+ g2)^\+ \+ g1^\- \+ g2^\- = (g1 \+ g2)^\- \+ g1^\+ \+ g2^\+.
  rewrite funeqE =&gt; x.
  apply/eqP; rewrite -2!addeA [in eqRHS]addeC -sube_eq; last 2 first.
    by rewrite /funepos /funeneg -!fine_max.
    by rewrite /funepos /funeneg -!fine_max.
  rewrite addeAC eq_sym -sube_eq; last 2 first.
    by rewrite /funepos /funeneg -!fine_max.
    by rewrite /funepos /funeneg -!fine_max.
  apply/eqP.
  rewrite -[LHS]/((g1^\+ \+ g2^\+ \- (g1^\- \+ g2^\-)) x) -funeD_posD.
  by rewrite -[RHS]/((_ \- _) x) -funeD_Dpos.
move/(congr1 (fun y =&gt; \int[mu]_(x in D) (y x) )).
rewrite (ge0_integralD mu mD); last 4 first.
  - by move=&gt; x _; rewrite adde_ge0.
  - apply: emeasurable_funD; last exact: measurable_funeneg.
    exact/measurable_funepos/emeasurable_funD.
  - by [].
  - exact: measurable_funeneg.
rewrite (ge0_integralD mu mD); last 4 first.
  - by [].
  - exact/measurable_funepos/emeasurable_funD.
  - by [].
  - exact/measurable_funepos/measurableT_comp.
move=&gt; -&gt;.
rewrite (ge0_integralD mu mD); last 4 first.
  - by move=&gt; x _; exact: adde_ge0.
  - apply: emeasurable_funD; last exact: measurable_funepos.
    exact/measurable_funeneg/emeasurable_funD.
  - by [].
  - exact: measurable_funepos.
rewrite (ge0_integralD mu mD) //; last exact: measurable_funepos.
exact/measurable_funeneg/emeasurable_funD.
Qed.
End linearity.
Lemma integralB_EFin d (T : measurableType d) (R : realType)
  (mu : {measure set T -&gt; \bar R}) (D : set T) (f1 f2 : T -&gt; R)
  (mD : measurable D) :
  mu.-integrable D (EFin \o f1) -&gt; mu.-integrable D (EFin \o f2) -&gt;
  (\int[mu]_(x in D) ((f1 x)%:E - (f2 x)%:E) =
    (\int[mu]_(x in D) (f1 x)%:E - \int[mu]_(x in D) (f2 x)%:E))%E.
Proof.
move=&gt; if1 if2; rewrite (integralD_EFin mD if1); last first.
  by rewrite (_ : _ \o _ = (fun x =&gt; - (f2 x)%:E))%E; [exact: integrableN|by []].
by rewrite -integralN//; exact: integrable_add_def.
Qed.
Lemma le_abse_integral d (T : measurableType d) (R : realType)
  (mu : {measure set T -&gt; \bar R}) (D : set T) (f : T -&gt; \bar R)
  (mD : measurable D) : measurable_fun D f -&gt;
  (`| \int[mu]_(x in D) (f x) | &lt;= \int[mu]_(x in D) `|f x|)%E.
Proof.
move=&gt; mf.
rewrite integralE (le_trans (lee_abs_sub _ _))// gee0_abs; last first.
  exact: integral_ge0.
rewrite gee0_abs; last exact: integral_ge0.
by rewrite -ge0_integralD // -?fune_abse//;
  [exact: measurable_funepos | exact: measurable_funeneg].
Qed.
Lemma abse_integralP d (T : measurableType d) (R : realType)
    (mu : {measure set T -&gt; \bar R}) (D : set T) (f : T -&gt; \bar R) :
    measurable D -&gt; measurable_fun D f -&gt;
  (`| \int[mu]_(x in D) f x | &lt; +oo &lt;-&gt; \int[mu]_(x in D) `|f x| &lt; +oo)%E.
Proof.
move=&gt; mD mf; split =&gt; [|] foo; last first.
  exact: (le_lt_trans (le_abse_integral mu mD mf) foo).
under eq_integral do rewrite -/((abse \o f) _) fune_abse.
rewrite ge0_integralD//;[|exact/measurable_funepos|exact/measurable_funeneg].
move: foo; rewrite integralE/= -fin_num_abs fin_numB =&gt; /andP[fpoo fnoo].
by rewrite lte_add_pinfty// ltey_eq ?fpoo ?fnoo.
Qed.
Section integral_indic.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType)
        (mu : {measure set T -&gt; \bar R}).
Lemma integral_setI_indic (E D : set T) (mD : measurable D) (f : T -&gt; \bar R) :
  measurable E -&gt;
  \int[mu]_(x in E `&amp;` D) f x = \int[mu]_(x in E) (f x * (\1_D x)%:E).
Proof.
move=&gt; mE; rewrite integral_mkcondr; apply: eq_integral =&gt; x xE.
by rewrite indic_restrict /patch; case: ifPn; rewrite ?mule1 ?mule0.
Qed.
Lemma integralEindic (D : set T) (mD : measurable D) (f : T -&gt; \bar R) :
  \int[mu]_(x in D) f x = \int[mu]_(x in D) (f x * (\1_D x)%:E).
Proof. by rewrite -integral_setI_indic// setIid. Qed.
End integral_indic.
Section ae_eq.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (mu : {measure set T -&gt; \bar R}) (D : set T).
Implicit Types f g h i : T -&gt; \bar R.
Definition ae_eq f g := {ae mu, forall x, D x -&gt; f x = g x}.
Lemma ae_eq0 f g : measurable D -&gt; mu D = 0 -&gt; ae_eq f g.
Proof. by move=&gt; mD D0; exists D; split =&gt; // t/= /not_implyP[]. Qed.
Lemma ae_eq_comp (j : \bar R -&gt; \bar R) f g :
  ae_eq f g -&gt; ae_eq (j \o f) (j \o g).
Proof. by apply: filterS =&gt; x /[apply] /= -&gt;. Qed.
Lemma ae_eq_funeposneg f g : ae_eq f g &lt;-&gt; ae_eq f^\+ g^\+ /\ ae_eq f^\- g^\-.
Proof.
split=&gt; [fg|[]].
  by rewrite /funepos /funeneg; split; apply: filterS fg =&gt; x /[apply] -&gt;.
apply: filterS2 =&gt; x + + Dx =&gt; /(_ Dx) fg /(_ Dx) gf.
by rewrite (funeposneg f) (funeposneg g) fg gf.
Qed.
Lemma ae_eq_refl f : ae_eq f f. Proof. exact/aeW. Qed.
Lemma ae_eq_sym f g : ae_eq f g -&gt; ae_eq g f.
Proof. by apply: filterS =&gt; x + Dx =&gt; /(_ Dx). Qed.
Lemma ae_eq_trans f g h : ae_eq f g -&gt; ae_eq g h -&gt; ae_eq f h.
Proof. by apply: filterS2 =&gt; x + + Dx =&gt; /(_ Dx) -&gt;; exact. Qed.
Lemma ae_eq_sub f g h i : ae_eq f g -&gt; ae_eq h i -&gt; ae_eq (f \- h) (g \- i).
Proof. by apply: filterS2 =&gt; x + + Dx =&gt; /(_ Dx) -&gt; /(_ Dx) -&gt;. Qed.
Lemma ae_eq_mul2r f g h : ae_eq f g -&gt; ae_eq (f \* h) (g \* h).
Proof. by apply: filterS =&gt; x /[apply] -&gt;. Qed.
Lemma ae_eq_mul2l f g h : ae_eq f g -&gt; ae_eq (h \* f) (h \* g).
Proof. by apply: filterS =&gt; x /[apply] -&gt;. Qed.
Lemma ae_eq_mul1l f g : ae_eq f (cst 1) -&gt; ae_eq g (g \* f).
Proof. by apply: filterS =&gt; x /[apply] -&gt;; rewrite mule1. Qed.
Lemma ae_eq_abse f g : ae_eq f g -&gt; ae_eq (abse \o f) (abse \o g).
Proof. by apply: filterS =&gt; x /[apply] /= -&gt;. Qed.
End ae_eq.
Section ae_eq_integral.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType)
        (mu : {measure set T -&gt; \bar R}).
Local Notation ae_eq := (ae_eq mu).
Let ae_eq_integral_abs_bounded (D : set T) (mD : measurable D) (f : T -&gt; \bar R)
    M : measurable_fun D f -&gt; (forall x, D x -&gt; `|f x| &lt;= M%:E) -&gt;
  ae_eq D f (cst 0) -&gt; \int[mu]_(x in D) `|f x|%E  = 0.
Proof.
move=&gt; mf fM [N [mA mN0 Df0N]].
pose Df_neq0 := D `&amp;` [set x | f x != 0].
have mDf_neq0 : measurable Df_neq0 by exact: emeasurable_neq.
pose f' : T -&gt; R := indic Df_neq0.
have le_f_M t : D t -&gt; `|f t| &lt;= M%:E * (f' t)%:E.
  move=&gt; Dt; rewrite /f' indicE; have [|] := boolP (t \in Df_neq0).
    by rewrite inE =&gt; -[_ _]; rewrite mule1 fM.
  by rewrite notin_set=&gt; /not_andP[//|/negP/negPn/eqP -&gt;]; rewrite abse0 mule0.
have : 0 &lt;= \int[mu]_(x in D) `|f x|  &lt;= `|M|%:E * mu Df_neq0.
  rewrite integral_ge0//= /Df_neq0 -{2}(setIid D) setIAC -integral_indic//.
  rewrite -/Df_neq0 -ge0_integralZl//; last 2 first.
    - exact: measurableT_comp.
    - by move=&gt; x ?; rewrite lee_fin.
  apply: ge0_le_integral =&gt; //.
  - exact: measurableT_comp.
  - by move=&gt; x Dx; rewrite mule_ge0// lee_fin.
  - by apply: emeasurable_funM =&gt; //; exact: measurableT_comp.
  - move=&gt; x Dx.
    rewrite (le_trans (le_f_M _ Dx))// lee_fin /f' indicE.
    by case: (_ \in _) =&gt; //; rewrite ?mulr1 ?mulr0// ler_norm.
have -&gt; : mu Df_neq0 = 0.
  apply: (subset_measure0 _ _ _ mN0) =&gt; //.
  apply: subset_trans Df0N =&gt; /= x [/= f0 Dx] /=.
  by apply/not_implyP; split =&gt; //; exact/eqP.
by rewrite mule0 -eq_le =&gt; /eqP.
Qed.
Lemma ae_eq_integral_abs (D : set T) (mD : measurable D) (f : T -&gt; \bar R) :
  measurable_fun D f -&gt; \int[mu]_(x in D) `|f x|  = 0 &lt;-&gt; ae_eq D f (cst 0).
Proof.
move=&gt; mf; split=&gt; [iDf0|Df0].
  exists (D `&amp;` [set x | f x != 0]); split;
    [exact: emeasurable_neq| |by move=&gt; t /= /not_implyP [Dt /eqP ft0]].
  have muDf a : (0 &lt; a)%R -&gt; mu (D `&amp;` [set x | a%:E &lt;= `|f x|]) = 0.
    move=&gt; a0; apply/eqP; rewrite -measure_le0.
    by have := le_integral_abse mu mD mf a0; rewrite iDf0 pmule_rle0 ?lte_fin.
  rewrite [X in mu X](_ : _ =
     \bigcup_n (D `&amp;` [set x | `|f x| &gt;= n.+1%:R^-1%:E])); last first.
    rewrite predeqE =&gt; t; split=&gt; [[Dt ft0]|[n _ /= [Dt nft]]].
      have [ftoo|ftoo] := eqVneq `|f t| +oo.
        by exists 0%N =&gt; //; split =&gt; //=; rewrite ftoo /= leey.
      pose m := `|ceil (fine `|f t|)^-1|%N.
      have ftfin : `|f t|%E \is a fin_num by rewrite ge0_fin_numE// ltey.
      exists m =&gt; //; split =&gt; //=.
      rewrite -(@fineK _ `|f t|) // lee_fin -ler_pinv; last 2 first.
        - rewrite inE unitfE fine_eq0// abse_eq0 ft0/= fine_gt0//.
          by rewrite lt0e abse_ge0 abse_eq0 ft0 ltey.
        - by rewrite inE unitfE invr_eq0 pnatr_eq0 /= invr_gt0.
      rewrite invrK /m -natr1 natr_absz ger0_norm ?ceil_ge0//.
      rewrite (@le_trans _ _ ((fine `|f t|)^-1 + 1)%R) ?ler_addl//.
      by rewrite ler_add2r// ceil_ge.
    by split =&gt; //; apply: contraTN nft =&gt; /eqP -&gt;; rewrite abse0 -ltNge.
  transitivity (lim (fun n =&gt; mu (D `&amp;` [set x | `|f x| &gt;= n.+1%:R^-1%:E]))).
    apply/esym/cvg_lim =&gt; //; apply: nondecreasing_cvg_mu.
    - move=&gt; i; apply: emeasurable_fun_c_infty =&gt; //.
      exact: measurableT_comp.
    - apply: bigcupT_measurable =&gt; i.
      by apply: emeasurable_fun_c_infty =&gt; //; exact: measurableT_comp.
    - move=&gt; m n mn; apply/subsetPset; apply: setIS =&gt; t /=.
      by apply: le_trans; rewrite lee_fin lef_pinv // ?ler_nat // posrE.
  by rewrite (_ : (fun _ =&gt; _) = cst 0) ?lim_cst//= funeqE =&gt; n /=; rewrite muDf.
pose f_ := fun n x =&gt; mine `|f x| n%:R%:E.
have -&gt; : (fun x =&gt; `|f x|) = (fun x =&gt; lim (f_^~ x)).
  rewrite funeqE =&gt; x; apply/esym/cvg_lim =&gt; //; apply/cvg_ballP =&gt; _/posnumP[e].
  near=&gt; n; rewrite /ball /= /ereal_ball /= /f_.
  have [-&gt;|fxoo] := eqVneq `|f x|%E +oo.
    rewrite -[contract +oo](@divrr _ (1 + n%:R)%R) ?unitfE ?nat1r//=.
    rewrite (@ger0_norm _ n%:R)// nat1r -mulrBl -natrB// subSnn ger0_norm//.
    by rewrite div1r; near: n; exact: near_infty_natSinv_lt.
  have fxn : `|f x| &lt;= n%:R%:E.
    rewrite -(@fineK _ `|f x|); last by rewrite ge0_fin_numE// ltey.
    rewrite lee_fin; near: n; exists (Num.bound (fine `|f x|)) =&gt; //= n/=.
    by rewrite -(ler_nat R); apply: le_trans; exact/ltW/archi_boundP.
  by rewrite min_l// subrr normr0.
transitivity (lim (fun n =&gt; \int[mu]_(x in D) (f_ n x) )).
  apply/esym/cvg_lim =&gt; //; apply: cvg_monotone_convergence =&gt; //.
  - by move=&gt; n; apply: measurable_mine =&gt; //; exact: measurableT_comp.
  - by move=&gt; n t Dt; rewrite /f_ lexI abse_ge0 //= lee_fin.
  - move=&gt; t Dt m n mn; rewrite /f_ lexI.
    have [ftm|ftm] := leP `|f t|%E m%:R%:E.
      by rewrite lexx /= (le_trans ftm)// lee_fin ler_nat.
    by rewrite (ltW ftm) /= lee_fin ler_nat.
have ae_eq_f_ n : ae_eq D (f_ n) (cst 0).
  case: Df0 =&gt; N [mN muN0 DfN].
  exists N; split =&gt; // t /= /not_implyP[Dt fnt0].
  apply: DfN =&gt; /=; apply/not_implyP; split =&gt; //.
  apply: contra_not fnt0 =&gt; ft0.
  by rewrite /f_ ft0 /= normr0 min_l// lee_fin.
have f_bounded n x : D x -&gt; `|f_ n x| &lt;= n%:R%:E.
  move=&gt; Dx; rewrite /f_; have [|_] := leP `|f x| n%:R%:E.
    by rewrite abse_id.
  by rewrite gee0_abs// lee_fin.
have if_0 n : \int[mu]_(x in D) `|f_ n x|  = 0.
  apply: (@ae_eq_integral_abs_bounded _ _ _ n%:R) =&gt; //.
    by apply: measurable_mine =&gt; //; exact: measurableT_comp.
  exact: f_bounded.
rewrite (_ : (fun _ =&gt; _) = cst 0) // ?lim_cst// funeqE =&gt; n.
by rewrite -(if_0 n); apply: eq_integral =&gt; x _; rewrite gee0_abs// /f_.
Unshelve. all: by end_near. Qed.
Lemma integral_abs_eq0 D (N : set T) (f : T -&gt; \bar R) :
  measurable N -&gt; measurable D -&gt; N `&lt;=` D -&gt; measurable_fun D f -&gt;
  mu N = 0 -&gt; \int[mu]_(x in N) `|f x| = 0.
Proof.
move=&gt; mN mD ND mf muN0; rewrite integralEindic//.
rewrite (eq_integral (fun x =&gt; `|f x * (\1_N x)%:E|)); last first.
  by move=&gt; t _; rewrite abseM (@gee0_abs _ (\1_N t)%:E)// lee_fin.
apply/ae_eq_integral_abs =&gt; //.
  apply: emeasurable_funM =&gt; //; first exact: (measurable_funS mD).
  exact/EFin_measurable_fun.
exists N; split =&gt; // t /= /not_implyP[_]; rewrite indicE.
by have [|] := boolP (t \in N); rewrite ?inE ?mule0.
Qed.
Lemma funID (N : set T) (mN : measurable N) (f : T -&gt; \bar R) :
  let oneCN := [the {nnsfun T &gt;-&gt; R} of mindic R (measurableC mN)] in
  let oneN := [the {nnsfun T &gt;-&gt; R} of mindic R mN] in
  f = (fun x =&gt; f x * (oneCN x)%:E) \+ (fun x =&gt; f x * (oneN x)%:E).
Proof.
move=&gt; oneCN oneN; rewrite funeqE =&gt; x.
rewrite /oneCN /oneN/= /mindic !indicE.
have [xN|xN] := boolP (x \in N).
  by rewrite mule1 in_setC xN mule0 add0e.
by rewrite in_setC xN mule0 adde0 mule1.
Qed.
Lemma negligible_integrable (D N : set T) (f : T -&gt; \bar R) :
  measurable N -&gt; measurable D -&gt; measurable_fun D f -&gt;
  mu N = 0 -&gt; mu.-integrable D f &lt;-&gt; mu.-integrable (D `\` N) f.
Proof.
move=&gt; mN mD mf muN0.
pose mCN := measurableC mN.
pose oneCN : {nnsfun T &gt;-&gt; R} := [the {nnsfun T &gt;-&gt; R} of mindic R mCN].
pose oneN : {nnsfun T &gt;-&gt; R} := [the {nnsfun T &gt;-&gt; R} of mindic R mN].
have /integrableP intone : mu.-integrable D (fun x =&gt; f x * (oneN x)%:E).
  apply/integrableP; split.
    apply: emeasurable_funM=&gt; //; apply/EFin_measurable_fun.
    exact: measurable_funTS.
  rewrite (eq_integral (fun x =&gt; `|f x| * (\1_N x)%:E)); last first.
    by move=&gt; t _; rewrite abseM (@gee0_abs _ (\1_N t)%:E) // lee_fin.
  rewrite -integral_setI_indic// (@integral_abs_eq0 D)//.
  - exact: measurableI.
  - by apply: (subset_measure0 _ _ _ muN0) =&gt; //; exact: measurableI.
have h1 : mu.-integrable D f &lt;-&gt; mu.-integrable D (fun x =&gt; f x * (oneCN x)%:E).
  split=&gt; [/integrableP intf | /integrableP intCf].
    apply/integrableP; split.
      apply: emeasurable_funM=&gt; //; apply/EFin_measurable_fun =&gt; //.
      exact: measurable_funTS.
    rewrite (eq_integral (fun x =&gt; `|f x| * (\1_(~` N) x)%:E)); last first.
      by move=&gt; t _; rewrite abseM (@gee0_abs _ (\1_(~` N) t)%:E) // lee_fin.
    rewrite -integral_setI_indic//; case: intf =&gt; _; apply: le_lt_trans.
    by apply: subset_integral =&gt; //; [exact:measurableI|exact:measurableT_comp].
  apply/integrableP; split =&gt; //; rewrite (funID mN f) -/oneCN -/oneN.
  have ? : measurable_fun D (fun x : T =&gt; f x * (oneCN x)%:E).
    by apply: emeasurable_funM=&gt; //; exact/EFin_measurable_fun/measurable_funTS.
  have ? : measurable_fun D (fun x : T =&gt; f x * (oneN x)%:E).
    apply: emeasurable_funM =&gt; //.
    exact/EFin_measurable_fun/measurable_funTS.
  apply: (@le_lt_trans _ _
    (\int[mu]_(x in D) (`|f x * (oneCN x)%:E| + `|f x * (oneN x)%:E|))).
    apply: ge0_le_integral =&gt; //.
    - by apply: measurableT_comp =&gt; //; exact: emeasurable_funD.
    - by apply: emeasurable_funD; exact: measurableT_comp.
    - by move=&gt; *; rewrite lee_abs_add.
  rewrite ge0_integralD//; [|exact: measurableT_comp|exact: measurableT_comp].
  by apply: lte_add_pinfty; [case: intCf|case: intone].
have h2 : mu.-integrable (D `\` N) f &lt;-&gt;
    mu.-integrable D (fun x =&gt; f x * (oneCN x)%:E).
  split=&gt; [/integrableP intCf | /integrableP intCf]; apply/integrableP.
    split.
      apply: emeasurable_funM=&gt; //; apply/EFin_measurable_fun =&gt; //.
      exact: measurable_funTS.
    rewrite (eq_integral (fun x =&gt; `|f x| * (\1_(~` N) x)%:E)); last first.
      by move=&gt; t _; rewrite abseM (@gee0_abs _ (\1_(~` N) t)%:E)// lee_fin.
    rewrite -integral_setI_indic //; case: intCf =&gt; _; apply: le_lt_trans.
    apply: subset_integral =&gt; //; [exact: measurableI|exact: measurableD|].
    by apply: measurableT_comp =&gt; //; apply: measurable_funS mf =&gt; // ? [].
  split.
    move=&gt; mDN A mA; rewrite setDE (setIC D) -setIA; apply: measurableI =&gt; //.
    exact: mf.
  rewrite integral_setI_indic//.
  case: intCf =&gt; _; rewrite (eq_integral (fun x =&gt; `|f x| * (\1_(~` N) x)%:E))//.
  by move=&gt; t _; rewrite abseM (@gee0_abs _ (\1_(~` N) t)%:E)// lee_fin.
by apply: (iff_trans h1); exact: iff_sym.
Qed.
Lemma ge0_negligible_integral (D N : set T) (f : T -&gt; \bar R) :
  measurable N -&gt; measurable D -&gt; measurable_fun D f -&gt;
  (forall x, D x -&gt; 0 &lt;= f x) -&gt;
  mu N = 0 -&gt; \int[mu]_(x in D) f x = \int[mu]_(x in D `\` N) f x.
Proof.
move=&gt; mN mD mf f0 muN0.
rewrite {1}(funID mN f) ge0_integralD//; last 4 first.
  - by move=&gt; x Dx; apply: mule_ge0 =&gt; //; [exact: f0|rewrite lee_fin].
  - apply: emeasurable_funM=&gt; //; apply/EFin_measurable_fun=&gt; //.
    exact: measurable_funTS.
  - by move=&gt; x Dx; apply: mule_ge0 =&gt; //; [exact: f0|rewrite lee_fin].
  - apply: emeasurable_funM=&gt; //; apply/EFin_measurable_fun=&gt; //.
    exact: measurable_funTS.
rewrite -integral_setI_indic//; last exact: measurableC.
rewrite -integral_setI_indic// [X in _ + X = _](_ : _ = 0) ?adde0//.
rewrite (eq_integral (abse \o f)); last first.
  move=&gt; x; rewrite in_setI =&gt; /andP[xD xN].
  by rewrite /= gee0_abs// f0//; rewrite inE in xD.
rewrite (@integral_abs_eq0 D)//; first exact: measurableI.
by apply: (subset_measure0 _ _ _ muN0) =&gt; //; exact: measurableI.
Qed.
Lemma ge0_ae_eq_integral (D : set T) (f g : T -&gt; \bar R) :
  measurable D -&gt; measurable_fun D f -&gt; measurable_fun D g -&gt;
  (forall x, D x -&gt; 0 &lt;= f x) -&gt; (forall x, D x -&gt; 0 &lt;= g x) -&gt;
  ae_eq D f g -&gt; \int[mu]_(x in D) (f x)  = \int[mu]_(x in D) (g x).
Proof.
move=&gt; mD mf mg f0 g0 [N [mN N0 subN]].
rewrite integralEindic// [RHS]integralEindic//.
rewrite (ge0_negligible_integral mN)//; last 2 first.
  - by apply: emeasurable_funM =&gt; //; exact/EFin_measurable_fun.
  - by move=&gt; x Dx; apply: mule_ge0 =&gt; //; [exact: f0|rewrite lee_fin].
rewrite [RHS](ge0_negligible_integral mN)//; last 2 first.
  - by apply: emeasurable_funM =&gt; //; exact/EFin_measurable_fun.
  - by move=&gt; x Dx; apply: mule_ge0 =&gt; //; [exact: g0|rewrite lee_fin].
- apply: eq_integral =&gt; x;rewrite in_setD =&gt; /andP[_ xN].
  apply: contrapT; rewrite indicE; have [|?] := boolP (x \in D).
    rewrite inE =&gt; Dx; rewrite !mule1.
    move: xN; rewrite notin_set; apply: contra_not =&gt; fxgx; apply: subN =&gt; /=.
    exact/not_implyP.
  by rewrite !mule0.
Qed.
Lemma ae_eq_integral (D : set T) (g f : T -&gt; \bar R) :
  measurable D -&gt; measurable_fun D f -&gt; measurable_fun D g -&gt;
  ae_eq D f g -&gt; integral mu D f = integral mu D g.
Proof.
move=&gt; mD mf mg /ae_eq_funeposneg[Dfgp Dfgn].
rewrite integralE// [in RHS]integralE//; congr (_ - _).
  by apply: ge0_ae_eq_integral =&gt; //; [exact: measurable_funepos|
                                       exact: measurable_funepos].
by apply: ge0_ae_eq_integral =&gt; //; [exact: measurable_funeneg|
                                     exact: measurable_funeneg].
Qed.
End ae_eq_integral.
Arguments ae_eq_integral {d T R mu D} g.
Local Open Scope ereal_scope.
Lemma integral_cst d (T : measurableType d) (R : realType)
    (mu : {measure set T -&gt; \bar R}) (D : set T) : d.-measurable D -&gt;
  forall r, \int[mu]_(x in D) (cst r) x = r * mu D.
Proof.
move=&gt; mD; have [D0 r|D0 [r| |]] := eqVneq (mu D) 0.
  by rewrite (ae_eq_integral (cst 0))// ?integral0 ?D0 ?mule0//; exact: ae_eq0.
- by rewrite integral_cstr.
- by rewrite integral_csty// gt0_mulye// lt0e D0/=.
- by rewrite integral_cstNy// gt0_mulNye// lt0e D0/=.
Qed.
Add Search Blacklist "integral_cstr" "integral_csty" "integral_cstNy".
Lemma le_integral_comp_abse d (T : measurableType d) (R : realType)
    (mu : {measure set T -&gt; \bar R})  (D : set T) (mD : measurable D)
    (g : T -&gt; \bar R) a (f : \bar R -&gt; \bar R) (mf : measurable_fun setT f)
    (f0 : forall r, 0 &lt;= r -&gt; 0 &lt;= f r)
    (f_nd : {in `[0, +oo[%classic &amp;, {homo f : x y / x &lt;= y}}) :
  measurable_fun D g -&gt; (0 &lt; a)%R -&gt;
  (f a%:E) * mu (D `&amp;` [set x | (`|g x| &gt;= a%:E)%E]) &lt;= \int[mu]_(x in D) f `|g x|.
Proof.
move=&gt; mg a0; have ? : measurable (D `&amp;` [set x | (a%:E &lt;= `|g x|)%E]).
  by apply: emeasurable_fun_c_infty =&gt; //; exact: measurableT_comp.
apply: (@le_trans _ _ (\int[mu]_(x in D `&amp;` [set x | `|g x| &gt;= a%:E]) f `|g x|)).
  rewrite -integral_cst//; apply: ge0_le_integral =&gt; //.
  - by move=&gt; x _ /=; rewrite f0 // lee_fin ltW.
  - by move=&gt; x _ /=; rewrite f0.
  - apply: measurableT_comp =&gt; //; apply: measurableT_comp =&gt; //.
    exact: measurable_funS mg.
  - by move=&gt; x /= [Dx]; apply: f_nd;
      rewrite inE /= in_itv /= andbT// lee_fin ltW.
apply: subset_integral =&gt; //; last by move=&gt; x _ /=; rewrite f0.
by apply: measurableT_comp =&gt; //; exact: measurableT_comp.
Qed.
Local Close Scope ereal_scope.
Section ae_measurable_fun.
Context d (T : measurableType d) (R : realType)
        (mu : {measure set T -&gt; \bar R}).
Hypothesis cmu : measure_is_complete mu.
Variables (D : set T) (f g : T -&gt; \bar R).
Lemma ae_measurable_fun : ae_eq mu D f g -&gt;
  measurable_fun D f -&gt; measurable_fun D g.
Proof.
move=&gt; [N [mN N0 subN]] mf B mB mD.
apply: (measurability (ErealGenOInfty.measurableE R)) =&gt; // _ [_ [x -&gt;] &lt;-].
rewrite [X in measurable X](_ : _ = D `&amp;` ~` N `&amp;` (f @^-1` `]x%:E, +oo[)
    `|` (D `&amp;` N `&amp;` g @^-1` `]x%:E, +oo[)); last first.
  apply/seteqP; split=&gt; [y /= [Dy gyxoo]|y /= [[[Dy Ny] fyxoo]|]].
  - have [-&gt;|fgy] := eqVneq (f y) (g y).
      have [yN|yN] := boolP (y \in N).
        by right; split =&gt; //; rewrite inE in yN.
      by left; split =&gt; //; rewrite notin_set in yN.
    by right; split =&gt; //; split =&gt; //; apply: subN =&gt; /= /(_ Dy); exact/eqP.
  - split =&gt; //; have [&lt;-//|fgy] := eqVneq (f y) (g y).
    by exfalso; apply/Ny/subN =&gt; /= /(_ Dy); exact/eqP.
  - by move=&gt; [[]].
apply: measurableU.
- rewrite setIAC; apply: measurableI; last exact/measurableC.
  exact/mf/emeasurable_itv.
- by apply: cmu; exists N; split =&gt; //; rewrite setIAC; apply: subIset; right.
Qed.
End ae_measurable_fun.
Section integralD.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (mu : {measure set T -&gt; \bar R}) (D : set T) (mD : measurable D).
Variables (f1 f2 : T -&gt; \bar R).
Hypotheses (if1 : mu.-integrable D f1) (if2 : mu.-integrable D f2).
Let mf1 : measurable_fun D f1. Proof. exact: measurable_int if1. Qed.
Let mf2 : measurable_fun D f2. Proof. exact: measurable_int if2. Qed.
Lemma integralD : \int[mu]_(x in D) (f1 x + f2 x) =
  \int[mu]_(x in D) f1 x + \int[mu]_(x in D) f2 x.
Proof.
pose A := D `&amp;` [set x | f1 x \is a fin_num].
pose B := D `&amp;` [set x | f2 x \is a fin_num].
have mA : measurable A by exact: emeasurable_fin_num.
have mB : measurable B by exact: emeasurable_fin_num.
have mAB : measurable (A `&amp;` B) by apply: measurableI.
pose g1 := (fine \o f1 \_ (A `&amp;` B))%R.
pose g2 := (fine \o f2 \_ (A `&amp;` B))%R.
have ig1 : mu.-integrable D (EFin \o g1).
  rewrite (_ : _ \o _ = f1 \_ (A `&amp;` B)) //.
    apply: (integrableS measurableT)=&gt;//; apply/(integrable_mkcond _ _).1 =&gt; //.
    by apply: integrableS if1=&gt;//; rewrite -setIAC -setIA; apply: subIset; left.
  rewrite /g1 funeqE =&gt; x //=; rewrite !/restrict; case: ifPn =&gt; //.
  rewrite 2!in_setI =&gt; /andP[/andP[xA f1xfin] _] /=.
  by rewrite fineK//; rewrite inE in f1xfin.
have mg1 := measurable_int ig1.
have ig2 : mu.-integrable D (EFin \o g2).
  rewrite (_ : _ \o _ = f2 \_ (A `&amp;` B)) //.
    apply: (integrableS measurableT)=&gt;//; apply/(integrable_mkcond _ _).1 =&gt; //.
    by apply: integrableS if2=&gt;//; rewrite -setIAC -setIA; apply: subIset; left.
  rewrite /g2 funeqE =&gt; x //=; rewrite !/restrict; case: ifPn =&gt; //.
  rewrite in_setI =&gt; /andP[_]; rewrite in_setI =&gt; /andP[xB f2xfin] /=.
  by rewrite fineK//; rewrite inE in f2xfin.
have mg2 := measurable_int ig2.
transitivity (\int[mu]_(x in D) (EFin \o (g1 \+ g2)%R) x).
  apply: ae_eq_integral =&gt; //.
  - exact: emeasurable_funD.
  - rewrite (_ : _ \o _ = (EFin \o g1) \+ (EFin \o g2))//.
    exact: emeasurable_funD.
  - apply: (filterS2 _ _ (integrable_ae mD if1) (integrable_ae mD if2)).
    move=&gt; x + + Dx =&gt; /(_ Dx) f1fin /(_ Dx) f2fin /=.
    rewrite EFinD /g1 /g2 /restrict /=; have [|] := boolP (x \in A `&amp;` B).
      by rewrite in_setI =&gt; /andP[xA xB] /=; rewrite !fineK.
    by rewrite in_setI negb_and =&gt; /orP[|];
      rewrite in_setI negb_and /= (mem_set Dx)/= notin_set/=.
- rewrite (_ : _ \o _ = (EFin \o g1) \+ (EFin \o g2))// integralD_EFin//.
  congr (_ + _); apply: ae_eq_integral =&gt; //.
  + apply: (filterS2 _ _ (integrable_ae mD if1) (integrable_ae mD if2)).
    move=&gt; x + + Dx =&gt; /(_ Dx) f1fin /(_ Dx) f2fin /=; rewrite /g1 /restrict /=.
    have [/=|] := boolP (x \in A `&amp;` B); first by rewrite fineK.
    by rewrite in_setI negb_and =&gt; /orP[|];
      rewrite in_setI negb_and /= (mem_set Dx) /= notin_set/=.
  + apply: (filterS2 _ _ (integrable_ae mD if1) (integrable_ae mD if2)).
    move=&gt; x + + Dx =&gt; /(_ Dx) f1fin /(_ Dx) f2fin /=; rewrite /g2 /restrict /=.
    have [/=|] := boolP (x \in A `&amp;` B); first by rewrite fineK.
    by rewrite in_setI negb_and =&gt; /orP[|];
      rewrite in_setI negb_and /= (mem_set Dx) /= notin_set.
Qed.
End integralD.
Section integralB.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (mu : {measure set T -&gt; \bar R}) (D : set T).
Variables (mD : measurable D) (f1 f2 : T -&gt; \bar R).
Hypotheses (if1 : mu.-integrable D f1) (if2 : mu.-integrable D f2).
Lemma integralB : \int[mu]_(x in D) (f1 \- f2) x =
                  \int[mu]_(x in D) f1 x - \int[mu]_(x in D) f2 x.
Proof.
rewrite -[in RHS](@integralN _ _ _ _ _ f2); last exact: integrable_add_def.
by rewrite -[in RHS]integralD//; exact: integrableN.
Qed.
End integralB.
Section negligible_integral.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType)
        (mu : {measure set T -&gt; \bar R}).
Lemma negligible_integral (D N : set T) (f : T -&gt; \bar R) :
  measurable N -&gt; measurable D -&gt; mu.-integrable D f -&gt;
  mu N = 0 -&gt; \int[mu]_(x in D) f x = \int[mu]_(x in D `\` N) f x.
Proof.
move=&gt; mN mD mf muN0; rewrite [f]funeposneg ?integralB //; first last.
- exact: integrable_funeneg.
- exact: integrable_funepos.
- apply: (integrableS mD) =&gt; //; first exact: measurableD.
  exact: integrable_funeneg.
- apply: (integrableS mD) =&gt; //; first exact: measurableD.
  exact: integrable_funepos.
- exact: measurableD.
congr (_ - _); apply: ge0_negligible_integral =&gt; //; apply: measurable_int.
  exact: (integrable_funepos mD mf).
exact: (integrable_funeneg mD mf).
Qed.
End negligible_integral.
Add Search Blacklist "ge0_negligible_integral".
Section integrable_fune.
Context d (T : measurableType d) (R : realType).
Variables (mu : {measure set T -&gt; \bar R}) (D : set T) (mD : measurable D).
Local Open Scope ereal_scope.
Lemma integral_fune_lt_pinfty (f : T -&gt; \bar R) :
  mu.-integrable D f -&gt; \int[mu]_(x in D) f x &lt; +oo.
Proof.
move=&gt; intf; rewrite (funeposneg f) integralB//;
  [|exact: integrable_funepos|exact: integrable_funeneg].
rewrite lte_add_pinfty ?integral_funepos_lt_pinfty// lte_oppl ltNye_eq.
by rewrite integrable_neg_fin_num.
Qed.
Lemma integral_fune_fin_num (f : T -&gt; \bar R) :
  mu.-integrable D f -&gt; \int[mu]_(x in D) f x \is a fin_num.
Proof.
move=&gt; h; apply/fin_numPlt; rewrite integral_fune_lt_pinfty// andbC/= -/(- +oo).
rewrite lte_oppl -integralN; first exact/integral_fune_lt_pinfty/integrableN.
by rewrite fin_num_adde_defl// fin_numN integrable_neg_fin_num.
Qed.
End integrable_fune.
Section integral_counting.
Local Open Scope ereal_scope.
Variable R : realType.
Lemma counting_dirac (A : set nat) :
  counting A = \sum_(n &lt;oo) \d_ n A :&gt; \bar R.
Proof.
have -&gt; : \sum_(n &lt;oo) \d_ n A = \esum_(i in A) \d_ i A :&gt; \bar R.
  rewrite nneseries_esum// (_ : [set _ | _] = setT); last exact/seteqP.
  rewrite [in LHS](esumID A)// !setTI [X in _ + X](_ : _ = 0) ?adde0//.
  by apply: esum1 =&gt; i Ai; rewrite /= /dirac indicE memNset.
rewrite /counting/=; case: ifPn =&gt; /asboolP finA.
  by rewrite -finite_card_dirac.
by rewrite infinite_card_dirac.
Qed.
Lemma summable_integral_dirac (a : nat -&gt; \bar R) : summable setT a -&gt;
  \sum_(n &lt;oo) `|\int[\d_ n]_x a x| &lt; +oo.
Proof.
move=&gt; sa.
apply: (@le_lt_trans _ _ (\sum_(i &lt;oo) `|fine (a i)|%:E)).
  apply: lee_nneseries =&gt; // n _; rewrite integral_dirac//.
  move: (@summable_pinfty _ _ _ _ sa n Logic.I).
  by case: (a n) =&gt; //= r _; rewrite indicE/= mem_set// mul1r.
move: (sa); rewrite /summable -fun_true -nneseries_esum//; apply: le_lt_trans.
by apply lee_nneseries =&gt; // n _ /=; case: (a n) =&gt; //; rewrite leey.
Qed.
Lemma integral_count (a : nat -&gt; \bar R) : summable setT a -&gt;
  \int[counting]_t (a t) = \sum_(k &lt;oo) (a k).
Proof.
move=&gt; sa.
transitivity (\int[mseries (fun n =&gt; [the measure _ _ of \d_ n]) O]_t a t).
  congr (integral _ _ _); apply/funext =&gt; A.
  by rewrite /= counting_dirac.
rewrite (@integral_measure_series _ _ R (fun n =&gt; [the measure _ _ of \d_ n]) setT)//=.
- by apply: eq_eseriesr=&gt; i _; rewrite integral_dirac//= diracT mul1e.
- move=&gt; n; apply/integrableP; split=&gt; [//|].
  by rewrite integral_dirac//= diracT mul1e (summable_pinfty sa).
- by apply: summable_integral_dirac =&gt; //; exact: summable_funeneg.
- by apply: summable_integral_dirac =&gt; //; exact: summable_funepos.
Qed.
Lemma ge0_integral_count (a : nat -&gt; \bar R) : (forall k, 0 &lt;= a k) -&gt;
  \int[counting]_t (a t) = \sum_(k &lt;oo) (a k).
Proof.
move=&gt; sa.
transitivity (\int[mseries (fun n =&gt; [the measure _ _ of \d_ n]) O]_t a t).
  congr (integral _ _ _); apply/funext =&gt; A.
  by rewrite /= counting_dirac.
rewrite (@ge0_integral_measure_series _ _ R (fun n =&gt; [the measure _ _ of \d_ n]) setT)//=.
by apply: eq_eseriesr=&gt; i _; rewrite integral_dirac//= diracT mul1e.
Qed.
End integral_counting.
Section subadditive_countable.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variable (mu : {measure set T -&gt; \bar R}).
Lemma integrable_abse (D : set T) (f : T -&gt; \bar R) :
  mu.-integrable D f -&gt; mu.-integrable D (abse \o f).
Proof.
move=&gt; /integrableP[mf foo]; apply/integrableP; split.
  exact: measurableT_comp.
by under eq_integral do rewrite abse_id.
Qed.
Lemma integrable_summable (F : (set T)^nat) (g : T -&gt; \bar R):
  trivIset setT F -&gt; (forall k, measurable (F k)) -&gt;
  mu.-integrable (\bigcup_k F k) g -&gt;
  summable [set: nat] (fun i =&gt; \int[mu]_(x in F i) g x).
Proof.
move=&gt; tF mF fi.
rewrite /summable -(_ : [set _ | true] = setT); last exact/seteqP.
rewrite -nneseries_esum//.
case: (integrableP _ _ _ fi) =&gt; _.
rewrite ge0_integral_bigcup//; last exact: integrable_abse.
apply: le_lt_trans; apply: lee_lim.
- exact: is_cvg_ereal_nneg_natsum_cond.
- by apply: is_cvg_ereal_nneg_natsum_cond =&gt; n _ _; exact: integral_ge0.
- apply: nearW =&gt; n; apply: lee_sum =&gt; m _; apply: le_abse_integral =&gt; //.
  apply: measurable_funS (measurable_int fi) =&gt; //; [exact: bigcup_measurable|].
  exact: bigcup_sup.
Qed.
Lemma integral_bigcup (F : (set _)^nat) (g : T -&gt; \bar R) :
  trivIset setT F -&gt; (forall k, measurable (F k)) -&gt;
  mu.-integrable (\bigcup_k F k) g -&gt;
  (\int[mu]_(x in \bigcup_i F i) g x = \sum_(i &lt;oo) \int[mu]_(x in F i) g x)%E.
Proof.
move=&gt; tF mF fi.
have ? : \int[mu]_(x in \bigcup_i F i) g x \is a fin_num.
  rewrite fin_numElt -(lte_absl _ +oo).
  apply: le_lt_trans (integrableP _ _ _ fi).2; apply: le_abse_integral =&gt; //.
    exact: bigcupT_measurable.
  exact: measurable_int fi.
transitivity (\int[mu]_(x in \bigcup_i F i) g^\+ x -
              \int[mu]_(x in \bigcup_i F i) g^\- x)%E.
  rewrite -integralB; last 3 first.
    - exact: bigcupT_measurable.
    - by apply: integrable_funepos =&gt; //; exact: bigcupT_measurable.
    -by apply: integrable_funeneg =&gt; //; exact: bigcupT_measurable.
  by apply: eq_integral =&gt; t Ft; rewrite [in LHS](funeposneg g).
transitivity (\sum_(i &lt;oo) (\int[mu]_(x in F i) g^\+ x -
                            \int[mu]_(x in F i) g^\- x)); last first.
  by apply: eq_eseriesr =&gt; // i; rewrite [RHS]integralE.
transitivity ((\sum_(i &lt;oo) \int[mu]_(x in F i) g^\+ x) -
              (\sum_(i &lt;oo) \int[mu]_(x in F i) g^\- x))%E.
  rewrite ge0_integral_bigcup//; last first.
    by apply: integrable_funepos =&gt; //; exact: bigcupT_measurable.
  by rewrite ge0_integral_bigcup//; apply: integrable_funepos =&gt; //;
    [exact: bigcupT_measurable|exact: integrableN].
rewrite [X in X - _]nneseries_esum; last by move=&gt; n _; exact: integral_ge0.
rewrite [X in _ - X]nneseries_esum; last by move=&gt; n _; exact: integral_ge0.
rewrite set_true -esumB//=; last 4 first.
  - apply: integrable_summable =&gt; //; apply: integrable_funepos =&gt; //.
    exact: bigcup_measurable.
  - apply: integrable_summable =&gt; //; apply: integrable_funepos =&gt; //.
    exact: bigcup_measurable.
  - exact: integrableN.
  - by move=&gt; n _; exact: integral_ge0.
  - by move=&gt; n _; exact: integral_ge0.
rewrite summable_eseries; last first.
  under [X in summable _ X]eq_fun do rewrite -integralE.
  by rewrite fun_true; exact: integrable_summable.
by congr (_ - _)%E; rewrite nneseries_esum// set_true.
Qed.
End subadditive_countable.
Section dominated_convergence_lemma.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (mu : {measure set T -&gt; \bar R}) (D : set T) (mD : measurable D).
Variables (f_ : (T -&gt; \bar R)^nat) (f : T -&gt; \bar R) (g : T -&gt; \bar R).
Hypothesis mf_ : forall n, measurable_fun D (f_ n).
Hypothesis f_f : forall x, D x -&gt; f_ ^~ x --&gt; f x.
Hypothesis fing : forall x, D x -&gt; g x \is a fin_num.
Hypothesis ig : mu.-integrable D g.
Hypothesis absfg : forall n x, D x -&gt; `|f_ n x| &lt;= g x.
Let g0 x : D x -&gt; 0 &lt;= g x.
Proof. by move=&gt; Dx; rewrite (le_trans _ (@absfg O _ Dx))// lee_fin. Qed.
Let mf : measurable_fun D f.
Proof. exact: (emeasurable_fun_cvg _ _ mf_ f_f). Qed.
Local Lemma dominated_integrable : mu.-integrable D f.
Proof.
apply/integrableP; split =&gt; //; have Dfg x : D x -&gt; `| f x | &lt;= g x.
  move=&gt; Dx; have /(@cvg_lim _) &lt;- // : `|f_ n x| @[n --&gt; \oo] --&gt; `|f x|.
    by apply: cvg_abse =&gt; //; exact: f_f.
  apply: lime_le =&gt; //.
  - by apply: is_cvg_abse; apply/cvg_ex; eexists; exact: f_f.
  - by apply: nearW =&gt; n; exact: absfg.
move: ig =&gt; /integrableP[mg]; apply: le_lt_trans; apply: ge0_le_integral =&gt; //.
- exact: measurableT_comp.
- exact: measurableT_comp.
- by move=&gt; x Dx /=; rewrite (gee0_abs (g0 Dx)); exact: Dfg.
Qed.
Let g_ n x := `|f_ n x - f x|.
Let cvg_g_ x : D x -&gt; g_ ^~ x --&gt; 0.
Proof.
move=&gt; Dx; rewrite -abse0; apply: cvg_abse.
move: (f_f Dx); case: (f x) =&gt; [r|/=|/=].
- by move=&gt; f_r; apply/cvge_sub0.
- move/cvgeyPge/(_ (fine (g x) + 1)%R) =&gt; [n _]/(_ _ (leqnn n))/= h.
  have : (fine (g x) + 1)%:E &lt;= g x.
    by rewrite (le_trans h)// (le_trans _ (absfg n Dx))// lee_abs.
  by case: (g x) (fing Dx) =&gt; [r _| |]//; rewrite leNgt EFinD lte_addl ?lte01.
- move/cvgeNyPle/(_ (- (fine (g x) + 1))%R) =&gt; [n _]/(_ _ (leqnn n)) h.
  have : (fine (g x) + 1)%:E &lt;= g x.
    move: h; rewrite EFinN lee_oppr =&gt; /le_trans -&gt;//.
    by rewrite (le_trans _ (absfg n Dx))// -abseN lee_abs.
  by case: (g x) (fing Dx) =&gt; [r _| |]//; rewrite leNgt EFinD lte_addl ?lte01.
Qed.
Let gg_ n x : D x -&gt; 0 &lt;= 2%:E * g x - g_ n x.
Proof.
move=&gt; Dx; rewrite subre_ge0; last by rewrite fin_numM// fing.
rewrite -(fineK (fing Dx)) -EFinM mulr_natl mulr2n /g_.
rewrite (le_trans (lee_abs_sub _ _))// [in leRHS]EFinD lee_add//.
  by rewrite fineK// ?fing// absfg.
have f_fx : `|(f_ n x)| @[n --&gt; \oo] --&gt; `|f x| by apply: cvg_abse; exact: f_f.
move/cvg_lim : (f_fx) =&gt; &lt;-//.
apply: lime_le; first by apply/cvg_ex; eexists; exact: f_fx.
by apply: nearW =&gt; k; rewrite fineK ?fing//; apply: absfg.
Qed.
Let mgg n : measurable_fun D (fun x =&gt; 2%:E * g x - g_ n x).
Proof.
apply/emeasurable_funB =&gt; //; [by apply/measurable_funeM/(measurable_int ig)|].
by apply/measurableT_comp =&gt; //; exact: emeasurable_funB.
Qed.
Let gg_ge0 n x : D x -&gt; 0 &lt;= 2%:E * g x - g_ n x.
Proof. by move=&gt; Dx; rewrite gg_. Qed.
Local Lemma dominated_cvg0 : [sequence \int[mu]_(x in D) g_ n x]_n --&gt; 0.
Proof.
have := fatou mu mD mgg gg_ge0.
rewrite [X in X &lt;= _ -&gt; _](_ : _ = \int[mu]_(x in D) (2%:E * g x) ); last first.
  apply: eq_integral =&gt; t; rewrite inE =&gt; Dt.
  rewrite limn_einf_shift//; last by rewrite fin_numM// fing.
  rewrite is_cvg_limn_einfE//; last first.
    by apply: is_cvgeN; apply/cvg_ex; eexists; exact: cvg_g_.
  rewrite [X in _ + X](_ : _ = 0) ?adde0//; apply/cvg_lim =&gt; //.
  by rewrite -(oppe0); apply: cvgeN; exact: cvg_g_.
have i2g : \int[mu]_(x in D) (2%:E * g x)  &lt; +oo.
rewrite integralZl// lte_mul_pinfty// ?lee_fin//; case: (integrableP _ _ _ ig) =&gt; _.
  apply: le_lt_trans; rewrite le_eqVlt; apply/orP; left; apply/eqP.
  by apply: eq_integral =&gt; t Dt; rewrite gee0_abs// g0//; rewrite inE in Dt.
have ? : \int[mu]_(x in D) (2%:E * g x)  \is a fin_num.
  by rewrite ge0_fin_numE// integral_ge0// =&gt; ? ?; rewrite mule_ge0 ?lee_fin ?g0.
rewrite [X in _ &lt;= X -&gt; _](_ : _ = \int[mu]_(x in D) (2%:E * g x)  + -
    limn_esup (fun n =&gt; \int[mu]_(x in D) g_ n x)); last first.
  rewrite (_ : (fun _ =&gt; _) = (fun n =&gt; \int[mu]_(x in D) (2%:E * g x)  +
      \int[mu]_(x in D) - g_ n x)); last first.
    rewrite funeqE =&gt; n; rewrite integralB//.
    - by rewrite -integral_ge0N// =&gt; x Dx//; rewrite /g_.
    - exact: integrableZl.
    - have integrable_normfn : mu.-integrable D (abse \o f_ n).
        apply: le_integrable ig =&gt; //; first exact: measurableT_comp.
        by move=&gt; x Dx /=; rewrite abse_id (le_trans (absfg _ Dx))// lee_abs.
      suff: mu.-integrable D (fun x =&gt; `|f_ n x| + `|f x|).
        apply: le_integrable =&gt; //.
        - by apply: measurableT_comp =&gt; //; exact: emeasurable_funB.
        - move=&gt; x Dx.
          by rewrite /g_ abse_id (le_trans (lee_abs_sub _ _))// lee_abs.
      apply: integrableD; [by []| by []|].
      apply: le_integrable dominated_integrable =&gt; //.
      - exact: measurableT_comp.
      - by move=&gt; x Dx; rewrite /= abse_id.
  rewrite limn_einf_shift // -limn_einfN; congr (_ + limn_einf _).
  by rewrite funeqE =&gt; n /=; rewrite -integral_ge0N// =&gt; x Dx; rewrite /g_.
rewrite addeC -lee_subl_addr// subee// lee_oppr oppe0 =&gt; lim_ge0.
by apply/limn_esup_le_cvg =&gt; // n; rewrite integral_ge0// =&gt; x _; rewrite /g_.
Qed.
Local Lemma dominated_cvg :
  (fun n =&gt; \int[mu]_(x in D) f_ n x) --&gt; \int[mu]_(x in D) f x.
Proof.
have h n : `| \int[mu]_(x in D) f_ n x - \int[mu]_(x in D) f x |
    &lt;= \int[mu]_(x in D) g_ n x.
  rewrite -(integralB _ _ dominated_integrable)//; last first.
    by apply: le_integrable ig =&gt; // x Dx /=; rewrite (gee0_abs (g0 Dx)) absfg.
  by apply: le_abse_integral =&gt; //; exact: emeasurable_funB.
suff: (fun n =&gt; `| \int[mu]_(x in D) f_ n x - \int[mu]_(x in D) f x |) --&gt; 0.
   move/cvg_abse0P/cvge_sub0; apply.
   rewrite fin_numElt (_ : -oo = - +oo)// -lte_absl.
   move: dominated_integrable =&gt; /integrableP[?]; apply: le_lt_trans.
   by apply: (le_trans _ (@le_abse_integral _ _ _ mu D f mD _)).
apply: (@squeeze_cvge _ _ _ _ (cst 0) _ (fun n =&gt; \int[mu]_(x in D) g_ n x)).
- by apply: nearW =&gt; n; rewrite abse_ge0//=; exact: h.
- exact: cvg_cst.
- exact: dominated_cvg0.
Qed.
End dominated_convergence_lemma.
Arguments dominated_integrable {d T R mu D} _ f_ f g.
Section dominated_convergence_theorem.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (mu : {measure set T -&gt; \bar R}) (D : set T) (mD : measurable D).
Variables (f_ : (T -&gt; \bar R)^nat) (f : T -&gt; \bar R) (g : T -&gt; \bar R).
Hypothesis mf_ : forall n, measurable_fun D (f_ n).
Hypothesis mf : measurable_fun D f.
Hypothesis f_f : {ae mu, forall x, D x -&gt; f_ ^~ x --&gt; f x}.
Hypothesis ig : mu.-integrable D g.
Hypothesis f_g : {ae mu, forall x n, D x -&gt; `|f_ n x| &lt;= g x}.
Let g_ n x := `|f_ n x - f x|.
Theorem dominated_convergence : [/\ mu.-integrable D f,
  [sequence \int[mu]_(x in D) (g_ n x)]_n --&gt; 0 &amp;
  [sequence \int[mu]_(x in D) (f_ n x)]_n --&gt; \int[mu]_(x in D) (f x) ].
Proof.
have [N1 [mN1 N10 subN1]] := f_f.
have [N2 [mN2 N20 subN2]] := f_g.
have [N3 [mN3 N30 subN3]] := integrable_ae mD ig.
pose N := N1 `|` N2 `|` N3.
have mN : measurable N by apply: measurableU =&gt; //; exact: measurableU.
have N0 : mu N = 0.
  by rewrite null_set_setU// ?null_set_setU//; exact: measurableU.
pose f' := f \_ (D `\` N); pose g' := g \_ (D `\` N).
pose f_' := fun n =&gt; f_ n \_ (D `\` N).
have f_f' x : D x -&gt; f_' ^~ x --&gt; f' x.
  move=&gt; Dx; rewrite /f_' /f' /restrict in_setD mem_set//=.
  have [/= xN|/= xN] := boolP (x \in N); first exact: cvg_cst.
  apply: contraPP (xN) =&gt; h; apply/negP; rewrite negbK inE; left; left.
  by apply: subN1 =&gt; /= /(_ Dx); exact: contra_not h.
have f_g' n x : D x -&gt; `|f_' n x| &lt;= g' x.
  move=&gt; Dx; rewrite /f_' /g' /restrict in_setD mem_set//=.
  have [/=|/= xN] := boolP (x \in N); first by rewrite normr0.
  apply: contrapT =&gt; fg; move: xN; apply/negP; rewrite negbK inE; left; right.
  by apply: subN2 =&gt; /= /(_ n Dx).
have mu_ n : measurable_fun D (f_' n).
  apply/(measurable_restrict (f_ n) (measurableD mD mN) _ _).1 =&gt; //.
  by apply: measurable_funS (mf_ _) =&gt; // x [].
have ig' : mu.-integrable D g'.
  apply: (integrableS measurableT) =&gt; //.
  apply/(integrable_mkcond g (measurableD mD mN)).1.
  by apply: integrableS ig =&gt; //; exact: measurableD.
have finv x : D x -&gt; g' x \is a fin_num.
  move=&gt; Dx; rewrite /g' /restrict in_setD// mem_set//=.
  have [//|xN /=] := boolP (x \in N).
  apply: contrapT =&gt; fing; move: xN; apply/negP; rewrite negbK inE; right.
  by apply: subN3 =&gt; /= /(_ Dx).
split.
- have /integrableP if' : mu.-integrable D f'.
    exact: (dominated_integrable _ f_' _ g').
  apply/integrableP; split =&gt; //.
  move: if' =&gt; [?]; apply: le_lt_trans.
  rewrite le_eqVlt; apply/orP; left; apply/eqP/ae_eq_integral =&gt; //;
    [exact: measurableT_comp|exact: measurableT_comp|].
  exists N; split =&gt; //; rewrite -(setCK N); apply: subsetC =&gt; x Nx Dx.
  by rewrite /f' /restrict mem_set.
- have := @dominated_cvg0 _ _ _ _ _ mD _ _ _ mu_ f_f' finv ig' f_g'.
  set X := (X in _ -&gt; X --&gt; _); rewrite [X in X --&gt; _ -&gt; _](_ : _ = X) //.
  apply/funext =&gt; n; apply: ae_eq_integral =&gt; //.
  + apply: measurableT_comp =&gt; //; apply: emeasurable_funB =&gt; //.
    apply/(measurable_restrict _ (measurableD _ _) _ _).1 =&gt; //.
    by apply: (measurable_funS mD) =&gt; // x [].
  + by rewrite /g_; apply: measurableT_comp =&gt; //; exact: emeasurable_funB.
  + exists N; split =&gt; //; rewrite -(setCK N); apply: subsetC =&gt; x /= Nx Dx.
    by rewrite /f_' /f' /restrict mem_set.
- have := @dominated_cvg _ _ _ _ _ mD _ _ _ mu_ f_f' finv ig' f_g'.
  set X := (X in _ -&gt; X --&gt; _); rewrite [X in X --&gt; _ -&gt; _](_ : _ = X) //; last first.
    apply/funext =&gt; n; apply: ae_eq_integral =&gt; //.
    exists N; split =&gt; //; rewrite -(setCK N); apply: subsetC =&gt; x /= Nx Dx.
    by rewrite /f_' /restrict mem_set.
  set Y := (X in _ -&gt; _ --&gt; X); rewrite [X in _ --&gt; X -&gt; _](_ : _ = Y) //.
  apply: ae_eq_integral =&gt; //.
    apply/(measurable_restrict _ (measurableD _ _) _ _).1 =&gt; //.
    by apply: (measurable_funS mD) =&gt; // x [].
  exists N; split =&gt; //; rewrite -(setCK N); apply: subsetC =&gt; x /= Nx Dx.
  by rewrite /f' /restrict mem_set.
Qed.
End dominated_convergence_theorem.
Section ae_ge0_le_integral.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variable mu : {measure set T -&gt; \bar R}.
Variables (D : set T) (mD : measurable D) (f1 f2 : T -&gt; \bar R).
Hypothesis f10 : forall x, D x -&gt; 0 &lt;= f1 x.
Hypothesis mf1 : measurable_fun D f1.
Hypothesis f20 : forall x, D x -&gt; 0 &lt;= f2 x.
Hypothesis mf2 : measurable_fun D f2.
Lemma ae_ge0_le_integral : {ae mu, forall x, D x -&gt; f1 x &lt;= f2 x} -&gt;
  \int[mu]_(x in D) f1 x &lt;= \int[mu]_(x in D) f2 x.
Proof.
move=&gt; [N [mN muN f1f2N]]; rewrite (ge0_negligible_integral _ _ _ _ muN)//.
rewrite [leRHS](ge0_negligible_integral _ _ _ _ muN)//.
apply: ge0_le_integral; first exact: measurableD.
- by move=&gt; t [Dt _]; exact: f10.
- exact: measurable_funS mf1.
- by move=&gt; t [Dt _]; exact: f20.
- exact: measurable_funS mf2.
- by move=&gt; t [Dt Nt]; move/subsetCl : f1f2N; apply.
Qed.
End ae_ge0_le_integral.
Section integral_bounded.
Context d {T : measurableType d} {R : realType}.
Variable mu : {measure set T -&gt; \bar R}.
Local Open Scope ereal_scope.
Lemma integral_le_bound (D : set T) (f : T -&gt; \bar R) (M : \bar R) :
  measurable D -&gt; measurable_fun D f -&gt; 0 &lt;= M -&gt;
  {ae mu, forall x, D x -&gt; `|f x| &lt;= M} -&gt;
  \int[mu]_(x in D) `|f x| &lt;= M * mu D.
Proof.
move=&gt; mD mf M0 dfx; rewrite -integral_cst =&gt; //.
by apply: ae_ge0_le_integral =&gt; //; exact: measurableT_comp.
Qed.
End integral_bounded.
Arguments integral_le_bound {d T R mu D f} M.
Section integral_ae_eq.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType) (mu : {measure set T -&gt; \bar R}).
Let integral_measure_lt (D : set T) (mD : measurable D) (g f : T -&gt; \bar R) :
  mu.-integrable D f -&gt; mu.-integrable D g -&gt;
  (forall E, measurable E -&gt; \int[mu]_(x in E) f x = \int[mu]_(x in E) g x) -&gt;
  mu (D `&amp;` [set x | g x &lt; f x]) = 0.
Proof.
move=&gt; itf itg fg; pose E j := D `&amp;` [set x | f x - g x &gt;= j.+1%:R^-1%:E].
have msf := measurable_int itf.
have msg := measurable_int itg.
have mE j : measurable (E j).
  rewrite /E; apply: emeasurable_fun_le =&gt; //.
  by apply/(emeasurable_funD msf)/measurableT_comp =&gt; //; case: mg.
have muE j : mu (E j) = 0.
  apply/eqP; rewrite -measure_le0.
  have fg0 : \int[mu]_(x in E j) (f \- g) x = 0.
    rewrite integralB//; last 2 first.
      by apply: integrableS itf =&gt; //; exact: subIsetl.
      by apply: integrableS itg =&gt; //; exact: subIsetl.
    rewrite fg// subee// fin_num_abs (le_lt_trans (le_abse_integral _ _ _))//.
      by apply: measurable_funS msg =&gt; //; first exact: subIsetl.
    apply: le_lt_trans (integrableP _ _ _ itg).2; apply: subset_integral =&gt; //.
      exact: measurableT_comp msg.
    exact: subIsetl.
  suff : mu (E j) &lt;= j.+1%:R%:E * \int[mu]_(x in E j) (f \- g) x.
    by rewrite fg0 mule0.
  apply: (@le_trans _ _ (j.+1%:R%:E * \int[mu]_(x in E j) j.+1%:R^-1%:E)).
    by rewrite integral_cst// muleA -EFinM divrr ?unitfE// mul1e.
  rewrite lee_pmul//; first exact: integral_ge0.
  apply: ge0_le_integral =&gt; //; [| |by move=&gt; x []].
  - by move=&gt; x [_/=]; exact: le_trans.
  - apply: emeasurable_funB.
    + by apply: measurable_funS msf =&gt; //; exact: subIsetl.
    + by apply: measurable_funS msg =&gt; //; exact: subIsetl.
have nd_E : {homo E : n0 m / (n0 &lt;= m)%N &gt;-&gt; (n0 &lt;= m)%O}.
  move=&gt; i j ij; apply/subsetPset =&gt; x [Dx /= ifg]; split =&gt; //.
  by move: ifg; apply: le_trans; rewrite lee_fin lef_pinv// ?posrE// ler_nat.
rewrite set_lte_bigcup.
have /cvg_lim h1 : mu \o E --&gt; 0 by apply: cvg_near_cst; exact: nearW.
have := @nondecreasing_cvg_mu _ _ _ mu E mE (bigcupT_measurable E mE) nd_E.
by move/cvg_lim =&gt; h2; rewrite setI_bigcupr -h2// h1.
Qed.
Lemma integral_ae_eq (D : set T) (mD : measurable D) (g f : T -&gt; \bar R) :
  mu.-integrable D f -&gt; measurable_fun D g -&gt;
  (forall E, measurable E -&gt; \int[mu]_(x in E) f x = \int[mu]_(x in E) g x) -&gt;
  ae_eq mu D f g.
Proof.
move=&gt; fi mg fg; have mf := measurable_int fi; have gi : mu.-integrable D g.
  apply/integrableP; split =&gt; //; apply/abse_integralP =&gt; //; rewrite -fg//.
  by apply/abse_integralP =&gt; //; case/integrableP : fi.
have mugf : mu (D `&amp;` [set x | g x &lt; f x]) = 0 by exact: integral_measure_lt.
have mufg : mu (D `&amp;` [set x | f x &lt; g x]) = 0.
  by apply: integral_measure_lt =&gt; // E mE; rewrite fg.
have h : ~` [set x | D x -&gt; f x = g x] = D `&amp;` [set x | f x != g x].
  apply/seteqP; split =&gt; [x/= /not_implyP[? /eqP]//|x/= [Dx fgx]].
  by apply/not_implyP; split =&gt; //; exact/eqP.
apply/negligibleP.
  by rewrite h; apply: emeasurable_fun_neq.
rewrite h set_neq_lt setIUr measureU//.
- by rewrite [X in X + _]mufg add0e [LHS]mugf.
- exact: emeasurable_fun_lt.
- exact: emeasurable_fun_lt.
- apply/seteqP; split =&gt; [x [[Dx/= + [_]]]|//].
  by move=&gt; /lt_trans =&gt; /[apply]; rewrite ltxx.
Qed.
End integral_ae_eq.
</pre>
<pre class="ssrdoc">
Section measurable_section.
Context d1 d2 (T1 : measurableType d1) (T2 : measurableType d2) (R : realType).
Implicit Types (A : set (T1 * T2)).
Lemma measurable_xsection A x : measurable A -&gt; measurable (xsection A x).
Proof.
move=&gt; mA; rewrite (xsection_indic R) -(setTI (_ @^-1` _)).
exact: measurableT_comp.
Qed.
Lemma measurable_ysection A y : measurable A -&gt; measurable (ysection A y).
Proof.
move=&gt; mA; rewrite (ysection_indic R) -(setTI (_ @^-1` _)).
exact: measurableT_comp.
Qed.
End measurable_section.
Section ndseq_closed_B.
Context d1 d2 (T1 : measurableType d1) (T2 : measurableType d2) (R : realType).
Implicit Types A : set (T1 * T2).
Section xsection.
Variables (pt2 : T2) (m2 : T1 -&gt; {measure set T2 -&gt; \bar R}).
the generalization from m2 : {measure set T2 -&gt; \bar R}t to
   T1 -&gt; {measure set T2 -&gt; \bar R} is needed to develop the theory
   of kernels; the original type was sufficient for the development
   of the theory of integration  
Let phi A x := m2 x (xsection A x).
Let B := [set A | measurable A /\ measurable_fun setT (phi A)].
Lemma xsection_ndseq_closed : ndseq_closed B.
Proof.
move=&gt; F ndF; rewrite /B /= =&gt; BF; split.
  by apply: bigcupT_measurable =&gt; n; have [] := BF n.
have phiF x : (fun i =&gt; phi (F i) x) --&gt; phi (\bigcup_i F i) x.
  rewrite /phi /= xsection_bigcup; apply: nondecreasing_cvg_mu.
  - by move=&gt; n; apply: measurable_xsection; case: (BF n).
  - by apply: bigcupT_measurable =&gt; i; apply: measurable_xsection; case: (BF i).
  - by move=&gt; m n mn; exact/subsetPset/le_xsection/subsetPset/ndF.
apply: (emeasurable_fun_cvg (phi \o F)) =&gt; //.
- by move=&gt; i; have [] := BF i.
- by move=&gt; x _; exact: phiF.
Qed.
End xsection.
Section ysection.
Variable m1 : {measure set T1 -&gt; \bar R}.
Let psi A := m1 \o ysection A.
Let B := [set A | measurable A /\ measurable_fun setT (psi A)].
Lemma ysection_ndseq_closed : ndseq_closed B.
Proof.
move=&gt; F ndF; rewrite /B /= =&gt; BF; split.
  by apply: bigcupT_measurable =&gt; n; have [] := BF n.
have psiF x : (fun i =&gt; psi (F i) x) --&gt; psi (\bigcup_i F i) x.
  rewrite /psi /= ysection_bigcup; apply: nondecreasing_cvg_mu.
  - by move=&gt; n; apply: measurable_ysection; case: (BF n).
  - by apply: bigcupT_measurable =&gt; i; apply: measurable_ysection; case: (BF i).
  - by move=&gt; m n mn; exact/subsetPset/le_ysection/subsetPset/ndF.
apply: (emeasurable_fun_cvg (psi \o F)) =&gt; //.
- by move=&gt; i; have [] := BF i.
- by move=&gt; x _; exact: psiF.
Qed.
End ysection.
End ndseq_closed_B.
Section measurable_prod_subset.
Context d1 d2 (T1 : measurableType d1) (T2 : measurableType d2) (R : realType).
Implicit Types A : set (T1 * T2).
Section xsection.
Variable (m2 : {measure set T2 -&gt; \bar R}) (D : set T2) (mD : measurable D).
Let m2D := mrestr m2 mD.
HB.instance Definition _ := Measure.on m2D.
Let phi A := m2D \o xsection A.
Let B := [set A | measurable A /\ measurable_fun setT (phi A)].
Lemma measurable_prod_subset_xsection
    (m2D_bounded : exists M, forall X, measurable X -&gt; (m2D X &lt; M%:E)%E) :
  measurable `&lt;=` B.
Proof.
rewrite measurable_prod_measurableType.
set C := [set A1 `*` A2 | A1 in measurable &amp; A2 in measurable].
have CI : setI_closed C.
  move=&gt; X Y [X1 mX1 [X2 mX2 &lt;-{X}]] [Y1 mY1 [Y2 mY2 &lt;-{Y}]].
  exists (X1 `&amp;` Y1); first exact: measurableI.
  by exists (X2 `&amp;` Y2); [exact: measurableI|rewrite setMI].
have CT : C setT by exists setT =&gt; //; exists setT =&gt; //; rewrite setMTT.
have CB : C `&lt;=` B.
  move=&gt; X [X1 mX1 [X2 mX2 &lt;-{X}]]; split; first exact: measurableM.
  have -&gt; : phi (X1 `*` X2) = (fun x =&gt; m2D X2 * (\1_X1 x)%:E)%E.
    rewrite funeqE =&gt; x; rewrite indicE /phi /m2/= /mrestr.
    have [xX1|xX1] := boolP (x \in X1); first by rewrite mule1 in_xsectionM.
    by rewrite mule0 notin_xsectionM// set0I measure0.
  exact/measurable_funeM/EFin_measurable_fun.
suff monoB : monotone_class setT B by exact: monotone_class_subset.
split =&gt; //; [exact: CB| |exact: xsection_ndseq_closed].
move=&gt; X Y XY [mX mphiX] [mY mphiY]; split; first exact: measurableD.
have -&gt; : phi (X `\` Y) = (fun x =&gt; phi X x - phi Y x)%E.
  rewrite funeqE =&gt; x; rewrite /phi/= xsectionD// /m2D measureD.
  - by rewrite setIidr//; exact: le_xsection.
  - exact: measurable_xsection.
  - exact: measurable_xsection.
  - move: m2D_bounded =&gt; [M m2M].
    rewrite (lt_le_trans (m2M (xsection X x) _))// ?leey//.
    exact: measurable_xsection.
exact: emeasurable_funB.
Qed.
End xsection.
Section ysection.
Variable (m1 : {measure set T1 -&gt; \bar R}) (D : set T1) (mD : measurable D).
Let m1D := mrestr m1 mD.
HB.instance Definition _ := Measure.on m1D.
Let psi A := m1D \o ysection A.
Let B := [set A | measurable A /\ measurable_fun setT (psi A)].
Lemma measurable_prod_subset_ysection
    (m1_bounded : exists M, forall X, measurable X -&gt; (m1D X &lt; M%:E)%E) :
  measurable `&lt;=` B.
Proof.
rewrite measurable_prod_measurableType.
set C := [set A1 `*` A2 | A1 in measurable &amp; A2 in measurable].
have CI : setI_closed C.
  move=&gt; X Y [X1 mX1 [X2 mX2 &lt;-{X}]] [Y1 mY1 [Y2 mY2 &lt;-{Y}]].
  exists (X1 `&amp;` Y1); first exact: measurableI.
  by exists (X2 `&amp;` Y2); [exact: measurableI|rewrite setMI].
have CT : C setT by exists setT =&gt; //; exists setT =&gt; //; rewrite setMTT.
have CB : C `&lt;=` B.
  move=&gt; X [X1 mX1 [X2 mX2 &lt;-{X}]]; split; first exact: measurableM.
  have -&gt; : psi (X1 `*` X2) = (fun x =&gt; m1D X1 * (\1_X2 x)%:E)%E.
    rewrite funeqE =&gt; y; rewrite indicE /psi /m1/= /mrestr.
    have [yX2|yX2] := boolP (y \in X2); first by rewrite mule1 in_ysectionM.
    by rewrite mule0 notin_ysectionM// set0I measure0.
  exact/measurable_funeM/EFin_measurable_fun.
suff monoB : monotone_class setT B by exact: monotone_class_subset.
split =&gt; //; [exact: CB| |exact: ysection_ndseq_closed].
move=&gt; X Y XY [mX mphiX] [mY mphiY]; split; first exact: measurableD.
rewrite (_ : psi _ = (psi X \- psi Y)%E); first exact: emeasurable_funB.
rewrite funeqE =&gt; y; rewrite /psi/= ysectionD// /m1D measureD.
- by rewrite setIidr//; exact: le_ysection.
- exact: measurable_ysection.
- exact: measurable_ysection.
- have [M m1M] := m1_bounded.
  rewrite (lt_le_trans (m1M (ysection X y) _))// ?leey//.
  exact: measurable_ysection.
Qed.
End ysection.
End measurable_prod_subset.
Section measurable_fun_xsection.
Context d1 d2 (T1 : measurableType d1) (T2 : measurableType d2) (R : realType).
Variable m2 : {sigma_finite_measure set T2 -&gt; \bar R}.
Implicit Types A : set (T1 * T2).
Let phi A := m2 \o xsection A.
Let B := [set A | measurable A /\ measurable_fun setT (phi A)].
Lemma measurable_fun_xsection A : measurable A -&gt; measurable_fun setT (phi A).
Proof.
move: A; suff : measurable `&lt;=` B by move=&gt; + A =&gt; /[apply] -[].
have /sigma_finiteP [F F_T [F_nd F_oo]] := sigma_finiteT m2 =&gt; X mX.
have -&gt; : X = \bigcup_n (X `&amp;` (setT `*` F n)).
  by rewrite -setI_bigcupr -setM_bigcupr -F_T setMTT setIT.
apply: xsection_ndseq_closed.
  move=&gt; m n mn; apply/subsetPset; apply: setIS; apply: setSM =&gt; //.
  exact/subsetPset/F_nd.
move=&gt; n; rewrite -/B; have [? ?] := F_oo n.
pose m2Fn := [the measure _ _ of mrestr m2 (F_oo n).1].
have m2Fn_bounded : exists M, forall X, measurable X -&gt; (m2Fn X &lt; M%:E)%E.
  exists (fine (m2Fn (F n)) + 1) =&gt; Y mY.
  rewrite [in ltRHS]EFinD lte_spadder// fineK; last first.
    by rewrite ge0_fin_numE ?measure_ge0//= /mrestr/= setIid.
  by rewrite /= /mrestr/= setIid le_measure// inE//; exact: measurableI.
pose phi' A := m2Fn \o xsection A.
pose B' := [set A | measurable A /\ measurable_fun setT (phi' A)].
have subset_B' : measurable `&lt;=` B' by exact: measurable_prod_subset_xsection.
split=&gt; [|_ Y mY]; first by apply: measurableI =&gt; //; exact: measurableM.
have [_ /(_ measurableT Y mY)] := subset_B' X mX.
have -&gt;// : phi' X = m2 \o xsection (X `&amp;` setT `*` F n).
by apply/funext =&gt; x/=; rewrite /phi' setTM xsectionI xsection_preimage_snd.
Qed.
End measurable_fun_xsection.
Section measurable_fun_ysection.
Context d1 d2 (T1 : measurableType d1) (T2 : measurableType d2) (R : realType).
Variable m1 : {sigma_finite_measure set T1 -&gt; \bar R}.
Implicit Types A : set (T1 * T2).
Let phi A := m1 \o ysection A.
Let B := [set A | measurable A /\ measurable_fun setT (phi A)].
Lemma measurable_fun_ysection A : measurable A -&gt; measurable_fun setT (phi A).
Proof.
move: A; suff : measurable `&lt;=` B by move=&gt; + A =&gt; /[apply] -[].
have /sigma_finiteP[F F_T [F_nd F_oo]] := sigma_finiteT m1 =&gt; X mX.
have -&gt; : X = \bigcup_n (X `&amp;` (F n `*` setT)).
  by rewrite -setI_bigcupr -setM_bigcupl -F_T setMTT setIT.
apply: ysection_ndseq_closed.
  move=&gt; m n mn; apply/subsetPset; apply: setIS; apply: setSM =&gt; //.
  exact/subsetPset/F_nd.
move=&gt; n; have [? ?] := F_oo n; rewrite -/B.
pose m1Fn := [the measure _ _ of mrestr m1 (F_oo n).1].
have m1Fn_bounded : exists M, forall X, measurable X -&gt; (m1Fn X &lt; M%:E)%E.
  exists (fine (m1Fn (F n)) + 1) =&gt; Y mY.
  rewrite [in ltRHS]EFinD lte_spadder// fineK; last first.
    by rewrite ge0_fin_numE ?measure_ge0// /m1Fn/= /mrestr setIid.
  by rewrite /m1Fn/= /mrestr setIid le_measure// inE//=; exact: measurableI.
pose psi' A := m1Fn \o ysection A.
pose B' := [set A | measurable A /\ measurable_fun setT (psi' A)].
have subset_B' : measurable `&lt;=` B' by exact: measurable_prod_subset_ysection.
split=&gt; [|_ Y mY]; first by apply: measurableI =&gt; //; exact: measurableM.
have [_ /(_ measurableT Y mY)] := subset_B' X mX.
have -&gt;// : psi' X = m1 \o (ysection (X `&amp;` F n `*` setT)).
by apply/funext =&gt; y/=; rewrite /psi' setMT ysectionI// ysection_preimage_fst.
Qed.
End measurable_fun_ysection.
Section product_measures.
Context d1 d2 (T1 : measurableType d1) (T2 : measurableType d2) (R : realType).
Context (m1 : {measure set T1 -&gt; \bar R}) (m2 : {measure set T2 -&gt; \bar R}).
Definition product_measure1 := (fun A =&gt; \int[m1]_x (m2 \o xsection A) x)%E.
Definition product_measure2 := (fun A =&gt; \int[m2]_x (m1 \o ysection A) x)%E.
End product_measures.
Notation "m1 '\x' m2" := (product_measure1 m1 m2) : ereal_scope.
Notation "m1 '\x^' m2" := (product_measure2 m1 m2) : ereal_scope.
Section product_measure1.
Local Open Scope ereal_scope.
Context d1 d2 (T1 : measurableType d1) (T2 : measurableType d2) (R : realType).
Variable m1 : {measure set T1 -&gt; \bar R}.
Variable m2 : {sigma_finite_measure set T2 -&gt; \bar R}.
Implicit Types A : set (T1 * T2).
Let pm10 : (m1 \x m2) set0 = 0.
Proof. by rewrite [LHS]integral0_eq// =&gt; x/= _; rewrite xsection0 measure0. Qed.
Let pm1_ge0 A : 0 &lt;= (m1 \x m2) A.
Proof.
by apply: integral_ge0 =&gt; // *; exact/measure_ge0/measurable_xsection.
Qed.
Let pm1_sigma_additive : semi_sigma_additive (m1 \x m2).
Proof.
move=&gt; F mF tF mUF.
rewrite [X in _ --&gt; X](_ : _ = \sum_(n &lt;oo) (m1 \x m2) (F n)).
  apply/cvg_closeP; split; last by rewrite closeE.
  by apply: is_cvg_nneseries =&gt; *; exact: integral_ge0.
rewrite -integral_nneseries//; last by move=&gt; n; exact: measurable_fun_xsection.
apply: eq_integral =&gt; x _; apply/esym/cvg_lim =&gt; //=; rewrite xsection_bigcup.
apply: (measure_sigma_additive _ (trivIset_xsection tF)) =&gt; ?.
exact: measurable_xsection.
Qed.
HB.instance Definition _ := isMeasure.Build _ _ _ (m1 \x m2)
  pm10 pm1_ge0 pm1_sigma_additive.
End product_measure1.
Section product_measure1E.
Local Open Scope ereal_scope.
Context d1 d2 (T1 : measurableType d1) (T2 : measurableType d2) (R : realType).
Variable m1 : {measure set T1 -&gt; \bar R}.
Variable m2 : {sigma_finite_measure set T2 -&gt; \bar R}.
Implicit Types A : set (T1 * T2).
Lemma product_measure1E (A1 : set T1) (A2 : set T2) :
  measurable A1 -&gt; measurable A2 -&gt; (m1 \x m2) (A1 `*` A2) = m1 A1 * m2 A2.
Proof.
move=&gt; mA1 mA2 /=; rewrite /product_measure1 /=.
rewrite (eq_integral (fun x =&gt; m2 A2 * (\1_A1 x)%:E)); last first.
  by move=&gt; x _; rewrite indicE; have [xA1|xA1] /= := boolP (x \in A1);
    [rewrite in_xsectionM// mule1|rewrite mule0 notin_xsectionM].
rewrite ge0_integralZl//; last by move=&gt; x _; rewrite lee_fin.
- by rewrite muleC integral_indic// setIT.
- exact: measurableT_comp.
Qed.
End product_measure1E.
Section product_measure_unique.
Local Open Scope ereal_scope.
Context d1 d2 (T1 : measurableType d1) (T2 : measurableType d2) (R : realType).
Variable m1 : {sigma_finite_measure set T1 -&gt; \bar R}.
Variable m2 : {sigma_finite_measure set T2 -&gt; \bar R}.
Lemma product_measure_unique
    (m' : {measure set [the semiRingOfSetsType _ of T1 * T2] -&gt; \bar R}) :
    (forall A1 A2, measurable A1 -&gt; measurable A2 -&gt;
      m' (A1 `*` A2) = m1 A1 * m2 A2) -&gt;
  forall X : set (T1 * T2), measurable X -&gt; (m1 \x m2) X = m' X.
Proof.
move=&gt; m'E; pose m := product_measure1 m1 m2.
have /sigma_finiteP [F1 F1_T [F1_nd F1_oo]] := sigma_finiteT m1.
have /sigma_finiteP [F2 F2_T [F2_nd F2_oo]] := sigma_finiteT m2.
have UF12T : \bigcup_k (F1 k `*` F2 k) = setT.
  rewrite -setMTT F1_T F2_T predeqE =&gt; -[x y]; split.
    by move=&gt; [n _ []/= ? ?]; split; exists n.
  move=&gt; [/= [n _ F1nx] [k _ F2ky]]; exists (maxn n k) =&gt; //; split.
  - by move: x F1nx; apply/subsetPset/F1_nd; rewrite leq_maxl.
  - by move: y F2ky; apply/subsetPset/F2_nd; rewrite leq_maxr.
have mF1F2 n : measurable (F1 n `*` F2 n) /\ m (F1 n `*` F2 n) &lt; +oo.
  have [? ?] := F1_oo n; have [? ?] := F2_oo n.
  split; first exact: measurableM.
  by rewrite /m product_measure1E // lte_mul_pinfty// ge0_fin_numE.
have sm : sigma_finite setT m by exists (fun n =&gt; F1 n `*` F2 n).
pose C : set (set (T1 * T2)) := [set C |
  exists A1, measurable A1 /\ exists A2, measurable A2 /\ C = A1 `*` A2].
have CI : setI_closed C.
  move=&gt; /= _ _ [X1 [mX1 [X2 [mX2 -&gt;]]]] [Y1 [mY1 [Y2 [mY2 -&gt;]]]].
  rewrite -setMI; exists (X1 `&amp;` Y1); split; first exact: measurableI.
  by exists (X2 `&amp;` Y2); split =&gt; //; exact: measurableI.
move=&gt; X mX; apply: (measure_unique C (fun n =&gt; F1 n `*` F2 n)) =&gt; //.
- rewrite measurable_prod_measurableType //; congr (&lt;&lt;s _ &gt;&gt;).
  rewrite predeqE; split =&gt; [[A1 mA1 [A2 mA2 &lt;-]]|[A1 [mA1 [A2 [mA2 -&gt;]]]]].
    by exists A1; split =&gt; //; exists A2; split.
  by exists A1 =&gt; //; exists A2.
- move=&gt; n; rewrite /C /=; exists (F1 n); split; first by have [] := F1_oo n.
  by exists (F2 n); split =&gt; //; have [] := F2_oo n.
- by move=&gt; A [A1 [mA1 [A2 [mA2 -&gt;]]]]; rewrite m'E//= product_measure1E.
- move=&gt; k; have [? ?] := F1_oo k; have [? ?] := F2_oo k.
  by rewrite /= product_measure1E// lte_mul_pinfty// ge0_fin_numE.
Qed.
End product_measure_unique.
Section product_measure2.
Local Open Scope ereal_scope.
Context d1 d2 (T1 : measurableType d1) (T2 : measurableType d2) (R : realType).
Variable m1 : {sigma_finite_measure set T1 -&gt; \bar R}.
Variable m2 : {measure set T2 -&gt; \bar R}.
Implicit Types A : set (T1 * T2).
Let pm20 : (m1 \x^ m2) set0 = 0.
Proof.
by rewrite /(_ \x^ _) integral0_eq// =&gt; y/= _; rewrite ysection0 measure0.
Qed.
Let pm2_ge0 A : 0 &lt;= (m1 \x^ m2) A.
Proof.
by apply: integral_ge0 =&gt; // *; exact/measure_ge0/measurable_ysection.
Qed.
Let pm2_sigma_additive : semi_sigma_additive (m1 \x^ m2).
Proof.
move=&gt; F mF tF mUF.
rewrite [X in _ --&gt; X](_ : _ = \sum_(n &lt;oo) (m1 \x^ m2) (F n)).
  apply/cvg_closeP; split; last by rewrite closeE.
  by apply: is_cvg_nneseries =&gt; *; exact: integral_ge0.
rewrite -integral_nneseries//; last first.
  by move=&gt; n; apply: measurable_fun_ysection =&gt; //; rewrite inE.
apply: eq_integral =&gt; y _; apply/esym/cvg_lim =&gt; //=; rewrite ysection_bigcup.
apply: (measure_sigma_additive _ (trivIset_ysection tF)) =&gt; ?.
exact: measurable_ysection.
Qed.
HB.instance Definition _ := isMeasure.Build _ _ _ (m1 \x^ m2)
  pm20 pm2_ge0 pm2_sigma_additive.
End product_measure2.
Section product_measure2E.
Local Open Scope ereal_scope.
Context d1 d2 (T1 : measurableType d1) (T2 : measurableType d2) (R : realType).
Variable m1 : {sigma_finite_measure set T1 -&gt; \bar R}.
Variable m2 : {measure set T2 -&gt; \bar R}.
Lemma product_measure2E (A1 : set T1) (A2 : set T2)
    (mA1 : measurable A1) (mA2 : measurable A2) :
  (m1 \x^ m2) (A1 `*` A2) = m1 A1 * m2 A2.
Proof.
have mA1A2 : measurable (A1 `*` A2) by apply: measurableM.
transitivity (\int[m2]_y (m1 \o ysection (A1 `*` A2)) y) =&gt; //.
rewrite (_ : _ \o _ = fun y =&gt; m1 A1 * (\1_A2 y)%:E).
  rewrite ge0_integralZl//; last 2 first.
    - exact: measurableT_comp.
    - by move=&gt; y _; rewrite lee_fin.
  by rewrite integral_indic ?setIT ?mul1e.
rewrite funeqE =&gt; y; rewrite indicE.
have [yA2|yA2] := boolP (y \in A2); first by rewrite mule1 /= in_ysectionM.
by rewrite mule0 /= notin_ysectionM.
Qed.
End product_measure2E.
Section simple_density_L1.
Context d (T : measurableType d) (R : realType).
Variables (mu : {measure set T -&gt; \bar R}) (E : set T) (mE : measurable E).
Local Open Scope ereal_scope.
Lemma measurable_bounded_integrable (f : T -&gt; R^o)  :
  mu E &lt; +oo -&gt; measurable_fun E f -&gt;
  [bounded f x | x in E] -&gt; mu.-integrable E (EFin \o f).
Proof.
move=&gt; Afin mfA bdA; apply/integrableP; split; first exact/EFin_measurable_fun.
have [M [_ mrt]] := bdA; apply: le_lt_trans.
  apply: (integral_le_bound (`|M| + 1)%:E) =&gt; //; first exact: measurableT_comp.
  by apply: aeW =&gt; z Az; rewrite lee_fin mrt// ltr_spaddr// ler_norm.
by rewrite lte_mul_pinfty.
Qed.
Let sfun_dense_L1_pos (f : T -&gt; \bar R) :
  mu.-integrable E f -&gt; (forall x, E x -&gt; 0 &lt;= f x) -&gt;
  exists g_ : {sfun T &gt;-&gt; R}^nat,
    [/\ forall n, mu.-integrable E (EFin \o g_ n),
        forall x, E x -&gt; EFin \o g_^~ x @ \oo --&gt; f x &amp;
        (fun n =&gt; \int[mu]_(z in E) `|f z - (g_ n z)%:E|) --&gt; 0].
Proof.
move=&gt; intf fpos; case/integrableP: (intf) =&gt; mfE _.
pose g_ n := nnsfun_approx mE mfE n.
have [] // := @dominated_convergence _ _ _ mu _ mE (fun n =&gt; EFin \o g_ n) f f.
- by move=&gt; ?; apply/EFin_measurable_fun/measurable_funTS.
- apply: aeW =&gt; ? ?; under eq_fun =&gt; ? do rewrite /g_ nnsfun_approxE.
  exact: ecvg_approx.
- apply: aeW =&gt; /= ? ? ?; rewrite ger0_norm // /g_ nnsfun_approxE.
  exact: le_approx.
move=&gt; _ /= fg0 gfcvg; exists g_; split.
- move=&gt; n; apply: (le_integrable mE _ _ intf).
    exact/EFin_measurable_fun/measurable_funTS.
  move=&gt; ? ?; rewrite /g_ !gee0_abs ?lee_fin//; last exact: fpos.
  by rewrite /= nnsfun_approxE le_approx.
- exact: cvg_nnsfun_approx.
- by apply: cvg_trans fg0; under eq_fun =&gt; ? do under eq_fun =&gt; t do
     rewrite EFinN -[_ - _]oppeK fin_num_oppeB // abseN addeC.
Qed.
Lemma approximation_sfun_integrable (f : T -&gt; \bar R):
  mu.-integrable E f -&gt;
  exists g_ : {sfun T &gt;-&gt; R}^nat,
    [/\ forall n, mu.-integrable E (EFin \o g_ n),
        forall x, E x -&gt; EFin \o g_^~ x @ \oo --&gt; f x &amp;
        (fun n =&gt; \int[mu]_(z in E) `|f z - (g_ n z)%:E|) --&gt; 0].
Proof.
move=&gt; intf.
have [//|p_ [intp pf pl1]] := sfun_dense_L1_pos (integrable_funepos mE intf).
have [//|n_ [intn nf nl1]] := sfun_dense_L1_pos (integrable_funeneg mE intf).
exists (fun n =&gt; p_ n - n_ n)%R; split.
- move=&gt; n; rewrite /comp; under eq_fun =&gt; ? do rewrite sfunB /= EFinB.
  by apply: integrableB =&gt; //; [exact: intp | exact: intn].
- move=&gt; ? ?; rewrite /comp; under eq_fun =&gt; ? do rewrite sfunB /= EFinB.
  rewrite [f]funeposneg; apply: cvgeB =&gt; //;[|exact: pf|exact:nf].
  exact: add_def_funeposneg.
have fpn z n : f z - ((p_ n - n_ n) z)%:E =
    (f^\+ z - (p_ n z)%:E) - (f^\- z - (n_ n z)%:E).
  rewrite sfunB EFinB fin_num_oppeB // {1}[f]funeposneg -addeACA.
  by congr (_ _); rewrite fin_num_oppeB.
case/integrableP: (intf) =&gt; mf _.
have mfpn n : mu.-integrable E (fun z =&gt; f z - ((p_ n - n_ n) z)%:E).
  under eq_fun =&gt; ? do rewrite fpn; apply: integrableB =&gt; //.
    by apply: integrableB =&gt; //; [exact: integrable_funepos | exact: intp].
  by apply: integrableB =&gt; //; [exact: integrable_funeneg | exact: intn].
apply/fine_cvgP; split =&gt; //.
  near=&gt; N; case/integrableP: (mfpn N) =&gt; _; rewrite ge0_fin_numE //.
  exact: integral_ge0.
apply/cvg_ballP=&gt; _/posnumP[eps]; have e2p : (0 &lt; eps%:num/2)%R by [].
case/fine_cvgP: pl1 =&gt; + /cvg_ballP/(_ _ e2p); apply: filter_app2.
case/fine_cvgP: nl1 =&gt; + /cvg_ballP/(_ _ e2p); apply: filter_app2.
near=&gt; n; rewrite /ball /=; do 3 rewrite distrC subr0.
move=&gt; finfn ne2 finfp pe2; rewrite [_%:num]splitr.
rewrite (le_lt_trans _ (ltr_add pe2 ne2))// (le_trans _ (ler_norm_add _ _))//.
under [fun z =&gt; _ (f^\+ z + _)]eq_fun =&gt; ? do rewrite EFinN.
under [fun z =&gt; _ (f^\- z + _)]eq_fun =&gt; ? do rewrite EFinN.
have mfp : mu.-integrable E (fun z =&gt; `|f^\+ z - (p_ n z)%:E|).
  apply/integrable_abse/integrableB =&gt; //; first exact: integrable_funepos.
  exact: intp.
have mfn : mu.-integrable E (fun z =&gt; `|f^\- z - (n_ n z)%:E|).
  apply/integrable_abse/integrableB =&gt; //; first exact: integrable_funeneg.
  exact: intn.
rewrite -[x in (_ &lt;= `|x|)%R]fineD // -integralD //.
rewrite !ger0_norm ?fine_ge0 ?integral_ge0 ?fine_le//.
- by apply: integral_fune_fin_num =&gt; //; exact/integrable_abse/mfpn.
- by apply: integral_fune_fin_num =&gt; //; exact: integrableD.
- apply: ge0_le_integral =&gt; //.
  + by apply: measurableT_comp =&gt; //; case/integrableP: (mfpn n).
  + by apply: emeasurable_funD; [move: mfp | move: mfn]; case/integrableP.
  + by move=&gt; ? ?; rewrite fpn; exact: lee_abs_sub.
Unshelve. all: by end_near. Qed.
End simple_density_L1.
Section continuous_density_L1.
Context (rT : realType).
Let mu := [the measure _ _ of @lebesgue_measure rT].
Let R  := [the measurableType _ of measurableTypeR rT].
Local Open Scope ereal_scope.
Lemma compact_finite_measure (A : set R^o) : compact A -&gt; mu A &lt; +oo.
Proof.
move=&gt; /[dup]/compact_measurable =&gt; mA /compact_bounded[N [_ N1x]].
have AN1 : (A `&lt;=` `[- (`|N| + 1), `|N| + 1])%R.
  by move=&gt; z Az; rewrite set_itvcc /= -ler_norml N1x// ltr_spaddr// ler_norm.
rewrite (le_lt_trans (le_measure _ _ _ AN1)) ?inE//=.
by rewrite lebesgue_measure_itv/= lte_fin gtr_opp// EFinD ltry.
Qed.
Lemma continuous_compact_integrable (f : R -&gt; R^o) (A : set R^o) :
  compact A -&gt; {within A, continuous f} -&gt; mu.-integrable A (EFin \o f).
Proof.
move=&gt; cptA ctsfA; apply: measurable_bounded_integrable.
- exact: compact_measurable.
- exact: compact_finite_measure.
- by apply: subspace_continuous_measurable_fun =&gt; //; exact: compact_measurable.
- have /compact_bounded[M [_ mrt]] := continuous_compact ctsfA cptA.
  by exists M; split; rewrite ?num_real // =&gt; ? ? ? ?; exact: mrt.
Qed.
Lemma approximation_continuous_integrable (E : set R) (f : R -&gt; R^o):
  measurable E -&gt; mu E &lt; +oo -&gt; mu.-integrable E (EFin \o f) -&gt;
  exists g_ : (rT -&gt; rT)^nat,
    [/\ forall n, continuous (g_ n),
        forall n, mu.-integrable E (EFin \o g_ n) &amp;
        (fun n =&gt; \int[mu]_(z in E) `|(f z - g_ n z)%:E|) --&gt; 0].
Proof.
move=&gt; mE Efin intf.
have mf : measurable_fun E f by case/integrableP : intf =&gt; /EFin_measurable_fun.
suff apxf eps : exists h : rT -&gt; rT, (eps &gt; 0)%R -&gt;
    [/\ continuous h,
        mu.-integrable E (EFin \o h) &amp;
        \int[mu]_(z in E) `|(f z - h z)%:E| &lt; eps%:E].
  pose g_ n := projT1 (cid (apxf n.+1%:R^-1)); exists g_; split.
  - by move=&gt; n; have [] := projT2 (cid (apxf n.+1%:R^-1)).
  - by move=&gt; n; have [] := projT2 (cid (apxf n.+1%:R^-1)).
  apply/cvg_ballP =&gt; eps epspos.
  have /cvg_ballP/(_ eps epspos)[N _ Nball] := @cvge_harmonic rT.
  exists N =&gt; //; apply: (subset_trans Nball) =&gt; n.
  rewrite /ball /= /ereal_ball contract0 !sub0r !normrN =&gt; /(lt_trans _); apply.
  rewrite ?ger0_norm; first last.
  - by rewrite -le_expandLR // ?inE ?normr0// expand0 integral_ge0.
  - by rewrite -le_expandLR // ?inE ?normr0// expand0.
  have [] := projT2 (cid (apxf n.+1%:R^-1)) =&gt; // _ _ ipaxfn.
  by rewrite -lt_expandRL ?contractK// inE contract_le1.
have [|] := ltP 0%R eps; last by exists point.
move: eps =&gt; _/posnumP[eps].
have [g [gfe2 ig]] : exists g : {sfun R &gt;-&gt; rT},
    \int[mu]_(z in E) `|(f z - g z)%:E| &lt; (eps%:num / 2)%:E /\
    mu.-integrable E (EFin \o g).
  have [g_ [intG ?]] := approximation_sfun_integrable mE intf.
  move/fine_fcvg/cvg_ballP/(_ (eps%:num / 2)) =&gt; -[] // n _ Nb; exists (g_ n).
  have fg_fin_num : \int[mu]_(z in E) `|(f z - g_ n z)%:E| \is a fin_num.
    rewrite integral_fune_fin_num// integrable_abse//.
    by under eq_fun do rewrite EFinB; apply: integrableB =&gt; //; exact: intG.
  split; last exact: intG.
  have /= := Nb _ (leqnn n); rewrite /ball/= sub0r normrN -fine_abse// -lte_fin.
  by rewrite fineK ?abse_fin_num// =&gt; /le_lt_trans; apply; exact: lee_abs.
have mg : measurable_fun E g.
  by apply: (measurable_funS measurableT) =&gt; //; exact: measurable_funP.
have [M Mpos Mbd] : (exists2 M, 0 &lt; M &amp; forall x, `|g x| &lt;= M)%R.
  have [M [_ /= bdM]] := simple_bounded g.
  exists (`|M| + 1)%R; first exact: ltr_spaddr.
  by move=&gt; x; rewrite bdM// ltr_spaddr// ler_norm.
have [] // := @measurable_almost_continuous _ _ mE _ g (eps%:num / 2 / (M *+ 2)).
  by rewrite divr_gt0// mulrn_wgt0.
move=&gt; A [cptA AE /= muAE ctsAF].
have [] := continuous_bounded_extension _ _ Mpos ctsAF.
- exact: pseudometric_normal.
- by apply: compact_closed =&gt; //; exact: Rhausdorff.
- by move=&gt; ? ?; exact: Mbd.
have mA : measurable A := compact_measurable cptA.
move=&gt; h [gh ctsh hbdM]; have mh : measurable_fun E h.
  by apply: subspace_continuous_measurable_fun=&gt; //; exact: continuous_subspaceT.
have intg : mu.-integrable E (EFin \o h).
  apply: measurable_bounded_integrable =&gt; //.
  exists M; split; rewrite ?num_real // =&gt; x Mx y _ /=.
  by rewrite (le_trans _ (ltW Mx)).
exists h; split =&gt; //; rewrite [eps%:num]splitr; apply: le_lt_trans.
  pose fgh x := `|(f x - g x)%:E| + `|(g x - h x)%:E|.
  apply: (@ge0_le_integral _ _ _ mu _ mE _ fgh) =&gt; //.
  - apply: (measurable_funS mE) =&gt; //; do 2 apply: measurableT_comp =&gt; //.
    exact: measurable_funB.
  - by move=&gt; z _; rewrite /fgh.
  - apply: measurableT_comp =&gt; //; apply: measurable_funD =&gt; //;
      apply: (measurable_funS mE) =&gt; //; (apply: measurableT_comp =&gt; //);
      exact: measurable_funB.
  - move=&gt; x _; rewrite -(subrK (g x) (f x)) -(addrA (_ + _)%R) lee_fin.
    by rewrite ler_norm_add.
rewrite integralD//; first last.
- by apply: integrable_abse; under eq_fun do rewrite EFinB; apply: integrableB.
- by apply: integrable_abse; under eq_fun do rewrite EFinB; apply: integrableB.
rewrite EFinD lte_add// -(setDKU AE) integral_setU =&gt; //; first last.
- by rewrite /disj_set setDKI.
- rewrite setDKU //; do 2 apply: measurableT_comp =&gt; //.
  exact: measurable_funB.
- exact: measurableD.
rewrite (@ae_eq_integral _ _ _ mu A (cst 0)) //; first last.
- by apply: aeW =&gt; z Az; rewrite (gh z) ?inE// subrr abse0.
- apply: (measurable_funS mE) =&gt; //; do 2 apply: measurableT_comp =&gt; //.
  exact: measurable_funB.
rewrite integral0 adde0.
apply: (le_lt_trans (integral_le_bound (M *+ 2)%:E _ _ _ _)) =&gt; //.
- exact: measurableD.
- apply: (measurable_funS mE) =&gt; //; apply: measurableT_comp =&gt; //.
  exact: measurable_funB.
- by rewrite lee_fin mulrn_wge0// ltW.
- apply: aeW =&gt; z [Ez _]; rewrite /= lee_fin mulr2n.
  by rewrite (le_trans (ler_norm_sub _ _))// ler_add.
by rewrite -lte_pdivl_mull ?mulrn_wgt0// muleC -EFinM.
Qed.
End continuous_density_L1.
Section fubini_functions.
Local Open Scope ereal_scope.
Context d1 d2 (T1 : measurableType d1) (T2 : measurableType d2) (R : realType).
Variables (m1 : {measure set T1 -&gt; \bar R}) (m2 : {measure set T2 -&gt; \bar R}).
Variable f : T1 * T2 -&gt; \bar R.
Definition fubini_F x := \int[m2]_y f (x, y).
Definition fubini_G y := \int[m1]_x f (x, y).
End fubini_functions.
Section fubini_tonelli.
Local Open Scope ereal_scope.
Context d1 d2 (T1 : measurableType d1) (T2 : measurableType d2) (R : realType).
Variable m1 : {sigma_finite_measure set T1 -&gt; \bar R}.
Variable m2 : {sigma_finite_measure set T2 -&gt; \bar R}.
Section indic_fubini_tonelli.
Variables (A : set (T1 * T2)) (mA : measurable A).
Implicit Types A : set (T1 * T2).
Let f : (T1 * T2) -&gt; R := \1_A.
Let F := fubini_F m2 (EFin \o f).
Let G := fubini_G m1 (EFin \o f).
Lemma indic_fubini_tonelli_F_ge0 x : 0 &lt;= F x.
Proof. by apply: integral_ge0 =&gt; // y _; rewrite lee_fin. Qed.
Lemma indic_fubini_tonelli_G_ge0 x : 0 &lt;= G x.
Proof. by apply: integral_ge0 =&gt; // y _; rewrite lee_fin. Qed.
Lemma indic_fubini_tonelli_FE : F = m2 \o xsection A.
Proof.
rewrite funeqE =&gt; x; rewrite /= -(setTI (xsection _ _)).
rewrite -integral_indic//; last exact: measurable_xsection.
rewrite /F /fubini_F -(setTI (xsection _ _)).
rewrite integral_setI_indic; [|exact: measurable_xsection|by []].
by apply: eq_integral =&gt; y _ /=; rewrite indicT mul1e /f !indicE mem_xsection.
Qed.
Lemma indic_fubini_tonelli_GE : G = m1 \o ysection A.
Proof.
rewrite funeqE =&gt; y; rewrite /= -(setTI (ysection _ _)).
rewrite -integral_indic//; last exact: measurable_ysection.
rewrite /F /fubini_F -(setTI (ysection _ _)).
rewrite integral_setI_indic; [|exact: measurable_ysection|by []].
by apply: eq_integral =&gt; x _ /=; rewrite indicT mul1e /f 2!indicE mem_ysection.
Qed.
Lemma indic_measurable_fun_fubini_tonelli_F : measurable_fun setT F.
Proof.
by rewrite indic_fubini_tonelli_FE//; exact: measurable_fun_xsection.
Qed.
Lemma indic_measurable_fun_fubini_tonelli_G : measurable_fun setT G.
Proof.
by rewrite indic_fubini_tonelli_GE//; exact: measurable_fun_ysection.
Qed.
Lemma indic_fubini_tonelli1 : \int[m1 \x m2]_z (f z)%:E = \int[m1]_x F x.
Proof. by rewrite /f integral_indic// setIT indic_fubini_tonelli_FE. Qed.
Lemma indic_fubini_tonelli2 : \int[m1 \x^ m2]_z (f z)%:E = \int[m2]_y G y.
Proof. by rewrite /f integral_indic// setIT indic_fubini_tonelli_GE. Qed.
Lemma indic_fubini_tonelli : \int[m1]_x F x = \int[m2]_y G y.
Proof.
rewrite -indic_fubini_tonelli1// -indic_fubini_tonelli2// integral_indic//=.
rewrite integral_indic//= !setIT.
by apply: product_measure_unique =&gt; //= ? ? ? ?; rewrite product_measure2E.
Qed.
End indic_fubini_tonelli.
Section sfun_fubini_tonelli.
Variable f : {nnsfun [the measurableType _ of T1 * T2 : Type] &gt;-&gt; R}.
Let F := fubini_F m2 (EFin \o f).
Let G := fubini_G m1 (EFin \o f).
Lemma sfun_fubini_tonelli_FE : F = fun x =&gt;
  \sum_(k \in range f) k%:E * m2 (xsection (f @^-1` [set k]) x).
Proof.
rewrite funeqE =&gt; x; rewrite /F /fubini_F [in LHS]/=.
under eq_fun do rewrite fimfunE -fsumEFin//.
rewrite ge0_integral_fsum //; last 2 first.
  - move=&gt; i; apply/EFin_measurable_fun/measurableT_comp =&gt; //=.
    exact: measurableT_comp.
  - by move=&gt; r y _; rewrite EFinM nnfun_muleindic_ge0.
apply: eq_fsbigr =&gt; i; rewrite inE =&gt; -[/= t _ &lt;-{i}].
under eq_fun do rewrite EFinM.
rewrite ge0_integralZl//; last by rewrite lee_fin.
- by rewrite -/((m2 \o xsection _) x) -indic_fubini_tonelli_FE.
- exact/EFin_measurable_fun/measurableT_comp.
- by move=&gt; y _; rewrite lee_fin.
Qed.
Lemma sfun_measurable_fun_fubini_tonelli_F : measurable_fun setT F.
Proof.
rewrite sfun_fubini_tonelli_FE//; apply: emeasurable_fun_fsum =&gt; // r.
exact/measurable_funeM/measurable_fun_xsection.
Qed.
Lemma sfun_fubini_tonelli_GE : G = fun y =&gt;
  \sum_(k \in range f) k%:E * m1 (ysection (f @^-1` [set k]) y).
Proof.
rewrite funeqE =&gt; y; rewrite /G /fubini_G [in LHS]/=.
under eq_fun do rewrite fimfunE -fsumEFin//.
rewrite ge0_integral_fsum //; last 2 first.
  - move=&gt; i; apply/EFin_measurable_fun/measurableT_comp =&gt; //=.
    exact: measurableT_comp.
  - by move=&gt; r x _; rewrite EFinM nnfun_muleindic_ge0.
apply: eq_fsbigr =&gt; i; rewrite inE =&gt; -[/= t _ &lt;-{i}].
under eq_fun do rewrite EFinM.
rewrite ge0_integralZl//; last by rewrite lee_fin.
- by rewrite -/((m1 \o ysection _) y) -indic_fubini_tonelli_GE.
- exact/EFin_measurable_fun/measurableT_comp.
- by move=&gt; x _; rewrite lee_fin.
Qed.
Lemma sfun_measurable_fun_fubini_tonelli_G : measurable_fun setT G.
Proof.
rewrite sfun_fubini_tonelli_GE//; apply: emeasurable_fun_fsum =&gt; // r.
exact/measurable_funeM/measurable_fun_ysection.
Qed.
Let EFinf x : (f x)%:E =
  \sum_(k \in range f) k%:E * (\1_(f @^-1` [set k]) x)%:E.
Proof. by rewrite fsumEFin //= fimfunE. Qed.
Lemma sfun_fubini_tonelli1 : \int[m1 \x m2]_z (f z)%:E = \int[m1]_x F x.
Proof.
under [LHS]eq_integral
  do rewrite EFinf; rewrite ge0_integral_fsum //; last 2 first.
  - move=&gt; r.
    apply/EFin_measurable_fun/measurableT_comp =&gt; //=.
  - by move=&gt; r /= z _; exact: nnfun_muleindic_ge0.
transitivity (\sum_(k \in range f)
  \int[m1]_x (k%:E * (fubini_F m2 (EFin \o \1_(f @^-1` [set k])) x))).
  apply: eq_fsbigr =&gt; i; rewrite inE =&gt; -[z _ &lt;-{i}].
  rewrite ge0_integralZl//; last 3 first.
    - exact/EFin_measurable_fun.
    - by move=&gt; /= x _; rewrite lee_fin.
    - by rewrite lee_fin.
  rewrite indic_fubini_tonelli1// -ge0_integralZl//; last by rewrite lee_fin.
  - exact: indic_measurable_fun_fubini_tonelli_F.
  - by move=&gt; /= x _; exact: indic_fubini_tonelli_F_ge0.
rewrite -ge0_integral_fsum //; last 2 first.
  - by move=&gt; r; apply/measurable_funeM/indic_measurable_fun_fubini_tonelli_F.
  - move=&gt; r x _; rewrite /fubini_F.
    have [r0|r0] := leP 0%R r.
      by rewrite mule_ge0//; exact: indic_fubini_tonelli_F_ge0.
    by rewrite integral0_eq// =&gt; y _; rewrite preimage_nnfun0//= indicE in_set0.
apply: eq_integral =&gt; x _; rewrite sfun_fubini_tonelli_FE.
by under eq_fsbigr do rewrite indic_fubini_tonelli_FE//.
Qed.
Lemma sfun_fubini_tonelli2 : \int[m1 \x^ m2]_z (f z)%:E = \int[m2]_y G y.
Proof.
under [LHS]eq_integral
  do rewrite EFinf; rewrite ge0_integral_fsum //; last 2 first.
  - move=&gt; i.
  apply/EFin_measurable_fun/measurableT_comp =&gt; //=.
  - by move=&gt; r /= z _; exact: nnfun_muleindic_ge0.
transitivity (\sum_(k \in range f)
  \int[m2]_x (k%:E * (fubini_G m1 (EFin \o \1_(f @^-1` [set k])) x))).
  apply: eq_fsbigr =&gt; i; rewrite inE =&gt; -[z _ &lt;-{i}].
  rewrite ge0_integralZl//; last 3 first.
    - exact/EFin_measurable_fun.
    - by move=&gt; /= x _; rewrite lee_fin.
    - by rewrite lee_fin.
  rewrite indic_fubini_tonelli2// -ge0_integralZl//; last by rewrite lee_fin.
  - exact: indic_measurable_fun_fubini_tonelli_G.
  - by move=&gt; /= x _; exact: indic_fubini_tonelli_G_ge0.
rewrite -ge0_integral_fsum //; last 2 first.
  - by move=&gt; r; apply/measurable_funeM/indic_measurable_fun_fubini_tonelli_G.
  - move=&gt; r y _; rewrite /fubini_G.
    have [r0|r0] := leP 0%R r.
      by rewrite mule_ge0//; exact: indic_fubini_tonelli_G_ge0.
    by rewrite integral0_eq// =&gt; x _; rewrite preimage_nnfun0//= indicE in_set0.
apply: eq_integral =&gt; x _; rewrite sfun_fubini_tonelli_GE.
by under eq_fsbigr do rewrite indic_fubini_tonelli_GE//.
Qed.
Lemma sfun_fubini_tonelli :
  \int[m1 \x m2]_z (f z)%:E = \int[m1 \x^ m2]_z (f z)%:E.
Proof.
apply: eq_measure_integral =&gt; /= A Ameasurable _.
by apply: product_measure_unique =&gt; //= *; rewrite product_measure2E.
Qed.
End sfun_fubini_tonelli.
Section fubini_tonelli.
Variable f : T1 * T2 -&gt; \bar R.
Hypothesis mf : measurable_fun setT f.
Hypothesis f0 : forall x, 0 &lt;= f x.
Let T := [the measurableType _ of T1 * T2 : Type].
Let F := fubini_F m2 f.
Let G := fubini_G m1 f.
Let F_ (g : {nnsfun T &gt;-&gt; R}^nat) n x := \int[m2]_y (g n (x, y))%:E.
Let G_ (g : {nnsfun T &gt;-&gt; R}^nat) n y := \int[m1]_x (g n (x, y))%:E.
Lemma measurable_fun_fubini_tonelli_F : measurable_fun setT F.
Proof.
have [g [g_nd /= g_f]] := approximation measurableT mf (fun x _ =&gt; f0 x).
apply: (emeasurable_fun_cvg (F_ g)) =&gt; //.
- by move=&gt; n; exact: sfun_measurable_fun_fubini_tonelli_F.
- move=&gt; x _.
  rewrite /F_ /F /fubini_F [in X in _ --&gt; X](_ : (fun _ =&gt; _) =
      fun y =&gt; lim (EFin \o g ^~ (x, y))); last first.
    by rewrite funeqE =&gt; y; apply/esym/cvg_lim =&gt; //; exact: g_f.
  apply: cvg_monotone_convergence =&gt; //.
  - by move=&gt; n; apply/EFin_measurable_fun =&gt; //; exact/measurableT_comp.
  - by move=&gt; n y _; rewrite lee_fin//; exact: fun_ge0.
  - by move=&gt; y _ a b ab; rewrite lee_fin; exact/lefP/g_nd.
Qed.
Lemma measurable_fun_fubini_tonelli_G : measurable_fun setT G.
Proof.
have [g [g_nd /= g_f]] := approximation measurableT mf (fun x _ =&gt; f0 x).
apply: (emeasurable_fun_cvg (G_ g)) =&gt; //.
- by move=&gt; n; exact: sfun_measurable_fun_fubini_tonelli_G.
- move=&gt; y _; rewrite /G_ /G /fubini_G [in X in _ --&gt; X](_ : (fun _ =&gt; _) =
      fun x =&gt; lim (EFin \o g ^~ (x, y))); last first.
    by rewrite funeqE =&gt; x; apply/esym/cvg_lim =&gt; //; exact: g_f.
  apply: cvg_monotone_convergence =&gt; //.
  - by move=&gt; n; apply/EFin_measurable_fun =&gt; //; exact/measurableT_comp.
  - by move=&gt; n x _; rewrite lee_fin; exact: fun_ge0.
  - by move=&gt; x _ a b ab; rewrite lee_fin; exact/lefP/g_nd.
Qed.
Lemma fubini_tonelli1 : \int[m1 \x m2]_z f z = \int[m1]_x F x.
Proof.
have [g [g_nd /= g_f]] := approximation measurableT mf (fun x _ =&gt; f0 x).
have F_F x : F x = lim (F_ g ^~ x).
  rewrite [RHS](_ : _ = lim (fun n =&gt; \int[m2]_y (EFin \o g n) (x, y)))//.
  rewrite -monotone_convergence//; last 3 first.
    - by move=&gt; n; exact/EFin_measurable_fun/measurableT_comp.
    - by move=&gt; n /= y _; rewrite lee_fin; exact: fun_ge0.
    - by move=&gt; y /= _ a b; rewrite lee_fin =&gt; /g_nd/lefP; exact.
  by apply: eq_integral =&gt; y _; apply/esym/cvg_lim =&gt; //; exact: g_f.
rewrite [RHS](_ : _ = lim (fun n =&gt; \int[m1 \x m2]_z (EFin \o g n) z)).
  rewrite -monotone_convergence //; last 3 first.
    - by move=&gt; n; exact/EFin_measurable_fun.
    - by move=&gt; n /= x _; rewrite lee_fin; exact: fun_ge0.
    - by move=&gt; y /= _ a b; rewrite lee_fin =&gt; /g_nd/lefP; exact.
  by apply: eq_integral =&gt; /= x _; apply/esym/cvg_lim =&gt; //; exact: g_f.
rewrite [LHS](_ : _ =
    lim (fun n =&gt; \int[m1]_x (\int[m2]_y (EFin \o g n) (x, y)))).
  by congr (lim _); rewrite funeqE =&gt; n; rewrite sfun_fubini_tonelli1.
rewrite [RHS](_ : _ = lim (fun n =&gt; \int[m1]_x F_ g n x))//.
rewrite -monotone_convergence //; first exact: eq_integral.
- by move=&gt; n; exact: sfun_measurable_fun_fubini_tonelli_F.
- move=&gt; n x _; apply: integral_ge0 =&gt; // y _ /=; rewrite lee_fin.
  exact: fun_ge0.
- move=&gt; x /= _ a b ab; apply: ge0_le_integral =&gt; //.
  + by move=&gt; y _; rewrite lee_fin; exact: fun_ge0.
  + exact/EFin_measurable_fun/measurableT_comp.
  + by move=&gt; *; rewrite lee_fin; exact: fun_ge0.
  + exact/EFin_measurable_fun/measurableT_comp.
  + by move=&gt; y _; rewrite lee_fin; move/g_nd : ab =&gt; /lefP; exact.
Qed.
Lemma fubini_tonelli2 : \int[m1 \x m2]_z f z = \int[m2]_y G y.
Proof.
have [g [g_nd /= g_f]] := approximation measurableT mf (fun x _ =&gt; f0 x).
have G_G y : G y = lim (G_ g ^~ y).
  rewrite /G /fubini_G.
  rewrite [RHS](_ : _ = lim (fun n =&gt; \int[m1]_x (EFin \o g n) (x, y)))//.
  rewrite -monotone_convergence//; last 3 first.
    - by move=&gt; n; exact/EFin_measurable_fun/measurableT_comp.
    - by move=&gt; n /= x _; rewrite lee_fin; exact: fun_ge0.
    - by move=&gt; x /= _ a b; rewrite lee_fin =&gt; /g_nd/lefP; exact.
  by apply: eq_integral =&gt; x _; apply/esym/cvg_lim =&gt; //; exact: g_f.
rewrite [RHS](_ : _ = lim (fun n =&gt; \int[m1 \x m2]_z (EFin \o g n) z)).
  rewrite -monotone_convergence //; last 3 first.
    - by move=&gt; n; exact/EFin_measurable_fun.
    - by move=&gt; n /= x _; rewrite lee_fin; exact: fun_ge0.
    - by move=&gt; y /= _ a b; rewrite lee_fin =&gt; /g_nd/lefP; exact.
  by apply: eq_integral =&gt; /= x _; apply/esym/cvg_lim =&gt; //; exact: g_f.
rewrite [LHS](_ : _ = lim
    (fun n =&gt; \int[m2]_y (\int[m1]_x (EFin \o g n) (x, y)))).
  congr (lim _); rewrite funeqE =&gt; n.
  by rewrite sfun_fubini_tonelli sfun_fubini_tonelli2.
rewrite [RHS](_ : _ = lim (fun n =&gt; \int[m2]_y G_ g n y))//.
rewrite -monotone_convergence //; first exact: eq_integral.
- by move=&gt; n; exact: sfun_measurable_fun_fubini_tonelli_G.
- by move=&gt; n y _; apply: integral_ge0 =&gt; // x _ /=; rewrite lee_fin fun_ge0.
- move=&gt; y /= _ a b ab; apply: ge0_le_integral =&gt; //.
  + by move=&gt; x _; rewrite lee_fin fun_ge0.
  + exact/EFin_measurable_fun/measurableT_comp.
  + by move=&gt; *; rewrite lee_fin fun_ge0.
  + exact/EFin_measurable_fun/measurableT_comp.
  + by move=&gt; x _; rewrite lee_fin; move/g_nd : ab =&gt; /lefP; exact.
Qed.
Lemma fubini_tonelli :
  \int[m1]_x \int[m2]_y f (x, y) = \int[m2]_y \int[m1]_x f (x, y).
Proof. by rewrite -fubini_tonelli1// fubini_tonelli2. Qed.
End fubini_tonelli.
End fubini_tonelli.
Arguments fubini_tonelli1 {d1 d2 T1 T2 R m1 m2} f.
Arguments fubini_tonelli2 {d1 d2 T1 T2 R m1 m2} f.
Arguments fubini_tonelli {d1 d2 T1 T2 R m1 m2} f.
Arguments measurable_fun_fubini_tonelli_F {d1 d2 T1 T2 R m2} f.
Arguments measurable_fun_fubini_tonelli_G {d1 d2 T1 T2 R m1} f.
Section fubini.
Local Open Scope ereal_scope.
Context d1 d2 (T1 : measurableType d1) (T2 : measurableType d2) (R : realType).
Variable m1 : {sigma_finite_measure set T1 -&gt; \bar R}.
Variable m2 : {sigma_finite_measure set T2 -&gt; \bar R}.
Variable f : T1 * T2 -&gt; \bar R.
Hypothesis imf : (m1 \x m2).-integrable setT f.
Let mf : measurable_fun setT f. Proof. exact: measurable_int imf. Qed.
NB: only relies on mf 
Lemma fubini1a :
  (m1 \x m2).-integrable setT f &lt;-&gt; \int[m1]_x \int[m2]_y `|f (x, y)| &lt; +oo.
Proof.
split=&gt; [/integrableP[_]|] ioo; [|apply/integrableP; split=&gt; [//|]].
- by rewrite -(fubini_tonelli1 (abse \o f))//=; exact: measurableT_comp.
- by rewrite fubini_tonelli1//; exact: measurableT_comp.
Qed.
Lemma fubini1b :
  (m1 \x m2).-integrable setT f &lt;-&gt; \int[m2]_y \int[m1]_x `|f (x, y)| &lt; +oo.
Proof.
split=&gt; [/integrableP[_]|] ioo; [|apply/integrableP; split=&gt; [//|]].
- by rewrite -(fubini_tonelli2 (abse \o f))//=; exact: measurableT_comp.
- by rewrite fubini_tonelli2//; exact: measurableT_comp.
Qed.
Let measurable_fun1 : measurable_fun setT (fun x =&gt; \int[m2]_y `|f (x, y)|).
Proof.
apply: (measurable_fun_fubini_tonelli_F (abse \o f)) =&gt; //=.
exact: measurableT_comp.
Qed.
Let measurable_fun2 : measurable_fun setT (fun y =&gt; \int[m1]_x `|f (x, y)|).
Proof.
apply: (measurable_fun_fubini_tonelli_G (abse \o f)) =&gt; //=.
exact: measurableT_comp.
Qed.
/NB: only relies on mf 
Lemma ae_integrable1 :
  {ae m1, forall x, m2.-integrable setT (fun y =&gt; f (x, y))}.
Proof.
have : m1.-integrable setT (fun x =&gt; \int[m2]_y `|f (x, y)|).
  apply/integrableP; split =&gt; //.
  rewrite (le_lt_trans _  (fubini1a.1 imf))// ge0_le_integral //.
  - exact: measurableT_comp.
  - by move=&gt; *; exact: integral_ge0.
  - by move=&gt; *; rewrite gee0_abs//; exact: integral_ge0.
move/integrable_ae =&gt; /(_ measurableT); apply: filterS =&gt; x /= /(_ I) im2f.
apply/integrableP; split; first exact/measurableT_comp.
by move/fin_numPlt : im2f =&gt; /andP[].
Qed.
Lemma ae_integrable2 :
  {ae m2, forall y, m1.-integrable setT (fun x =&gt; f (x, y))}.
Proof.
have : m2.-integrable setT (fun y =&gt; \int[m1]_x `|f (x, y)|).
  apply/integrableP; split =&gt; //.
  rewrite (le_lt_trans _ (fubini1b.1 imf))// ge0_le_integral //.
  - exact: measurableT_comp.
  - by move=&gt; *; exact: integral_ge0.
  - by move=&gt; *; rewrite gee0_abs//; exact: integral_ge0.
move/integrable_ae =&gt; /(_ measurableT); apply: filterS =&gt; x /= /(_ I) im2f.
apply/integrableP; split; first exact/measurableT_comp.
by move/fin_numPlt : im2f =&gt; /andP[].
Qed.
Let F := fubini_F m2 f.
Let Fplus x := \int[m2]_y f^\+ (x, y).
Let Fminus x := \int[m2]_y f^\- (x, y).
Let FE : F = Fplus \- Fminus. Proof. apply/funext=&gt; x; exact: integralE. Qed.
Let measurable_Fplus : measurable_fun setT Fplus.
Proof.
by apply: measurable_fun_fubini_tonelli_F =&gt; //; exact: measurable_funepos.
Qed.
Let measurable_Fminus : measurable_fun setT Fminus.
Proof.
by apply: measurable_fun_fubini_tonelli_F =&gt; //; exact: measurable_funeneg.
Qed.
Lemma measurable_fubini_F : measurable_fun setT F.
Proof.
rewrite FE.
by apply: emeasurable_funB; [exact: measurable_Fplus|exact: measurable_Fminus].
Qed.
Let integrable_Fplus : m1.-integrable setT Fplus.
Proof.
apply/integrableP; split=&gt; //.
apply: le_lt_trans (fubini1a.1 imf); apply: ge0_le_integral =&gt; //.
- exact: measurableT_comp.
- by move=&gt; x _; exact: integral_ge0.
- move=&gt; x _; apply: le_trans.
    apply: le_abse_integral =&gt; //; apply: measurable_funepos =&gt; //.
    exact: measurableT_comp.
  apply: ge0_le_integral =&gt; //.
  - apply: measurableT_comp =&gt; //.
    by apply: measurable_funepos =&gt; //; exact: measurableT_comp.
  - by apply: measurableT_comp =&gt; //; exact/measurableT_comp.
  - by move=&gt; y _; rewrite gee0_abs// -/((abse \o f) (x, y)) fune_abse lee_addl.
Qed.
Let integrable_Fminus : m1.-integrable setT Fminus.
Proof.
apply/integrableP; split=&gt; //.
apply: le_lt_trans (fubini1a.1 imf); apply: ge0_le_integral =&gt; //.
- exact: measurableT_comp.
- by move=&gt; *; exact: integral_ge0.
- move=&gt; x _; apply: le_trans.
    apply: le_abse_integral =&gt; //; apply: measurable_funeneg =&gt; //.
    exact: measurableT_comp.
  apply: ge0_le_integral =&gt; //.
  + apply: measurableT_comp =&gt; //; apply: measurable_funeneg =&gt; //.
    exact: measurableT_comp.
  + by apply: measurableT_comp =&gt; //; exact: measurableT_comp.
  + by move=&gt; y _; rewrite gee0_abs// -/((abse \o f) (x, y)) fune_abse lee_addr.
Qed.
Lemma integrable_fubini_F : m1.-integrable setT F.
Proof. by rewrite FE; exact: integrableB. Qed.
Let G := fubini_G m1 f.
Let Gplus y := \int[m1]_x f^\+ (x, y).
Let Gminus y := \int[m1]_x f^\- (x, y).
Let GE : G = Gplus \- Gminus. Proof. apply/funext=&gt; x; exact: integralE. Qed.
Let measurable_Gplus : measurable_fun setT Gplus.
Proof.
by apply: measurable_fun_fubini_tonelli_G =&gt; //; exact: measurable_funepos.
Qed.
Let measurable_Gminus : measurable_fun setT Gminus.
Proof.
by apply: measurable_fun_fubini_tonelli_G =&gt; //; exact: measurable_funeneg.
Qed.
Lemma measurable_fubini_G : measurable_fun setT G.
Proof. by rewrite GE; exact: emeasurable_funB. Qed.
Let integrable_Gplus : m2.-integrable setT Gplus.
Proof.
apply/integrableP; split=&gt; //.
apply: le_lt_trans (fubini1b.1 imf); apply: ge0_le_integral =&gt; //.
- exact: measurableT_comp.
- by move=&gt; *; exact: integral_ge0.
- move=&gt; y _; apply: le_trans.
    apply: le_abse_integral =&gt; //; apply: measurable_funepos =&gt; //.
    exact: measurableT_comp.
  apply: ge0_le_integral =&gt; //.
  - apply: measurableT_comp =&gt; //.
    by apply: measurable_funepos =&gt; //; exact: measurableT_comp.
  - by apply: measurableT_comp =&gt; //; exact: measurableT_comp.
  - by move=&gt; x _; rewrite gee0_abs// -/((abse \o f) (x, y)) fune_abse lee_addl.
Qed.
Let integrable_Gminus : m2.-integrable setT Gminus.
Proof.
apply/integrableP; split=&gt; //.
apply: le_lt_trans (fubini1b.1 imf); apply: ge0_le_integral =&gt; //.
- exact: measurableT_comp.
- by move=&gt; *; exact: integral_ge0.
- move=&gt; y _; apply: le_trans.
    apply: le_abse_integral =&gt; //; apply: measurable_funeneg =&gt; //.
    exact: measurableT_comp.
  apply: ge0_le_integral =&gt; //.
  + apply: measurableT_comp =&gt; //.
    by apply: measurable_funeneg =&gt; //; exact: measurableT_comp.
  + by apply: measurableT_comp =&gt; //; exact: measurableT_comp.
  + by move=&gt; x _; rewrite gee0_abs// -/((abse \o f) (x, y)) fune_abse lee_addr.
Qed.
Lemma fubini1 : \int[m1]_x F x = \int[m1 \x m2]_z f z.
Proof.
rewrite FE integralB; [|by[]|exact: integrable_Fplus|exact: integrable_Fminus].
by rewrite [in RHS]integralE ?fubini_tonelli1//;
  [exact: measurable_funeneg|exact: measurable_funepos].
Qed.
Lemma fubini2 : \int[m2]_x G x = \int[m1 \x m2]_z f z.
Proof.
rewrite GE integralB; [|by[]|exact: integrable_Gplus|exact: integrable_Gminus].
by rewrite [in RHS]integralE ?fubini_tonelli2//;
  [exact: measurable_funeneg|exact: measurable_funepos].
Qed.
Theorem Fubini :
  \int[m1]_x \int[m2]_y f (x, y) = \int[m2]_y \int[m1]_x f (x, y).
Proof. by rewrite fubini1 -fubini2. Qed.
End fubini.
Section sfinite_fubini.
Local Open Scope ereal_scope.
Context d d' (X : measurableType d) (Y : measurableType d') (R : realType).
Variables (m1 : {sfinite_measure set X -&gt; \bar R}).
Variables (m2 : {sfinite_measure set Y -&gt; \bar R}).
Variables (f : X * Y -&gt; \bar R) (f0 : forall xy, 0 &lt;= f xy).
Hypothesis mf : measurable_fun setT f.
Lemma sfinite_Fubini :
  \int[m1]_x \int[m2]_y f (x, y) = \int[m2]_y \int[m1]_x f (x, y).
Proof.
pose s1 := sfinite_measure_seq m1.
pose s2 := sfinite_measure_seq m2.
rewrite [LHS](eq_measure_integral [the measure _ _ of mseries s1 0]); last first.
  by move=&gt; A mA _; rewrite /=; exact: sfinite_measure_seqP.
transitivity (\int[mseries s1 0]_x \int[mseries s2 0]_y f (x, y)).
  apply: eq_integral =&gt; x _; apply: eq_measure_integral =&gt; ? ? _.
  exact: sfinite_measure_seqP.
transitivity (\sum_(n &lt;oo) \int[s1 n]_x \sum_(m &lt;oo) \int[s2 m]_y f (x, y)).
  rewrite ge0_integral_measure_series; [|by []| |]; last 2 first.
    by move=&gt; t _; exact: integral_ge0.
    rewrite [X in measurable_fun _ X](_ : _ =
        fun x =&gt; \sum_(n &lt;oo) \int[s2 n]_y f (x, y)); last first.
      apply/funext =&gt; x.
      by rewrite ge0_integral_measure_series//; exact/measurableT_comp.
    apply: ge0_emeasurable_fun_sum; first by move=&gt; k x; exact: integral_ge0.
    by move=&gt; k; apply: measurable_fun_fubini_tonelli_F.
  apply: eq_eseriesr =&gt; n _; apply: eq_integral =&gt; x _.
  by rewrite ge0_integral_measure_series//; exact/measurableT_comp.
transitivity (\sum_(n &lt;oo) \sum_(m &lt;oo) \int[s1 n]_x \int[s2 m]_y f (x, y)).
  apply: eq_eseriesr =&gt; n _; rewrite integral_nneseries//.
    by move=&gt; m; exact: measurable_fun_fubini_tonelli_F.
  by move=&gt; m x _; exact: integral_ge0.
transitivity (\sum_(n &lt;oo) \sum_(m &lt;oo) \int[s2 m]_y \int[s1 n]_x f (x, y)).
  apply: eq_eseriesr =&gt; n _; apply: eq_eseriesr =&gt; m _.
  by rewrite fubini_tonelli//; exact: finite_measure_sigma_finite.
transitivity (\sum_(n &lt;oo) \int[mseries s2 0]_y \int[s1 n]_x f (x, y)).
  apply: eq_eseriesr =&gt; n _; rewrite ge0_integral_measure_series//.
    by move=&gt; y _; exact: integral_ge0.
  exact: measurable_fun_fubini_tonelli_G.
transitivity (\int[mseries s2 0]_y \sum_(n &lt;oo) \int[s1 n]_x f (x, y)).
  rewrite integral_nneseries//.
    by move=&gt; n; apply: measurable_fun_fubini_tonelli_G.
  by move=&gt; n y _; exact: integral_ge0.
transitivity (\int[mseries s2 0]_y \int[mseries s1 0]_x f (x, y)).
  apply: eq_integral =&gt; y _.
  by rewrite ge0_integral_measure_series//; exact/measurableT_comp.
transitivity (\int[m2]_y \int[mseries s1 0]_x f (x, y)).
  by apply: eq_measure_integral =&gt; A mA _ /=; rewrite sfinite_measure_seqP.
apply: eq_integral =&gt; y _; apply: eq_measure_integral =&gt; A mA _ /=.
by rewrite sfinite_measure_seqP.
Qed.
End sfinite_fubini.
Arguments sfinite_Fubini {d d' X Y R} m1 m2 f.
Section lebesgue_differentiation_continuous.
Context (rT : realType).
Let mu := [the measure _ _ of @lebesgue_measure rT].
Let R  := [the measurableType _ of measurableTypeR rT].
Let ballE (x : R) (r : {posnum rT}) :
  ball x r%:num = `](x - r%:num), (x + r%:num)[%classic :&gt; set rT.
Proof.
rewrite -(@ball_normE rT [normedModType rT of R^o]) /ball_ set_itvoo.
by under eq_set =&gt; ? do rewrite ltr_distlC.
Qed.
Lemma lebesgue_differentiation_continuous (f : R -&gt; rT^o) (A : set R) (x : R) :
  open A -&gt; mu.-integrable A (EFin \o f) -&gt; {for x, continuous f} -&gt; A x -&gt;
  (fun r =&gt; 1 / (r *+ 2) * \int[mu]_(z in ball x r) f z) @ 0^'+ --&gt;
  (f x : R^o).
Proof.
have ball_itvr r : 0 &lt; r -&gt; `[x - r, x + r] `\` ball x r = [set x + r; x - r].
  move: r =&gt; _/posnumP[r].
  rewrite -setU1itv ?bnd_simp ?ler_subl_addr -?addrA ?ler_paddr//.
  rewrite -setUitv1 ?bnd_simp ?ltr_subl_addr -?addrA ?ltr_spaddr//.
  rewrite setUA setUC setUA setDUl !ballE setDv setU0 setDidl// -subset0.
  by move=&gt; z /= [[]] -&gt;; rewrite in_itv/= ltxx// andbF.
have ball_itv2 r : 0 &lt; r -&gt; ball x r = `[x - r, x + r] `\` [set x + r; x - r].
  move: r =&gt; _/posnumP[r].
  rewrite -ball_itvr // setDD setIC; apply/esym/setIidPl.
  by rewrite ballE set_itvcc =&gt; ?/=; rewrite in_itv =&gt; /andP [/ltW -&gt; /ltW -&gt;].
have ritv r : 0 &lt; r -&gt; mu `[x - r, x + r]%classic = (r *+ 2)%:E.
  move=&gt; /gt0_cp rE; rewrite /= lebesgue_measure_itv/= lte_fin.
  rewrite ler_lt_add // ?rE // -EFinD; congr (_ _).
  by rewrite opprB addrAC [_ - _]addrC addrA subrr add0r.
move=&gt; oA intf ctsfx Ax.
apply: (@cvg_zero rT [normedModType R of rT^o]).
apply/cvgrPdist_le =&gt; eps epos; apply: filter_app (@nbhs_right_gt rT 0).
move/cvgrPdist_le/(_ eps epos)/at_right_in_segment : ctsfx; apply: filter_app.
apply: filter_app (open_itvcc_subset oA Ax).
have mA : measurable A := open_measurable oA.
near=&gt; r =&gt; xrA; rewrite addrfctE opprfctE =&gt; feps rp.
have cptxr : compact `[x - r, x + r] := @segment_compact _ _ _.
rewrite distrC subr0.
have -&gt; : \int[mu]_(z in ball x r) f z = \int[mu]_(z in `[x - r, x + r]) f z.
  rewrite ball_itv2 //; congr (fine _); rewrite -negligible_integral //.
  - by apply/measurableU; exact: measurable_set1.
  - exact: (integrableS mA).
  - by rewrite measureU0//; exact: lebesgue_measure_set1.
have r20 : 0 &lt;= 1 / (r *+ 2) by rewrite ?divr_ge0 // mulrn_wge0.
have -&gt; : f x = 1 / (r *+ 2) * \int[mu]_(z in `[x - r, x + r]) cst (f x) z.
  rewrite /Rintegral /= integral_cst /= ?ritv // mulrC mul1r.
  by rewrite -mulrA divff ?mulr1//; apply: lt0r_neq0; rewrite mulrn_wgt0.
have intRf : mu.-integrable `[x - r, x + r] (EFin \o f).
  exact: (@integrableS _ _ _ mu _ _ _ _ _ xrA intf).
rewrite /= -mulrBr -fineB; first last.
- rewrite integral_fune_fin_num// continuous_compact_integrable// =&gt; ?.
  exact: cvg_cst.
- by rewrite integral_fune_fin_num.
rewrite -integralB_EFin //; first last.
  by apply: continuous_compact_integrable =&gt; // ?; exact: cvg_cst.
under [fun _ =&gt; adde _ _ ]eq_fun =&gt; ? do rewrite -EFinD.
have int_fx : mu.-integrable `[x - r, x + r] (fun z =&gt; (f z - f x)%:E).
  under [fun z =&gt; (f z - _)%:E]eq_fun =&gt; ? do rewrite EFinB.
  rewrite integrableB// continuous_compact_integrable// =&gt; ?.
  exact: cvg_cst.
rewrite normrM [ `|_/_| ]ger0_norm // -fine_abse //; first last.
  by rewrite integral_fune_fin_num.
suff : (\int[mu]_(z in `[(x - r)%R, (x + r)%R]) `|f z - f x|%:E &lt;=
    (r *+ 2 * eps)%:E)%E.
  move=&gt; intfeps; apply: le_trans.
    apply: (ler_pmul r20 _ (le_refl _)); first exact: fine_ge0.
    apply: fine_le; last apply: le_abse_integral =&gt; //.
    - by rewrite abse_fin_num integral_fune_fin_num.
    - by rewrite integral_fune_fin_num// integrable_abse.
    - by case/integrableP : int_fx.
  rewrite div1r ler_pdivr_mull ?mulrn_wgt0 // -[_ * _]/(fine (_%:E)).
  by rewrite fine_le// integral_fune_fin_num// integrable_abse.
apply: le_trans.
- apply: (@integral_le_bound _ _ _ _ _ (fun z =&gt; (f z - f x)%:E) eps%:E) =&gt; //.
  + by case/integrableP: int_fx.
  + exact: ltW.
  + by apply: aeW =&gt; ? ?; rewrite /= lee_fin distrC feps.
by rewrite ritv //= -EFinM lee_fin mulrC.
Unshelve. all: by end_near. Qed.
End lebesgue_differentiation_continuous.
</pre>

</div>
<div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/tree/yoshihiro503%40generate_index">a fork of coq2html</a></div>
</body>
</html>
