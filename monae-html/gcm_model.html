
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module gcm_model</title>
<meta name="description" content="Documentation of Coq module gcm_model" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init('proofscript')">
<h1 class="title">Module gcm_model</h1>
<div class="coq">
<span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">Reals</span>.<br/>
<span class="vernacular">From</span> <span class="id">mathcomp</span> <span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">all_ssreflect</span>.<br/>
<span class="vernacular">From</span> <span class="id">mathcomp</span> <span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">boolp</span> <span class="id">classical_sets</span>.<br/>
<span class="vernacular">From</span> <span class="id">mathcomp</span> <span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">finmap</span>.<br/>
<span class="vernacular">From</span> <span class="id">infotheo</span> <span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">Reals_ext</span> <span class="id">classical_sets_ext</span> <span class="id">ssrR</span> <span class="id">ssr_ext</span>.<br/>
<span class="vernacular">From</span> <span class="id">infotheo</span> <span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">fdist</span> <span class="id">fsdist</span> <span class="id">convex</span> <span class="id">necset</span>.<br/>
<span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">monae_lib</span>.<br/>
<span class="vernacular">From</span> <span class="id">HB</span> <span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">structures</span>.<br/>
<span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">category</span>.<br/>
<br/>
<pre class="ssrdoc">
            Construction of the geometrically convex monad                 
                                                                           
This file defines the functor P_delta and shows that it is a monad.        
The proof uses the adjointness relations depicted as follows:              
                                                                           
Functors:  |       FC            F0           F1                           
           |     ----&gt;          ----&gt;        ----&gt;                         
Categories:| Type     choiceType     convType     semiCompSemiLattConvType 
           |             (CC)          (CV)                (CS)            
           |     &lt;----          &lt;----        &lt;----                         
Forgetful  |       UC             U0           U1                          
Functors:  |                                                               
                                                                           
FC -| UC:                                                                  
                 CC := [the category of choiceType]                        
    free_choiceType := [the {functor CT -&gt; CC} of choice_of_Type]          
                       (notation FC)                                       
  forget_choiceType := [the {functor CC -&gt; CT} of idfun]                   
                       (notation UC)                                       
               epsC == counit FC \O UC ~&gt; 1                                
               etaC == unit 1 ~&gt; UC \O FC                                  
F0 -| U0:                                                                  
                 CV := [the category of convType]                          
                       (morphisms are affine functions)                    
      free_convType := [the {functor CC -&gt; CV} of                          
                        (fun a : CC =&gt; [the convType of {dist a}])]        
                       (notation F0)                                       
    forget_convType := [the {functor CV -&gt; CC} of idfun]                   
               eps0 == counit F0 \O U0 ~&gt; 1                                
               eta0 == unit 1 ~&gt; U0 \O F0                                  
       triL0, triR0 == triangular laws                                     
F1 -| U1:                                                                  
                 CS := [the category of semiCompSemiLattConvType]          
                       the category of semi-complete semi-lattice convex   
                       spaces, morphisms are biglubmorph and affine        
free_semiCompSemiLattConvType := [the {functor CV -&gt; CS} of                
                       (fun a : CV =&gt; {necset a})]]                        
                       (notation F1)                                       
forget_semiCompSemiLattConvType := [the {functor CS -&gt; CV} of idfun]       
                       (notation U1)                                       
               eps1 == counit F1 \O U1 ~&gt; FId                              
               eta1 == unit FId ~&gt; U1 \O F1                                
       triL1, triR1 == triangular laws                                     
                                                                           
              join1 == eps1 : necset (necset C) -&gt; necset C where C is a   
                       convType                                            
                       | F1                                                
       P_delta_left == | F0                                                
                       | FC                                                
                       | UC                                                
      P_delta_right == | U0                                                
                       | U1                                                
            P_delta == functor CT CT, P_delta_right \O P_delta_left.       
                eps == P_delta_left \O P_delta_right ~&gt; FId                
                ret == FId ~&gt; P_delta                                      
               join == P_delta \O P_delta ~&gt; P_delta                       
                gcm == geometrically convex monad in the context of        
                       monad.v                                             
</pre>
<br/>
<span class="gallina-kwd">Set</span> <span class="vernacular">Implicit</span> <span class="vernacular">Arguments</span>.<br/>
<span class="id">Unset</span> <span class="id">Strict</span> <span class="vernacular">Implicit</span>.<br/>
<span class="id">Unset</span> <span class="id">Printing</span> <span class="vernacular">Implicit</span> <span class="id">Defensive</span>.<br/>
<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">proba_scope</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">category_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">choiceType_as_a_category</span>.<br/>
<br/>
<span class="id">HB.instance</span> <span class="vernacular">Definition</span> <span class="id">_</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">isCategory.Build</span> <span class="id">choiceType</span> (<span class="gallina-kwd">fun</span> <span class="id">x</span> <span class="id">:</span> <span class="id">choiceType</span> <span class="id">=&gt;</span> <span class="id">Choice.sort</span> <span class="id">x</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">fun</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">=&gt;</span> <span class="id">True</span>) (<span class="id">fun=&gt;</span> <span class="id">I</span>) (<span class="gallina-kwd">fun</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">=&gt;</span> <span class="id">I</span>).<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">hom_choiceType</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">a</span> <span class="id">b</span> <span class="id">:</span> <span class="id">[the</span> <span class="id">category</span> <span class="id">of</span> <span class="id">choiceType]</span>) (<span class="id">f</span> <span class="id">:</span> <span class="id">a</span> <span class="id">-&gt;</span> <span class="id">b</span>) <span class="id">:</span> <span class="id">{hom</span> <span class="id">a,</span> <span class="id">b}</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">Hom.Pack</span> (<span class="id">Hom.Class</span> (<span class="id">isHom.Axioms_</span> <span class="id">a</span> <span class="id">b</span> <span class="id">f</span> <span class="id">I</span>)).<br/>
<br/>
<span class="vernacular">End</span> <span class="id">choiceType_as_a_category</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">CC</span> <span class="id">:=</span> <span class="id">[the</span> <span class="id">category</span> <span class="id">of</span> <span class="id">choiceType]</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">free_choiceType_functor</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Notation</span> <span class="id">m</span> <span class="id">:=</span> <span class="id">choice_of_Type</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">free_choiceType_mor</span> (<span class="id">T</span> <span class="id">U</span> <span class="id">:</span> <span class="id">CT</span>) (<span class="id">f</span> <span class="id">:</span> <span class="id">{hom</span> <span class="id">T,</span> <span class="id">U}</span>) <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">{hom</span> <span class="id">m</span> <span class="id">T,</span> <span class="id">m</span> <span class="id">U}</span> <span class="id">:=</span> <span class="id">hom_choiceType</span> (<span class="id">f</span> <span class="id">:</span> <span class="id">m</span> <span class="id">T</span> <span class="id">-&gt;</span> <span class="id">m</span> <span class="id">U</span>).<br/>
<br/>
<span class="vernacular">Let</span> <span class="id">free_choiceType_mor_id</span> <span class="id">:</span> <span class="id">FunctorLaws.id</span> <span class="id">free_choiceType_mor</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof1')">Proof.</span></div>
<div class="proofscript" id="proof1">
 <span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">a;</span> <span class="id">rewrite</span> <span class="id">hom_ext</span>. Qed.</div>
<br/>
<span class="vernacular">Let</span> <span class="id">free_choiceType_mor_comp</span> <span class="id">:</span> <span class="id">FunctorLaws.comp</span> <span class="id">free_choiceType_mor</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof2')">Proof.</span></div>
<div class="proofscript" id="proof2">
 <span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">a</span> <span class="id">b</span> <span class="id">c</span> <span class="id">g</span> <span class="id">h;</span> <span class="id">rewrite</span> <span class="id">hom_ext</span>. Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="vernacular">Definition</span> <span class="id">_</span> <span class="id">:=</span> <span class="id">isFunctor.Build</span> <span class="id">CT</span> <span class="id">CC</span> <span class="id">_</span><br/>
&nbsp;&nbsp;<span class="id">free_choiceType_mor_id</span> <span class="id">free_choiceType_mor_comp</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">free_choiceType</span> <span class="id">:=</span> <span class="id">[the</span> <span class="id">{functor</span> <span class="id">CT</span> <span class="id">-&gt;</span> <span class="id">CC}</span> <span class="id">of</span> <span class="id">m]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">free_choiceType_mor_comp_fun</span> (<span class="id">a</span> <span class="id">b</span> <span class="id">c</span> <span class="id">:</span> <span class="gallina-kwd">Type</span>) (<span class="id">g</span> <span class="id">:</span> <span class="id">{hom</span> <span class="id">b,</span> <span class="id">c}</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">h</span> <span class="id">:</span> <span class="id">{hom</span> <span class="id">a,</span> <span class="id">b}</span>)<span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">free_choiceType_mor</span> <span class="id">[hom</span> <span class="id">g</span> <span class="id">\o</span> <span class="id">h]</span> <span class="id">=</span><br/>
&nbsp;&nbsp;(<span class="id">free_choiceType_mor</span> <span class="id">g</span>) <span class="id">\o</span> (<span class="id">free_choiceType_mor</span> <span class="id">h</span>) <span class="id">:&gt;</span> (<span class="id">_</span> <span class="id">-&gt;</span> <span class="id">_</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof3')">Proof.</span></div>
<div class="proofscript" id="proof3">
 <span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">free_choiceType_mor_comp</span>. Qed.</div>
<br/>
<span class="vernacular">End</span> <span class="id">free_choiceType_functor</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">forget_choiceType_functor</span>.<br/>
<br/>
<span class="vernacular">Let</span> <span class="id">m</span> <span class="id">:</span> <span class="id">CC</span> <span class="id">-&gt;</span> <span class="id">CT</span> <span class="id">:=</span> <span class="id">idfun</span>.<br/>
<br/>
<span class="vernacular">Let</span> <span class="id">h</span> (<span class="id">a</span> <span class="id">b</span> <span class="id">:</span> <span class="id">CC</span>) (<span class="id">f</span> <span class="id">:</span> <span class="id">{hom</span> <span class="id">a,</span> <span class="id">b}</span>) <span class="id">:</span> <span class="id">{hom</span> <span class="id">CT;</span> <span class="id">m</span> <span class="id">a,</span> <span class="id">m</span> <span class="id">b}</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">Hom.Pack</span> (<span class="id">Hom.Class</span> (<span class="id">isHom.Axioms_</span> (<span class="id">a</span> <span class="id">:</span> <span class="id">CT</span>) (<span class="id">b</span> <span class="id">:</span> <span class="id">_</span>) (<span class="id">FId</span> <span class="id">#</span> <span class="id">f</span>) <span class="id">I</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">h_id</span> <span class="id">:</span> <span class="id">FunctorLaws.id</span> <span class="id">h</span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof4')">Proof.</span></div>
<div class="proofscript" id="proof4">
 <span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">*;</span> <span class="id">apply</span> <span class="id">hom_ext</span>. Qed.</div>
<br/>
<span class="vernacular">Lemma</span> <span class="id">h_comp</span> <span class="id">:</span> <span class="id">FunctorLaws.comp</span> <span class="id">h</span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof5')">Proof.</span></div>
<div class="proofscript" id="proof5">
 <span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">*;</span> <span class="id">apply</span> <span class="id">hom_ext</span>. Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="vernacular">Definition</span> <span class="id">_</span> <span class="id">:=</span> <span class="id">isFunctor.Build</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">h_id</span> <span class="id">h_comp</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">forget_choiceType</span> <span class="id">:=</span> <span class="id">[the</span> <span class="id">{functor</span> <span class="id">CC</span> <span class="id">-&gt;</span> <span class="id">CT}</span> <span class="id">of</span> <span class="id">m]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">forget_choiceTypeE</span> <span class="id">:</span> (<span class="gallina-kwd">forall</span> <span class="id">a</span> <span class="id">:</span> <span class="id">CC,</span> <span class="id">forget_choiceType</span> <span class="id">a</span> <span class="id">=</span> <span class="id">a</span>) <span class="id">/\</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span> (<span class="id">a</span> <span class="id">b</span> <span class="id">:</span> <span class="id">CC</span>) (<span class="id">f</span> <span class="id">:</span> <span class="id">{hom</span> <span class="id">CC;</span> <span class="id">a</span> <span class="id">,</span> <span class="id">b}</span>)<span class="id">,</span> <span class="id">forget_choiceType</span> <span class="id">#</span> <span class="id">f</span> <span class="id">=</span> <span class="id">f</span> <span class="id">:&gt;</span> (<span class="id">a</span> <span class="id">-&gt;</span> <span class="id">b</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof6')">Proof.</span></div>
<div class="proofscript" id="proof6">
 <span class="gallina-kwd">by</span> <span class="id">[]</span>. Qed.</div>
<br/>
<span class="vernacular">End</span> <span class="id">forget_choiceType_functor</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">epsC_etaC</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Notation</span> <span class="id">FC</span> <span class="id">:=</span> <span class="id">free_choiceType</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Notation</span> <span class="id">UC</span> <span class="id">:=</span> <span class="id">forget_choiceType</span>.<br/>
<br/>
<span class="vernacular">Let</span> <span class="id">epsC'</span> <span class="id">:</span> <span class="id">FC</span> <span class="id">\O</span> <span class="id">UC</span> <span class="id">~~&gt;</span> <span class="id">FId</span> <span class="id">:=</span> <span class="gallina-kwd">fun</span> <span class="id">A</span> <span class="id">:</span> <span class="id">CC</span> <span class="id">=&gt;</span> <span class="id">Hom.Pack</span> (<span class="id">Hom.Class</span><br/>
&nbsp;&nbsp;(<span class="id">isHom.Axioms_</span> ((<span class="id">FC</span> <span class="id">\O</span> <span class="id">UC</span>) <span class="id">A</span>) (<span class="id">FId</span> <span class="id">A</span>) <span class="id">idfun</span> <span class="id">I</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">epsC'_natural</span> <span class="id">:</span> <span class="id">naturality</span> <span class="id">_</span> <span class="id">_</span> <span class="id">epsC'</span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof7')">Proof.</span></div>
<div class="proofscript" id="proof7">
 <span class="gallina-kwd">by</span> <span class="id">[]</span>. Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="vernacular">Definition</span> <span class="id">_</span> <span class="id">:=</span> <span class="id">isNatural.Build</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">epsC'_natural</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">epsC</span> <span class="id">:=</span> <span class="id">locked</span> <span class="id">[the</span> <span class="id">_</span> <span class="id">~&gt;</span> <span class="id">_</span> <span class="id">of</span> <span class="id">epsC']</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">epsCE</span> (<span class="id">T</span> <span class="id">:</span> <span class="id">choiceType</span>) <span class="id">:</span> <span class="id">epsC</span> <span class="id">T</span> <span class="id">=</span> <span class="id">idfun</span> <span class="id">:&gt;</span> (<span class="id">_</span> <span class="id">-&gt;</span> <span class="id">_</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof8')">Proof.</span></div>
<div class="proofscript" id="proof8">
 <span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">/epsC;</span> <span class="id">unlock</span>. Qed.</div>
<br/>
<span class="vernacular">Let</span> <span class="id">etaC'</span> <span class="id">:</span> <span class="id">FId</span> <span class="id">~~&gt;</span> <span class="id">UC</span> <span class="id">\O</span> <span class="id">FC</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">fun</span> (<span class="id">_</span> <span class="id">:</span> <span class="id">CT</span>) <span class="id">=&gt;</span> <span class="id">Hom.Pack</span> (<span class="id">Hom.Class</span> (<span class="id">isHom.Axioms_</span> (<span class="id">FId</span> <span class="id">_</span>) ((<span class="id">UC</span> <span class="id">\O</span> <span class="id">FC</span>) <span class="id">_</span>) <span class="id">idfun</span> <span class="id">I</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">etaC'_natural</span> <span class="id">:</span> <span class="id">naturality</span> <span class="id">_</span> <span class="id">_</span> <span class="id">etaC'</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof9')">Proof.</span></div>
<div class="proofscript" id="proof9">
 <span class="gallina-kwd">by</span> <span class="id">[]</span>. Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="vernacular">Definition</span> <span class="id">_</span> <span class="id">:=</span> <span class="id">isNatural.Build</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">etaC'_natural</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">etaC</span> <span class="id">:=</span> <span class="id">locked</span> <span class="id">[the</span> <span class="id">_</span> <span class="id">~&gt;</span> <span class="id">_</span> <span class="id">of</span> <span class="id">etaC']</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">etaCE</span> (<span class="id">T</span> <span class="id">:</span> <span class="gallina-kwd">Type</span>) <span class="id">:</span> <span class="id">etaC</span> <span class="id">T</span> <span class="id">=</span> <span class="id">idfun</span> <span class="id">:&gt;</span> (<span class="id">_</span> <span class="id">-&gt;</span> <span class="id">_</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof10')">Proof.</span></div>
<div class="proofscript" id="proof10">
 <span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">/etaC;</span> <span class="id">unlock</span>. Qed.</div>
<br/>
<span class="vernacular">Import</span> <span class="id">comps_notation</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">triLC</span> <span class="id">:</span> <span class="id">TriangularLaws.left</span> <span class="id">etaC</span> <span class="id">epsC</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof11')">Proof.</span></div>
<div class="proofscript" id="proof11">
 <span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">c;</span> <span class="id">rewrite</span> <span class="id">etaCE</span> <span class="id">epsCE</span>. Qed.</div>
<br/>
<span class="vernacular">Lemma</span> <span class="id">triRC</span> <span class="id">:</span> <span class="id">TriangularLaws.right</span> <span class="id">etaC</span> <span class="id">epsC</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof12')">Proof.</span></div>
<div class="proofscript" id="proof12">
 <span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">c;</span> <span class="id">rewrite</span> <span class="id">etaCE</span> <span class="id">epsCE</span>. Qed.</div>
<br/>
<span class="vernacular">End</span> <span class="id">epsC_etaC</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">convType_as_a_category</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Obligation</span> <span class="vernacular">Tactic</span> <span class="id">:=</span> <span class="id">idtac</span>.<br/>
<br/>
<span class="vernacular">Let</span> <span class="id">affine_idfun'</span> (<span class="id">U</span> <span class="id">:</span> <span class="id">convType</span>) <span class="id">:</span> <span class="id">affine</span> (<span class="id">@idfun</span> <span class="id">U</span>)<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof13')">Proof.</span></div>
<div class="proofscript" id="proof13">
 <span class="gallina-kwd">by</span> <span class="id">[]</span>. Qed.</div>
<br/>
<span class="vernacular">Let</span> <span class="id">affine_comp'</span> (<span class="id">a</span> <span class="id">b</span> <span class="id">c</span> <span class="id">:</span> <span class="id">convType</span>) (<span class="id">f</span> <span class="id">:</span> <span class="id">a</span> <span class="id">-&gt;</span> <span class="id">b</span>) (<span class="id">g</span> <span class="id">:</span> <span class="id">b</span> <span class="id">-&gt;</span> <span class="id">c</span>) <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">affine</span> <span class="id">f</span> <span class="id">-&gt;</span> <span class="id">affine</span> <span class="id">g</span> <span class="id">-&gt;</span> <span class="id">affine</span> (<span class="id">g</span> <span class="id">\o</span> <span class="id">f</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof14')">Proof.</span></div>
<div class="proofscript" id="proof14">
 <span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">hf</span> <span class="id">hg</span> <span class="id">?</span> <span class="id">?</span> <span class="id">?</span> <span class="id">/=;</span> <span class="id">rewrite</span> <span class="id">hf</span> <span class="id">hg</span>. Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="vernacular">Definition</span> <span class="id">_</span> <span class="id">:=</span> <span class="id">isCategory.Build</span> <span class="id">convType</span> (<span class="gallina-kwd">fun</span> <span class="id">A</span> <span class="id">:</span> <span class="id">convType</span> <span class="id">=&gt;</span> <span class="id">A</span>)<br/>
&nbsp;&nbsp;<span class="id">_</span> <span class="id">affine_idfun'</span> <span class="id">affine_comp'</span>.<br/>
<br/>
<span class="vernacular">End</span> <span class="id">convType_as_a_category</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">CV</span> <span class="id">:=</span> <span class="id">[the</span> <span class="id">category</span> <span class="id">of</span> <span class="id">convType]</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">conv_hom_is_affine</span>.<br/>
<br/>
<span class="vernacular">Fact</span> <span class="id">conv_hom_is_affine</span> (<span class="id">a</span> <span class="id">b</span> <span class="id">:</span> <span class="id">CV</span>) (<span class="id">f</span> <span class="id">:</span> <span class="id">{hom</span> <span class="id">a,</span> <span class="id">b}</span>) <span class="id">:</span> <span class="id">affine</span> <span class="id">f</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof15')">Proof.</span></div>
<div class="proofscript" id="proof15">
 <span class="gallina-kwd">by</span> <span class="id">case:</span> <span class="id">f=&gt;</span> <span class="id">?</span> <span class="id">[]</span> <span class="id">[]</span>. Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="vernacular">Definition</span> <span class="id">_</span> (<span class="id">A</span> <span class="id">B</span> <span class="id">:</span> <span class="id">convType</span>) (<span class="id">f</span> <span class="id">:</span> <span class="id">{hom</span> <span class="id">A,</span> <span class="id">B}</span>) <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">isAffine.Build</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">conv_hom_is_affine</span> <span class="id">f</span>).<br/>
<br/>
<span class="vernacular">End</span> <span class="id">conv_hom_is_affine</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">free_convType_functor</span>.<br/>
<span class="vernacular">Let</span> <span class="id">acto</span> (<span class="id">a</span> <span class="id">:</span> <span class="id">CC</span>) <span class="id">:</span> <span class="id">CV</span> <span class="id">:=</span> <span class="id">[the</span> <span class="id">convType</span> <span class="id">of</span> <span class="id">{dist</span> <span class="id">a}]</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">free_convType_mor</span> (<span class="id">A</span> <span class="id">B</span> <span class="id">:</span> <span class="id">CC</span>) (<span class="id">f</span> <span class="id">:</span> <span class="id">{hom</span> <span class="id">A,</span> <span class="id">B}</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">:</span> <span class="id">{hom</span> <span class="id">acto</span> <span class="id">A,</span> <span class="id">acto</span> <span class="id">B}</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">Hom.Pack</span> (<span class="id">Hom.Class</span> (<span class="id">isHom.Axioms_</span> (<span class="id">acto</span> <span class="id">A</span>) (<span class="id">acto</span> <span class="id">B</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">fsdistmap</span> <span class="id">f</span>) (<span class="id">fsdistmap_affine</span> <span class="id">f</span>))).<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">mem_finsupp_free_convType_mor</span> (<span class="id">A</span> <span class="id">B</span> <span class="id">:</span> <span class="id">CC</span>) (<span class="id">f</span> <span class="id">:</span> <span class="id">A</span> <span class="id">-&gt;</span> <span class="id">B</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">d</span> <span class="id">:</span> <span class="id">{dist</span> <span class="id">A}</span>) (<span class="id">x</span> <span class="id">:</span> <span class="id">finsupp</span> <span class="id">d</span>) <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">f</span> (<span class="id">fsval</span> <span class="id">x</span>) <span class="id">\in</span> <span class="id">finsupp</span> (<span class="id">free_convType_mor</span> (<span class="id">hom_choiceType</span> <span class="id">f</span>) <span class="id">d</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof16')">Proof.</span></div>
<div class="proofscript" id="proof16">
<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">/=</span> <span class="id">supp_fsdistmap;</span> <span class="id">apply/imfsetP</span> <span class="id">=&gt;</span> <span class="id">/=;</span> <span class="gallina-kwd">exists</span> (<span class="id">fsval</span> <span class="id">x</span>).<br/>
Qed.</div>
<br/>
<span class="vernacular">Definition</span> <span class="id">free_convType_mor_supp</span><br/>
&nbsp;&nbsp;(<span class="id">A</span> <span class="id">B</span> <span class="id">:</span> <span class="id">CC</span>) (<span class="id">f</span> <span class="id">:</span> <span class="id">A</span> <span class="id">-&gt;</span> <span class="id">B</span>) (<span class="id">d</span> <span class="id">:</span> <span class="id">{dist</span> <span class="id">A}</span>) (<span class="id">x</span> <span class="id">:</span> <span class="id">finsupp</span> <span class="id">d</span>)<br/>
&nbsp;&nbsp;<span class="id">:</span> <span class="id">[finType</span> <span class="id">of</span> <span class="id">finsupp</span> ((<span class="id">free_convType_mor</span> (<span class="id">hom_choiceType</span> <span class="id">f</span>)) <span class="id">d</span>)<span class="id">]</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">FSetSub</span> (<span class="id">mem_finsupp_free_convType_mor</span> <span class="id">f</span> <span class="id">x</span>).<br/>
<span class="id">Global</span> <span class="vernacular">Arguments</span> <span class="id">free_convType_mor_supp</span> <span class="id">[A</span> <span class="id">B]</span> <span class="id">f</span> <span class="id">d</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">fsval_free_convType_mor_supp</span> (<span class="id">A</span> <span class="id">B</span> <span class="id">:</span> <span class="id">choiceType</span>) (<span class="id">f</span> <span class="id">:</span> <span class="id">{hom</span> <span class="id">A</span> <span class="id">,</span> <span class="id">B}</span>) <span class="id">d</span> <span class="id">i</span> <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">fsval</span> (<span class="id">free_convType_mor_supp</span> <span class="id">f</span> <span class="id">d</span> <span class="id">i</span>) <span class="id">=</span> <span class="id">f</span> (<span class="id">fsval</span> <span class="id">i</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof17')">Proof.</span></div>
<div class="proofscript" id="proof17">
 <span class="gallina-kwd">by</span> <span class="id">case:</span> <span class="id">i</span>. Qed.</div>
<br/>
<span class="vernacular">Let</span> <span class="id">free_convType_mor_id</span> <span class="id">:</span> <span class="id">FunctorLaws.id</span> <span class="id">free_convType_mor</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof18')">Proof.</span></div>
<div class="proofscript" id="proof18">
<span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">a;</span> <span class="id">rewrite</span> <span class="id">hom_ext</span> <span class="id">funeqE=&gt;</span> <span class="id">x</span> <span class="id">/=;</span> <span class="id">rewrite</span> <span class="id">fsdistmap_id</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">Let</span> <span class="id">free_convType_mor_comp</span> <span class="id">:</span> <span class="id">FunctorLaws.comp</span> <span class="id">free_convType_mor</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof19')">Proof.</span></div>
<div class="proofscript" id="proof19">
 <span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">a</span> <span class="id">b</span> <span class="id">c</span> <span class="id">g</span> <span class="id">h;</span> <span class="id">apply/hom_ext;</span> <span class="id">exact:</span> <span class="id">fsdistmap_comp</span>. Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="vernacular">Definition</span> <span class="id">_</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">isFunctor.Build</span> <span class="id">CC</span> <span class="id">CV</span> <span class="id">acto</span> <span class="id">free_convType_mor_id</span> <span class="id">free_convType_mor_comp</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">free_convType</span> <span class="id">:=</span> <span class="id">[the</span> <span class="id">{functor</span> <span class="id">CC</span> <span class="id">-&gt;</span> <span class="id">CV}</span> <span class="id">of</span> <span class="id">acto]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">free_convType_mor_comp_fun</span> (<span class="id">A</span> <span class="id">B</span> <span class="id">C</span> <span class="id">:</span> <span class="id">CC</span>) (<span class="id">g</span> <span class="id">:</span> <span class="id">{hom</span> <span class="id">B,</span> <span class="id">C}</span>) (<span class="id">h</span> <span class="id">:</span> <span class="id">{hom</span> <span class="id">A,</span> <span class="id">B}</span>) <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">free_convType_mor</span> <span class="id">[hom</span> <span class="id">g</span> <span class="id">\o</span> <span class="id">h]</span> <span class="id">=</span><br/>
&nbsp;&nbsp;(<span class="id">free_convType_mor</span> <span class="id">g</span>) <span class="id">\o</span> (<span class="id">free_convType_mor</span> <span class="id">h</span>) <span class="id">:&gt;</span> (<span class="id">_</span> <span class="id">-&gt;</span> <span class="id">_</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof20')">Proof.</span></div>
<div class="proofscript" id="proof20">
 <span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">free_convType_mor_comp</span>. Qed.</div>
<br/>
<span class="vernacular">End</span> <span class="id">free_convType_functor</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">forget_convType_functor</span>.<br/>
<br/>
<span class="vernacular">Let</span> <span class="id">m1</span> <span class="id">:</span> <span class="id">CV</span> <span class="id">-&gt;</span> <span class="id">CC</span> <span class="id">:=</span> <span class="id">idfun</span>.<br/>
<br/>
<span class="vernacular">Let</span> <span class="id">h1</span> <span class="id">:=</span> <span class="gallina-kwd">fun</span> (<span class="id">a</span> <span class="id">b</span> <span class="id">:</span> <span class="id">CV</span>) (<span class="id">f</span> <span class="id">:</span> <span class="id">{hom</span> <span class="id">CV;</span> <span class="id">a,</span> <span class="id">b}</span>) <span class="id">=&gt;</span><br/>
&nbsp;&nbsp;<span class="id">Hom.Pack</span> (<span class="id">Hom.Class</span> (<span class="id">isHom.Axioms_</span> (<span class="id">m1</span> <span class="id">a</span>) (<span class="id">m1</span> <span class="id">b</span>) <span class="id">f</span> <span class="id">I</span>)).<br/>
<br/>
<span class="vernacular">Let</span> <span class="id">h1_id</span> <span class="id">:</span> <span class="id">FunctorLaws.id</span> <span class="id">h1</span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof21')">Proof.</span></div>
<div class="proofscript" id="proof21">
 <span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">*;</span> <span class="id">apply</span> <span class="id">hom_ext</span>. Qed.</div>
<br/>
<span class="vernacular">Let</span> <span class="id">h1_comp</span> <span class="id">:</span> <span class="id">FunctorLaws.comp</span> <span class="id">h1</span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof22')">Proof.</span></div>
<div class="proofscript" id="proof22">
 <span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">*;</span> <span class="id">apply</span> <span class="id">hom_ext</span>. Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="vernacular">Definition</span> <span class="id">_</span> <span class="id">:=</span> <span class="id">isFunctor.Build</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">h1_id</span> <span class="id">h1_comp</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">forget_convType</span> <span class="id">:=</span> <span class="id">[the</span> <span class="id">{functor</span> <span class="id">CV</span> <span class="id">-&gt;</span> <span class="id">CC}</span> <span class="id">of</span> <span class="id">m1]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">forget_convTypeE</span> <span class="id">:</span> (<span class="gallina-kwd">forall</span> <span class="id">a</span> <span class="id">:</span> <span class="id">CV,</span> <span class="id">forget_convType</span> <span class="id">a</span> <span class="id">=</span> <span class="id">a</span>) <span class="id">/\</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span> (<span class="id">a</span> <span class="id">b</span> <span class="id">:</span> <span class="id">CV</span>) (<span class="id">f</span> <span class="id">:</span> <span class="id">{hom</span> <span class="id">CV;</span> <span class="id">a</span> <span class="id">,</span> <span class="id">b}</span>)<span class="id">,</span> <span class="id">forget_convType</span> <span class="id">#</span> <span class="id">f</span> <span class="id">=</span> <span class="id">f</span> <span class="id">:&gt;</span> (<span class="id">a</span> <span class="id">-&gt;</span> <span class="id">b</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof23')">Proof.</span></div>
<div class="proofscript" id="proof23">
 <span class="gallina-kwd">by</span> <span class="id">[]</span>. Qed.</div>
<br/>
<span class="vernacular">End</span> <span class="id">forget_convType_functor</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">eps0_eta0</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">fset_scope</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">R_scope</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">convex_scope</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Notation</span> <span class="id">F0</span> <span class="id">:=</span> <span class="id">free_convType</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Notation</span> <span class="id">U0</span> <span class="id">:=</span> <span class="id">forget_convType</span>.<br/>
<br/>
<span class="vernacular">Let</span> <span class="id">eps0'</span> <span class="id">:</span> <span class="id">F0</span> <span class="id">\O</span> <span class="id">U0</span> <span class="id">~~&gt;</span> <span class="id">FId</span> <span class="id">:=</span> <span class="gallina-kwd">fun</span> <span class="id">a</span> <span class="id">=&gt;</span><br/>
&nbsp;&nbsp;<span class="id">Hom.Pack</span> (<span class="id">Hom.Class</span> (<span class="id">isHom.Axioms_</span> ((<span class="id">F0</span> <span class="id">\O</span> <span class="id">U0</span>) <span class="id">a</span>) (<span class="id">FId</span> <span class="id">a</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">@Convn_of_fsdist</span> <span class="id">a</span>) (<span class="id">@Convn_of_fsdist_affine</span> (<span class="id">FId</span> <span class="id">a</span>)))).<br/>
<br/>
<span class="vernacular">Let</span> <span class="id">eps0'_natural</span> <span class="id">:</span> <span class="id">naturality</span> <span class="id">_</span> <span class="id">_</span> <span class="id">eps0'</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof24')">Proof.</span></div>
<div class="proofscript" id="proof24">
<span class="id">move=&gt;</span> <span class="id">C</span> <span class="id">D</span> <span class="id">f;</span> <span class="id">rewrite</span> <span class="id">FCompE</span> <span class="id">/=</span> <span class="id">/id_f;</span> <span class="id">apply</span> <span class="id">funext</span> <span class="id">=&gt;</span> <span class="id">d</span> <span class="id">/=</span>.<br/>
<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">Convn_of_fsdistmap</span>.<br/>
Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="vernacular">Definition</span> <span class="id">_</span> <span class="id">:=</span> <span class="id">isNatural.Build</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">eps0'_natural</span>.<br/>
<span class="vernacular">Definition</span> <span class="id">eps0</span> <span class="id">:=</span> <span class="id">locked</span> <span class="id">[the</span> <span class="id">_</span> <span class="id">~&gt;</span> <span class="id">_</span> <span class="id">of</span> <span class="id">eps0']</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">eps0E</span> (<span class="id">C</span> <span class="id">:</span> <span class="id">convType</span>) <span class="id">:</span> <span class="id">eps0</span> <span class="id">C</span> <span class="id">=</span> <span class="id">@Convn_of_fsdist</span> <span class="id">C</span> <span class="id">:&gt;</span> (<span class="id">_</span> <span class="id">-&gt;</span> <span class="id">_</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof25')">Proof.</span></div>
<div class="proofscript" id="proof25">
 <span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">/eps0;</span> <span class="id">unlock</span>. Qed.</div>
<br/>
<span class="vernacular">Let</span> <span class="id">eta0'</span> <span class="id">:</span> <span class="id">FId</span> <span class="id">~~&gt;</span> <span class="id">U0</span> <span class="id">\O</span> <span class="id">F0</span> <span class="id">:=</span> <span class="gallina-kwd">fun</span> <span class="id">T</span> <span class="id">=&gt;</span><br/>
&nbsp;&nbsp;<span class="id">Hom.Pack</span> (<span class="id">Hom.Class</span> (<span class="id">isHom.Axioms_</span> (<span class="id">FId</span> <span class="id">T</span>) ((<span class="id">U0</span> <span class="id">\O</span> <span class="id">F0</span>) <span class="id">T</span>) (<span class="id">@fsdist1</span> <span class="id">_</span>) <span class="id">I</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">eta0'_natural</span> <span class="id">:</span> <span class="id">naturality</span> <span class="id">_</span> <span class="id">_</span> <span class="id">eta0'</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof26')">Proof.</span></div>
<div class="proofscript" id="proof26">
<span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">a</span> <span class="id">b</span> <span class="id">h;</span> <span class="id">rewrite</span> <span class="id">funeqE=&gt;</span> <span class="id">x;</span> <span class="id">rewrite</span> <span class="id">FIdf</span> <span class="id">/eta0'</span> <span class="id">/=</span> <span class="id">fsdistmap1</span>.<br/>
Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="vernacular">Definition</span> <span class="id">_</span> <span class="id">:=</span> <span class="id">isNatural.Build</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">eta0'_natural</span>.<br/>
<span class="vernacular">Definition</span> <span class="id">eta0</span> <span class="id">:=</span> <span class="id">locked</span> <span class="id">[the</span> <span class="id">_</span> <span class="id">~&gt;</span> <span class="id">_</span> <span class="id">of</span> <span class="id">eta0']</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">eta0E</span> (<span class="id">T</span> <span class="id">:</span> <span class="id">choiceType</span>) <span class="id">:</span> <span class="id">eta0</span> <span class="id">T</span> <span class="id">=</span> <span class="id">@fsdist1</span> <span class="id">_</span> <span class="id">:&gt;</span> (<span class="id">_</span> <span class="id">-&gt;</span> <span class="id">_</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof27')">Proof.</span></div>
<div class="proofscript" id="proof27">
 <span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">/eta0;</span> <span class="id">unlock</span>. Qed.</div>
<br/>
<span class="vernacular">Import</span> <span class="id">comps_notation</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">fset_scope</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">R_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">triL0</span> <span class="id">:</span> <span class="id">TriangularLaws.left</span> <span class="id">eta0</span> <span class="id">eps0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof28')">Proof.</span></div>
<div class="proofscript" id="proof28">
<span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">c;</span> <span class="id">apply</span> <span class="id">funext=&gt;</span> <span class="id">x</span> <span class="id">/=;</span> <span class="id">rewrite</span> <span class="id">eps0E</span> <span class="id">eta0E</span> <span class="id">triangular_laws_left0</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">Lemma</span> <span class="id">triR0</span> <span class="id">:</span> <span class="id">TriangularLaws.right</span> <span class="id">eta0</span> <span class="id">eps0</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof29')">Proof.</span></div>
<div class="proofscript" id="proof29">
<span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">c;</span> <span class="id">rewrite</span> <span class="id">eps0E</span> <span class="id">eta0E</span> <span class="id">funeqE</span> <span class="id">=&gt;</span> <span class="id">a</span> <span class="id">/=;</span> <span class="id">rewrite</span> <span class="id">Convn_of_fsdist1</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">End</span> <span class="id">eps0_eta0</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">eps0_correct</span>.<br/>
<span class="vernacular">Import</span> <span class="id">category</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">R_scope</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">convex_scope</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">A</span> <span class="id">:</span> <span class="id">choiceType</span>) (<span class="id">D</span> <span class="id">:</span> <span class="id">{dist</span> <span class="id">{dist</span> <span class="id">A}}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">eps0_correct</span> <span class="id">:</span> <span class="id">eps0</span> <span class="id">_</span> <span class="id">D</span> <span class="id">=</span> <span class="id">fsdistjoin</span> <span class="id">D</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof30')">Proof.</span></div>
<div class="proofscript" id="proof30">
 <span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">eps0E</span> <span class="id">Convn_of_fsdistjoin</span>. Qed.</div>
<br/>
<span class="vernacular">End</span> <span class="id">eps0_correct</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">semiCompSemiLattConvType_as_a_category</span>.<br/>
<span class="vernacular">Import</span> <span class="id">category</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Obligation</span> <span class="vernacular">Tactic</span> <span class="id">:=</span> <span class="id">idtac</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">biglub_affine</span> (<span class="id">a</span> <span class="id">b</span> <span class="id">:</span> <span class="id">semiCompSemiLattConvType</span>) (<span class="id">f</span> <span class="id">:</span> <span class="id">a</span> <span class="id">-&gt;</span> <span class="id">b</span>) <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">biglubmorph</span> <span class="id">f</span> <span class="id">/\</span> <span class="id">affine</span> <span class="id">f</span>.<br/>
<br/>
<span class="vernacular">Let</span> <span class="id">comp_is_biglub_affine</span> (<span class="id">a</span> <span class="id">b</span> <span class="id">c</span> <span class="id">:</span> <span class="id">semiCompSemiLattConvType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">f</span> <span class="id">:</span> <span class="id">a</span> <span class="id">-&gt;</span> <span class="id">b</span>) (<span class="id">g</span> <span class="id">:</span> <span class="id">b</span> <span class="id">-&gt;</span> <span class="id">c</span>) <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">biglub_affine</span> <span class="id">f</span> <span class="id">-&gt;</span> <span class="id">biglub_affine</span> <span class="id">g</span> <span class="id">-&gt;</span> <span class="id">biglub_affine</span> (<span class="id">g</span> <span class="id">\o</span> <span class="id">f</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof31')">Proof.</span></div>
<div class="proofscript" id="proof31">
<span class="id">move=&gt;</span> <span class="id">[bf</span> <span class="id">af]</span> <span class="id">[bg</span> <span class="id">ag];</span> <span class="id">split</span> <span class="id">=&gt;</span> <span class="id">x/=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">bf</span> <span class="id">bg/=;congr</span> (<span class="id">biglub</span> <span class="id">_</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span> <span class="id">apply/neset_ext</span> <span class="id">=&gt;</span> <span class="id">/=;</span> <span class="id">rewrite</span> <span class="id">image_comp</span>.<br/>
<span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">?</span> <span class="id">?</span> <span class="id">/=;</span> <span class="id">rewrite</span> <span class="id">af</span> <span class="id">ag</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">Let</span> <span class="id">idfun_is_biglub_affine</span> (<span class="id">a</span> <span class="id">:</span> <span class="id">semiCompSemiLattConvType</span>) <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">biglub_affine</span> (<span class="id">@idfun</span> <span class="id">a</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof32')">Proof.</span></div>
<div class="proofscript" id="proof32">
 <span class="gallina-kwd">by</span> <span class="id">split</span> <span class="id">=&gt;</span> <span class="id">//;</span> <span class="id">exact:</span> <span class="id">biglub_morph</span>. Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="vernacular">Definition</span> <span class="id">_</span> <span class="id">:=</span> <span class="id">isCategory.Build</span> <span class="id">semiCompSemiLattConvType</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">fun</span> <span class="id">U</span> <span class="id">:</span> <span class="id">semiCompSemiLattConvType</span> <span class="id">=&gt;</span> <span class="id">U</span>) <span class="id">biglub_affine</span> <span class="id">idfun_is_biglub_affine</span><br/>
&nbsp;&nbsp;<span class="id">comp_is_biglub_affine</span>.<br/>
<br/>
<span class="vernacular">End</span> <span class="id">semiCompSemiLattConvType_as_a_category</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">CS</span> <span class="id">:=</span> <span class="id">[the</span> <span class="id">category</span> <span class="id">of</span> <span class="id">semiCompSemiLattConvType]</span>.<br/>
<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">classical_set_scope</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">latt_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">scsl_hom_is_biglub_affine</span>.<br/>
<span class="vernacular">Import</span> <span class="id">category</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">convex_scope</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">K</span> <span class="id">L</span> <span class="id">:</span> <span class="id">CS</span>) (<span class="id">f</span> <span class="id">:</span> <span class="id">{hom</span> <span class="id">K</span> <span class="id">,</span> <span class="id">L}</span>).<br/>
<br/>
<span class="vernacular">Fact</span> <span class="id">scsl_hom_is_biglub_affine</span> <span class="id">:</span> <span class="id">biglub_affine</span> <span class="id">f</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof33')">Proof.</span></div>
<div class="proofscript" id="proof33">
 <span class="gallina-kwd">by</span> <span class="id">split;</span> <span class="id">move=&gt;</span> <span class="id">?;</span> <span class="id">case:</span> <span class="id">f=&gt;</span> <span class="id">?</span> <span class="id">[]</span> <span class="id">[]</span> <span class="id">[]</span>. Qed.</div>
<br/>
<span class="vernacular">Fact</span> <span class="id">scsl_hom_is_affine</span> <span class="id">:</span> <span class="id">affine</span> <span class="id">f</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof34')">Proof.</span></div>
<div class="proofscript" id="proof34">
 <span class="gallina-kwd">by</span> <span class="id">case:</span> <span class="id">scsl_hom_is_biglub_affine</span>. Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="vernacular">Definition</span> <span class="id">SCSL_hom_affine</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">isAffine.Build</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">scsl_hom_is_affine</span>.<br/>
<br/>
<span class="vernacular">Fact</span> <span class="id">scsl_hom_is_biglubmorph</span> <span class="id">:</span> <span class="id">biglubmorph</span> <span class="id">f</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof35')">Proof.</span></div>
<div class="proofscript" id="proof35">
 <span class="gallina-kwd">by</span> <span class="id">case:</span> <span class="id">scsl_hom_is_biglub_affine</span>. Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="vernacular">Definition</span> <span class="id">SCSL_hom_biglubmorph</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">isBiglubMorph.Build</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">scsl_hom_is_biglubmorph</span>.<br/>
<br/>
<span class="vernacular">Fact</span> <span class="id">scsl_hom_is_lubmorph</span> <span class="id">:</span> <span class="id">lub_morph</span> <span class="id">f</span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof36')">Proof.</span></div>
<div class="proofscript" id="proof36">
 <span class="id">exact:</span> <span class="id">biglub_lub_morph</span>. Qed.</div>
<br/>
<span class="vernacular">End</span> <span class="id">scsl_hom_is_biglub_affine</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">free_semiCompSemiLattConvType_functor</span>.<br/>
<span class="vernacular">Import</span> <span class="id">category</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">convex_scope</span>.<br/>
<br/>
<span class="vernacular">Let</span> <span class="id">acto</span> (<span class="id">a</span> <span class="id">:</span> <span class="id">CV</span>) <span class="id">:</span> <span class="id">CS</span> <span class="id">:=</span> <span class="id">{necset</span> <span class="id">a}</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">free_semiCompSemiLattConvType_mor</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">A</span> <span class="id">B</span> <span class="id">:</span> <span class="id">convType</span>) (<span class="id">f</span> <span class="id">:</span> <span class="id">{hom</span> <span class="id">A</span> <span class="id">,</span> <span class="id">B}</span>).<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">free_semiCompSemiLattConvType_mor'</span> (<span class="id">X</span> <span class="id">:</span> <span class="id">acto</span> <span class="id">A</span>) <span class="id">:</span> <span class="id">acto</span> <span class="id">B</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">NECSet.Pack</span> (<span class="id">NECSet.Class</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">CSet.Mixin</span> (<span class="id">is_convex_set_image</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Affine.Pack</span> (<span class="id">Affine.Class</span> (<span class="id">isAffine.Axioms_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">conv_hom_is_affine</span> <span class="id">f</span>))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">X</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NESet.Mixin</span> (<span class="id">neset_image_neq0</span> <span class="id">_</span> <span class="id">_</span>))).<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">free_semiCompSemiLattConvType_mor'_affine</span> <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">affine</span> <span class="id">free_semiCompSemiLattConvType_mor'</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof37')">Proof.</span></div>
<div class="proofscript" id="proof37">
<span class="id">move=&gt;</span> <span class="id">p</span> <span class="id">a0</span> <span class="id">a1;</span> <span class="id">apply</span> <span class="id">necset_ext</span> <span class="id">=&gt;</span> <span class="id">/=;</span> <span class="id">rewrite</span> <span class="id">predeqE</span> <span class="id">=&gt;</span> <span class="id">b0;</span> <span class="id">split</span>.<br/>
<span class="id">-</span> <span class="id">rewrite</span> <span class="id">!necset_convType</span>.<span class="id">convE</span>.<br/>
&nbsp;&nbsp;<span class="id">case=&gt;</span> <span class="id">a</span> <span class="id">[]</span> <span class="id">a0'</span> <span class="id">a0a0';</span> <span class="id">rewrite</span> <span class="id">conv_pt_setE=&gt;</span> <span class="id">-[]</span> <span class="id">a1'</span> <span class="id">a1a1'</span> <span class="id">&lt;-</span> <span class="id">&lt;-</span> <span class="id">/=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">affine_conv</span> <span class="id">/=;</span> <span class="id">exact:</span> <span class="id">conv_in_conv_set</span>.<br/>
<span class="id">-</span> <span class="id">rewrite</span> <span class="id">!necset_convType</span>.<span class="id">convE</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span> <span class="id">/conv_in_conv_set'</span> <span class="id">[]</span> <span class="id">x</span> <span class="id">[]</span> <span class="id">y</span> <span class="id">[]</span> <span class="id">[]</span> <span class="id">a0'</span> <span class="id">a0a0'</span> <span class="id">&lt;-</span> <span class="id">[]</span> <span class="id">[]</span> <span class="id">a1'</span> <span class="id">a1a1'</span> <span class="id">&lt;-</span> <span class="id">-&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">affine_image_conv_set</span> <span class="id">/=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span> <span class="id">apply</span> <span class="id">conv_in_conv_set;</span> <span class="id">apply</span> <span class="id">imageP</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">Lemma</span> <span class="id">bigsetU_affine</span> (<span class="id">X</span> <span class="id">:</span> <span class="id">neset</span> (<span class="id">necset</span> <span class="id">A</span>)) <span class="id">:</span> (<span class="id">f</span> <span class="id">@`</span> (<span class="id">\bigcup_</span>(<span class="id">x</span> <span class="gallina-kwd">in</span> <span class="id">X</span>) <span class="id">x</span>) <span class="id">=</span><br/>
&nbsp;&nbsp;<span class="id">\bigcup_</span>(<span class="id">x</span> <span class="gallina-kwd">in</span> <span class="id">free_semiCompSemiLattConvType_mor'</span> <span class="id">@`</span> <span class="id">X</span>) <span class="id">x</span>)<span class="id">%classic</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof38')">Proof.</span></div>
<div class="proofscript" id="proof38">
<span class="id">rewrite</span> <span class="id">funeqE</span> <span class="id">=&gt;</span> <span class="id">b;</span> <span class="id">rewrite</span> <span class="id">propeqE;</span> <span class="id">split</span>.<br/>
<span class="id">-</span> <span class="id">case</span> <span class="id">=&gt;</span> <span class="id">a</span> <span class="id">[x</span> <span class="id">Xx</span> <span class="id">xa]</span> <span class="id">&lt;-{b}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">NECSet.Pack</span> (<span class="id">NECSet.Class</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">CSet.Mixin</span> (<span class="id">is_convex_set_image</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Affine.Pack</span> (<span class="id">Affine.Class</span> (<span class="id">isAffine.Axioms_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">conv_hom_is_affine</span> <span class="id">f</span>))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">x</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NESet.Mixin</span> (<span class="id">neset_image_neq0</span> <span class="id">f</span> <span class="id">x</span>)))) <span class="id">=&gt;</span> <span class="id">/=;</span> <span class="id">last</span> <span class="gallina-kwd">by</span> <span class="gallina-kwd">exists</span> <span class="id">a</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span> <span class="gallina-kwd">exists</span> <span class="id">x</span> <span class="id">=&gt;</span> <span class="id">//=;</span> <span class="id">exact/necset_ext</span>.<br/>
<span class="id">-</span> <span class="gallina-kwd">by</span> <span class="id">case</span> <span class="id">=&gt;</span> <span class="id">b0</span> <span class="id">[a0</span> <span class="id">Xa0</span> <span class="id">&lt;-{b0}]</span> <span class="id">[a</span> <span class="id">a0a</span> <span class="id">&lt;-{b}];</span> <span class="gallina-kwd">exists</span> <span class="id">a</span> <span class="id">=&gt;</span> <span class="id">//;</span> <span class="gallina-kwd">exists</span> <span class="id">a0</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">Lemma</span> <span class="id">free_semiCompSemiLattConvType_mor'_biglub_morph</span> <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">biglubmorph</span> <span class="id">free_semiCompSemiLattConvType_mor'</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof39')">Proof.</span></div>
<div class="proofscript" id="proof39">
<span class="id">move=&gt;</span> <span class="id">/=</span> <span class="id">X;</span> <span class="id">apply</span> <span class="id">necset_ext</span> <span class="id">=&gt;</span> <span class="id">/=;</span> <span class="id">rewrite</span> <span class="id">funeqE</span> <span class="id">=&gt;</span> <span class="id">b</span>.<br/>
<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">image_preserves_convex_hull</span> <span class="id">bigsetU_affine</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">Definition</span> <span class="id">free_semiCompSemiLattConvType_mor</span> <span class="id">:</span> <span class="id">{hom</span> <span class="id">acto</span> <span class="id">A,</span> <span class="id">acto</span> <span class="id">B}</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">locked</span> (<span class="id">Hom.Pack</span> (<span class="id">Hom.Class</span> (<span class="id">isHom.Axioms_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">acto</span> <span class="id">A</span>) (<span class="id">acto</span> <span class="id">B</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">free_semiCompSemiLattConvType_mor'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">conj</span> <span class="id">free_semiCompSemiLattConvType_mor'_biglub_morph</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">free_semiCompSemiLattConvType_mor'_affine</span>)))).<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">free_semiCompSemiLattConvType_morE</span> (<span class="id">X</span> <span class="id">:</span> <span class="id">acto</span> <span class="id">A</span>) <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">NECSet.mixinType</span> (<span class="id">free_semiCompSemiLattConvType_mor</span> <span class="id">X</span>) <span class="id">=</span> <span class="id">image_neset</span> <span class="id">f</span> <span class="id">X</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof40')">Proof.</span></div>
<div class="proofscript" id="proof40">
<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">/free_semiCompSemiLattConvType_mor;</span> <span class="id">unlock;</span> <span class="id">apply</span> <span class="id">neset_ext</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">Lemma</span> <span class="id">free_semiCompSemiLattConvType_morE'</span> (<span class="id">X</span> <span class="id">:</span> <span class="id">acto</span> <span class="id">A</span>) <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">NESet.car</span> (<span class="id">NECSet.mixinType</span> (<span class="id">free_semiCompSemiLattConvType_mor</span> <span class="id">X</span>)) <span class="id">=</span><br/>
&nbsp;&nbsp;<span class="id">image_neset</span> <span class="id">f</span> <span class="id">X</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof41')">Proof.</span></div>
<div class="proofscript" id="proof41">
 <span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">/free_semiCompSemiLattConvType_mor;</span> <span class="id">unlock</span>. Qed.</div>
<br/>
<span class="vernacular">End</span> <span class="id">free_semiCompSemiLattConvType_mor</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">free_semiCompSemiLattConvType_mor_id</span> <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">FunctorLaws.id</span> <span class="id">free_semiCompSemiLattConvType_mor</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof42')">Proof.</span></div>
<div class="proofscript" id="proof42">
<span class="id">move=&gt;</span> <span class="id">a;</span> <span class="id">rewrite</span> <span class="id">hom_ext</span> <span class="id">funeqE=&gt;</span> <span class="id">/=</span> <span class="id">x</span> <span class="id">/=;</span> <span class="id">apply</span> <span class="id">necset_ext</span> <span class="id">=&gt;</span> <span class="id">/=</span>.<br/>
<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">free_semiCompSemiLattConvType_morE'</span> <span class="id">/=</span> <span class="id">image_id</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">Lemma</span> <span class="id">free_semiCompSemiLattConvType_mor_comp</span> <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">FunctorLaws.comp</span> <span class="id">free_semiCompSemiLattConvType_mor</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof43')">Proof.</span></div>
<div class="proofscript" id="proof43">
<span class="id">move=&gt;</span> <span class="id">a</span> <span class="id">b</span> <span class="id">c</span> <span class="id">[]</span> <span class="id">g</span> <span class="id">affine_g</span> <span class="id">[]</span> <span class="id">h</span> <span class="id">affine_h;</span> <span class="id">rewrite</span> <span class="id">hom_ext</span> <span class="id">funeqE</span> <span class="id">=&gt;</span> <span class="id">/=</span> <span class="id">x</span> <span class="id">/=</span>.<br/>
<span class="id">apply</span> <span class="id">necset_ext</span> <span class="id">=&gt;</span> <span class="id">/=</span>.<br/>
<span class="id">rewrite</span> <span class="id">2!free_semiCompSemiLattConvType_morE'</span> <span class="id">/=</span> <span class="id">-image_comp</span>.<br/>
<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">free_semiCompSemiLattConvType_morE'</span>.<br/>
Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="vernacular">Definition</span> <span class="id">_</span> <span class="id">:=</span> <span class="id">isFunctor.Build</span> <span class="id">_</span> <span class="id">_</span> <span class="id">acto</span><br/>
&nbsp;&nbsp;<span class="id">free_semiCompSemiLattConvType_mor_id</span> <span class="id">free_semiCompSemiLattConvType_mor_comp</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">free_semiCompSemiLattConvType</span> <span class="id">:=</span> <span class="id">[the</span> <span class="id">{functor</span> <span class="id">CV</span> <span class="id">-&gt;</span> <span class="id">CS}</span> <span class="id">of</span> <span class="id">acto]</span>.<br/>
<br/>
<span class="vernacular">End</span> <span class="id">free_semiCompSemiLattConvType_functor</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">forget_semiCompSemiLattConvType_functor</span>.<br/>
<br/>
<span class="vernacular">Let</span> <span class="id">m2</span> <span class="id">:</span> <span class="id">CS</span> <span class="id">-&gt;</span> <span class="id">CV</span> <span class="id">:=</span> <span class="id">idfun</span>.<br/>
<br/>
<span class="vernacular">Let</span> <span class="id">h2</span> <span class="id">:=</span> <span class="gallina-kwd">fun</span> (<span class="id">a</span> <span class="id">b</span> <span class="id">:</span> <span class="id">CS</span>) (<span class="id">f</span> <span class="id">:</span> <span class="id">{hom</span> <span class="id">CS;</span> <span class="id">a,</span> <span class="id">b}</span>) <span class="id">=&gt;</span> <span class="id">Hom.Pack</span> (<span class="id">Hom.Class</span><br/>
&nbsp;&nbsp;(<span class="id">isHom.Axioms_</span> (<span class="id">m2</span> <span class="id">a</span>) (<span class="id">m2</span> <span class="id">b</span>) <span class="id">f</span> (<span class="id">scsl_hom_is_affine</span> <span class="id">f</span>))).<br/>
<br/>
<span class="vernacular">Let</span> <span class="id">h2_id</span> <span class="id">:</span> <span class="id">FunctorLaws.id</span> <span class="id">h2</span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof44')">Proof.</span></div>
<div class="proofscript" id="proof44">
 <span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">*;</span> <span class="id">apply</span> <span class="id">hom_ext</span>. Qed.</div>
<br/>
<span class="vernacular">Let</span> <span class="id">h2_comp</span> <span class="id">:</span> <span class="id">FunctorLaws.comp</span> <span class="id">h2</span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof45')">Proof.</span></div>
<div class="proofscript" id="proof45">
 <span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">*;</span> <span class="id">apply</span> <span class="id">hom_ext</span>. Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="vernacular">Definition</span> <span class="id">_</span> <span class="id">:=</span> <span class="id">isFunctor.Build</span> <span class="id">_</span> <span class="id">_</span> <span class="id">m2</span> <span class="id">h2_id</span> <span class="id">h2_comp</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">forget_semiCompSemiLattConvType</span> <span class="id">:=</span> <span class="id">[the</span> <span class="id">{functor</span> <span class="id">CS</span> <span class="id">-&gt;</span> <span class="id">CV}</span> <span class="id">of</span> <span class="id">m2]</span>.<br/>
<br/>
<span class="id">Local</span> <span class="vernacular">Notation</span> <span class="id">U1</span> <span class="id">:=</span> <span class="id">forget_semiCompSemiLattConvType</span>.<br/>
<br/>
<span class="vernacular">End</span> <span class="id">forget_semiCompSemiLattConvType_functor</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">eps1_eta1</span>.<br/>
<span class="vernacular">Import</span> <span class="id">category</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">classical_set_scope</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">convex_scope</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Notation</span> <span class="id">F1</span> <span class="id">:=</span> <span class="id">free_semiCompSemiLattConvType</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Notation</span> <span class="id">U1</span> <span class="id">:=</span> <span class="id">forget_semiCompSemiLattConvType</span>.<br/>
<span class="vernacular">Implicit</span> <span class="id">Types</span> <span class="id">L</span> <span class="id">:</span> <span class="id">semiCompSemiLattConvType</span>.<br/>
<br/>
<span class="vernacular">Let</span> <span class="id">eps1''</span> <span class="id">L</span> <span class="id">:=</span> (<span class="gallina-kwd">fun</span> <span class="id">X</span> <span class="id">:</span> <span class="id">{necset</span> <span class="id">L}</span> <span class="id">=&gt;</span> <span class="id">|_|</span> <span class="id">X</span>).<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">eps1''_biglubmorph</span> <span class="id">L</span> <span class="id">:</span> <span class="id">biglubmorph</span> (<span class="id">@eps1''</span> <span class="id">L</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof46')">Proof.</span></div>
<div class="proofscript" id="proof46">
<span class="id">move=&gt;</span> <span class="id">F</span>.<br/>
<span class="id">transitivity</span> (<span class="id">|_|</span> (<span class="id">biglub</span> <span class="id">@`</span> ((<span class="gallina-kwd">fun</span> <span class="id">X</span> <span class="id">:</span> <span class="id">{necset</span> <span class="id">L}</span> <span class="id">=&gt;</span> (<span class="id">X</span> <span class="id">:</span> <span class="id">neset</span> <span class="id">_</span>)) <span class="id">@`</span> <span class="id">F</span>))<span class="id">%:ne</span>).<br/>
&nbsp;&nbsp;<span class="id">transitivity</span> (<span class="id">|_|</span> (<span class="id">hull</span> (<span class="id">\bigcup_</span>(<span class="id">x</span> <span class="gallina-kwd">in</span> <span class="id">F</span>) <span class="id">x</span>))<span class="id">%:ne</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span> <span class="id">congr</span> (<span class="id">|_|</span> <span class="id">_</span>)<span class="id">;</span> <span class="id">apply</span> <span class="id">neset_ext</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">biglub_hull</span> <span class="id">biglub_bigcup</span>.<br/>
<span class="id">congr</span> (<span class="id">|_|</span> <span class="id">_</span>).<br/>
<span class="id">apply/neset_ext;</span> <span class="id">rewrite</span> <span class="id">eqEsubset;</span> <span class="id">split</span> <span class="id">=&gt;</span> <span class="id">x</span> <span class="id">[]</span> <span class="id">x0</span> <span class="id">Fx0</span> <span class="id">&lt;-</span>.<br/>
<span class="id">+</span> <span class="gallina-kwd">by</span> <span class="id">case:</span> <span class="id">Fx0</span> <span class="id">=&gt;</span> <span class="id">x1</span> <span class="id">Fx1</span> <span class="id">&lt;-;</span> <span class="gallina-kwd">exists</span> <span class="id">x1</span>.<br/>
<span class="id">+</span> <span class="gallina-kwd">by</span> <span class="gallina-kwd">exists</span> <span class="id">x0</span> <span class="id">=&gt;</span> <span class="id">//</span> <span class="id">;</span> <span class="gallina-kwd">exists</span> <span class="id">x0</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">Lemma</span> <span class="id">eps1''_affine</span> <span class="id">L</span> <span class="id">:</span> <span class="id">affine</span> (<span class="id">@eps1''</span> <span class="id">L</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof47')">Proof.</span></div>
<div class="proofscript" id="proof47">
<span class="id">move=&gt;</span> <span class="id">p</span> <span class="id">X</span> <span class="id">Y;</span> <span class="id">rewrite</span> <span class="id">-biglub_conv_setD</span>.<br/>
<span class="id">congr</span> (<span class="id">|_|</span> <span class="id">_%:ne</span>)<span class="id">;</span> <span class="id">apply/neset_ext</span> <span class="id">=&gt;</span> <span class="id">/=</span>.<br/>
<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">necset_convType.convE</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">Let</span> <span class="id">eps1'</span> <span class="id">:</span> <span class="id">F1</span> <span class="id">\O</span> <span class="id">U1</span> <span class="id">~~&gt;</span> <span class="id">FId</span> <span class="id">:=</span> <span class="gallina-kwd">fun</span> <span class="id">L</span> <span class="id">=&gt;</span> <span class="id">Hom.Pack</span> (<span class="id">Hom.Class</span> (<span class="id">isHom.Axioms_</span><br/>
&nbsp;&nbsp;((<span class="id">F1</span> <span class="id">\O</span> <span class="id">U1</span>) <span class="id">L</span>) (<span class="id">FId</span> <span class="id">L</span>) (<span class="id">@eps1''</span> <span class="id">L</span>)<br/>
&nbsp;&nbsp;(<span class="id">conj</span> (<span class="id">@eps1''_biglubmorph</span> <span class="id">L</span>) (<span class="id">@eps1''_affine</span> <span class="id">L</span>)))).<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">eps1'_natural</span> <span class="id">:</span> <span class="id">naturality</span> <span class="id">_</span> <span class="id">_</span> <span class="id">eps1'</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof48')">Proof.</span></div>
<div class="proofscript" id="proof48">
<span class="id">move=&gt;</span> <span class="id">K</span> <span class="id">L</span> <span class="id">f</span> <span class="id">/=;</span> <span class="id">rewrite</span> <span class="id">funeqE</span> <span class="id">=&gt;</span> <span class="id">X</span> <span class="id">/=</span>.<br/>
<span class="id">rewrite</span> <span class="id">biglub_morph;</span> <span class="id">congr</span> (<span class="id">|_|</span> <span class="id">_</span>).<br/>
<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">free_semiCompSemiLattConvType_morE</span>.<br/>
Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="vernacular">Definition</span> <span class="id">_</span> <span class="id">:=</span> <span class="id">isNatural.Build</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">eps1'_natural</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">eps1</span> <span class="id">:=</span> <span class="id">locked</span> <span class="id">[the</span> <span class="id">_</span> <span class="id">~&gt;</span> <span class="id">_</span> <span class="id">of</span> <span class="id">eps1']</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">eps1E</span> (<span class="id">L</span> <span class="id">:</span> <span class="id">semiCompSemiLattConvType</span>) <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">eps1</span> <span class="id">L</span> <span class="id">=</span> (<span class="gallina-kwd">fun</span> <span class="id">X</span> <span class="id">=&gt;</span> <span class="id">|_|</span> <span class="id">X</span>) <span class="id">:&gt;</span> (<span class="id">_</span> <span class="id">-&gt;</span> <span class="id">_</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof49')">Proof.</span></div>
<div class="proofscript" id="proof49">
 <span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">/eps1;</span> <span class="id">unlock</span>. Qed.</div>
<br/>
<span class="vernacular">Lemma</span> <span class="id">necset1_affine</span> (<span class="id">C</span> <span class="id">:</span> <span class="id">convType</span>) <span class="id">:</span> <span class="id">affine</span> (<span class="id">@necset1</span> <span class="id">C</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof50')">Proof.</span></div>
<div class="proofscript" id="proof50">
<span class="id">move=&gt;</span> <span class="id">p</span> <span class="id">a</span> <span class="id">b</span> <span class="id">/=;</span> <span class="id">apply/necset_ext;</span> <span class="id">rewrite</span> <span class="id">eqEsubset;</span> <span class="id">split=&gt;</span> <span class="id">x</span> <span class="id">/=</span>.<br/>
<span class="id">-</span> <span class="id">move-&gt;;</span> <span class="id">rewrite</span> <span class="id">necset_convType.convE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span> <span class="id">apply</span> <span class="id">conv_in_conv_set</span>.<br/>
<span class="id">-</span> <span class="id">rewrite</span> <span class="id">necset_convType.convE</span> <span class="id">/necset1</span> <span class="id">/=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span> <span class="id">case/conv_in_conv_set'=&gt;</span> <span class="id">a0</span> <span class="id">[]</span> <span class="id">b0</span> <span class="id">[]</span> <span class="id">-&gt;</span> <span class="id">[]</span> <span class="id">-&gt;</span> <span class="id">-&gt;</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">Let</span> <span class="id">eta1'</span> <span class="id">:</span> <span class="id">FId</span> <span class="id">~~&gt;</span> <span class="id">U1</span> <span class="id">\O</span> <span class="id">F1</span> <span class="id">:=</span> <span class="gallina-kwd">fun</span> <span class="id">C</span> <span class="id">=&gt;</span> <span class="id">Hom.Pack</span> (<span class="id">Hom.Class</span><br/>
&nbsp;&nbsp;(<span class="id">isHom.Axioms_</span> (<span class="id">FId</span> <span class="id">C</span>) ((<span class="id">U1</span> <span class="id">\O</span> <span class="id">F1</span>) <span class="id">C</span>) (<span class="id">@necset1</span> <span class="id">C</span>) (<span class="id">@necset1_affine</span> <span class="id">C</span>))).<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">eta1'_natural</span> <span class="id">:</span> <span class="id">naturality</span> <span class="id">_</span> <span class="id">_</span> <span class="id">eta1'</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof51')">Proof.</span></div>
<div class="proofscript" id="proof51">
<span class="id">move=&gt;</span> <span class="id">a</span> <span class="id">b</span> <span class="id">h;</span> <span class="id">rewrite</span> <span class="id">funeqE</span> <span class="id">=&gt;</span> <span class="id">x;</span> <span class="id">apply</span> <span class="id">necset_ext</span> <span class="id">=&gt;</span> <span class="id">/=</span>.<br/>
<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">free_semiCompSemiLattConvType_morE'</span> <span class="id">/=</span> <span class="id">image_set1</span>.<br/>
Qed.</div>
<br/>
<span class="id">HB.instance</span> <span class="vernacular">Definition</span> <span class="id">_</span> <span class="id">:=</span> <span class="id">isNatural.Build</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">eta1'_natural</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">eta1</span> <span class="id">:=</span> <span class="id">locked</span> <span class="id">[the</span> <span class="id">_</span> <span class="id">~&gt;</span> <span class="id">_</span> <span class="id">of</span> <span class="id">eta1']</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">eta1E</span> (<span class="id">C</span> <span class="id">:</span> <span class="id">convType</span>) <span class="id">:</span> <span class="id">eta1</span> <span class="id">C</span> <span class="id">=</span> <span class="id">@necset1</span> <span class="id">_</span> <span class="id">:&gt;</span> (<span class="id">_</span> <span class="id">-&gt;</span> <span class="id">_</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof52')">Proof.</span></div>
<div class="proofscript" id="proof52">
 <span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">/eta1;</span> <span class="id">unlock</span>. Qed.</div>
<br/>
<span class="vernacular">Import</span> <span class="id">comps_notation</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">necset1E</span> (<span class="id">T</span> <span class="id">:</span> <span class="id">convType</span>) (<span class="id">t</span> <span class="id">:</span> <span class="id">T</span>) <span class="id">:</span> <span class="id">necset1</span> <span class="id">t</span> <span class="id">=</span> <span class="id">[set</span> <span class="id">t]</span> <span class="id">:&gt;</span> <span class="id">set</span> <span class="id">T</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof53')">Proof.</span></div>
<div class="proofscript" id="proof53">
 <span class="gallina-kwd">by</span> <span class="id">[]</span>. Qed.</div>
<br/>
<span class="vernacular">Lemma</span> <span class="id">triL1</span> <span class="id">:</span> <span class="id">TriangularLaws.left</span> <span class="id">eta1</span> <span class="id">eps1</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof54')">Proof.</span></div>
<div class="proofscript" id="proof54">
<span class="id">move=&gt;</span> <span class="id">c;</span> <span class="id">apply</span> <span class="id">funext</span> <span class="id">=&gt;</span> <span class="id">x</span> <span class="id">/=;</span> <span class="id">apply/necset_ext</span> <span class="id">=&gt;</span> <span class="id">/=</span>.<br/>
<span class="id">rewrite</span> <span class="id">eps1E</span> <span class="id">/=</span> <span class="id">free_semiCompSemiLattConvType_morE'</span> <span class="id">/=</span>.<br/>
<span class="id">rewrite</span> <span class="id">-[in</span> <span class="id">RHS]</span>(<span class="id">hull_cset</span> <span class="id">x</span>)<span class="id">;</span> <span class="id">congr</span> <span class="id">hull</span>.<br/>
<span class="id">rewrite</span> <span class="id">eqEsubset</span> <span class="id">eta1E;</span> <span class="id">split=&gt;</span> <span class="id">a</span>.<br/>
<span class="id">-</span> <span class="gallina-kwd">by</span> <span class="id">case=&gt;</span> <span class="id">y</span> <span class="id">[]</span> <span class="id">b</span> <span class="id">xb</span> <span class="id">&lt;-;</span> <span class="id">rewrite</span> <span class="id">necset1E</span> <span class="id">=&gt;</span> <span class="id">-&gt;</span>.<br/>
<span class="id">-</span> <span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">xa;</span> <span class="gallina-kwd">exists</span> (<span class="id">necset1</span> <span class="id">a</span>)<span class="id">;</span> <span class="id">[exists</span> <span class="id">a</span> <span class="id">|</span> <span class="id">rewrite</span> <span class="id">necset1E]</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">Lemma</span> <span class="id">triR1</span> <span class="id">:</span> <span class="id">TriangularLaws.right</span> <span class="id">eta1</span> <span class="id">eps1</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof55')">Proof.</span></div>
<div class="proofscript" id="proof55">
 <span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">c;</span> <span class="id">apply</span> <span class="id">funext=&gt;</span> <span class="id">/=</span> <span class="id">x;</span> <span class="id">rewrite</span> <span class="id">eps1E</span> <span class="id">eta1E</span> <span class="id">/=</span> <span class="id">biglub1</span>. Qed.</div>
<br/>
<span class="vernacular">End</span> <span class="id">eps1_eta1</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">join1</span>.<br/>
<span class="vernacular">Import</span> <span class="id">category</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">convex_scope</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">classical_set_scope</span>.<br/>
<span class="vernacular">Variable</span> <span class="id">C</span> <span class="id">:</span> <span class="id">convType</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">join1'</span> (<span class="id">s</span> <span class="id">:</span> <span class="id">necset</span> <span class="id">{necset</span> <span class="id">C}</span>) <span class="id">:</span> <span class="id">{convex_set</span> <span class="id">C}</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">CSet.Pack</span> (<span class="id">CSet.Mixin</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">hull_is_convex</span> (<span class="id">\bigcup_</span>(<span class="id">x</span> <span class="gallina-kwd">in</span> <span class="id">s</span>) <span class="gallina-kwd">if</span> <span class="id">x</span> <span class="id">\in</span> <span class="id">s</span> <span class="gallina-kwd">then</span> <span class="id">x</span> <span class="id">:</span> <span class="id">set</span> <span class="id">_</span> <span class="gallina-kwd">else</span> <span class="id">cset0</span> <span class="id">_</span>))).<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">join1'_neq0</span> (<span class="id">s</span> <span class="id">:</span> <span class="id">necset</span> <span class="id">{necset</span> <span class="id">C}</span>) <span class="id">:</span> <span class="id">join1'</span> <span class="id">s</span> <span class="id">!=</span> <span class="id">set0</span> <span class="id">:&gt;</span> <span class="id">set</span> <span class="id">_</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof56')">Proof.</span></div>
<div class="proofscript" id="proof56">
<span class="id">rewrite</span> <span class="id">hull_eq0</span> <span class="id">set0P</span>.<br/>
<span class="id">case/set0P:</span> (<span class="id">neset_neq0</span> <span class="id">s</span>) <span class="id">=&gt;</span> <span class="id">y</span>.<br/>
<span class="id">case/set0P:</span> (<span class="id">neset_neq0</span> <span class="id">y</span>) <span class="id">=&gt;</span> <span class="id">x</span> <span class="id">yx</span> <span class="id">sy</span>.<br/>
<span class="gallina-kwd">by</span> <span class="gallina-kwd">exists</span> <span class="id">x;</span> <span class="gallina-kwd">exists</span> <span class="id">y</span> <span class="id">=&gt;</span> <span class="id">//;</span> <span class="id">move:</span> <span class="id">sy;</span> <span class="id">rewrite</span> <span class="id">-in_setE</span> <span class="id">=&gt;</span> <span class="id">-&gt;</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">Definition</span> <span class="id">join1</span> (<span class="id">s</span> <span class="id">:</span> <span class="id">necset</span> <span class="id">{necset</span> <span class="id">C}</span>) <span class="id">:</span> <span class="id">necset</span> <span class="id">C</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">NECSet.Pack</span> (<span class="id">NECSet.Class</span> (<span class="id">CSet.Mixin</span> (<span class="id">hull_is_convex</span> <span class="id">_</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NESet.Mixin</span> (<span class="id">join1'_neq0</span> <span class="id">s</span>))).<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">eps1_correct</span> (<span class="id">s</span> <span class="id">:</span> <span class="id">necset</span> <span class="id">{necset</span> <span class="id">C}</span>) <span class="id">:</span> <span class="id">@eps1</span> <span class="id">_</span> <span class="id">s</span> <span class="id">=</span> <span class="id">join1</span> <span class="id">s</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof57')">Proof.</span></div>
<div class="proofscript" id="proof57">
<span class="id">rewrite</span> <span class="id">eps1E;</span> <span class="id">apply/necset_ext</span> <span class="id">=&gt;</span> <span class="id">/=;</span> <span class="id">congr</span> (<span class="id">hull</span> <span class="id">_</span>).<br/>
<span class="id">rewrite</span> <span class="id">/bigcup;</span> <span class="id">rewrite</span> <span class="id">funeqE</span> <span class="id">=&gt;</span> <span class="id">c;</span> <span class="id">rewrite</span> <span class="id">propeqE;</span> <span class="id">split</span>.<br/>
<span class="id">-</span> <span class="gallina-kwd">by</span> <span class="id">case=&gt;</span> <span class="id">X</span> <span class="id">sX</span> <span class="id">Xc;</span> <span class="gallina-kwd">exists</span> <span class="id">X</span> <span class="id">=&gt;</span> <span class="id">//;</span> <span class="id">rewrite</span> <span class="id">-in_setE</span> <span class="gallina-kwd">in</span> <span class="id">sX;</span> <span class="id">rewrite</span> <span class="id">sX</span>.<br/>
<span class="id">-</span> <span class="id">case=&gt;</span> <span class="id">X</span> <span class="id">sX;</span> <span class="id">rewrite</span> <span class="id">-in_setE</span> <span class="gallina-kwd">in</span> <span class="id">sX;</span> <span class="id">rewrite</span> <span class="id">sX</span> <span class="id">=&gt;</span> <span class="id">Xc;</span> <span class="gallina-kwd">exists</span> <span class="id">X</span> <span class="id">=&gt;</span> <span class="id">//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">-in_setE</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">End</span> <span class="id">join1</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">P_delta_functor</span>.<br/>
<span class="vernacular">Import</span> <span class="id">category</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">P_delta_left</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">free_semiCompSemiLattConvType</span> <span class="id">\O</span> <span class="id">free_convType</span> <span class="id">\O</span> <span class="id">free_choiceType</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">P_delta_right</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">forget_choiceType</span> <span class="id">\O</span> <span class="id">forget_convType</span> <span class="id">\O</span> <span class="id">forget_semiCompSemiLattConvType</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">P_delta_acto</span> (<span class="id">T</span> <span class="id">:</span> <span class="gallina-kwd">Type</span>) <span class="id">:</span> <span class="gallina-kwd">Type</span> <span class="id">:=</span> <span class="id">P_delta_left</span> <span class="id">T</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">P_delta</span> <span class="id">:</span> <span class="id">{functor</span> <span class="id">CT</span> <span class="id">-&gt;</span> <span class="id">CT}</span> <span class="id">:=</span> <span class="id">P_delta_right</span> <span class="id">\O</span> <span class="id">P_delta_left</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">P_deltaE</span> (<span class="id">A</span> <span class="id">B</span> <span class="id">:</span> <span class="gallina-kwd">Type</span>) (<span class="id">f</span> <span class="id">:</span> <span class="id">{hom</span> <span class="id">A,</span> <span class="id">B}</span>) <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">P_delta</span> <span class="id">#</span> <span class="id">f</span> <span class="id">=</span> <span class="id">P_delta_left</span> <span class="id">#</span> <span class="id">f</span> <span class="id">:&gt;</span> (<span class="id">_</span> <span class="id">-&gt;</span> <span class="id">_</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof58')">Proof.</span></div>
<div class="proofscript" id="proof58">
 <span class="id">exact:</span> <span class="id">funext</span>. Qed.</div>
<br/>
<span class="vernacular">Lemma</span> <span class="id">eps0_Dist1</span> (<span class="id">A</span> <span class="id">:</span> <span class="gallina-kwd">Type</span>) (<span class="id">d</span> <span class="id">:</span> <span class="id">P_delta_acto</span> <span class="id">A</span>) <span class="id">:</span> <span class="id">eps0</span> <span class="id">_</span> (<span class="id">fsdist1</span> <span class="id">d</span>) <span class="id">=</span> <span class="id">d</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof59')">Proof.</span></div>
<div class="proofscript" id="proof59">
 <span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">eps0E</span> <span class="id">Convn_of_fsdist1</span>. Qed.</div>
<br/>
<span class="vernacular">End</span> <span class="id">P_delta_functor</span>.<br/>
<br/>
<span class="vernacular">Require</span> <span class="id">monad_lib</span>.<br/>
<span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">hierarchy</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">P_delta_category_monad</span>.<br/>
<span class="vernacular">Import</span> <span class="id">category</span>.<br/>
<span class="vernacular">Definition</span> <span class="id">AC</span> <span class="id">:=</span> <span class="id">AdjointFunctors.mk</span> <span class="id">triLC</span> <span class="id">triRC</span>.<br/>
<span class="vernacular">Definition</span> <span class="id">A0</span> <span class="id">:=</span> <span class="id">AdjointFunctors.mk</span> <span class="id">triL0</span> <span class="id">triR0</span>.<br/>
<span class="vernacular">Definition</span> <span class="id">A1</span> <span class="id">:=</span> <span class="id">AdjointFunctors.mk</span> <span class="id">triL1</span> <span class="id">triR1</span>.<br/>
<span class="vernacular">Definition</span> <span class="id">Aprob</span> <span class="id">:=</span> <span class="id">adj_comp</span> <span class="id">AC</span> <span class="id">A0</span>.<br/>
<span class="vernacular">Definition</span> <span class="id">Agcm</span> <span class="id">:=</span> <span class="id">adj_comp</span> <span class="id">Aprob</span> <span class="id">A1</span>.<br/>
<span class="vernacular">Definition</span> <span class="id">Mgcm</span> <span class="id">:=</span> <span class="id">Monad_of_adjoint_functors</span> <span class="id">Agcm</span>.<br/>
<span class="vernacular">Definition</span> <span class="id">gcm</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">[the</span> <span class="id">hierarchy.Monad.Exports.monad</span> <span class="id">of</span> <span class="id">Monad_of_category_monad.acto</span> <span class="id">Mgcm]</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">gcm_opsE</span>.<br/>
<span class="vernacular">Import</span> <span class="id">hierarchy</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">gcm_retE</span> (<span class="id">T</span> <span class="id">:</span> <span class="gallina-kwd">Type</span>) (<span class="id">x</span> <span class="id">:</span> <span class="id">choice_of_Type</span> <span class="id">T</span>) <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">Ret</span> <span class="id">x</span> <span class="id">=</span> <span class="id">necset1</span> (<span class="id">fsdist1</span> <span class="id">x</span>) <span class="id">:&gt;</span> <span class="id">gcm</span> <span class="id">T</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof60')">Proof.</span></div>
<div class="proofscript" id="proof60">
<span class="id">rewrite</span> <span class="id">/=</span> <span class="id">/ret_</span> <span class="id">/Monad_of_category_monad</span>.<span class="id">ret</span> <span class="id">/=</span>.<br/>
<span class="id">rewrite</span> <span class="id">!HCompId</span> <span class="id">!HIdComp</span> <span class="id">/=</span>.<br/>
<span class="id">rewrite</span> <span class="id">/id_f</span> <span class="id">/=</span> <span class="id">/etaC</span>.<br/>
<span class="id">unlock</span> <span class="id">=&gt;</span> <span class="id">/=</span>.<br/>
<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">eta0E</span> <span class="id">eta1E</span>.<br/>
Qed.</div>
<br/>
<span class="id">Local</span> <span class="vernacular">Notation</span> <span class="id">F1</span> <span class="id">:=</span> <span class="id">free_semiCompSemiLattConvType</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Notation</span> <span class="id">F0</span> <span class="id">:=</span> <span class="id">free_convType</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Notation</span> <span class="id">FC</span> <span class="id">:=</span> <span class="id">free_choiceType</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Notation</span> <span class="id">UC</span> <span class="id">:=</span> <span class="id">forget_choiceType</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Notation</span> <span class="id">U0</span> <span class="id">:=</span> <span class="id">forget_convType</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Notation</span> <span class="id">U1</span> <span class="id">:=</span> <span class="id">forget_semiCompSemiLattConvType</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span> <span class="id">:</span> <span class="gallina-kwd">Type</span>) (<span class="id">X</span> <span class="id">:</span> <span class="id">gcm</span> (<span class="id">gcm</span> <span class="id">T</span>)).<br/>
<br/>
<span class="vernacular">Import</span> <span class="id">category</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">convex_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">gcm_joinE</span> <span class="id">:</span> <span class="id">Join</span> <span class="id">X</span> <span class="id">=</span> <span class="id">necset_join</span> <span class="id">X</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof61')">Proof.</span></div>
<div class="proofscript" id="proof61">
<span class="id">apply/necset_ext</span>.<br/>
<span class="id">rewrite</span> <span class="id">/=</span> <span class="id">/join_</span> <span class="id">/=</span> <span class="id">/Monad_of_category_monad</span>.<span class="id">join</span> <span class="id">/=</span> <span class="id">!HCompId</span> <span class="id">!HIdComp</span> <span class="id">eps1E</span>.<br/>
<span class="id">rewrite</span> <span class="id">functor_o</span> <span class="id">NEqE</span> <span class="id">functor_id</span> <span class="id">compfid</span>.<br/>
<span class="id">rewrite</span> <span class="id">2!VCompE_nat</span> <span class="id">HCompId</span> <span class="id">HIdComp</span>.<br/>
<span class="id">set</span> <span class="id">E</span> <span class="id">:=</span> <span class="id">epsC</span> <span class="id">_;</span> <span class="id">have-&gt;:</span> <span class="id">E</span> <span class="id">=</span> <span class="id">[hom</span> <span class="id">idfun]</span> <span class="gallina-kwd">by</span> <span class="id">apply/hom_ext;</span> <span class="id">rewrite</span> <span class="id">epsCE</span>.<br/>
<span class="id">rewrite</span> <span class="id">functor_id_hom</span>.<br/>
<span class="id">rewrite</span> <span class="id">!functor_o</span> <span class="id">functor_id</span> <span class="id">!compfid</span>.<br/>
<span class="id">set</span> <span class="id">F1J</span> <span class="id">:=</span> <span class="id">F1</span> <span class="id">#</span> <span class="id">_</span>.<br/>
<span class="id">have-&gt;</span> <span class="id">:</span> <span class="id">F1J</span> <span class="id">=</span> <span class="id">@necset_join</span>.<span class="id">F1join0</span> <span class="id">_</span> <span class="id">:&gt;</span> (<span class="id">_</span> <span class="id">-&gt;</span> <span class="id">_</span>).<br/>
<span class="id">-</span> <span class="id">apply</span> <span class="id">funext=&gt;</span> <span class="id">x;</span> <span class="id">apply</span> <span class="id">necset_ext=&gt;</span> <span class="id">/=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">/F1J</span> <span class="id">/=</span> <span class="id">/necset_join</span>.<span class="id">F1join0'</span> <span class="id">/=</span>.<br/>
&nbsp;&nbsp;<span class="id">cbn</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">/free_semiCompSemiLattConvType_mor;</span> <span class="id">unlock=&gt;</span> <span class="id">/=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">eps0E</span>.<br/>
<span class="id">congr</span> <span class="id">hull;</span> <span class="id">apply:</span> <span class="id">classical_sets.eq_bigcup</span><span class="id">;</span> <span class="id">first</span> <span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">-eqEsubset</span>.<br/>
<span class="gallina-kwd">by</span> <span class="id">move=&gt;</span> <span class="id">x</span> <span class="id">nXx;</span> <span class="id">case:</span> <span class="id">ifPn</span> <span class="id">=&gt;</span> <span class="id">//</span> <span class="id">/negP;</span> <span class="id">rewrite</span> <span class="id">in_setE</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">End</span> <span class="id">gcm_opsE</span>.<br/>
<span class="vernacular">End</span> <span class="id">P_delta_category_monad</span>.<br/>
<br/>
<span class="vernacular">Require</span> <span class="id">proba_monad_model</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">probMonad_out_of_F0U0</span>.<br/>
<span class="vernacular">Import</span> <span class="id">category</span>.<br/>
<span class="vernacular">Definition</span> <span class="id">M</span> <span class="id">:=</span> <span class="id">proba_monad_model.MonadProbModel.t</span>.<br/>
<span class="vernacular">Definition</span> <span class="id">N</span> <span class="id">:=</span> <span class="id">[the</span> <span class="id">hierarchy.Monad.Exports.monad</span> <span class="id">of</span><br/>
&nbsp;&nbsp;<span class="id">Monad_of_category_monad.acto</span> (<span class="id">Monad_of_adjoint_functors</span> <span class="id">Aprob</span>)<span class="id">]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">actmE</span> <span class="id">T</span> <span class="id">:</span> <span class="id">N</span> <span class="id">T</span> <span class="id">=</span> <span class="id">M</span> <span class="id">T</span><br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof62')">Proof.</span></div>
<div class="proofscript" id="proof62">
 <span class="gallina-kwd">by</span> <span class="id">[]</span>. Qed.</div>
<br/>
<span class="vernacular">Import</span> <span class="id">comps_notation</span> <span class="id">hierarchy</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">monae_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">JoinE</span> <span class="id">T</span> <span class="id">:</span> (<span class="id">Join</span> <span class="id">:</span> (<span class="id">N</span> <span class="id">\o</span> <span class="id">N</span>) <span class="id">T</span> <span class="id">-&gt;</span> <span class="id">N</span> <span class="id">T</span>) <span class="id">=</span> (<span class="id">Join</span> <span class="id">:</span> (<span class="id">M</span> <span class="id">\o</span> <span class="id">M</span>) <span class="id">T</span> <span class="id">-&gt;</span> <span class="id">M</span> <span class="id">T</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof63')">Proof.</span></div>
<div class="proofscript" id="proof63">
<span class="id">apply</span> <span class="id">funext</span> <span class="id">=&gt;</span> <span class="id">t</span> <span class="id">/=</span>.<br/>
<span class="id">rewrite</span> <span class="id">/join_</span>.<br/>
<span class="id">rewrite</span> <span class="id">[in</span> <span class="id">LHS]/=</span> <span class="id">HCompId</span> <span class="id">HIdComp</span> <span class="id">[X</span> <span class="gallina-kwd">in</span> <span class="id">_</span> (<span class="id">X</span> <span class="id">t</span>)<span class="id">]/=</span>.<br/>
<span class="id">rewrite</span> <span class="id">/actm</span> <span class="id">[in</span> <span class="id">LHS]/=</span>.<br/>
<span class="id">rewrite</span> <span class="id">epsCE</span>.<br/>
<span class="id">rewrite</span> <span class="id">eps0_correct</span>.<br/>
<span class="id">rewrite</span> <span class="id">/fsdistjoin</span> <span class="id">/fsdistmap</span> <span class="id">/=</span> <span class="id">fsdistbindA</span> <span class="id">/=</span>.<br/>
<span class="id">congr</span> <span class="id">fsdistbind</span>.<br/>
<span class="gallina-kwd">by</span> <span class="id">apply</span> <span class="id">funext</span> <span class="id">=&gt;</span> <span class="id">x;</span> <span class="id">rewrite</span> <span class="id">fsdist1bind</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">Lemma</span> <span class="id">RetE</span> <span class="id">T</span> <span class="id">:</span> (<span class="id">Ret</span> <span class="id">:</span> <span class="id">idfun</span> <span class="id">T</span> <span class="id">-&gt;</span> <span class="id">N</span> <span class="id">T</span>) <span class="id">=</span> (<span class="id">Ret</span> <span class="id">:</span> <span class="id">FId</span> <span class="id">T</span> <span class="id">-&gt;</span> <span class="id">M</span> <span class="id">T</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof64')">Proof.</span></div>
<div class="proofscript" id="proof64">
<span class="id">apply</span> <span class="id">funext</span> <span class="id">=&gt;</span> <span class="id">t</span> <span class="id">/=</span>.<br/>
<span class="id">rewrite</span> <span class="id">/ret_</span>.<br/>
<span class="id">rewrite</span> <span class="id">[in</span> <span class="id">LHS]/=</span>.<br/>
<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">HCompId</span> <span class="id">HIdComp</span> <span class="id">[X</span> <span class="gallina-kwd">in</span> <span class="id">_</span> (<span class="id">X</span> <span class="id">t</span>)<span class="id">]/=</span> <span class="id">eta0E</span> <span class="id">etaCE</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">End</span> <span class="id">probMonad_out_of_F0U0</span>.<br/>

</div>
<div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/">a fork of coq2html</a></div>
</body>
</html>
