
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module example_typed_store</title>
<meta name="description" content="Documentation of Coq module example_typed_store" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init('proofscript')">
<h1 class="title">Module example_typed_store</h1>
<div class="coq">
<span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">ZArith</span>.<br/>
<span class="vernacular">From</span> <span class="id">mathcomp</span> <span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">all_ssreflect</span>.<br/>
<span class="vernacular">From</span> <span class="id">mathcomp</span> <span class="vernacular">Require</span> <span class="id">boolp</span>.<br/>
<span class="vernacular">From</span> <span class="id">infotheo</span> <span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">ssrZ</span>.<br/>
<span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">monad_model</span>.<br/>
<span class="vernacular">From</span> <span class="id">HB</span> <span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">structures</span>.<br/>
<span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">monae_lib</span> <span class="id">hierarchy</span> <span class="id">monad_lib</span> <span class="id">typed_store_lib</span>.<br/>
<br/>
<pre class="ssrdoc">
                        Typed store examples                               
                                                                           
 Inductive ml_type == generated by coqgen                                  
                                                                           
 Module MLTypesNat                                                         
   coq_type_nat          == adapted from code generated by coqgen          
   coq_type_nat0         == coq_type_nat with identity monad               
   Definition cycle                                                        
   Fixpoint fact_ref                                                       
   Definition fact_for                                                     
   Fixpoint fibo_ref                                                       
                                                                           
 Module MLtypes63                                                          
   Fixpoint coq_type63   == generated type translation function            
   Definition fact_for63                                                   
</pre>
<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">monae_scope</span>.<br/>
<br/>
<pre class="ssrdoc">
                            generated by coqgen                            
</pre>
<span class="vernacular">Module</span> <span class="id">MLTypes</span>.<br/>
<span class="vernacular">Inductive</span> <span class="id">ml_type</span> <span class="id">:</span> <span class="gallina-kwd">Set</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">ml_int</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">ml_bool</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">ml_unit</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">ml_ref</span> (<span class="id">_</span> <span class="id">:</span> <span class="id">ml_type</span>)<br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">ml_arrow</span> (<span class="id">_</span> <span class="id">:</span> <span class="id">ml_type</span>) (<span class="id">_</span> <span class="id">:</span> <span class="id">ml_type</span>)<br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">ml_rlist</span> (<span class="id">_</span> <span class="id">:</span> <span class="id">ml_type</span>).<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">ml_type_eq_dec</span> (<span class="id">T1</span> <span class="id">T2</span> <span class="id">:</span> <span class="id">ml_type</span>) <span class="id">:</span> <span class="id">{T1=T2}+{T1&lt;&gt;T2}</span>.<br/>
<span class="id">revert</span> <span class="id">T2;</span> <span class="id">induction</span> <span class="id">T1;</span> <span class="id">destruct</span> <span class="id">T2;</span><br/>
&nbsp;&nbsp;<span class="id">try</span> (<span class="id">right;</span> <span class="id">intro;</span> <span class="id">discriminate</span>)<span class="id">;</span> <span class="id">try</span> (<span class="id">now</span> <span class="id">left</span>)<span class="id">;</span><br/>
&nbsp;&nbsp;<span class="id">try</span> (<span class="id">case</span> (<span class="id">IHT1_5</span> <span class="id">T2_5</span>)<span class="id">;</span> <span class="id">[|right;</span> <span class="id">injection;</span> <span class="id">intros;</span> <span class="id">contradiction]</span>)<span class="id">;</span><br/>
&nbsp;&nbsp;<span class="id">try</span> (<span class="id">case</span> (<span class="id">IHT1_4</span> <span class="id">T2_4</span>)<span class="id">;</span> <span class="id">[|right;</span> <span class="id">injection;</span> <span class="id">intros;</span> <span class="id">contradiction]</span>)<span class="id">;</span><br/>
&nbsp;&nbsp;<span class="id">try</span> (<span class="id">case</span> (<span class="id">IHT1_3</span> <span class="id">T2_3</span>)<span class="id">;</span> <span class="id">[|right;</span> <span class="id">injection;</span> <span class="id">intros;</span> <span class="id">contradiction]</span>)<span class="id">;</span><br/>
&nbsp;&nbsp;<span class="id">try</span> (<span class="id">case</span> (<span class="id">IHT1_2</span> <span class="id">T2_2</span>)<span class="id">;</span> <span class="id">[|right;</span> <span class="id">injection;</span> <span class="id">intros;</span> <span class="id">contradiction]</span>)<span class="id">;</span><br/>
&nbsp;&nbsp;(<span class="id">case</span> (<span class="id">IHT1</span> <span class="id">T2</span>) <span class="id">||</span> <span class="id">case</span> (<span class="id">IHT1_1</span> <span class="id">T2_1</span>))<span class="id">;</span> <span class="id">try</span> (<span class="id">left;</span> <span class="id">now</span> <span class="id">subst</span>)<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">right;</span> <span class="id">injection;</span> <span class="id">intros;</span> <span class="id">contradiction</span>.<br/>
Defined.</div>
<br/>
<span class="vernacular">Definition</span> <span class="id">val_nonempty</span> (<span class="id">M</span> <span class="id">:</span> <span class="id">UU0</span> <span class="id">-&gt;</span> <span class="id">UU0</span>) <span class="id">:=</span> <span class="id">tt</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">loc</span> <span class="id">:=</span> (<span class="id">@loc</span> <span class="id">_</span> <span class="id">monad_model.locT_nat</span>).<br/>
<br/>
<span class="vernacular">Inductive</span> <span class="id">rlist</span> (<span class="id">a</span> <span class="id">:</span> <span class="gallina-kwd">Type</span>) (<span class="id">a_1</span> <span class="id">:</span> <span class="id">ml_type</span>) <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">Nil</span><br/>
&nbsp;&nbsp;<span class="id">|</span> <span class="id">Cons</span> (<span class="id">_</span> <span class="id">:</span> <span class="id">a</span>) (<span class="id">_</span> <span class="id">:</span> <span class="id">loc</span> (<span class="id">ml_rlist</span> <span class="id">a_1</span>)).<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">ml_type_eq_mixin</span> <span class="id">:=</span> <span class="id">EqMixin</span> (<span class="id">comparePc</span> <span class="id">MLTypes.ml_type_eq_dec</span>).<br/>
<span class="vernacular">Canonical</span> <span class="id">ml_type_eqType</span> <span class="id">:=</span> <span class="vernacular">Eval</span> <span class="id">hnf</span> <span class="gallina-kwd">in</span> <span class="id">EqType</span> <span class="id">_</span> <span class="id">ml_type_eq_mixin</span>.<br/>
<br/>
<span class="vernacular">End</span> <span class="id">MLTypes</span>.<br/>
<pre class="ssrdoc">
Module CoqTypeNat.
Import MLTypes.
Section with_monad.
Context [M : Type -&gt; Type].
Fixpoint coq_type_nat (T : ml_type) : Type :=
  match T with
  | ml_int =&gt; nat
  | ml_bool =&gt; bool
  | ml_unit =&gt; unit
  | ml_arrow T1 T2 =&gt; coq_type_nat T1 -&gt; M (coq_type_nat T2)
  | ml_ref T1 =&gt; loc T1
  | ml_rlist T1 =&gt; rlist (coq_type_nat T1) T1
  end.
End with_monad.
HB.instance Definition _ := @isML_universe.Build ml_type
  (Equality.class ml_type_eqType) coq_type_nat ml_unit val_nonempty.
Definition typedStoreMonad (N : monad) :=
  typedStoreMonad ml_type N monad_model.locT_nat.
Section cyclic.
Variables (N : monad) (M : typedStoreMonad N).
Local Notation coq_type := (hierarchy.coq_type N).
Local Open Scope do_notation.
Definition cycle (T : ml_type) (a b : coq_type T)
  : M (coq_type (ml_rlist T)) :=
  do r &lt;- cnew (ml_rlist T) (Nil (coq_type T) T);
  do l &lt;-
  (do v &lt;- cnew (ml_rlist T) (Cons (coq_type T) T b r);
   Ret (Cons (coq_type T) T a v));
  do _ &lt;- cput r l; Ret l.
Definition hd (T : ml_type) (def : coq_type T)
  (param : coq_type (ml_rlist T)) : coq_type T :=
  match param with | Nil =&gt; def | Cons a _ =&gt; a end.
Lemma hd_is_true :
  crun (do l &lt;- cycle ml_bool true false; Ret (hd ml_bool false l)) = Some true.
Proof.
rewrite bindA.
under eq_bind =&gt; tl.
  rewrite !bindA.
  under eq_bind do rewrite !bindA bindretf !bindA bindretf /=.
  over.
rewrite -bindA_uncurry -bindA crunret // crunchkput // bindA.
under eq_bind do rewrite !bindA.
under eq_bind do under eq_bind do rewrite bindretf /=.
by rewrite crunnewchkC // crunnewchk0.
Qed.
Definition tl (T : ml_type) (param : coq_type (ml_rlist T))
  : M (coq_type (ml_rlist T)) :=
  match param with
  | Nil =&gt; Ret (Nil (coq_type T) T)
  | Cons _ t =&gt; cget t
  end.
Lemma hd_tl_tl_is_true :
  crun (do l &lt;- cycle ml_bool true false; do l1 &lt;- tl _ l; do l2 &lt;- tl _ l1;
        Ret (hd ml_bool false l2)) = Some true.
Proof.
rewrite bindA -cnewchk.
under eq_bind =&gt; r1.
  under eq_bind do rewrite !bindA.
  under cchknewE do rewrite !(bindA,bindretf) -bindA cputgetC //.
  rewrite cnewget /=.
  under cchknewE do rewrite cputget /=.
  over.
rewrite cnewchk -bindA_uncurry -bindA crunret // crunchkput // bindA.
under eq_bind do rewrite !bindA.
under eq_bind do under eq_bind do rewrite bindretf /=.
by rewrite crunnewchkC // crunnewchk0.
Qed.
End cyclic.
Module eval_cyclic.
Section eval.
Import monad_model.ModelTypedStore.
                
Definition M :=
  [the typedStoreMonad idfun of @acto ml_type idfun].
Definition Env := Env ml_type idfun.
Definition empty_env : Env := [::].
copied from typed_store_model.v 
Definition W (A : UU0) : UU0 := monad_model.option_monad (A * Env).
Definition Restart [A B] (r : W A) (f : M B) : W B :=
  if r is inr (_, env) then f env else inl tt.
Definition FromW [A] (r : W A) : M A :=
  fun env =&gt; if r is inr (a, _) then inr (a, env) else inl tt.
Definition it0 : W unit := inr (tt, empty_env).
Local Open Scope do_notation.
Local Notation mkloc := (mkloc (locT:=monad_model.locT_nat)).
Local Notation coq_type := (coq_type _).
Definition incr (l : loc ml_int) : M nat :=
  do x &lt;- cget l; do _ &lt;- cput l (succn x); Ret (succn x).
Definition l : W (loc ml_int) := Restart it0 (cnew ml_int 3).
Eval vm_compute in l.
Definition it1 := Restart l (do l &lt;- FromW l; incr l).
Eval vm_compute in it1.
Definition it2 := Restart it1 (do l &lt;- FromW l; incr l).
Eval vm_compute in it2.
Local Notation cycle := (cycle idfun M).
Definition it3 := Restart it2 (cycle ml_bool true false).
Eval vm_compute in it3.
Local Notation hd := (hd idfun).
Definition it4 := Restart it3 (do l &lt;- FromW it3; Ret (hd ml_bool false l)).
Eval vm_compute in it4.
Eval vm_compute in crun (FromW it4).
Local Notation tl := (tl idfun M).
Definition it5 := Restart it4
                    (do l0 &lt;- FromW it3;
                     do l1 &lt;- tl _ l0;
                     do l2 &lt;- tl _ l1;
                     Ret (hd ml_bool false l2)).
Eval vm_compute in it5.
Eval vm_compute in crun (FromW it5).
End eval.
End eval_cyclic.
Section factorial.
Variable (N : monad) (M : typedStoreMonad N).
Fixpoint fact_ref (r : loc ml_int) (n : nat) : M unit :=
  if n is m.+1 then cget r &gt;&gt;= fun p =&gt; cput r (n * p) &gt;&gt; fact_ref r m
  else skip.
Theorem fact_ref_ok n :
  crun (cnew ml_int 1 &gt;&gt;= fun r =&gt; fact_ref r n &gt;&gt; cget r) = Some (fact_rec n).
Proof.
set fn := fact_rec n.
set m := n.
set s := 1.
have smn : s * fact_rec m = fn by rewrite mul1n.
elim: m s smn =&gt; [|m IH] s /= smn.
  rewrite /fact_ref -smn muln1.
  under eq_bind do rewrite bindskipf.
  by rewrite cnewgetret crunret // crunnew0.
under eq_bind do rewrite bindA.
rewrite cnewget.
under eq_bind do rewrite bindA.
by rewrite cnewput IH // (mulnC m.+1) -mulnA.
Qed.
End factorial.
Section fact_for.
Variable (N : monad) (M : typedStoreMonad N).
Local Notation coq_type := (hierarchy.coq_type N).
Local Open Scope do_notation.
Definition fact_for (n : coq_type ml_int) : M (coq_type ml_int) :=
  do v &lt;- cnew ml_int 1;
  do _ &lt;-
  (do u &lt;- Ret 1;
   do v_1 &lt;- Ret n;
   forloop u v_1
     (fun i =&gt;
        do v_1 &lt;- (do v_1 &lt;- cget v; Ret (v_1 * i));
        cput v v_1));
  cget v.
Theorem fact_for_ok n : crun (fact_for n) = Some (fact_rec n).
Proof.
rewrite /fact_for.
under eq_bind do rewrite !bindA !bindretf.
transitivity (crun (cnew ml_int (fact_rec n) &gt;&gt; Ret (fact_rec n) : M _));
  last by rewrite crunret // crunnew0.
congr crun.
rewrite -{1}/(fact_rec 0).
pose m := n.
have -&gt; : 0 = n - m by rewrite subnn.
have : m &lt;= n by [].
elim: m =&gt; [|m IH] mn.
  rewrite subn0.
  under eq_bind do rewrite forloop0 ?leqnn // bindretf -cgetret.
  by rewrite cnewget.
rewrite subnSK //.
under eq_bind do (rewrite forloopS; last by apply leq_subr).
under eq_bind do rewrite !bindA.
rewrite cnewget.
under eq_bind do rewrite bindretf.
rewrite cnewput -IH; last by apply ltnW.
by rewrite subnS mulnC -(@prednK (n-m)) // lt0n subn_eq0 -ltnNge.
Qed.
End fact_for.
Section fibonacci.
Variables (N : monad) (M : typedStoreMonad N).
Fixpoint fibo_rec n :=
  if n is m.+1 then
    if m is k.+1 then fibo_rec k + fibo_rec m else 1
  else 1.
Fixpoint fibo_ref n (a b : loc ml_int) : M unit :=
  if n is n.+1 then
    cget a &gt;&gt;= (fun x =&gt; cget b &gt;&gt;= fun y =&gt; cput a y &gt;&gt; cput b (x + y))
           &gt;&gt; fibo_ref n a b
  else skip.
Theorem fibo_ref_ok n :
  crun (cnew ml_int 1 &gt;&gt;=
             (fun a =&gt; cnew ml_int 1 &gt;&gt;= fun b =&gt; fibo_ref n a b &gt;&gt; cget a))
  = Some (fibo_rec n).
Proof.
set x := 1.
pose y := x.
rewrite -{2}/y.
pose i := n.
rewrite -[in LHS]/i.
have : (x, y) = (fibo_rec (n - i), fibo_rec (n.+1 - i)).
  by rewrite subnn -addn1 addKn.
have : i &lt;= n by [].
elim: i x y =&gt; [|i IH] x y Hi.
  rewrite !subn0 =&gt; -[-&gt; -&gt;].
  rewrite -/(fibo_rec n.+1).
  under eq_bind do under eq_bind do rewrite /= bindskipf.
  rewrite -cnewchk.
  under eq_bind do rewrite -cgetret cchknewget.
  by rewrite cnewget -bindA crunret // crunnew // crunnew0.
rewrite subSS =&gt; -[] Hx Hy.
rewrite -(IH y (x + y) (ltnW Hi)); last first.
  rewrite {}Hx {}Hy; congr pair.
  rewrite subSn 1?ltnW//.
  case: n {IH} =&gt; // n in Hi *.
  by rewrite [in RHS]subSn -1?ltnS// subSS subSn -1?ltnS.
rewrite /=.
under eq_bind do under eq_bind do rewrite !bindA.
rewrite -cnewchk.
under eq_bind do rewrite cchknewget.
rewrite cnewget.
under eq_bind do under eq_bind do rewrite !bindA.
under eq_bind do rewrite cnewget.
under eq_bind do under eq_bind do rewrite !bindA.
rewrite -[in LHS]cnewchk.
under eq_bind do rewrite cchknewput.
rewrite cnewput.
by under eq_bind do rewrite cnewput.
Qed.
End fibonacci.
End CoqTypeNat.
Require Import PrimInt63.
Require Sint63.
Section Int63.
Definition uint2N (n : int) : nat :=
  if Uint63.to_Z n is Zpos pos then Pos.to_nat pos else 0.
Definition N2int n := Uint63.of_Z (Z.of_nat n).
Lemma ltsbNlesb m n : ltsb m n = ~~ lesb n m.
Proof.
case/boolP: (lesb n m) =&gt; /Sint63.lebP nm; apply/Sint63.ltbP =&gt; /=;
  by [apply Z.le_ngt | apply Z.nle_gt].
Qed.
Lemma ltsbW m n : ltsb m n -&gt; lesb m n.
Proof. move/Sint63.ltbP/Z.lt_le_incl =&gt; mn; by apply/Sint63.lebP. Qed.
Lemma lesb_ltsbS_eq m n : lesb m n -&gt; ltsb n (Uint63.succ m) -&gt; m = n.
Proof.
move/Sint63.lebP =&gt; mn /Sint63.ltbP nSm.
move: (nSm).
rewrite Sint63.succ_of_Z -Sint63.is_int; last first.
  split.
    apply Z.le_le_succ_r.
    by case: (Sint63.to_Z_bounded m).
  apply Zlt_le_succ, (Z.le_lt_trans _ _ _ mn), (Z.lt_le_trans _ _ _ nSm).
  by case: (Sint63.to_Z_bounded (Uint63.succ m)).
move/Zlt_le_succ/Zsucc_le_reg =&gt; nm.
by apply Sint63.to_Z_inj, Zle_antisym.
Qed.
The opposite is not true ! (n = max_int) 
Lemma ltsbS_lesb m n : ltsb m (Uint63.succ n) -&gt; lesb m n.
Proof.
rewrite -[lesb _ _]negbK -ltsbNlesb =&gt; nSm; apply/negP =&gt; /[dup] /ltsbW nm.
by rewrite (lesb_ltsbS_eq n m) // =&gt; /Sint63.ltbP /Z.lt_irrefl.
Qed.
Lemma uint63_min n : (0 &lt;= Uint63.to_Z n)%Z.
Proof. by case: (Uint63.to_Z_bounded n). Qed.
Lemma uint63_max n : (Uint63.to_Z n &lt; Uint63.wB)%Z.
Proof. by case: (Uint63.to_Z_bounded n). Qed.
Lemma uint2N_pred n : n &lt;&gt; 0%int63 -&gt; uint2N n = (uint2N (Uint63.pred n)).+1.
Proof.
move=&gt; Hn.
rewrite /uint2N Uint63.pred_spec.
case HnZ: (Uint63.to_Z n) =&gt; [|m|m].
- rewrite (_ : 0 = Uint63.to_Z 0)%Z // in HnZ.
  move/Uint63.to_Z_inj in HnZ.
  by elim Hn.
- have Hm1 : (0 &lt;= Z.pos m - 1 &lt; Uint63.wB)%Z.
    split. by apply leZsub1, Pos2Z.is_pos.
    apply (Z.lt_trans _ (Z.pos m)).
      by apply leZsub1, Z.le_refl.
    rewrite -HnZ; by apply uint63_max.
  rewrite Zmod_small //.
  case HmZ: (Z.pos m - 1)%Z =&gt; [|p|p].
  + by move/Z.sub_move_r: HmZ =&gt; /= [] -&gt;.
  + apply Nat2Z.inj =&gt; /=.
    rewrite positive_nat_Z Pos2SuccNat.id_succ Pos2Z.inj_succ -HmZ.
    by rewrite (Z.succ_pred (Z.pos m)).
  + by destruct m.
- move: (uint63_min n).
  rewrite HnZ =&gt; /Zle_not_lt; elim.
  by apply Zlt_neg_0.
Qed.
Lemma lesb_sub_bounded m n :
  lesb m n -&gt; (0 &lt;= Sint63.to_Z n - Sint63.to_Z m &lt; Uint63.wB)%Z.
Proof.
move/Sint63.lebP =&gt; mn.
split. by apply Zle_minus_le_0.
apply
 (Z.le_lt_trans _ (Sint63.to_Z Sint63.max_int - Sint63.to_Z Sint63.min_int))%Z.
  apply leZ_sub.
    by case: (Sint63.to_Z_bounded n).
  by case: (Sint63.to_Z_bounded m).
done.
Qed.
Lemma ltsb_neq m n : ltsb m n -&gt; m &lt;&gt; n.
Proof. by move/Sint63.ltbP/[swap]/(f_equal Sint63.to_Z)-&gt; =&gt;/Z.lt_irrefl. Qed.
(*
Lemma sub0_eq m n : sub m n = 0%int63 -&gt; m = n.
Proof.
rewrite Sint63.sub_of_Z =&gt; /(f_equal Uint63.to_Z).
rewrite Uint63.of_Z_spec.
move/Sint63.ltbP in mn.
rewrite Zmod_small.
  rewrite Z.sub_move_r /= =&gt; nm.
  rewrite nm in mn.
  by move/Z.lt_irrefl in mn.
by apply /lesb_sub_bounded /Sint63.lebP /Z.lt_le_incl.
Qed.

Lemma ltsb_sub_neq0 m n : ltsb m n -&gt; sub n m &lt;&gt; 0%int63.
Proof.
move=&gt; mn.
rewrite Sint63.sub_of_Z =&gt; /(f_equal Uint63.to_Z).
rewrite Uint63.of_Z_spec.
move/Sint63.ltbP in mn.
rewrite Zmod_small.
  rewrite Z.sub_move_r /= =&gt; nm.
  rewrite nm in mn.
  by move/Z.lt_irrefl in mn.
by apply /lesb_sub_bounded /Sint63.lebP /Z.lt_le_incl.
Qed.
Lemma sub_succ_pred m n : sub n (Uint63.succ m) = Uint63.pred (sub n m).
Proof.
apply Uint63.to_Z_inj.
rewrite Uint63.sub_spec Uint63.succ_spec Uint63.pred_spec Uint63.sub_spec.
rewrite Zminus_mod Zmod_mod -Zminus_mod Z.sub_add_distr.
apply/esym.
by rewrite Zminus_mod Zmod_mod -Zminus_mod.
Qed.
Lemma uint2N_sub_succ m n : ltsb m n -&gt;
  uint2N (sub n m) = (uint2N (sub n (Uint63.succ m))).+1.
Proof. move/ltsb_sub_neq0 =&gt; mn. by rewrite sub_succ_pred uint2N_pred. Qed.
Lemma N2int_succ : {morph N2int : x / x.+1 &gt;-&gt; Uint63.succ x}.
Proof.
move=&gt; x; apply Uint63.to_Z_inj; rewrite Uint63.succ_spec !Uint63.of_Z_spec.
by rewrite Zplus_mod /= Zpos_P_of_succ_nat /Z.succ Zplus_mod Zmod_mod.
Qed.
Lemma N2int_mul : {morph N2int : x y / x * y &gt;-&gt; mul x y}.
Proof.
move=&gt; x y; apply Uint63.to_Z_inj.
by rewrite Uint63.mul_spec !Uint63.of_Z_spec Nat2Z.inj_mul Zmult_mod.
Qed.
Lemma N2int_bounded n :
  (Z.of_nat n &lt;= Sint63.to_Z Sint63.max_int)%Z -&gt;
  (Sint63.to_Z Sint63.min_int &lt;= Z.of_nat n &lt;= Sint63.to_Z Sint63.max_int)%Z.
Proof.
split =&gt; //.
apply (Z.le_trans _ 0).
  rewrite -[0%Z]/(Sint63.to_Z 0).
  by case: (Sint63.to_Z_bounded 0).
by apply Zle_0_nat.
Qed.
End Int63.
Module CoqTypeInt63.
Import MLTypes.
</pre>
<pre class="ssrdoc">
Section with_monad.
Context [M : Type -&gt; Type].
Fixpoint coq_type63 (T : ml_type) : Type :=
  match T with
  | ml_int =&gt; int
  | ml_bool =&gt; bool
  | ml_unit =&gt; unit
  | ml_arrow T1 T2 =&gt; coq_type63 T1 -&gt; M (coq_type63 T2)
  | ml_ref T1 =&gt; loc T1
  | ml_rlist T1 =&gt; rlist (coq_type63 T1) T1
  end.
End with_monad.
</pre>
<br/>
<span class="id">HB.instance</span> <span class="vernacular">Definition</span> <span class="id">_</span> <span class="id">:=</span> <span class="id">@isML_universe</span>.<span class="id">Build</span> <span class="id">ml_type</span><br/>
&nbsp;&nbsp;(<span class="id">Equality.class</span> <span class="id">ml_type_eqType</span>) <span class="id">coq_type63</span> <span class="id">ml_unit</span> <span class="id">val_nonempty</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">fact_for_int63</span>.<br/>
<span class="vernacular">Variable</span> <span class="id">N</span> <span class="id">:</span> <span class="id">monad</span>.<br/>
<span class="vernacular">Variable</span> <span class="id">M</span> <span class="id">:</span> <span class="id">typedStoreMonad</span> <span class="id">ml_type</span> <span class="id">N</span> <span class="id">monad_model.locT_nat</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Notation</span> <span class="id">coq_type</span> <span class="id">:=</span> (<span class="id">hierarchy.coq_type</span> <span class="id">N</span>).<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">do_notation</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">forloop63</span>.<br/>
<span class="vernacular">Definition</span> <span class="id">forloop63</span> (<span class="id">n_1</span> <span class="id">n_2</span> <span class="id">:</span> <span class="id">int</span>) (<span class="id">b</span> <span class="id">:</span> <span class="id">int</span> <span class="id">-&gt;</span> <span class="id">M</span> <span class="id">unit</span>) <span class="id">:</span> <span class="id">M</span> <span class="id">unit</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span> <span class="id">Sint63.ltb</span> <span class="id">n_2</span> <span class="id">n_1</span> <span class="gallina-kwd">then</span> <span class="id">Ret</span> <span class="id">tt</span> <span class="gallina-kwd">else</span><br/>
&nbsp;&nbsp;<span class="id">iter</span> (<span class="id">uint2N</span> (<span class="id">sub</span> <span class="id">n_2</span> <span class="id">n_1</span>)).<span class="id">+1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">fun</span> (<span class="id">m</span> <span class="id">:</span> <span class="id">M</span> <span class="id">int</span>) <span class="id">=&gt;</span> <span class="id">do</span> <span class="id">i</span> <span class="id">&lt;-</span> <span class="id">m;</span> <span class="id">do</span> <span class="id">_</span> <span class="id">&lt;-</span> <span class="id">b</span> <span class="id">i;</span> <span class="id">Ret</span> (<span class="id">Uint63.succ</span> <span class="id">i</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Ret</span> <span class="id">n_1</span>) <span class="id">&gt;&gt;</span> <span class="id">Ret</span> <span class="id">tt</span>.<br/>
<br/>
<span class="vernacular">Lemma</span> <span class="id">forloop63S</span> <span class="id">m</span> <span class="id">n</span> (<span class="id">f</span> <span class="id">:</span> <span class="id">int</span> <span class="id">-&gt;</span> <span class="id">M</span> <span class="id">unit</span>) <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">ltsb</span> <span class="id">m</span> <span class="id">n</span> <span class="id">-&gt;</span> <span class="id">forloop63</span> <span class="id">m</span> <span class="id">n</span> <span class="id">f</span> <span class="id">=</span> <span class="id">f</span> <span class="id">m</span> <span class="id">&gt;&gt;</span> <span class="id">forloop63</span> (<span class="id">Uint63.succ</span> <span class="id">m</span>) <span class="id">n</span> <span class="id">f</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof1')">Proof.</span></div>
<div class="proofscript" id="proof1">
<span class="id">rewrite</span> <span class="id">/forloop63</span> <span class="id">=&gt;</span> <span class="id">mn</span>.<br/>
<span class="id">rewrite</span> <span class="id">ltsbNlesb</span> (<span class="id">ltsbW</span> <span class="id">_</span> <span class="id">_</span> <span class="id">mn</span>) <span class="id">/=</span>.<br/>
<span class="id">case:</span> <span class="id">ifPn</span> <span class="id">=&gt;</span> <span class="id">nSm</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span> <span class="id">move:</span> <span class="id">mn;</span> <span class="id">rewrite</span> <span class="id">ltsbNlesb</span> <span class="id">=&gt;</span> <span class="id">/negP;</span> <span class="id">elim;</span> <span class="id">apply</span> <span class="id">ltsbS_lesb</span>.<br/>
<span class="id">rewrite</span> <span class="id">ltsbNlesb</span> <span class="id">negbK</span> <span class="gallina-kwd">in</span> <span class="id">nSm</span>.<br/>
<span class="id">rewrite</span> <span class="id">uint2N_sub_succ</span> <span class="id">//</span>.<br/>
<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">iterSr</span> <span class="id">bindretf</span> <span class="id">!bindA</span> <span class="id">iter_bind</span> <span class="id">!bindA</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">Lemma</span> <span class="id">forloop631</span> <span class="id">m</span> (<span class="id">f</span> <span class="id">:</span> <span class="id">int</span> <span class="id">-&gt;</span> <span class="id">M</span> <span class="id">unit</span>) <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">forloop63</span> <span class="id">m</span> <span class="id">m</span> <span class="id">f</span> <span class="id">=</span> <span class="id">f</span> <span class="id">m</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof2')">Proof.</span></div>
<div class="proofscript" id="proof2">
 <span class="id">rewrite</span> <span class="id">/forloop63</span>.<br/>
<span class="id">case:</span> (<span class="id">Sint63.ltbP</span> <span class="id">m</span> <span class="id">m</span>) <span class="id">=&gt;</span> <span class="id">[/Z</span>.<span class="id">lt_irrefl</span> <span class="id">//</span> <span class="id">|</span> <span class="id">_]</span>.<br/>
<span class="id">rewrite</span> <span class="id">/=</span> <span class="id">bindA</span>.<br/>
<span class="id">rewrite</span> <span class="id">/uint2N</span> <span class="id">Uint63.sub_spec</span> <span class="id">Z.sub_diag</span> <span class="id">Zmod_0_l</span> <span class="id">/=</span>.<br/>
<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">!</span>(<span class="id">bindretf,bindA</span>) <span class="id">bindmskip</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">Lemma</span> <span class="id">forloop630</span> <span class="id">m</span> <span class="id">n</span> (<span class="id">f</span> <span class="id">:</span> <span class="id">int</span> <span class="id">-&gt;</span> <span class="id">M</span> <span class="id">unit</span>) <span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">ltsb</span> <span class="id">n</span> <span class="id">m</span> <span class="id">-&gt;</span> <span class="id">forloop63</span> <span class="id">m</span> <span class="id">n</span> <span class="id">f</span> <span class="id">=</span> <span class="id">skip</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof3')">Proof.</span></div>
<div class="proofscript" id="proof3">
 <span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">/forloop63</span> <span class="id">=&gt;</span> <span class="id">-&gt;</span>. Qed.</div>
<span class="vernacular">End</span> <span class="id">forloop63</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">fact_for63</span> (<span class="id">n</span> <span class="id">:</span> <span class="id">coq_type</span> <span class="id">ml_int</span>) <span class="id">:</span> <span class="id">M</span> (<span class="id">coq_type</span> <span class="id">ml_int</span>) <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">do</span> <span class="id">v</span> <span class="id">&lt;-</span> <span class="id">cnew</span> <span class="id">ml_int</span> <span class="id">1%int63;</span><br/>
&nbsp;&nbsp;<span class="id">do</span> <span class="id">_</span> <span class="id">&lt;-</span><br/>
&nbsp;&nbsp;(<span class="id">do</span> <span class="id">u</span> <span class="id">&lt;-</span> <span class="id">Ret</span> <span class="id">1%int63;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">do</span> <span class="id">v_1</span> <span class="id">&lt;-</span> <span class="id">Ret</span> <span class="id">n;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">forloop63</span> <span class="id">u</span> <span class="id">v_1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">fun</span> <span class="id">i</span> <span class="id">=&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">do</span> <span class="id">v_1</span> <span class="id">&lt;-</span> (<span class="id">do</span> <span class="id">v_1</span> <span class="id">&lt;-</span> <span class="id">cget</span> <span class="id">v;</span> <span class="id">Ret</span> (<span class="id">mul</span> <span class="id">v_1</span> <span class="id">i</span>))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">cput</span> <span class="id">v</span> <span class="id">v_1</span>))<span class="id">;</span><br/>
&nbsp;&nbsp;<span class="id">cget</span> <span class="id">v</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">fact_for63_ok</span>.<br/>
<span class="vernacular">Variable</span> <span class="id">n</span> <span class="id">:</span> <span class="id">nat</span>.<br/>
<span class="vernacular">Hypothesis</span> <span class="id">Hn</span> <span class="id">:</span> (<span class="id">Z.of_nat</span> <span class="id">n</span> <span class="id">&lt;</span> <span class="id">Sint63.to_Z</span> <span class="id">Sint63.max_int</span>)<span class="id">%Z</span>.<br/>
<br/>
<span class="vernacular">Let</span> <span class="id">n_bounded</span> <span class="id">:</span><br/>
&nbsp;&nbsp;(<span class="id">Sint63.to_Z</span> <span class="id">Sint63.min_int</span> <span class="id">&lt;=</span> <span class="id">Z.of_nat</span> <span class="id">n</span> <span class="id">&lt;=</span> <span class="id">Sint63.to_Z</span> <span class="id">Sint63.max_int</span>)<span class="id">%Z</span>.<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof4')">Proof.</span></div>
<div class="proofscript" id="proof4">
 <span class="gallina-kwd">by</span> <span class="id">apply</span> <span class="id">N2int_bounded,</span> <span class="id">Z.lt_le_incl</span>. Qed.</div>
<br/>
<span class="vernacular">Lemma</span> <span class="id">ltsb_succ</span> <span class="id">:</span> <span class="id">ltsb</span> (<span class="id">N2int</span> <span class="id">n</span>) (<span class="id">Uint63.succ</span> (<span class="id">N2int</span> <span class="id">n</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof5')">Proof.</span></div>
<div class="proofscript" id="proof5">
<span class="id">apply/Sint63</span>.<span class="id">ltbP</span>.<br/>
<span class="id">rewrite</span> <span class="id">Sint63.succ_spec</span> <span class="id">Sint63.cmod_small</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span> <span class="id">apply/Zle_lt_succ/Z</span>.<span class="id">le_refl</span>.<br/>
<span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span> <span class="id">leZ_addr</span> <span class="id">=&gt;</span> <span class="id">//;</span> <span class="gallina-kwd">by</span> <span class="id">case:</span> (<span class="id">Sint63.to_Z_bounded</span> (<span class="id">N2int</span> <span class="id">n</span>)).<br/>
<span class="id">apply</span> <span class="id">Z.lt_add_lt_sub_r</span><span class="id">;</span> <span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">-Sint63</span>.<span class="id">is_int</span>.<br/>
Qed.</div>
<br/>
<span class="vernacular">Lemma</span> <span class="id">ltsb_subr</span> <span class="id">m</span> <span class="id">:</span> <span class="id">m</span>.<span class="id">+1</span> <span class="id">&lt;</span> <span class="id">n</span> <span class="id">-&gt;</span> <span class="id">ltsb</span> (<span class="id">N2int</span> (<span class="id">n</span> <span class="id">-</span> <span class="id">m</span>.<span class="id">+1</span>)) (<span class="id">N2int</span> <span class="id">n</span>).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof6')">Proof.</span></div>
<div class="proofscript" id="proof6">
<span class="id">move=&gt;</span> <span class="id">Smn</span>.<br/>
<span class="id">apply/Sint63</span>.<span class="id">ltbP</span>.<br/>
<span class="id">have</span> <span class="id">Hm</span> <span class="id">:</span> <span class="id">n</span> <span class="id">-</span> <span class="id">m</span>.<span class="id">+1</span> <span class="id">&lt;</span> <span class="id">n</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">ltn_subLR</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">addSn</span> <span class="id">ltnS</span> <span class="id">leq_addl</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span> <span class="id">apply</span> <span class="id">ltnW</span>.<br/>
<span class="id">rewrite</span> <span class="id">/N2int</span> <span class="id">-!Sint63</span>.<span class="id">is_int</span> <span class="id">//</span>.<br/>
<span class="id">-</span> <span class="gallina-kwd">by</span> <span class="id">apply/inj_lt/ltP</span>.<br/>
<span class="id">-</span> <span class="id">move/ltP/inj_lt</span> <span class="gallina-kwd">in</span> <span class="id">Hm</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span> <span class="id">split;</span> <span class="id">apply</span> <span class="id">N2int_bounded,</span> <span class="id">Z.lt_le_incl</span><span class="id">,</span> (<span class="id">Z.lt_trans</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Hm</span>).<br/>
Qed.</div>
<br/>
<span class="vernacular">Theorem</span> <span class="id">fact_for63_ok</span> <span class="id">:</span> <span class="id">crun</span> (<span class="id">fact_for63</span> (<span class="id">N2int</span> <span class="id">n</span>)) <span class="id">=</span> <span class="id">Some</span> (<span class="id">N2int</span> (<span class="id">fact_rec</span> <span class="id">n</span>)).<br/>
<div><span class="toggleproof" onclick="toggleDisplay('proof7')">Proof.</span></div>
<div class="proofscript" id="proof7">
<span class="id">rewrite</span> <span class="id">/fact_for63</span>.<br/>
<span class="id">under</span> <span class="id">eq_bind</span> <span class="id">do</span> <span class="id">rewrite</span> <span class="id">!bindA</span> <span class="id">!bindretf</span>.<br/>
<span class="id">set</span> <span class="id">fn</span> <span class="id">:=</span> <span class="id">N2int</span> (<span class="id">fact_rec</span> <span class="id">n</span>).<br/>
<span class="id">transitivity</span> (<span class="id">crun</span> (<span class="id">cnew</span> <span class="id">ml_int</span> <span class="id">fn</span> <span class="id">&gt;&gt;</span> <span class="id">Ret</span> <span class="id">fn</span> <span class="id">:</span> <span class="id">M</span> <span class="id">_</span>))<span class="id">;</span><br/>
&nbsp;&nbsp;<span class="id">last</span> <span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">crunret</span> <span class="id">//</span> <span class="id">crunnew0</span>.<br/>
<span class="id">congr</span> <span class="id">crun</span>.<br/>
<span class="id">have</span> <span class="id">{1}-&gt;</span> <span class="id">:</span> (<span class="id">1</span> <span class="id">=</span> <span class="id">N2int</span> <span class="id">1</span>)<span class="id">%int63</span> <span class="gallina-kwd">by</span> <span class="id">[]</span>.<br/>
<span class="id">rewrite</span> <span class="id">-/</span>(<span class="id">fact_rec</span> <span class="id">0</span>).<br/>
<span class="id">have</span> <span class="id">-&gt;</span> <span class="id">:</span> (<span class="id">1</span> <span class="id">=</span> <span class="id">Uint63.succ</span> (<span class="id">N2int</span> <span class="id">0</span>))<span class="id">%int63</span> <span class="gallina-kwd">by</span> <span class="id">[]</span>.<br/>
<span class="id">pose</span> <span class="id">m</span> <span class="id">:=</span> <span class="id">n</span>.<br/>
<span class="id">have</span> <span class="id">-&gt;</span> <span class="id">:</span> <span class="id">0</span> <span class="id">=</span> <span class="id">n</span> <span class="id">-</span> <span class="id">m</span> <span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">subnn</span>.<br/>
<span class="id">have</span> <span class="id">:</span> <span class="id">m</span> <span class="id">&lt;=</span> <span class="id">n</span> <span class="gallina-kwd">by</span> <span class="id">[]</span>.<br/>
<span class="id">elim:</span> <span class="id">m</span> <span class="id">=&gt;</span> <span class="id">[|m</span> <span class="id">IH]</span> <span class="id">mn</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">subn0</span>.<br/>
&nbsp;&nbsp;<span class="id">under</span> <span class="id">eq_bind</span> <span class="id">do</span> <span class="id">rewrite</span> <span class="id">forloop630</span> (<span class="id">ltsb_succ,bindretf</span>) <span class="id">//</span> <span class="id">-cgetret</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">cnewget</span>.<br/>
<span class="id">rewrite</span> <span class="id">-N2int_succ</span> <span class="id">subnSK</span> <span class="id">//</span>.<br/>
<span class="id">case:</span> <span class="id">m</span> <span class="id">IH</span> <span class="id">mn</span> <span class="id">=&gt;</span> <span class="id">[|m]</span> <span class="id">IH</span> <span class="id">mn</span>.<br/>
&nbsp;&nbsp;<span class="id">under</span> <span class="id">eq_bind</span> <span class="id">do</span> <span class="id">rewrite</span> <span class="id">subn0</span> <span class="id">forloop631</span> <span class="id">!</span>(<span class="id">ltsb_subr,bindA</span>) <span class="id">//</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">cnewget</span>.<br/>
&nbsp;&nbsp;<span class="id">under</span> <span class="id">eq_bind</span> <span class="id">do</span> <span class="id">rewrite</span> <span class="id">bindretf</span> <span class="id">-cgetret</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">cnewput</span> <span class="id">-N2int_mul</span> <span class="id">mulnC</span> <span class="id">-{1}</span>(<span class="id">prednK</span> <span class="id">mn</span>) <span class="id">cnewget</span> <span class="id">subn1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">-/</span>(<span class="id">fact_rec</span> <span class="id">n</span>.<span class="id">-1</span>.<span class="id">+1</span>) <span class="id">prednK</span>.<br/>
<span class="id">under</span> <span class="id">eq_bind</span> <span class="id">do</span> <span class="id">rewrite</span> <span class="id">forloop63S</span> <span class="id">!</span>(<span class="id">ltsb_subr,bindA</span>) <span class="id">//</span>.<br/>
<span class="id">rewrite</span> <span class="id">cnewget</span>.<br/>
<span class="id">under</span> <span class="id">eq_bind</span> <span class="id">do</span> <span class="id">rewrite</span> <span class="id">bindretf</span>.<br/>
<span class="id">rewrite</span> <span class="id">cnewput</span> <span class="id">-IH</span> (<span class="id">ltnW,subnS</span>) <span class="id">//</span> <span class="id">-N2int_mul</span> <span class="id">mulnC</span> <span class="id">-</span>(<span class="id">@prednK</span> (<span class="id">n-m</span>.<span class="id">+1</span>)) <span class="id">//</span>.<br/>
<span class="gallina-kwd">by</span> <span class="id">rewrite</span> <span class="id">lt0n</span> <span class="id">subn_eq0</span> <span class="id">-ltnNge</span>.<br/>
Qed.</div>
<span class="vernacular">End</span> <span class="id">fact_for63_ok</span>.<br/>
<span class="vernacular">End</span> <span class="id">fact_for_int63</span>.<br/>
<br/>
<span class="vernacular">Section</span> <span class="id">eval</span>.<br/>
<span class="vernacular">Require</span> <span class="vernacular">Import</span> <span class="id">typed_store_model</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">M</span> <span class="id">:=</span> <span class="id">[the</span> <span class="id">typedStoreMonad</span> <span class="id">ml_type</span> <span class="id">_</span> <span class="id">monad_model.locT_nat</span> <span class="id">of</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">acto</span> <span class="id">ml_type]</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">Env</span> <span class="id">:=</span> <span class="id">typed_store_model.Env</span> <span class="id">ml_type</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">empty_env</span> <span class="id">:=</span> <span class="id">@typed_store_model</span>.<span class="id">mkEnv</span> <span class="id">ml_type</span> <span class="id">nil</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">it0</span> <span class="id">:</span> <span class="id">W</span> <span class="id">unit</span> <span class="id">:=</span> <span class="id">inr</span> (<span class="id">tt,</span> <span class="id">empty_env</span>).<br/>
<br/>
<span class="id">Local</span> <span class="vernacular">Open</span> <span class="vernacular">Scope</span> <span class="id">do_notation</span>.<br/>
<span class="id">Local</span> <span class="vernacular">Notation</span> <span class="id">mkloc</span> <span class="id">:=</span> (<span class="id">mkloc</span> (<span class="id">locT:=monad_model</span>.<span class="id">locT_nat</span>)).<br/>
<span class="id">Local</span> <span class="vernacular">Notation</span> <span class="id">coq_type</span> <span class="id">:=</span> (<span class="id">coq_type</span> <span class="id">M</span>).<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">incr</span> (<span class="id">l</span> <span class="id">:</span> <span class="id">loc</span> <span class="id">ml_int</span>) <span class="id">:</span> <span class="id">M</span> <span class="id">int</span> <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">do</span> <span class="id">x</span> <span class="id">&lt;-</span> <span class="id">cget</span> <span class="id">l;</span> <span class="id">do</span> <span class="id">_</span> <span class="id">&lt;-</span> <span class="id">cput</span> <span class="id">l</span> (<span class="id">Uint63.succ</span> <span class="id">x</span>)<span class="id">;</span> <span class="id">Ret</span> (<span class="id">Uint63.succ</span> <span class="id">x</span>).<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">l</span> <span class="id">:</span> <span class="id">W</span> (<span class="id">loc</span> <span class="id">ml_int</span>) <span class="id">:=</span> <span class="id">Restart</span> <span class="id">it0</span> (<span class="id">cnew</span> <span class="id">ml_int</span> <span class="id">3</span>)<span class="id">%int63</span>.<br/>
<span class="vernacular">Eval</span> <span class="id">vm_compute</span> <span class="gallina-kwd">in</span> <span class="id">l</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">it1</span> <span class="id">:=</span> <span class="id">Restart</span> <span class="id">l</span> (<span class="id">do</span> <span class="id">l</span> <span class="id">&lt;-</span> <span class="id">FromW</span> <span class="id">l;</span> <span class="id">incr</span> <span class="id">l</span>).<br/>
<span class="vernacular">Eval</span> <span class="id">vm_compute</span> <span class="gallina-kwd">in</span> <span class="id">it1</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">it2</span> <span class="id">:=</span> <span class="id">Restart</span> <span class="id">it1</span> (<span class="id">do</span> <span class="id">l</span> <span class="id">&lt;-</span> <span class="id">FromW</span> <span class="id">l;</span> <span class="id">incr</span> <span class="id">l</span>).<br/>
<span class="vernacular">Eval</span> <span class="id">vm_compute</span> <span class="gallina-kwd">in</span> <span class="id">it2</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">it3</span> <span class="id">:=</span> <span class="id">Restart</span> <span class="id">it2</span> (<span class="id">fact_for63</span> <span class="id">M</span> <span class="id">M</span> <span class="id">5</span>)<span class="id">%uint63</span>.<br/>
<span class="vernacular">Eval</span> <span class="id">vm_compute</span> <span class="gallina-kwd">in</span> <span class="id">it3</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">AppM</span> <span class="id">{A</span> <span class="id">B}</span> (<span class="id">f</span> <span class="id">:</span> <span class="id">M</span> (<span class="id">A</span> <span class="id">-&gt;</span> <span class="id">M</span> <span class="id">B</span>)) (<span class="id">x</span> <span class="id">:</span> <span class="id">A</span>) <span class="id">:=</span> <span class="id">do</span> <span class="id">f</span> <span class="id">&lt;-</span> <span class="id">f;</span> <span class="id">f</span> <span class="id">x</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">omega</span> (<span class="id">T</span> <span class="id">:</span> <span class="id">ml_type</span>) (<span class="id">n</span> <span class="id">:</span> <span class="id">coq_type</span> <span class="id">T</span>) <span class="id">:</span> <span class="id">M</span> (<span class="id">coq_type</span> <span class="id">T</span>) <span class="id">:=</span><br/>
&nbsp;&nbsp;<span class="id">do</span> <span class="id">r_1</span> <span class="id">&lt;-</span> <span class="id">cnew</span> (<span class="id">ml_arrow</span> <span class="id">T</span> <span class="id">T</span>) (<span class="gallina-kwd">fun</span> <span class="id">x</span> <span class="id">:</span> <span class="id">coq_type</span> <span class="id">T</span> <span class="id">=&gt;</span> <span class="id">Ret</span> (<span class="id">x</span> <span class="id">:</span> <span class="id">coq_type</span> <span class="id">T</span>))<span class="id">;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span> <span class="id">delta</span> (<span class="id">i</span> <span class="id">:</span> <span class="id">coq_type</span> <span class="id">T</span>) <span class="id">:</span> <span class="id">M</span> (<span class="id">coq_type</span> <span class="id">T</span>) <span class="id">:=</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">AppM</span> (<span class="id">cget</span> <span class="id">r_1</span>) <span class="id">i</span> <span class="gallina-kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">do</span> <span class="id">_</span> <span class="id">&lt;-</span> <span class="id">cput</span> <span class="id">r_1</span> <span class="id">delta;</span> <span class="id">delta</span> <span class="id">n</span>.<br/>
<br/>
<span class="vernacular">Definition</span> <span class="id">it_omega</span> <span class="id">:=</span> <span class="id">Restart</span> <span class="id">it3</span> (<span class="id">omega</span> <span class="id">ml_unit</span> <span class="id">tt</span>).<br/>
<span class="vernacular">Fail</span> <span class="id">Timeout</span> <span class="id">1</span> <span class="vernacular">Eval</span> <span class="id">vm_compute</span> <span class="gallina-kwd">in</span> <span class="id">it_omega</span>.<br/>
<br/>
<span class="vernacular">End</span> <span class="id">eval</span>.<br/>
<br/>
<span class="vernacular">End</span> <span class="id">CoqTypeInt63</span>.<br/>

</div>
<div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/">a fork of coq2html</a></div>
</body>
</html>
